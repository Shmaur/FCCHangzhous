webpackJsonp([0],{

/***/ "+rd1":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("30Io");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "/N1I":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("38t3");
var descriptor = __webpack_require__("TUEb");
var setToStringTag = __webpack_require__("9Poz");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("q1/O")(IteratorPrototype, __webpack_require__("IFGh")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "/RPK":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("z59m");
var defined = __webpack_require__("30Io");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "/ZBN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
    return Array.isArray(val) ? [] : {}
}

function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true;
    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}

function defaultArrayMerge(target, source, optionsArgument) {
    var destination = target.slice();
    source.forEach(function(e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
        } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
        }
    });
    return destination
}

function mergeObject(target, source, optionsArgument) {
    var destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function(key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function(key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
    });
    return destination
}

function deepmerge(target, source, optionsArgument) {
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var options = optionsArgument || { arrayMerge: defaultArrayMerge };
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    if (!sourceAndTargetTypesMatch) {
        return cloneIfNecessary(source, optionsArgument)
    } else if (sourceIsArray) {
        var arrayMerge = options.arrayMerge || defaultArrayMerge;
        return arrayMerge(target, source, optionsArgument)
    } else {
        return mergeObject(target, source, optionsArgument)
    }
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
    if (!Array.isArray(array) || array.length < 2) {
        throw new Error('first argument should be an array with at least two elements')
    }

    // we are sure there are at least 2 values, so it is safe to have no initial value
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, optionsArgument)
    })
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "0nnt":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "13kP":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("lSMs");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),

/***/ "1rx+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__("9goP");
var gOPS = __webpack_require__("BWjf");
var pIE = __webpack_require__("ex+5");
var toObject = __webpack_require__("+rd1");
var IObject = __webpack_require__("z59m");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("YEmw")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "26oO":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  // console.log('validate on %s value', value);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value)) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      if (value) {
        __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (date);

/***/ }),

/***/ "2LoE":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("vV1w"), __esModule: true };

/***/ }),

/***/ "30Io":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "38t3":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("fHSC");
var dPs = __webpack_require__("PTA0");
var enumBugKeys = __webpack_require__("M8Yd");
var IE_PROTO = __webpack_require__("qq67")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("l3hl")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("hX0p").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "46Yf":
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "4LxP":
/***/ (function(module, exports, __webpack_require__) {

!function(V,U){ true?module.exports=U():"function"==typeof define&&define.amd?define([],U):"object"==typeof exports?exports.VueQArt=U():V.VueQArt=U()}(this,function(){return function(V){function U(F){if(l[F])return l[F].exports;var R=l[F]={i:F,l:!1,exports:{}};return V[F].call(R.exports,R,R.exports,U),R.l=!0,R.exports}var l={};return U.m=V,U.c=l,U.i=function(V){return V},U.d=function(V,l,F){U.o(V,l)||Object.defineProperty(V,l,{configurable:!1,enumerable:!0,get:F})},U.n=function(V){var l=V&&V.__esModule?function(){return V.default}:function(){return V};return U.d(l,"a",l),l},U.o=function(V,U){return Object.prototype.hasOwnProperty.call(V,U)},U.p="/dist/",U(U.s=5)}([function(module,exports,__webpack_require__){eval("var Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(1),\n  /* template */\n  __webpack_require__(4),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlLXFhcnQudnVlP2U2NmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi92dWUtcWFydC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi01NjNhNjQ3YyEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi92dWUtcWFydC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3Z1ZS1xYXJ0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _qartjs = __webpack_require__(2);\n\nvar _qartjs2 = _interopRequireDefault(_qartjs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  props: ['config', 'downloadButton'],\n  name: 'VueQart',\n\n  data: function data() {\n    return {\n      msg: ''\n    };\n  },\n\n  watch: {\n    'config.value': function configValue(val, oldVal) {\n      this.config.value = val;\n      this.renderQrcode(this.config);\n      console.log('new: %s, old: %s', val, oldVal);\n    }\n  },\n  mounted: function mounted() {\n    this.renderQrcode(this.config);\n  },\n\n\n  methods: {\n    renderQrcode: function renderQrcode(config) {\n      this.qart = new _qartjs2.default(config);\n      this.qart.make(this.$refs.qart);\n    },\n    convertToImage: function convertToImage() {\n      var myCanvas = this.$refs.qart.children[0];\n      var type = 'image/png';\n      var image = myCanvas.toDataURL(type).replace(type, \"image/octet-stream\");\n      window.location.href = image; // it will save locally\n    }\n  }\n}; //\n//\n//\n//\n//\n//\n//\n//\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdnVlLXFhcnQudnVlPzI5NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBVUE7Ozs7Ozs7b0JBRUE7UUFFQTs7d0JBQ0E7O1dBR0E7QUFGQTtBQUdBOzs7c0RBRUE7MEJBQ0E7NkJBQ0E7MkNBQ0E7QUFFQTtBQU5BOzhCQU9BOzJCQUNBO0FBRUE7Ozs7Z0RBRUE7dUNBQ0E7Z0NBQ0E7QUFDQTs7OENBRUE7aUJBQ0E7eURBQ0E7bUNBSEEsQ0FJQTtBQUVBO0FBWEE7QUFwQkEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2PlxuICAgICAgICA8ZGl2IHJlZj1cInFhcnRcIj48L2Rpdj5cbiAgICAgICAgPGJ1dHRvbiBAY2xpY2s9XCJjb252ZXJ0VG9JbWFnZVwiIHYtaWY9XCJkb3dubG9hZEJ1dHRvblwiPmRvd25sb2FkIHQybyBpbWFnZTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0IHR5cGU9XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI+XG5pbXBvcnQgUUFydCBmcm9tICdxYXJ0anMnO1xuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnY29uZmlnJywgJ2Rvd25sb2FkQnV0dG9uJ10sXG4gICAgbmFtZTogJ1Z1ZVFhcnQnLFxuICBcbiAgICBkYXRhICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1zZzogJycsXG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgJ2NvbmZpZy52YWx1ZSc6IGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgICAgICB0aGlzLmNvbmZpZy52YWx1ZSA9IHZhbDtcbiAgICAgICAgdGhpcy5yZW5kZXJRcmNvZGUodGhpcy5jb25maWcpO1xuICAgICAgY29uc29sZS5sb2coJ25ldzogJXMsIG9sZDogJXMnLCB2YWwsIG9sZFZhbClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBtb3VudGVkKCl7XG4gICAgICB0aGlzLnJlbmRlclFyY29kZSh0aGlzLmNvbmZpZylcbiAgICB9LFxuICAgIFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlbmRlclFyY29kZShjb25maWcpe1xuICAgICAgICB0aGlzLnFhcnQgPSAgbmV3IFFBcnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5xYXJ0Lm1ha2UodGhpcy4kcmVmcy5xYXJ0KVxuICAgICAgfSxcbiAgICAgIGNvbnZlcnRUb0ltYWdlKCl7XG4gICAgICAgIGNvbnN0IG15Q2FudmFzID0gdGhpcy4kcmVmcy5xYXJ0LmNoaWxkcmVuWzBdO1xuICAgICAgICBjb25zdCB0eXBlID0gJ2ltYWdlL3BuZyc7XG4gICAgICAgIGxldCBpbWFnZSA9IG15Q2FudmFzLnRvRGF0YVVSTCh0eXBlKS5yZXBsYWNlKHR5cGUsIFwiaW1hZ2Uvb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGltYWdlOyAvLyBpdCB3aWxsIHNhdmUgbG9jYWxseVxuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB2dWUtcWFydC52dWU/ODJhMjg3NjYiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('!function(t,r){ true?module.exports=r():"function"==typeof define&&define.amd?define([],r):"object"==typeof exports?exports.qart=r():t.qart=r()}(this,function(){return function(t){function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports}var e={};return r.m=t,r.c=e,r.p="../dist/",r(0)}([function(t,r,e){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(r,"__esModule",{value:!0});var o=e(1),i=n(o),u=e(2),f=n(u),a=e(21),c=e(75),s=n(c),l=function(){function t(r){if((0,i.default)(this,t),"undefined"==typeof r)throw new TypeError("QArt required `options`.");if("undefined"==typeof r.value)throw new TypeError("QArt required `value` option.");if("undefined"==typeof r.imagePath)throw new TypeError("QArt required `imagePath` option.");this.filter="undefined"==typeof r.filter?t.DEFAULTS.filter:r.filter,this.value=r.value,this.imagePath=r.imagePath}return(0,f.default)(t,[{key:"make",value:function(t){var r=195,e=12,n=10,o=(0,a.QRCode)(n,"H");o.addData(this.value),o.make();var i=o.createImgObject(3),u=this;i.onload=function(){var o=new Image;o.src=u.imagePath;var f=s.default.createCanvas(r,i),c=s.default.createCanvas(r,i);o.onload=function(){o.width<o.height?(o.height=(r-2*e)*(1*o.height/o.width),o.width=r-2*e):(o.width=(r-2*e)*(1*o.width/o.height),o.height=r-2*e);var i=document.createElement("canvas");i.width=r,i.height=r,i.getContext("2d").drawImage(o,e,e,r-2*e,r-2*e);for(var l=i.getContext("2d").getImageData(0,0,r,r),h=l.data,g=f.getContext("2d").getImageData(0,0,r,r),v=g.data,p=0;p<h.length;p+=4){var d=Math.floor(p/4)%r,y=Math.floor(Math.floor(p/4)/r);if(d<e||y<e||d>=r-e||y>=r-e)v[p+3]=0;else if((d%3!=1||y%3!=1)&&!(d<36&&(y<36||y>=r-36)||d>=r-36&&y<36)){if("threshold"==u.filter){var w=s.default.threshold(h[p],h[p+1],h[p+2],127);v[p]=w,v[p+1]=w,v[p+2]=w}else"color"==u.filter&&(v[p]=h[p],v[p+1]=h[p+1],v[p+2]=h[p+2]);v[p+3]=h[p+3]}}f.getContext("2d").putImageData(g,0,0);for(var m=a.QRUtil.getPatternPosition(n),p=0;p<m.length;p+=1)for(var b=0;b<m.length;b+=1){var d=m[p],y=m[b];if(!(6==d&&50==y||6==y&&50==d||6==d&&6==y)){var A=3*(d-2)+12,x=3*(y-2)+12,E=3*(d+3)+12-A,M=3*(y+3)+12-x,_=c.getContext("2d").getImageData(A,x,E,M);f.getContext("2d").putImageData(_,A,x)}}t.innerHTML="",t.appendChild(f)}}}}],[{key:"DEFAULTS",get:function(){return{value:"",filter:"threshold"}}}]),t}();window.QArt=l,r.default=window.QArt},function(t,r){"use strict";r.__esModule=!0,r.default=function(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}},function(t,r,e){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var o=e(3),i=n(o);r.default=function(){function t(t,r){for(var e=0;e<r.length;e++){var n=r[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),(0,i.default)(t,n.key,n)}}return function(r,e,n){return e&&t(r.prototype,e),n&&t(r,n),r}}()},function(t,r,e){t.exports={default:e(4),__esModule:!0}},function(t,r,e){e(5);var n=e(8).Object;t.exports=function(t,r,e){return n.defineProperty(t,r,e)}},function(t,r,e){var n=e(6);n(n.S+n.F*!e(16),"Object",{defineProperty:e(12).f})},function(t,r,e){var n=e(7),o=e(8),i=e(9),u=e(11),f="prototype",a=function(t,r,e){var c,s,l,h=t&a.F,g=t&a.G,v=t&a.S,p=t&a.P,d=t&a.B,y=t&a.W,w=g?o:o[r]||(o[r]={}),m=w[f],b=g?n:v?n[r]:(n[r]||{})[f];g&&(e=r);for(c in e)s=!h&&b&&void 0!==b[c],s&&c in w||(l=s?b[c]:e[c],w[c]=g&&"function"!=typeof b[c]?e[c]:d&&s?i(l,n):y&&b[c]==l?function(t){var r=function(r,e,n){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(r);case 2:return new t(r,e)}return new t(r,e,n)}return t.apply(this,arguments)};return r[f]=t[f],r}(l):p&&"function"==typeof l?i(Function.call,l):l,p&&((w.virtual||(w.virtual={}))[c]=l,t&a.R&&m&&!m[c]&&u(m,c,l)))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,r){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,r){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,r,e){var n=e(10);t.exports=function(t,r,e){if(n(t),void 0===r)return t;switch(e){case 1:return function(e){return t.call(r,e)};case 2:return function(e,n){return t.call(r,e,n)};case 3:return function(e,n,o){return t.call(r,e,n,o)}}return function(){return t.apply(r,arguments)}}},function(t,r){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,r,e){var n=e(12),o=e(20);t.exports=e(16)?function(t,r,e){return n.f(t,r,o(1,e))}:function(t,r,e){return t[r]=e,t}},function(t,r,e){var n=e(13),o=e(15),i=e(19),u=Object.defineProperty;r.f=e(16)?Object.defineProperty:function(t,r,e){if(n(t),r=i(r,!0),n(e),o)try{return u(t,r,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[r]=e.value),t}},function(t,r,e){var n=e(14);t.exports=function(t){if(!n(t))throw TypeError(t+" is not an object!");return t}},function(t,r){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,r,e){t.exports=!e(16)&&!e(17)(function(){return 7!=Object.defineProperty(e(18)("div"),"a",{get:function(){return 7}}).a})},function(t,r,e){t.exports=!e(17)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,r){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,r,e){var n=e(14),o=e(7).document,i=n(o)&&n(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,r,e){var n=e(14);t.exports=function(t,r){if(!n(t))return t;var e,o;if(r&&"function"==typeof(e=t.toString)&&!n(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!n(o=e.call(t)))return o;if(!r&&"function"==typeof(e=t.toString)&&!n(o=e.call(t)))return o;throw TypeError("Can\'t convert object to primitive value")}},function(t,r){t.exports=function(t,r){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:r}}},function(t,r,e){function n(t){return t&&t.__esModule?t:{default:t}}var o,i,u,f=e(22),a=(n(f),function(){function t(r,e){if("undefined"==typeof r.length)throw new Error(r.length+"/"+e);var n=function(){for(var t=0;t<r.length&&0==r[t];)t+=1;for(var n=new Array(r.length-t+e),o=0;o<r.length-t;o+=1)n[o]=r[o+t];return n}(),o={};return o.getAt=function(t){return n[t]},o.getLength=function(){return n.length},o.multiply=function(r){for(var e=new Array(o.getLength()+r.getLength()-1),n=0;n<o.getLength();n+=1)for(var i=0;i<r.getLength();i+=1)e[n+i]^=u.gexp(u.glog(o.getAt(n))+u.glog(r.getAt(i)));return t(e,0)},o.mod=function(r){if(o.getLength()-r.getLength()<0)return o;for(var e=u.glog(o.getAt(0))-u.glog(r.getAt(0)),n=new Array(o.getLength()),i=0;i<o.getLength();i+=1)n[i]=o.getAt(i);for(var i=0;i<r.getLength();i+=1)n[i]^=u.gexp(u.glog(r.getAt(i))+e);return t(n,0).mod(r)},o}var r=function(r,e){var o=236,u=17,g=r,v=n[e],p=null,d=0,m=null,b=new Array,A={},x=function(t,r){d=4*g+17,p=function(t){for(var r=new Array(t),e=0;e<t;e+=1){r[e]=new Array(t);for(var n=0;n<t;n+=1)r[e][n]=null}return r}(d),E(0,0),E(d-7,0),E(0,d-7),O(),_(),B(t,r),g>=7&&T(t),null==m&&(m=C(g,v,b)),S(m,r)},E=function(t,r){for(var e=-1;e<=7;e+=1)if(!(t+e<=-1||d<=t+e))for(var n=-1;n<=7;n+=1)r+n<=-1||d<=r+n||(0<=e&&e<=6&&(0==n||6==n)||0<=n&&n<=6&&(0==e||6==e)||2<=e&&e<=4&&2<=n&&n<=4?p[t+e][r+n]=!0:p[t+e][r+n]=!1)},M=function(){for(var t=0,r=0,e=0;e<8;e+=1){x(!0,e);var n=i.getLostPoint(A);(0==e||t>n)&&(t=n,r=e)}return r},_=function(){for(var t=8;t<d-8;t+=1)null==p[t][6]&&(p[t][6]=t%2==0);for(var r=8;r<d-8;r+=1)null==p[6][r]&&(p[6][r]=r%2==0)},O=function(){for(var t=i.getPatternPosition(g),r=0;r<t.length;r+=1)for(var e=0;e<t.length;e+=1){var n=t[r],o=t[e];if(null==p[n][o])for(var u=-2;u<=2;u+=1)for(var f=-2;f<=2;f+=1)u==-2||2==u||f==-2||2==f||0==u&&0==f?p[n+u][o+f]=!0:p[n+u][o+f]=!1}},T=function(t){for(var r=i.getBCHTypeNumber(g),e=0;e<18;e+=1){var n=!t&&1==(r>>e&1);p[Math.floor(e/3)][e%3+d-8-3]=n}for(var e=0;e<18;e+=1){var n=!t&&1==(r>>e&1);p[e%3+d-8-3][Math.floor(e/3)]=n}},B=function(t,r){for(var e=v<<3|r,n=i.getBCHTypeInfo(e),o=0;o<15;o+=1){var u=!t&&1==(n>>o&1);o<6?p[o][8]=u:o<8?p[o+1][8]=u:p[d-15+o][8]=u}for(var o=0;o<15;o+=1){var u=!t&&1==(n>>o&1);o<8?p[8][d-o-1]=u:o<9?p[8][15-o-1+1]=u:p[8][15-o-1]=u}p[d-8][8]=!t},S=function(t,r){for(var e=-1,n=d-1,o=7,u=0,f=i.getMaskFunction(r),a=d-1;a>0;a-=2)for(6==a&&(a-=1);;){for(var c=0;c<2;c+=1)if(null==p[n][a-c]){var s=!1;u<t.length&&(s=1==(t[u]>>>o&1));var l=f(n,a-c);l&&(s=!s),p[n][a-c]=s,o-=1,o==-1&&(u+=1,o=7)}if(n+=e,n<0||d<=n){n-=e,e=-e;break}}},P=function(r,e){for(var n=0,o=0,u=0,f=new Array(e.length),a=new Array(e.length),c=0;c<e.length;c+=1){var s=e[c].dataCount,l=e[c].totalCount-s;o=Math.max(o,s),u=Math.max(u,l),f[c]=new Array(s);for(var h=0;h<f[c].length;h+=1)f[c][h]=255&r.getBuffer()[h+n];n+=s;var g=i.getErrorCorrectPolynomial(l),v=t(f[c],g.getLength()-1),p=v.mod(g);a[c]=new Array(g.getLength()-1);for(var h=0;h<a[c].length;h+=1){var d=h+p.getLength()-a[c].length;a[c][h]=d>=0?p.getAt(d):0}}for(var y=0,h=0;h<e.length;h+=1)y+=e[h].totalCount;for(var w=new Array(y),m=0,h=0;h<o;h+=1)for(var c=0;c<e.length;c+=1)h<f[c].length&&(w[m]=f[c][h],m+=1);for(var h=0;h<u;h+=1)for(var c=0;c<e.length;c+=1)h<a[c].length&&(w[m]=a[c][h],m+=1);return w},C=function(t,r,e){for(var n=f.getRSBlocks(t,r),c=a(),s=0;s<e.length;s+=1){var l=e[s];c.put(l.getMode(),4),c.put(l.getLength(),i.getLengthInBits(l.getMode(),t)),l.write(c)}for(var h=0,s=0;s<n.length;s+=1)h+=n[s].dataCount;if(c.getLengthInBits()>8*h)throw new Error("code length overflow. ("+c.getLengthInBits()+">"+8*h+")");for(c.getLengthInBits()+4<=8*h&&c.put(0,4);c.getLengthInBits()%8!=0;)c.putBit(!1);for(;;){if(c.getLengthInBits()>=8*h)break;if(c.put(o,8),c.getLengthInBits()>=8*h)break;c.put(u,8)}return P(c,n)};return A.addData=function(t,r){r=r||"Byte";var e=null;switch(r){case"Numeric":e=c(t);break;case"Alphanumeric":e=s(t);break;case"Byte":e=l(t);break;case"Kanji":e=h(t);break;default:throw"mode:"+r}b.push(e),m=null},A.isDark=function(t,r){if(t<0||d<=t||r<0||d<=r)throw new Error(t+","+r);return p[t][r]},A.getModuleCount=function(){return d},A.make=function(){x(!1,M())},A.createTableTag=function(t,r){t=t||2,r="undefined"==typeof r?4*t:r;var e="";e+=\'<table style="\',e+=" border-width: 0px; border-style: none;",e+=" border-collapse: collapse;",e+=" padding: 0px; margin: "+r+"px;",e+=\'">\',e+="<tbody>";for(var n=0;n<A.getModuleCount();n+=1){e+="<tr>";for(var o=0;o<A.getModuleCount();o+=1)e+=\'<td style="\',e+=" border-width: 0px; border-style: none;",e+=" border-collapse: collapse;",e+=" padding: 0px; margin: 0px;",e+=" width: "+t+"px;",e+=" height: "+t+"px;",e+=" background-color: ",e+=A.isDark(n,o)?"#000000":"#ffffff",e+=";",e+=\'"/>\';e+="</tr>"}return e+="</tbody>",e+="</table>"},A.createSvgTag=function(t,r){t=t||2,r="undefined"==typeof r?4*t:r;var e,n,o,i,u,f=A.getModuleCount()*t+2*r,a="";for(u="l"+t+",0 0,"+t+" -"+t+",0 0,-"+t+"z ",a+="<svg",a+=\' width="\'+f+\'px"\',a+=\' height="\'+f+\'px"\',a+=\' xmlns="http://www.w3.org/2000/svg"\',a+=">",a+=\'<path d="\',o=0;o<A.getModuleCount();o+=1)for(i=o*t+r,e=0;e<A.getModuleCount();e+=1)A.isDark(o,e)&&(n=e*t+r,a+="M"+n+","+i+u);return a+=\'" stroke="transparent" fill="black"/>\',a+="</svg>"},A.createImgTag=function(t,r){t=t||2,r="undefined"==typeof r?4*t:r;var e=A.getModuleCount()*t+2*r,n=r,o=e-r;return y(e,e,function(r,e){if(n<=r&&r<o&&n<=e&&e<o){var i=Math.floor((r-n)/t),u=Math.floor((e-n)/t);return A.isDark(u,i)?0:1}return 1})},A.createImgObject=function(t,r){t=t||2,r="undefined"==typeof r?4*t:r;var e=A.getModuleCount()*t+2*r,n=r,o=e-r;return w(e,e,function(r,e){if(n<=r&&r<o&&n<=e&&e<o){var i=Math.floor((r-n)/t),u=Math.floor((e-n)/t);return A.isDark(u,i)?0:1}return 1})},A};r.stringToBytes=function(t){for(var r=new Array,e=0;e<t.length;e+=1){var n=t.charCodeAt(e);r.push(255&n)}return r},r.createStringToBytes=function(t,r){var e=function(){for(var e=p(t),n=function(){var t=e.read();if(t==-1)throw new Error;return t},o=0,i={};;){var u=e.read();if(u==-1)break;var f=n(),a=n(),c=n(),s=String.fromCharCode(u<<8|f),l=a<<8|c;i[s]=l,o+=1}if(o!=r)throw new Error(o+" != "+r);return i}(),n="?".charCodeAt(0);return function(t){for(var r=new Array,o=0;o<t.length;o+=1){var i=t.charCodeAt(o);if(i<128)r.push(i);else{var u=e[t.charAt(o)];"number"==typeof u?(255&u)==u?r.push(u):(r.push(u>>>8),r.push(255&u)):r.push(n)}}return r}};var e={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},n={L:1,M:0,Q:3,H:2},o={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},i=function(){var r=[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],n=1335,i=7973,f=21522,a={},c=function(t){for(var r=0;0!=t;)r+=1,t>>>=1;return r};return a.getBCHTypeInfo=function(t){for(var r=t<<10;c(r)-c(n)>=0;)r^=n<<c(r)-c(n);return(t<<10|r)^f},a.getBCHTypeNumber=function(t){for(var r=t<<12;c(r)-c(i)>=0;)r^=i<<c(r)-c(i);return t<<12|r},a.getPatternPosition=function(t){return r[t-1]},a.getMaskFunction=function(t){switch(t){case o.PATTERN000:return function(t,r){return(t+r)%2==0};case o.PATTERN001:return function(t,r){return t%2==0};case o.PATTERN010:return function(t,r){return r%3==0};case o.PATTERN011:return function(t,r){return(t+r)%3==0};case o.PATTERN100:return function(t,r){return(Math.floor(t/2)+Math.floor(r/3))%2==0};case o.PATTERN101:return function(t,r){return t*r%2+t*r%3==0};case o.PATTERN110:return function(t,r){return(t*r%2+t*r%3)%2==0};case o.PATTERN111:return function(t,r){return(t*r%3+(t+r)%2)%2==0};default:throw new Error("bad maskPattern:"+t)}},a.getErrorCorrectPolynomial=function(r){for(var e=t([1],0),n=0;n<r;n+=1)e=e.multiply(t([1,u.gexp(n)],0));return e},a.getLengthInBits=function(t,r){if(1<=r&&r<10)switch(t){case e.MODE_NUMBER:return 10;case e.MODE_ALPHA_NUM:return 9;case e.MODE_8BIT_BYTE:return 8;case e.MODE_KANJI:return 8;default:throw new Error("mode:"+t)}else if(r<27)switch(t){case e.MODE_NUMBER:return 12;case e.MODE_ALPHA_NUM:return 11;case e.MODE_8BIT_BYTE:return 16;case e.MODE_KANJI:return 10;default:throw new Error("mode:"+t)}else{if(!(r<41))throw new Error("type:"+r);switch(t){case e.MODE_NUMBER:return 14;case e.MODE_ALPHA_NUM:return 13;case e.MODE_8BIT_BYTE:return 16;case e.MODE_KANJI:return 12;default:throw new Error("mode:"+t)}}},a.getLostPoint=function(t){for(var r=t.getModuleCount(),e=0,n=0;n<r;n+=1)for(var o=0;o<r;o+=1){for(var i=0,u=t.isDark(n,o),f=-1;f<=1;f+=1)if(!(n+f<0||r<=n+f))for(var a=-1;a<=1;a+=1)o+a<0||r<=o+a||0==f&&0==a||u==t.isDark(n+f,o+a)&&(i+=1);i>5&&(e+=3+i-5)}for(var n=0;n<r-1;n+=1)for(var o=0;o<r-1;o+=1){var c=0;t.isDark(n,o)&&(c+=1),t.isDark(n+1,o)&&(c+=1),t.isDark(n,o+1)&&(c+=1),t.isDark(n+1,o+1)&&(c+=1),0!=c&&4!=c||(e+=3)}for(var n=0;n<r;n+=1)for(var o=0;o<r-6;o+=1)t.isDark(n,o)&&!t.isDark(n,o+1)&&t.isDark(n,o+2)&&t.isDark(n,o+3)&&t.isDark(n,o+4)&&!t.isDark(n,o+5)&&t.isDark(n,o+6)&&(e+=40);for(var o=0;o<r;o+=1)for(var n=0;n<r-6;n+=1)t.isDark(n,o)&&!t.isDark(n+1,o)&&t.isDark(n+2,o)&&t.isDark(n+3,o)&&t.isDark(n+4,o)&&!t.isDark(n+5,o)&&t.isDark(n+6,o)&&(e+=40);for(var s=0,o=0;o<r;o+=1)for(var n=0;n<r;n+=1)t.isDark(n,o)&&(s+=1);var l=Math.abs(100*s/r/r-50)/5;return e+=10*l},a}(),u=function(){for(var t=new Array(256),r=new Array(256),e=0;e<8;e+=1)t[e]=1<<e;for(var e=8;e<256;e+=1)t[e]=t[e-4]^t[e-5]^t[e-6]^t[e-8];for(var e=0;e<255;e+=1)r[t[e]]=e;var n={};return n.glog=function(t){if(t<1)throw new Error("glog("+t+")");return r[t]},n.gexp=function(r){for(;r<0;)r+=255;for(;r>=256;)r-=255;return t[r]},n}(),f=function(){var t=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],r=function(t,r){var e={};return e.totalCount=t,e.dataCount=r,e},e={},o=function(r,e){switch(e){case n.L:return t[4*(r-1)+0];case n.M:return t[4*(r-1)+1];case n.Q:return t[4*(r-1)+2];case n.H:return t[4*(r-1)+3];default:return}};return e.getRSBlocks=function(t,e){var n=o(t,e);if("undefined"==typeof n)throw new Error("bad rs block @ typeNumber:"+t+"/errorCorrectionLevel:"+e);for(var i=n.length/3,u=new Array,f=0;f<i;f+=1)for(var a=n[3*f+0],c=n[3*f+1],s=n[3*f+2],l=0;l<a;l+=1)u.push(r(c,s));return u},e}(),a=function(){var t=new Array,r=0,e={};return e.getBuffer=function(){return t},e.getAt=function(r){var e=Math.floor(r/8);return 1==(t[e]>>>7-r%8&1)},e.put=function(t,r){for(var n=0;n<r;n+=1)e.putBit(1==(t>>>r-n-1&1))},e.getLengthInBits=function(){return r},e.putBit=function(e){var n=Math.floor(r/8);t.length<=n&&t.push(0),e&&(t[n]|=128>>>r%8),r+=1},e},c=function(t){var r=e.MODE_NUMBER,n=t,o={};o.getMode=function(){return r},o.getLength=function(t){return n.length},o.write=function(t){for(var r=n,e=0;e+2<r.length;)t.put(i(r.substring(e,e+3)),10),e+=3;e<r.length&&(r.length-e==1?t.put(i(r.substring(e,e+1)),4):r.length-e==2&&t.put(i(r.substring(e,e+2)),7))};var i=function(t){for(var r=0,e=0;e<t.length;e+=1)r=10*r+u(t.charAt(e));return r},u=function(t){if("0"<=t&&t<="9")return t.charCodeAt(0)-"0".charCodeAt(0);throw"illegal char :"+t};return o},s=function(t){var r=e.MODE_ALPHA_NUM,n=t,o={};o.getMode=function(){return r},o.getLength=function(t){return n.length},o.write=function(t){for(var r=n,e=0;e+1<r.length;)t.put(45*i(r.charAt(e))+i(r.charAt(e+1)),11),e+=2;e<r.length&&t.put(i(r.charAt(e)),6)};var i=function(t){if("0"<=t&&t<="9")return t.charCodeAt(0)-"0".charCodeAt(0);if("A"<=t&&t<="Z")return t.charCodeAt(0)-"A".charCodeAt(0)+10;switch(t){case" ":return 36;case"$":return 37;case"%":return 38;case"*":return 39;case"+":return 40;case"-":return 41;case".":return 42;case"/":return 43;case":":return 44;default:throw"illegal char :"+t}};return o},l=function(t){var n=e.MODE_8BIT_BYTE,o=r.stringToBytes(t),i={};return i.getMode=function(){return n},i.getLength=function(t){return o.length},i.write=function(t){for(var r=0;r<o.length;r+=1)t.put(o[r],8)},i},h=function(t){var n=e.MODE_KANJI,o=r.stringToBytes(t);!function(t,e){var n=r.stringToBytes(t);if(2!=n.length||(n[0]<<8|n[1])!=e)throw"sjis not supported."}("友",38726);var i={};return i.getMode=function(){return n},i.getLength=function(t){return~~(o.length/2)},i.write=function(t){for(var r=o,e=0;e+1<r.length;){var n=(255&r[e])<<8|255&r[e+1];if(33088<=n&&n<=40956)n-=33088;else{if(!(57408<=n&&n<=60351))throw"illegal char at "+(e+1)+"/"+n;n-=49472}n=192*(n>>>8&255)+(255&n),t.put(n,13),e+=2}if(e<r.length)throw"illegal char at "+(e+1)},i},g=function(){var t=new Array,r={};return r.writeByte=function(r){t.push(255&r)},r.writeShort=function(t){r.writeByte(t),r.writeByte(t>>>8)},r.writeBytes=function(t,e,n){e=e||0,n=n||t.length;for(var o=0;o<n;o+=1)r.writeByte(t[o+e])},r.writeString=function(t){for(var e=0;e<t.length;e+=1)r.writeByte(t.charCodeAt(e))},r.toByteArray=function(){return t},r.toString=function(){var r="";r+="[";for(var e=0;e<t.length;e+=1)e>0&&(r+=","),r+=t[e];return r+="]"},r},v=function(){var t=0,r=0,e=0,n="",o={},i=function(t){n+=String.fromCharCode(u(63&t))},u=function(t){if(t<0);else{if(t<26)return 65+t;if(t<52)return 97+(t-26);if(t<62)return 48+(t-52);if(62==t)return 43;if(63==t)return 47}throw new Error("n:"+t)};return o.writeByte=function(n){for(t=t<<8|255&n,r+=8,e+=1;r>=6;)i(t>>>r-6),r-=6},o.flush=function(){if(r>0&&(i(t<<6-r),t=0,r=0),e%3!=0)for(var o=3-e%3,u=0;u<o;u+=1)n+="="},o.toString=function(){return n},o},p=function(t){var r=t,e=0,n=0,o=0,i={};i.read=function(){for(;o<8;){if(e>=r.length){if(0==o)return-1;throw new Error("unexpected end of file./"+o)}var t=r.charAt(e);if(e+=1,"="==t)return o=0,-1;t.match(/^\\s$/)||(n=n<<6|u(t.charCodeAt(0)),o+=6)}var i=n>>>o-8&255;return o-=8,i};var u=function(t){if(65<=t&&t<=90)return t-65;if(97<=t&&t<=122)return t-97+26;if(48<=t&&t<=57)return t-48+52;if(43==t)return 62;if(47==t)return 63;throw new Error("c:"+t)};return i},d=function(t,r){var e=t,n=r,o=new Array(t*r),i={};i.setPixel=function(t,r,n){o[r*e+t]=n},i.write=function(t){t.writeString("GIF87a"),t.writeShort(e),t.writeShort(n),t.writeByte(128),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(255),t.writeByte(255),t.writeByte(255),t.writeString(","),t.writeShort(0),t.writeShort(0),t.writeShort(e),t.writeShort(n),t.writeByte(0);var r=2,o=f(r);t.writeByte(r);for(var i=0;o.length-i>255;)t.writeByte(255),t.writeBytes(o,i,255),i+=255;t.writeByte(o.length-i),t.writeBytes(o,i,o.length-i),t.writeByte(0),t.writeString(";")};var u=function(t){var r=t,e=0,n=0,o={};return o.write=function(t,o){if(t>>>o!=0)throw new Error("length over");for(;e+o>=8;)r.writeByte(255&(t<<e|n)),o-=8-e,t>>>=8-e,n=0,e=0;n|=t<<e,e+=o},o.flush=function(){e>0&&r.writeByte(n)},o},f=function(t){for(var r=1<<t,e=(1<<t)+1,n=t+1,i=a(),f=0;f<r;f+=1)i.add(String.fromCharCode(f));i.add(String.fromCharCode(r)),i.add(String.fromCharCode(e));var c=g(),s=u(c);s.write(r,n);var l=0,h=String.fromCharCode(o[l]);for(l+=1;l<o.length;){var v=String.fromCharCode(o[l]);l+=1,i.contains(h+v)?h+=v:(s.write(i.indexOf(h),n),i.size()<4095&&(i.size()==1<<n&&(n+=1),i.add(h+v)),h=v)}return s.write(i.indexOf(h),n),s.write(e,n),s.flush(),c.toByteArray()},a=function(){var t={},r=0,e={};return e.add=function(n){if(e.contains(n))throw new Error("dup key:"+n);t[n]=r,r+=1},e.size=function(){return r},e.indexOf=function(r){return t[r]},e.contains=function(r){return"undefined"!=typeof t[r]},e};return i},y=function(t,r,e,n){for(var o=d(t,r),i=0;i<r;i+=1)for(var u=0;u<t;u+=1)o.setPixel(u,i,e(u,i));var f=g();o.write(f);for(var a=v(),c=f.toByteArray(),s=0;s<c.length;s+=1)a.writeByte(c[s]);a.flush();var l="";return l+="<img",l+=\' src="\',l+="data:image/gif;base64,",l+=a,l+=\'"\',l+=\' width="\',l+=t,l+=\'"\',l+=\' height="\',l+=r,l+=\'"\',n&&(l+=\' alt="\',l+=n,l+=\'"\'),l+="/>"},w=function(t,r,e){for(var n=d(t,r),o=0;o<r;o+=1)for(var i=0;i<t;i+=1)n.setPixel(i,o,e(i,o));var u=g();n.write(u);for(var f=v(),a=u.toByteArray(),c=0;c<a.length;c+=1)f.writeByte(a[c]);f.flush();var s=new Image;return s.src="data:image/gif;base64,"+f,s.width=t,s.height=r,s};return{QRCode:r,QRUtil:i}}());!function(e){i=[],o=e,u="function"==typeof o?o.apply(r,i):o,!(void 0!==u&&(t.exports=u))}(function(){return{QRCode:a.QRCode,QRUtil:a.QRUtil}})},function(t,r,e){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var o=e(23),i=n(o),u=e(59),f=n(u),a="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};r.default="function"==typeof f.default&&"symbol"===a(i.default)?function(t){return"undefined"==typeof t?"undefined":a(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":a(t)}},function(t,r,e){t.exports={default:e(24),__esModule:!0}},function(t,r,e){e(25),e(54),t.exports=e(58).f("iterator")},function(t,r,e){"use strict";var n=e(26)(!0);e(29)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,r=this._t,e=this._i;return e>=r.length?{value:void 0,done:!0}:(t=n(r,e),this._i+=t.length,{value:t,done:!1})})},function(t,r,e){var n=e(27),o=e(28);t.exports=function(t){return function(r,e){var i,u,f=String(o(r)),a=n(e),c=f.length;return a<0||a>=c?t?"":void 0:(i=f.charCodeAt(a),i<55296||i>56319||a+1===c||(u=f.charCodeAt(a+1))<56320||u>57343?t?f.charAt(a):i:t?f.slice(a,a+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,r){var e=Math.ceil,n=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?n:e)(t)}},function(t,r){t.exports=function(t){if(void 0==t)throw TypeError("Can\'t call method on  "+t);return t}},function(t,r,e){"use strict";var n=e(30),o=e(6),i=e(31),u=e(11),f=e(32),a=e(33),c=e(34),s=e(50),l=e(52),h=e(51)("iterator"),g=!([].keys&&"next"in[].keys()),v="@@iterator",p="keys",d="values",y=function(){return this};t.exports=function(t,r,e,w,m,b,A){c(e,r,w);var x,E,M,_=function(t){if(!g&&t in S)return S[t];switch(t){case p:return function(){return new e(this,t)};case d:return function(){return new e(this,t)}}return function(){return new e(this,t)}},O=r+" Iterator",T=m==d,B=!1,S=t.prototype,P=S[h]||S[v]||m&&S[m],C=P||_(m),k=m?T?_("entries"):C:void 0,D="Array"==r?S.entries||P:P;if(D&&(M=l(D.call(new t)),M!==Object.prototype&&(s(M,O,!0),n||f(M,h)||u(M,h,y))),T&&P&&P.name!==d&&(B=!0,C=function(){return P.call(this)}),n&&!A||!g&&!B&&S[h]||u(S,h,C),a[r]=C,a[O]=y,m)if(x={values:T?C:_(d),keys:b?C:_(p),entries:k},A)for(E in x)E in S||i(S,E,x[E]);else o(o.P+o.F*(g||B),r,x);return x}},function(t,r){t.exports=!0},function(t,r,e){t.exports=e(11)},function(t,r){var e={}.hasOwnProperty;t.exports=function(t,r){return e.call(t,r)}},function(t,r){t.exports={}},function(t,r,e){"use strict";var n=e(35),o=e(20),i=e(50),u={};e(11)(u,e(51)("iterator"),function(){return this}),t.exports=function(t,r,e){t.prototype=n(u,{next:o(1,e)}),i(t,r+" Iterator")}},function(t,r,e){var n=e(13),o=e(36),i=e(48),u=e(45)("IE_PROTO"),f=function(){},a="prototype",c=function(){var t,r=e(18)("iframe"),n=i.length,o="<",u=">";for(r.style.display="none",e(49).appendChild(r),r.src="javascript:",t=r.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),c=t.F;n--;)delete c[a][i[n]];return c()};t.exports=Object.create||function(t,r){var e;return null!==t?(f[a]=n(t),e=new f,f[a]=null,e[u]=t):e=c(),void 0===r?e:o(e,r)}},function(t,r,e){var n=e(12),o=e(13),i=e(37);t.exports=e(16)?Object.defineProperties:function(t,r){o(t);for(var e,u=i(r),f=u.length,a=0;f>a;)n.f(t,e=u[a++],r[e]);return t}},function(t,r,e){var n=e(38),o=e(48);t.exports=Object.keys||function(t){return n(t,o)}},function(t,r,e){var n=e(32),o=e(39),i=e(42)(!1),u=e(45)("IE_PROTO");t.exports=function(t,r){var e,f=o(t),a=0,c=[];for(e in f)e!=u&&n(f,e)&&c.push(e);for(;r.length>a;)n(f,e=r[a++])&&(~i(c,e)||c.push(e));return c}},function(t,r,e){var n=e(40),o=e(28);t.exports=function(t){return n(o(t))}},function(t,r,e){var n=e(41);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==n(t)?t.split(""):Object(t)}},function(t,r){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,r,e){var n=e(39),o=e(43),i=e(44);t.exports=function(t){return function(r,e,u){var f,a=n(r),c=o(a.length),s=i(u,c);if(t&&e!=e){for(;c>s;)if(f=a[s++],f!=f)return!0}else for(;c>s;s++)if((t||s in a)&&a[s]===e)return t||s||0;return!t&&-1}}},function(t,r,e){var n=e(27),o=Math.min;t.exports=function(t){return t>0?o(n(t),9007199254740991):0}},function(t,r,e){var n=e(27),o=Math.max,i=Math.min;t.exports=function(t,r){return t=n(t),t<0?o(t+r,0):i(t,r)}},function(t,r,e){var n=e(46)("keys"),o=e(47);t.exports=function(t){return n[t]||(n[t]=o(t))}},function(t,r,e){var n=e(7),o="__core-js_shared__",i=n[o]||(n[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,r){var e=0,n=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+n).toString(36))}},function(t,r){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,r,e){t.exports=e(7).document&&document.documentElement},function(t,r,e){var n=e(12).f,o=e(32),i=e(51)("toStringTag");t.exports=function(t,r,e){t&&!o(t=e?t:t.prototype,i)&&n(t,i,{configurable:!0,value:r})}},function(t,r,e){var n=e(46)("wks"),o=e(47),i=e(7).Symbol,u="function"==typeof i,f=t.exports=function(t){return n[t]||(n[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=n},function(t,r,e){var n=e(32),o=e(53),i=e(45)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),n(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,r,e){var n=e(28);t.exports=function(t){return Object(n(t))}},function(t,r,e){e(55);for(var n=e(7),o=e(11),i=e(33),u=e(51)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],a=0;a<5;a++){var c=f[a],s=n[c],l=s&&s.prototype;l&&!l[u]&&o(l,u,c),i[c]=i.Array}},function(t,r,e){"use strict";var n=e(56),o=e(57),i=e(33),u=e(39);t.exports=e(29)(Array,"Array",function(t,r){this._t=u(t),this._i=0,this._k=r},function(){var t=this._t,r=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==r?o(0,e):"values"==r?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,n("keys"),n("values"),n("entries")},function(t,r){t.exports=function(){}},function(t,r){t.exports=function(t,r){return{value:r,done:!!t}}},function(t,r,e){r.f=e(51)},function(t,r,e){t.exports={default:e(60),__esModule:!0}},function(t,r,e){e(61),e(72),e(73),e(74),t.exports=e(8).Symbol},function(t,r,e){"use strict";var n=e(7),o=e(32),i=e(16),u=e(6),f=e(31),a=e(62).KEY,c=e(17),s=e(46),l=e(50),h=e(47),g=e(51),v=e(58),p=e(63),d=e(64),y=e(65),w=e(68),m=e(13),b=e(39),A=e(19),x=e(20),E=e(35),M=e(69),_=e(71),O=e(12),T=e(37),B=_.f,S=O.f,P=M.f,C=n.Symbol,k=n.JSON,D=k&&k.stringify,N="prototype",I=g("_hidden"),L=g("toPrimitive"),j={}.propertyIsEnumerable,R=s("symbol-registry"),F=s("symbols"),U=s("op-symbols"),Q=Object[N],H="function"==typeof C,J=n.QObject,K=!J||!J[N]||!J[N].findChild,Y=i&&c(function(){\nreturn 7!=E(S({},"a",{get:function(){return S(this,"a",{value:7}).a}})).a})?function(t,r,e){var n=B(Q,r);n&&delete Q[r],S(t,r,e),n&&t!==Q&&S(Q,r,n)}:S,z=function(t){var r=F[t]=E(C[N]);return r._k=t,r},W=H&&"symbol"==typeof C.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof C},q=function(t,r,e){return t===Q&&q(U,r,e),m(t),r=A(r,!0),m(e),o(F,r)?(e.enumerable?(o(t,I)&&t[I][r]&&(t[I][r]=!1),e=E(e,{enumerable:x(0,!1)})):(o(t,I)||S(t,I,x(1,{})),t[I][r]=!0),Y(t,r,e)):S(t,r,e)},G=function(t,r){m(t);for(var e,n=y(r=b(r)),o=0,i=n.length;i>o;)q(t,e=n[o++],r[e]);return t},$=function(t,r){return void 0===r?E(t):G(E(t),r)},Z=function(t){var r=j.call(this,t=A(t,!0));return!(this===Q&&o(F,t)&&!o(U,t))&&(!(r||!o(this,t)||!o(F,t)||o(this,I)&&this[I][t])||r)},V=function(t,r){if(t=b(t),r=A(r,!0),t!==Q||!o(F,r)||o(U,r)){var e=B(t,r);return!e||!o(F,r)||o(t,I)&&t[I][r]||(e.enumerable=!0),e}},X=function(t){for(var r,e=P(b(t)),n=[],i=0;e.length>i;)o(F,r=e[i++])||r==I||r==a||n.push(r);return n},tt=function(t){for(var r,e=t===Q,n=P(e?U:b(t)),i=[],u=0;n.length>u;)!o(F,r=n[u++])||e&&!o(Q,r)||i.push(F[r]);return i};H||(C=function(){if(this instanceof C)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),r=function(e){this===Q&&r.call(U,e),o(this,I)&&o(this[I],t)&&(this[I][t]=!1),Y(this,t,x(1,e))};return i&&K&&Y(Q,t,{configurable:!0,set:r}),z(t)},f(C[N],"toString",function(){return this._k}),_.f=V,O.f=q,e(70).f=M.f=X,e(67).f=Z,e(66).f=tt,i&&!e(30)&&f(Q,"propertyIsEnumerable",Z,!0),v.f=function(t){return z(g(t))}),u(u.G+u.W+u.F*!H,{Symbol:C});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)g(rt[et++]);for(var rt=T(g.store),et=0;rt.length>et;)p(rt[et++]);u(u.S+u.F*!H,"Symbol",{for:function(t){return o(R,t+="")?R[t]:R[t]=C(t)},keyFor:function(t){if(W(t))return d(R,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){K=!0},useSimple:function(){K=!1}}),u(u.S+u.F*!H,"Object",{create:$,defineProperty:q,defineProperties:G,getOwnPropertyDescriptor:V,getOwnPropertyNames:X,getOwnPropertySymbols:tt}),k&&u(u.S+u.F*(!H||c(function(){var t=C();return"[null]"!=D([t])||"{}"!=D({a:t})||"{}"!=D(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!W(t)){for(var r,e,n=[t],o=1;arguments.length>o;)n.push(arguments[o++]);return r=n[1],"function"==typeof r&&(e=r),!e&&w(r)||(r=function(t,r){if(e&&(r=e.call(this,t,r)),!W(r))return r}),n[1]=r,D.apply(k,n)}}}),C[N][L]||e(11)(C[N],L,C[N].valueOf),l(C,"Symbol"),l(Math,"Math",!0),l(n.JSON,"JSON",!0)},function(t,r,e){var n=e(47)("meta"),o=e(14),i=e(32),u=e(12).f,f=0,a=Object.isExtensible||function(){return!0},c=!e(17)(function(){return a(Object.preventExtensions({}))}),s=function(t){u(t,n,{value:{i:"O"+ ++f,w:{}}})},l=function(t,r){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,n)){if(!a(t))return"F";if(!r)return"E";s(t)}return t[n].i},h=function(t,r){if(!i(t,n)){if(!a(t))return!0;if(!r)return!1;s(t)}return t[n].w},g=function(t){return c&&v.NEED&&a(t)&&!i(t,n)&&s(t),t},v=t.exports={KEY:n,NEED:!1,fastKey:l,getWeak:h,onFreeze:g}},function(t,r,e){var n=e(7),o=e(8),i=e(30),u=e(58),f=e(12).f;t.exports=function(t){var r=o.Symbol||(o.Symbol=i?{}:n.Symbol||{});"_"==t.charAt(0)||t in r||f(r,t,{value:u.f(t)})}},function(t,r,e){var n=e(37),o=e(39);t.exports=function(t,r){for(var e,i=o(t),u=n(i),f=u.length,a=0;f>a;)if(i[e=u[a++]]===r)return e}},function(t,r,e){var n=e(37),o=e(66),i=e(67);t.exports=function(t){var r=n(t),e=o.f;if(e)for(var u,f=e(t),a=i.f,c=0;f.length>c;)a.call(t,u=f[c++])&&r.push(u);return r}},function(t,r){r.f=Object.getOwnPropertySymbols},function(t,r){r.f={}.propertyIsEnumerable},function(t,r,e){var n=e(41);t.exports=Array.isArray||function(t){return"Array"==n(t)}},function(t,r,e){var n=e(39),o=e(70).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(n(t))}},function(t,r,e){var n=e(38),o=e(48).concat("length","prototype");r.f=Object.getOwnPropertyNames||function(t){return n(t,o)}},function(t,r,e){var n=e(67),o=e(20),i=e(39),u=e(19),f=e(32),a=e(15),c=Object.getOwnPropertyDescriptor;r.f=e(16)?c:function(t,r){if(t=i(t),r=u(r,!0),a)try{return c(t,r)}catch(t){}if(f(t,r))return o(!n.f.call(t,r),t[r])}},function(t,r){},function(t,r,e){e(63)("asyncIterator")},function(t,r,e){e(63)("observable")},function(t,r,e){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(r,"__esModule",{value:!0});var o=e(1),i=n(o),u=e(2),f=n(u),a=function(){function t(){(0,i.default)(this,t)}return(0,f.default)(t,null,[{key:"createCanvas",value:function(t,r){var e=document.createElement("canvas");return e.width=t,e.height=t,e.getContext("2d").drawImage(r,0,0,t,t),e}},{key:"threshold",value:function(t,r,e,n){return.2126*t+.7152*r+.0722*e>=n?255:0}}]),t}();r.default=a}])});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy9xYXJ0Lm1pbi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNmY4MjhkN2E2YjMwZWNkOGQzZDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL3FhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcXJjb2RlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcyJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJ0aGlzIiwibW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImluc3RhbGxlZE1vZHVsZXMiLCJpZCIsImxvYWRlZCIsImNhbGwiLCJtIiwiYyIsInAiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2NsYXNzQ2FsbENoZWNrMiIsIl9jbGFzc0NhbGxDaGVjazMiLCJfY3JlYXRlQ2xhc3MyIiwiX2NyZWF0ZUNsYXNzMyIsIl9xcmNvZGUiLCJfdXRpbCIsIl91dGlsMiIsIlFBcnQiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiaW1hZ2VQYXRoIiwiZmlsdGVyIiwiREVGQVVMVFMiLCJrZXkiLCJlbCIsImltYWdlU2l6ZSIsInBhZGRpbmciLCJsZXZlbCIsInFyIiwiUVJDb2RlIiwiYWRkRGF0YSIsIm1ha2UiLCJxckltYWdlIiwiY3JlYXRlSW1nT2JqZWN0Iiwic2VsZiIsIm9ubG9hZCIsImNvdmVySW1hZ2UiLCJJbWFnZSIsInNyYyIsInJlc3VsdENhbnZhcyIsImNyZWF0ZUNhbnZhcyIsInFyQ2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjb3ZlckNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJjb3ZlckltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImNvdmVySW1hZ2VCaW5hcnkiLCJkYXRhIiwicmVzdWx0SW1hZ2VEYXRhIiwicmVzdWx0SW1hZ2VCaW5hcnkiLCJpIiwibGVuZ3RoIiwieCIsIk1hdGgiLCJmbG9vciIsInkiLCJmYWN0b3IiLCJ0aHJlc2hvbGQiLCJwdXRJbWFnZURhdGEiLCJwYXR0ZXJuUG9zdGlvbiIsIlFSVXRpbCIsImdldFBhdHRlcm5Qb3NpdGlvbiIsImoiLCJyZWN0WCIsInJlY3RZIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsInJlY3REYXRhIiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJnZXQiLCJ3aW5kb3ciLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnR5IiwiX2RlZmluZVByb3BlcnR5MiIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCIkT2JqZWN0IiwiaXQiLCJkZXNjIiwiJGV4cG9ydCIsIlMiLCJGIiwiZiIsImdsb2JhbCIsImNvcmUiLCJjdHgiLCJoaWRlIiwiUFJPVE9UWVBFIiwidHlwZSIsIm5hbWUiLCJzb3VyY2UiLCJvd24iLCJvdXQiLCJJU19GT1JDRUQiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJQIiwiSVNfQklORCIsIkIiLCJJU19XUkFQIiwiVyIsImV4cFByb3RvIiwidW5kZWZpbmVkIiwiQyIsImEiLCJiIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJGdW5jdGlvbiIsInZpcnR1YWwiLCJSIiwiVSIsIl9fZyIsInZlcnNpb24iLCJfX2UiLCJhRnVuY3Rpb24iLCJmbiIsInRoYXQiLCJkUCIsImNyZWF0ZURlc2MiLCJvYmplY3QiLCJhbk9iamVjdCIsIklFOF9ET01fREVGSU5FIiwidG9QcmltaXRpdmUiLCJPIiwiQXR0cmlidXRlcyIsImUiLCJpc09iamVjdCIsImV4ZWMiLCJpcyIsInZhbCIsInRvU3RyaW5nIiwidmFsdWVPZiIsImJpdG1hcCIsIl9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyIsIl9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18iLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyIsIl90eXBlb2YyIiwicXJjb2RlIiwicXJQb2x5bm9taWFsIiwibnVtIiwic2hpZnQiLCJFcnJvciIsIl9udW0iLCJvZmZzZXQiLCJBcnJheSIsIl90aGlzIiwiZ2V0QXQiLCJpbmRleCIsImdldExlbmd0aCIsIm11bHRpcGx5IiwiUVJNYXRoIiwiZ2V4cCIsImdsb2ciLCJtb2QiLCJyYXRpbyIsInR5cGVOdW1iZXIiLCJlcnJvckNvcnJlY3Rpb25MZXZlbCIsIlBBRDAiLCJQQUQxIiwiX3R5cGVOdW1iZXIiLCJfZXJyb3JDb3JyZWN0aW9uTGV2ZWwiLCJRUkVycm9yQ29ycmVjdGlvbkxldmVsIiwiX21vZHVsZXMiLCJfbW9kdWxlQ291bnQiLCJfZGF0YUNhY2hlIiwiX2RhdGFMaXN0IiwibWFrZUltcGwiLCJ0ZXN0IiwibWFza1BhdHRlcm4iLCJtb2R1bGVDb3VudCIsInJvdyIsImNvbCIsInNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4iLCJzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiIsInNldHVwVGltaW5nUGF0dGVybiIsInNldHVwVHlwZUluZm8iLCJzZXR1cFR5cGVOdW1iZXIiLCJjcmVhdGVEYXRhIiwibWFwRGF0YSIsInIiLCJnZXRCZXN0TWFza1BhdHRlcm4iLCJtaW5Mb3N0UG9pbnQiLCJwYXR0ZXJuIiwibG9zdFBvaW50IiwiZ2V0TG9zdFBvaW50IiwicG9zIiwiYml0cyIsImdldEJDSFR5cGVOdW1iZXIiLCJnZXRCQ0hUeXBlSW5mbyIsImluYyIsImJpdEluZGV4IiwiYnl0ZUluZGV4IiwibWFza0Z1bmMiLCJnZXRNYXNrRnVuY3Rpb24iLCJkYXJrIiwibWFzayIsImNyZWF0ZUJ5dGVzIiwiYnVmZmVyIiwicnNCbG9ja3MiLCJtYXhEY0NvdW50IiwibWF4RWNDb3VudCIsImRjZGF0YSIsImVjZGF0YSIsImRjQ291bnQiLCJkYXRhQ291bnQiLCJlY0NvdW50IiwidG90YWxDb3VudCIsIm1heCIsImdldEJ1ZmZlciIsInJzUG9seSIsImdldEVycm9yQ29ycmVjdFBvbHlub21pYWwiLCJyYXdQb2x5IiwibW9kUG9seSIsIm1vZEluZGV4IiwidG90YWxDb2RlQ291bnQiLCJkYXRhTGlzdCIsIlFSUlNCbG9jayIsImdldFJTQmxvY2tzIiwicXJCaXRCdWZmZXIiLCJwdXQiLCJnZXRNb2RlIiwiZ2V0TGVuZ3RoSW5CaXRzIiwid3JpdGUiLCJ0b3RhbERhdGFDb3VudCIsInB1dEJpdCIsIm1vZGUiLCJuZXdEYXRhIiwicXJOdW1iZXIiLCJxckFscGhhTnVtIiwicXI4Qml0Qnl0ZSIsInFyS2FuamkiLCJwdXNoIiwiaXNEYXJrIiwiZ2V0TW9kdWxlQ291bnQiLCJjcmVhdGVUYWJsZVRhZyIsImNlbGxTaXplIiwibWFyZ2luIiwicXJIdG1sIiwiY3JlYXRlU3ZnVGFnIiwibWMiLCJtciIsInJlY3QiLCJzaXplIiwicXJTdmciLCJjcmVhdGVJbWdUYWciLCJtaW4iLCJzdHJpbmdUb0J5dGVzIiwicyIsImJ5dGVzIiwiY2hhckNvZGVBdCIsImNyZWF0ZVN0cmluZ1RvQnl0ZXMiLCJ1bmljb2RlRGF0YSIsIm51bUNoYXJzIiwidW5pY29kZU1hcCIsImJpbiIsImJhc2U2NERlY29kZUlucHV0U3RyZWFtIiwicmVhZCIsImNvdW50IiwiYjAiLCJiMSIsImIyIiwiYjMiLCJrIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwidiIsInVua25vd25DaGFyIiwiY2hhckF0IiwiUVJNb2RlIiwiTU9ERV9OVU1CRVIiLCJNT0RFX0FMUEhBX05VTSIsIk1PREVfOEJJVF9CWVRFIiwiTU9ERV9LQU5KSSIsIkwiLCJNIiwiUSIsIkgiLCJRUk1hc2tQYXR0ZXJuIiwiUEFUVEVSTjAwMCIsIlBBVFRFUk4wMDEiLCJQQVRURVJOMDEwIiwiUEFUVEVSTjAxMSIsIlBBVFRFUk4xMDAiLCJQQVRURVJOMTAxIiwiUEFUVEVSTjExMCIsIlBBVFRFUk4xMTEiLCJQQVRURVJOX1BPU0lUSU9OX1RBQkxFIiwiRzE1IiwiRzE4IiwiRzE1X01BU0siLCJnZXRCQ0hEaWdpdCIsImRpZ2l0IiwiZCIsImVycm9yQ29ycmVjdExlbmd0aCIsInNhbWVDb3VudCIsImRhcmtDb3VudCIsImFicyIsIkVYUF9UQUJMRSIsIkxPR19UQUJMRSIsIm4iLCJSU19CTE9DS19UQUJMRSIsInFyUlNCbG9jayIsImdldFJzQmxvY2tUYWJsZSIsInJzQmxvY2siLCJsaXN0IiwiX2J1ZmZlciIsIl9sZW5ndGgiLCJidWZJbmRleCIsImJpdCIsIl9tb2RlIiwiX2RhdGEiLCJzdHJUb051bSIsInN1YnN0cmluZyIsImNoYXRUb051bSIsImdldENvZGUiLCJfYnl0ZXMiLCJjb2RlIiwiYnl0ZUFycmF5T3V0cHV0U3RyZWFtIiwid3JpdGVCeXRlIiwid3JpdGVTaG9ydCIsIndyaXRlQnl0ZXMiLCJvZmYiLCJsZW4iLCJ3cml0ZVN0cmluZyIsInRvQnl0ZUFycmF5IiwiYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtIiwiX2J1ZmxlbiIsIl9iYXNlNjQiLCJ3cml0ZUVuY29kZWQiLCJlbmNvZGUiLCJmbHVzaCIsInBhZGxlbiIsInN0ciIsIl9zdHIiLCJfcG9zIiwibWF0Y2giLCJkZWNvZGUiLCJnaWZJbWFnZSIsIl93aWR0aCIsIl9oZWlnaHQiLCJzZXRQaXhlbCIsInBpeGVsIiwibHp3TWluQ29kZVNpemUiLCJyYXN0ZXIiLCJnZXRMWldSYXN0ZXIiLCJiaXRPdXRwdXRTdHJlYW0iLCJfb3V0IiwiX2JpdExlbmd0aCIsIl9iaXRCdWZmZXIiLCJjbGVhckNvZGUiLCJlbmRDb2RlIiwiYml0TGVuZ3RoIiwidGFibGUiLCJsendUYWJsZSIsImFkZCIsImJ5dGVPdXQiLCJiaXRPdXQiLCJkYXRhSW5kZXgiLCJjb250YWlucyIsImluZGV4T2YiLCJfbWFwIiwiX3NpemUiLCJnZXRQaXhlbCIsImFsdCIsImdpZiIsImJhc2U2NCIsImltZyIsIl9pdGVyYXRvciIsIl9pdGVyYXRvcjIiLCJfc3ltYm9sIiwiX3N5bWJvbDIiLCJfdHlwZW9mIiwiY29uc3RydWN0b3IiLCIkYXQiLCJpdGVyYXRlZCIsIl90IiwiX2kiLCJwb2ludCIsImRvbmUiLCJ0b0ludGVnZXIiLCJkZWZpbmVkIiwiVE9fU1RSSU5HIiwibCIsInNsaWNlIiwiY2VpbCIsImlzTmFOIiwiTElCUkFSWSIsInJlZGVmaW5lIiwiaGFzIiwiSXRlcmF0b3JzIiwiJGl0ZXJDcmVhdGUiLCJzZXRUb1N0cmluZ1RhZyIsImdldFByb3RvdHlwZU9mIiwiSVRFUkFUT1IiLCJCVUdHWSIsImtleXMiLCJGRl9JVEVSQVRPUiIsIktFWVMiLCJWQUxVRVMiLCJyZXR1cm5UaGlzIiwiQmFzZSIsIk5BTUUiLCJuZXh0IiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsIm1ldGhvZHMiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldE1ldGhvZCIsImtpbmQiLCJwcm90byIsIlRBRyIsIkRFRl9WQUxVRVMiLCJWQUxVRVNfQlVHIiwiJG5hdGl2ZSIsIiRkZWZhdWx0IiwiJGVudHJpZXMiLCIkYW55TmF0aXZlIiwiZW50cmllcyIsInZhbHVlcyIsImhhc093blByb3BlcnR5IiwiY3JlYXRlIiwiZFBzIiwiZW51bUJ1Z0tleXMiLCJJRV9QUk9UTyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZURvY3VtZW50IiwiaWZyYW1lIiwibHQiLCJndCIsInN0eWxlIiwiZGlzcGxheSIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwiY2xvc2UiLCJQcm9wZXJ0aWVzIiwicmVzdWx0IiwiZ2V0S2V5cyIsIiRrZXlzIiwidG9JT2JqZWN0IiwiYXJyYXlJbmRleE9mIiwibmFtZXMiLCJJT2JqZWN0IiwiY29mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzcGxpdCIsInRvTGVuZ3RoIiwidG9JbmRleCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJmcm9tSW5kZXgiLCJzaGFyZWQiLCJ1aWQiLCJTSEFSRUQiLCJzdG9yZSIsInB4IiwicmFuZG9tIiwiY29uY2F0IiwiZG9jdW1lbnRFbGVtZW50IiwiZGVmIiwidGFnIiwic3RhdCIsIlN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsInRvT2JqZWN0IiwiT2JqZWN0UHJvdG8iLCJUT19TVFJJTkdfVEFHIiwiY29sbGVjdGlvbnMiLCJDb2xsZWN0aW9uIiwiYWRkVG9VbnNjb3BhYmxlcyIsInN0ZXAiLCJfayIsIkFyZ3VtZW50cyIsIkRFU0NSSVBUT1JTIiwiTUVUQSIsIktFWSIsIiRmYWlscyIsIndrcyIsIndrc0V4dCIsIndrc0RlZmluZSIsImtleU9mIiwiZW51bUtleXMiLCJpc0FycmF5IiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkR09QRCIsIiREUCIsImdPUEQiLCJnT1BOIiwiJFN5bWJvbCIsIiRKU09OIiwiSlNPTiIsIl9zdHJpbmdpZnkiLCJzdHJpbmdpZnkiLCJISURERU4iLCJUT19QUklNSVRJVkUiLCJpc0VudW0iLCJTeW1ib2xSZWdpc3RyeSIsIkFsbFN5bWJvbHMiLCJPUFN5bWJvbHMiLCJVU0VfTkFUSVZFIiwiUU9iamVjdCIsInNldHRlciIsImZpbmRDaGlsZCIsInNldFN5bWJvbERlc2MiLCJEIiwicHJvdG9EZXNjIiwid3JhcCIsInN5bSIsImlzU3ltYm9sIiwiaXRlcmF0b3IiLCIkZGVmaW5lUHJvcGVydHkiLCIkZGVmaW5lUHJvcGVydGllcyIsIiRjcmVhdGUiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJFIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIklTX09QIiwiJHNldCIsInNldCIsInN5bWJvbHMiLCJmb3IiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicmVwbGFjZXIiLCIkcmVwbGFjZXIiLCJhcmdzIiwic2V0RGVzYyIsImlzRXh0ZW5zaWJsZSIsIkZSRUVaRSIsInByZXZlbnRFeHRlbnNpb25zIiwic2V0TWV0YSIsInciLCJmYXN0S2V5IiwiZ2V0V2VhayIsIm9uRnJlZXplIiwibWV0YSIsIk5FRUQiLCJnT1BTIiwicElFIiwiZ2V0U3ltYm9scyIsImFyZyIsIndpbmRvd05hbWVzIiwiZ2V0V2luZG93TmFtZXMiLCJoaWRkZW5LZXlzIiwiVXRpbCIsImltYWdlIiwiY2FudmFzIiwiZyJdLCJtYXBwaW5ncyI6IkNBQUEsU0FBQUEsRUFBQUMsR0FDQSxnQkFBQUMsVUFBQSxnQkFBQUMsUUFDQUEsT0FBQUQsUUFBQUQsSUFDQSxrQkFBQUcsZ0JBQUFDLElBQ0FELFVBQUFILEdBQ0EsZ0JBQUFDLFNBQ0FBLFFBQUEsS0FBQUQsSUFFQUQsRUFBQSxLQUFBQyxLQUNDSyxLQUFBLFdBQ0QsTUNBZ0IsVUFBVUMsR0NOMUIsUUFBQUMsR0FBQUMsR0FHQSxHQUFBQyxFQUFBRCxHQUNBLE1BQUFDLEdBQUFELEdBQUFQLE9BR0EsSUFBQUMsR0FBQU8sRUFBQUQsSUFDQVAsV0FDQVMsR0FBQUYsRUFDQUcsUUFBQSxFQVVBLE9BTkFMLEdBQUFFLEdBQUFJLEtBQUFWLEVBQUFELFFBQUFDLElBQUFELFFBQUFNLEdBR0FMLEVBQUFTLFFBQUEsRUFHQVQsRUFBQUQsUUF2QkEsR0FBQVEsS0FxQ0EsT0FUQUYsR0FBQU0sRUFBQVAsRUFHQUMsRUFBQU8sRUFBQUwsRUFHQUYsRUFBQVEsRUFBQSxXQUdBUixFQUFBLEtEZ0JNLFNBQVNMLEVBQVFELEVBQVNNLEdBRS9CLFlBb0JBLFNBQVNTLEdBQXVCQyxHQUFPLE1BQU9BLElBQU9BLEVBQUlDLFdBQWFELEdBQVFFLFFBQVNGLEdBbEJ2RkcsT0FBT0MsZUFBZXBCLEVBQVMsY0FDM0JxQixPQUFPLEdBR1gsSUFBSUMsR0FBbUJoQixFQUFvQixHQUV2Q2lCLEVBQW1CUixFQUF1Qk8sR0FFMUNFLEVBQWdCbEIsRUFBb0IsR0FFcENtQixFQUFnQlYsRUFBdUJTLEdFcEU1Q0UsRUFBQXBCLEVBQUEsSUFDQXFCLEVBQUFyQixFQUFBLElGeUVLc0IsRUFBU2IsRUFBdUJZLEdFdkUvQkUsRUYyRU0sV0UxRVYsUUFBQUEsR0FBWUMsR0FDVixJQURtQixFQUFBUCxFQUFBTCxTQUFBZCxLQUFBeUIsR0FDSSxtQkFBWkMsR0FDUCxLQUFNLElBQUlDLFdBQVUsMkJBQ2pCLElBQTZCLG1CQUFsQkQsR0FBUVQsTUFDdEIsS0FBTSxJQUFJVSxXQUFVLGdDQUNqQixJQUFpQyxtQkFBdEJELEdBQVFFLFVBQ3RCLEtBQU0sSUFBSUQsV0FBVSxvQ0FJeEIzQixNQUFLNkIsT0FBb0MsbUJBQW5CSCxHQUFRRyxPQUEwQkosRUFBS0ssU0FBU0QsT0FBU0gsRUFBUUcsT0FDdkY3QixLQUFLaUIsTUFBUVMsRUFBUVQsTUFDckJqQixLQUFLNEIsVUFBWUYsRUFBUUUsVUZzTHhCLE9BdkdBLEVBQUlQLEVBQWNQLFNBQVNXLElBQ3ZCTSxJQUFLLE9BQ0xkLE1BQU8sU0V0RVRlLEdBQ0gsR0FBSUMsR0FBWSxJQUNaQyxFQUFVLEdBQ1ZDLEVBQVEsR0FFUkMsR0FBSyxFQUFBZCxFQUFBZSxRQUFPRixFQUFPLElBQ3ZCQyxHQUFHRSxRQUFRdEMsS0FBS2lCLE9BQ2hCbUIsRUFBR0csTUFDSCxJQUFJQyxHQUFVSixFQUFHSyxnQkFBZ0IsR0FFN0JDLEVBQU8xQyxJQUNYd0MsR0FBUUcsT0FBUyxXQUNiLEdBQUlDLEdBQWEsR0FBSUMsTUFDckJELEdBQVdFLElBQU1KLEVBQUtkLFNBRXRCLElBQUltQixHQUFldkIsRUFBQVYsUUFBS2tDLGFBQWFmLEVBQVdPLEdBQzVDUyxFQUFXekIsRUFBQVYsUUFBS2tDLGFBQWFmLEVBQVdPLEVBRTVDSSxHQUFXRCxPQUFTLFdBQ1pDLEVBQVdNLE1BQVFOLEVBQVdPLFFBQzlCUCxFQUFXTyxRQUFVbEIsRUFBc0IsRUFBVkMsSUFBZ0IsRUFBTVUsRUFBV08sT0FBU1AsRUFBV00sT0FDdEZOLEVBQVdNLE1BQVFqQixFQUFzQixFQUFWQyxJQUUvQlUsRUFBV00sT0FBU2pCLEVBQXNCLEVBQVZDLElBQWdCLEVBQU1VLEVBQVdNLE1BQVFOLEVBQVdPLFFBQ3BGUCxFQUFXTyxPQUFTbEIsRUFBc0IsRUFBVkMsRUFHcEMsSUFBSWtCLEdBQWNDLFNBQVNDLGNBQWMsU0FDekNGLEdBQVlGLE1BQVFqQixFQUNwQm1CLEVBQVlELE9BQVNsQixFQUNyQm1CLEVBQVlHLFdBQVcsTUFBTUMsVUFBVVosRUFBWVYsRUFBU0EsRUFBU0QsRUFBc0IsRUFBVkMsRUFBYUQsRUFBc0IsRUFBVkMsRUFPMUcsS0FBSyxHQUxEdUIsR0FBaUJMLEVBQVlHLFdBQVcsTUFBTUcsYUFBYSxFQUFHLEVBQUd6QixFQUFXQSxHQUM1RTBCLEVBQW1CRixFQUFlRyxLQUNsQ0MsRUFBa0JkLEVBQWFRLFdBQVcsTUFBTUcsYUFBYSxFQUFHLEVBQUd6QixFQUFXQSxHQUM5RTZCLEVBQW9CRCxFQUFnQkQsS0FFL0JHLEVBQUksRUFBR0EsRUFBSUosRUFBaUJLLE9BQVFELEdBQUssRUFBRyxDQUNqRCxHQUFJRSxHQUFJQyxLQUFLQyxNQUFNSixFQUFJLEdBQUs5QixFQUN4Qm1DLEVBQUlGLEtBQUtDLE1BQU1ELEtBQUtDLE1BQU1KLEVBQUksR0FBSzlCLEVBRXZDLElBQUlnQyxFQUFJL0IsR0FBV2tDLEVBQUlsQyxHQUFXK0IsR0FBS2hDLEVBQVVDLEdBQVdrQyxHQUFLbkMsRUFBVUMsRUFDdkU0QixFQUFrQkMsRUFBRSxHQUFLLE1BRzdCLEtBQUlFLEVBQUUsR0FBSyxHQUFLRyxFQUFFLEdBQUssTUFHbkJILEVBQUksS0FBT0csRUFBSSxJQUFNQSxHQUFLbkMsRUFBVSxLQUdwQ2dDLEdBQUtoQyxFQUFVLElBQU1tQyxFQUFJLElBQTdCLENBSUEsR0FBbUIsYUFBZjFCLEVBQUtiLE9BQXVCLENBQzVCLEdBQUl3QyxHQUFTN0MsRUFBQVYsUUFBS3dELFVBQVVYLEVBQWlCSSxHQUFJSixFQUFpQkksRUFBRSxHQUFJSixFQUFpQkksRUFBRSxHQUFJLElBQy9GRCxHQUFrQkMsR0FBS00sRUFDdkJQLEVBQWtCQyxFQUFFLEdBQUtNLEVBQ3pCUCxFQUFrQkMsRUFBRSxHQUFLTSxNQUNILFNBQWYzQixFQUFLYixTQUNaaUMsRUFBa0JDLEdBQUtKLEVBQWlCSSxHQUN4Q0QsRUFBa0JDLEVBQUUsR0FBS0osRUFBaUJJLEVBQUUsR0FDNUNELEVBQWtCQyxFQUFFLEdBQUtKLEVBQWlCSSxFQUFFLEdBRWhERCxHQUFrQkMsRUFBRSxHQUFLSixFQUFpQkksRUFBRSxJQUdoRGhCLEVBQWFRLFdBQVcsTUFBTWdCLGFBQWFWLEVBQWlCLEVBQUcsRUFHL0QsS0FBSyxHQUREVyxHQUFpQmxELEVBQUFtRCxPQUFPQyxtQkFBbUJ2QyxHQUN0QzRCLEVBQUksRUFBR0EsRUFBSVMsRUFBZVIsT0FBUUQsR0FBSyxFQUM1QyxJQUFLLEdBQUlZLEdBQUksRUFBR0EsRUFBSUgsRUFBZVIsT0FBUVcsR0FBSyxFQUFHLENBQy9DLEdBQUlWLEdBQUlPLEVBQWVULEdBQ25CSyxFQUFJSSxFQUFlRyxFQUN2QixNQUFZLEdBQUxWLEdBQWUsSUFBTEcsR0FBa0IsR0FBTEEsR0FBZSxJQUFMSCxHQUFrQixHQUFMQSxHQUFlLEdBQUxHLEdBQVUsQ0FDckUsR0FBSVEsR0FBUSxHQUFLWCxFQUFFLEdBQUssR0FDcEJZLEVBQVEsR0FBS1QsRUFBRSxHQUFLLEdBQ3BCVSxFQUFhLEdBQUtiLEVBQUUsR0FBSyxHQUFNVyxFQUMvQkcsRUFBYyxHQUFLWCxFQUFFLEdBQUssR0FBTVMsRUFFaENHLEVBQVcvQixFQUFTTSxXQUFXLE1BQU1HLGFBQWFrQixFQUFPQyxFQUFPQyxFQUFXQyxFQUMvRWhDLEdBQWFRLFdBQVcsTUFBTWdCLGFBQWFTLEVBQVVKLEVBQU9DLElBT3hFN0MsRUFBR2lELFVBQVksR0FDZmpELEVBQUdrRCxZQUFZbkMsVUZ5RWxCaEIsSUFBSyxXQUNMb0QsSUFBSyxXRTNLVixPQUVFbEUsTUFBTyxHQUNQWSxPQUFRLGlCRitLRkosSUUzRVoyRCxRQUFPM0QsS0FBT0EsRUYrRWI3QixFQUFRa0IsUUU5RU1zRSxPQUFPM0QsTUZrRmhCLFNBQVM1QixFQUFRRCxHRzlNdkIsWUFFQUEsR0FBQWlCLFlBQUEsRUFFQWpCLEVBQUFrQixRQUFBLFNBQUF1RSxFQUFBQyxHQUNBLEtBQUFELFlBQUFDLElBQ0EsU0FBQTNELFdBQUEsdUNIc05NLFNBQVM5QixFQUFRRCxFQUFTTSxHSTVOaEMsWUFRQSxTQUFBUyxHQUFBQyxHQUFzQyxNQUFBQSxNQUFBQyxXQUFBRCxHQUF1Q0UsUUFBQUYsR0FON0VoQixFQUFBaUIsWUFBQSxDQUVBLElBQUEwRSxHQUFBckYsRUFBQSxHQUVBc0YsRUFBQTdFLEVBQUE0RSxFQUlBM0YsR0FBQWtCLFFBQUEsV0FDQSxRQUFBMkUsR0FBQUMsRUFBQUMsR0FDQSxPQUFBNUIsR0FBQSxFQUFtQkEsRUFBQTRCLEVBQUEzQixPQUFrQkQsSUFBQSxDQUNyQyxHQUFBNkIsR0FBQUQsRUFBQTVCLEVBQ0E2QixHQUFBQyxXQUFBRCxFQUFBQyxhQUFBLEVBQ0FELEVBQUFFLGNBQUEsRUFDQSxTQUFBRixPQUFBRyxVQUFBLElBQ0EsRUFBQVAsRUFBQTFFLFNBQUE0RSxFQUFBRSxFQUFBN0QsSUFBQTZELElBSUEsZ0JBQUFOLEVBQUFVLEVBQUFDLEdBR0EsTUFGQUQsSUFBQVAsRUFBQUgsRUFBQVksVUFBQUYsR0FDQUMsR0FBQVIsRUFBQUgsRUFBQVcsR0FDQVgsT0pvT00sU0FBU3pGLEVBQVFELEVBQVNNLEdLNVBoQ0wsRUFBQUQsU0FBa0JrQixRQUFBWixFQUFBLEdBQUFXLFlBQUEsSUxrUVosU0FBU2hCLEVBQVFELEVBQVNNLEdNbFFoQ0EsRUFBQSxFQUNBLElBQUFpRyxHQUFBakcsRUFBQSxHQUFBYSxNQUNBbEIsR0FBQUQsUUFBQSxTQUFBd0csRUFBQXJFLEVBQUFzRSxHQUNBLE1BQUFGLEdBQUFuRixlQUFBb0YsRUFBQXJFLEVBQUFzRSxLTnlRTSxTQUFTeEcsRUFBUUQsRUFBU00sR081UWhDLEdBQUFvRyxHQUFBcEcsRUFBQSxFQUVBb0csS0FBQUMsRUFBQUQsRUFBQUUsR0FBQXRHLEVBQUEsY0FBdUVjLGVBQUFkLEVBQUEsSUFBQXVHLEtQa1JqRSxTQUFTNUcsRUFBUUQsRUFBU00sR1FwUmhDLEdBQUF3RyxHQUFBeEcsRUFBQSxHQUNBeUcsRUFBQXpHLEVBQUEsR0FDQTBHLEVBQUExRyxFQUFBLEdBQ0EyRyxFQUFBM0csRUFBQSxJQUNBNEcsRUFBQSxZQUVBUixFQUFBLFNBQUFTLEVBQUFDLEVBQUFDLEdBQ0EsR0FTQWxGLEdBQUFtRixFQUFBQyxFQVRBQyxFQUFBTCxFQUFBVCxFQUFBRSxFQUNBYSxFQUFBTixFQUFBVCxFQUFBZ0IsRUFDQUMsRUFBQVIsRUFBQVQsRUFBQUMsRUFDQWlCLEVBQUFULEVBQUFULEVBQUFtQixFQUNBQyxFQUFBWCxFQUFBVCxFQUFBcUIsRUFDQUMsRUFBQWIsRUFBQVQsRUFBQXVCLEVBQ0FqSSxFQUFBeUgsRUFBQVYsSUFBQUssS0FBQUwsRUFBQUssT0FDQWMsRUFBQWxJLEVBQUFrSCxHQUNBcEIsRUFBQTJCLEVBQUFYLEVBQUFhLEVBQUFiLEVBQUFNLElBQUFOLEVBQUFNLFFBQXFGRixFQUVyRk8sS0FBQUosRUFBQUQsRUFDQSxLQUFBakYsSUFBQWtGLEdBRUFDLEdBQUFFLEdBQUExQixHQUFBcUMsU0FBQXJDLEVBQUEzRCxHQUNBbUYsR0FBQW5GLElBQUFuQyxLQUVBdUgsRUFBQUQsRUFBQXhCLEVBQUEzRCxHQUFBa0YsRUFBQWxGLEdBRUFuQyxFQUFBbUMsR0FBQXNGLEdBQUEsa0JBQUEzQixHQUFBM0QsR0FBQWtGLEVBQUFsRixHQUVBMkYsR0FBQVIsRUFBQU4sRUFBQU8sRUFBQVQsR0FFQWtCLEdBQUFsQyxFQUFBM0QsSUFBQW9GLEVBQUEsU0FBQWEsR0FDQSxHQUFBeEIsR0FBQSxTQUFBeUIsRUFBQUMsRUFBQXpILEdBQ0EsR0FBQVQsZUFBQWdJLEdBQUEsQ0FDQSxPQUFBRyxVQUFBbkUsUUFDQSxpQkFBQWdFLEVBQ0Esa0JBQUFBLEdBQUFDLEVBQ0Esa0JBQUFELEdBQUFDLEVBQUFDLEdBQ1csVUFBQUYsR0FBQUMsRUFBQUMsRUFBQXpILEdBQ0YsTUFBQXVILEdBQUFJLE1BQUFwSSxLQUFBbUksV0FHVCxPQURBM0IsR0FBQU0sR0FBQWtCLEVBQUFsQixHQUNBTixHQUVLVyxHQUFBSyxHQUFBLGtCQUFBTCxHQUFBUCxFQUFBeUIsU0FBQTlILEtBQUE0RyxLQUVMSyxLQUNBNUgsRUFBQTBJLFVBQUExSSxFQUFBMEksYUFBK0N2RyxHQUFBb0YsRUFFL0NKLEVBQUFULEVBQUFpQyxHQUFBVCxNQUFBL0YsSUFBQThFLEVBQUFpQixFQUFBL0YsRUFBQW9GLEtBS0FiLEdBQUFFLEVBQUEsRUFDQUYsRUFBQWdCLEVBQUEsRUFDQWhCLEVBQUFDLEVBQUEsRUFDQUQsRUFBQW1CLEVBQUEsRUFDQW5CLEVBQUFxQixFQUFBLEdBQ0FyQixFQUFBdUIsRUFBQSxHQUNBdkIsRUFBQWtDLEVBQUEsR0FDQWxDLEVBQUFpQyxFQUFBLElBQ0ExSSxFQUFBRCxRQUFBMEcsR1IwUk0sU0FBU3pHLEVBQVFELEdTclZ2QixHQUFBOEcsR0FBQTdHLEVBQUFELFFBQUEsbUJBQUF3RixnQkFBQWxCLFdBQ0FrQixPQUFBLG1CQUFBMUMsWUFBQXdCLFdBQUF4QixLQUFBMkYsU0FBQSxnQkFDQSxpQkFBQUksV0FBQS9CLElUNFZNLFNBQVM3RyxFQUFRRCxHVS9WdkIsR0FBQStHLEdBQUE5RyxFQUFBRCxTQUE2QjhJLFFBQUEsUUFDN0IsaUJBQUFDLFdBQUFoQyxJVnFXTSxTQUFTOUcsRUFBUUQsRUFBU00sR1dyV2hDLEdBQUEwSSxHQUFBMUksRUFBQSxHQUNBTCxHQUFBRCxRQUFBLFNBQUFpSixFQUFBQyxFQUFBOUUsR0FFQSxHQURBNEUsRUFBQUMsR0FDQWQsU0FBQWUsRUFBQSxNQUFBRCxFQUNBLFFBQUE3RSxHQUNBLHVCQUFBaUUsR0FDQSxNQUFBWSxHQUFBdEksS0FBQXVJLEVBQUFiLEdBRUEsd0JBQUFBLEVBQUFDLEdBQ0EsTUFBQVcsR0FBQXRJLEtBQUF1SSxFQUFBYixFQUFBQyxHQUVBLHdCQUFBRCxFQUFBQyxFQUFBekgsR0FDQSxNQUFBb0ksR0FBQXRJLEtBQUF1SSxFQUFBYixFQUFBQyxFQUFBekgsSUFHQSxrQkFDQSxNQUFBb0ksR0FBQVQsTUFBQVUsRUFBQVgsY1g4V00sU0FBU3RJLEVBQVFELEdZL1h2QkMsRUFBQUQsUUFBQSxTQUFBd0csR0FDQSxxQkFBQUEsR0FBQSxLQUFBekUsV0FBQXlFLEVBQUEsc0JBQ0EsT0FBQUEsS1pzWU0sU0FBU3ZHLEVBQVFELEVBQVNNLEdheFloQyxHQUFBNkksR0FBQTdJLEVBQUEsSUFDQThJLEVBQUE5SSxFQUFBLEdBQ0FMLEdBQUFELFFBQUFNLEVBQUEsYUFBQStJLEVBQUFsSCxFQUFBZCxHQUNBLE1BQUE4SCxHQUFBdEMsRUFBQXdDLEVBQUFsSCxFQUFBaUgsRUFBQSxFQUFBL0gsS0FDQyxTQUFBZ0ksRUFBQWxILEVBQUFkLEdBRUQsTUFEQWdJLEdBQUFsSCxHQUFBZCxFQUNBZ0ksSWIrWU0sU0FBU3BKLEVBQVFELEVBQVNNLEdjclpoQyxHQUFBZ0osR0FBQWhKLEVBQUEsSUFDQWlKLEVBQUFqSixFQUFBLElBQ0FrSixFQUFBbEosRUFBQSxJQUNBNkksRUFBQWhJLE9BQUFDLGNBRUFwQixHQUFBNkcsRUFBQXZHLEVBQUEsSUFBQWEsT0FBQUMsZUFBQSxTQUFBcUksRUFBQTVCLEVBQUE2QixHQUlBLEdBSEFKLEVBQUFHLEdBQ0E1QixFQUFBMkIsRUFBQTNCLEdBQUEsR0FDQXlCLEVBQUFJLEdBQ0FILEVBQUEsSUFDQSxNQUFBSixHQUFBTSxFQUFBNUIsRUFBQTZCLEdBQ0csTUFBQUMsSUFDSCxVQUFBRCxJQUFBLE9BQUFBLEdBQUEsS0FBQTNILFdBQUEsMkJBRUEsT0FEQSxTQUFBMkgsS0FBQUQsRUFBQTVCLEdBQUE2QixFQUFBckksT0FDQW9JLElkNFpNLFNBQVN4SixFQUFRRCxFQUFTTSxHZTFhaEMsR0FBQXNKLEdBQUF0SixFQUFBLEdBQ0FMLEdBQUFELFFBQUEsU0FBQXdHLEdBQ0EsSUFBQW9ELEVBQUFwRCxHQUFBLEtBQUF6RSxXQUFBeUUsRUFBQSxxQkFDQSxPQUFBQSxLZmliTSxTQUFTdkcsRUFBUUQsR2dCcGJ2QkMsRUFBQUQsUUFBQSxTQUFBd0csR0FDQSxzQkFBQUEsR0FBQSxPQUFBQSxFQUFBLGtCQUFBQSxLaEIyYk0sU0FBU3ZHLEVBQVFELEVBQVNNLEdpQjViaENMLEVBQUFELFNBQUFNLEVBQUEsTUFBQUEsRUFBQSxlQUNBLE1BQW1HLElBQW5HYSxPQUFBQyxlQUFBZCxFQUFBLGdCQUFzRWlGLElBQUEsV0FBZ0IsWUFBYThDLEtqQm1jN0YsU0FBU3BJLEVBQVFELEVBQVNNLEdrQm5jaENMLEVBQUFELFNBQUFNLEVBQUEsZUFDQSxNQUFzRSxJQUF0RWEsT0FBQUMsa0JBQWlDLEtBQVFtRSxJQUFBLFdBQWdCLFlBQWE4QyxLbEIyY2hFLFNBQVNwSSxFQUFRRCxHbUI3Y3ZCQyxFQUFBRCxRQUFBLFNBQUE2SixHQUNBLElBQ0EsUUFBQUEsSUFDRyxNQUFBRixHQUNILFluQnFkTSxTQUFTMUosRUFBUUQsRUFBU00sR29CemRoQyxHQUFBc0osR0FBQXRKLEVBQUEsSUFDQW1ELEVBQUFuRCxFQUFBLEdBQUFtRCxTQUVBcUcsRUFBQUYsRUFBQW5HLElBQUFtRyxFQUFBbkcsRUFBQUMsY0FDQXpELEdBQUFELFFBQUEsU0FBQXdHLEdBQ0EsTUFBQXNELEdBQUFyRyxFQUFBQyxjQUFBOEMsUXBCZ2VNLFNBQVN2RyxFQUFRRCxFQUFTTSxHcUJwZWhDLEdBQUFzSixHQUFBdEosRUFBQSxHQUdBTCxHQUFBRCxRQUFBLFNBQUF3RyxFQUFBRyxHQUNBLElBQUFpRCxFQUFBcEQsR0FBQSxNQUFBQSxFQUNBLElBQUF5QyxHQUFBYyxDQUNBLElBQUFwRCxHQUFBLG1CQUFBc0MsRUFBQXpDLEVBQUF3RCxZQUFBSixFQUFBRyxFQUFBZCxFQUFBdEksS0FBQTZGLElBQUEsTUFBQXVELEVBQ0EsdUJBQUFkLEVBQUF6QyxFQUFBeUQsV0FBQUwsRUFBQUcsRUFBQWQsRUFBQXRJLEtBQUE2RixJQUFBLE1BQUF1RCxFQUNBLEtBQUFwRCxHQUFBLG1CQUFBc0MsRUFBQXpDLEVBQUF3RCxZQUFBSixFQUFBRyxFQUFBZCxFQUFBdEksS0FBQTZGLElBQUEsTUFBQXVELEVBQ0EsTUFBQWhJLFdBQUEsNkNyQjRlTSxTQUFTOUIsRUFBUUQsR3NCdGZ2QkMsRUFBQUQsUUFBQSxTQUFBa0ssRUFBQTdJLEdBQ0EsT0FDQTRFLGFBQUEsRUFBQWlFLEdBQ0FoRSxlQUFBLEVBQUFnRSxHQUNBL0QsV0FBQSxFQUFBK0QsR0FDQTdJLFd0QjhmTSxTQUFTcEIsRUFBUUQsRUFBU00sR0FRL0IsUUFBU1MsR0FBdUJDLEdBQU8sTUFBT0EsSUFBT0EsRUFBSUMsV0FBYUQsR0FBUUUsUUFBU0YsR0FOdkYsR0FBSW1KLEdBQWdDQyxFQUE4QkMsRUFFOURDLEVBQVdoSyxFQUFvQixJdUJ0ZmhDaUssR3ZCd2ZZeEosRUFBdUJ1SixHdUJ4ZjFCLFdBMjhCWCxRQUFTRSxHQUFhQyxFQUFLQyxHQUV6QixHQUF5QixtQkFBZEQsR0FBSXJHLE9BQ2IsS0FBTSxJQUFJdUcsT0FBTUYsRUFBSXJHLE9BQVMsSUFBTXNHLEVBR3JDLElBQUlFLEdBQU8sV0FFVCxJQURBLEdBQUlDLEdBQVMsRUFDTkEsRUFBU0osRUFBSXJHLFFBQXlCLEdBQWZxRyxFQUFJSSxJQUNoQ0EsR0FBVSxDQUdaLEtBQUssR0FEREQsR0FBTyxHQUFJRSxPQUFNTCxFQUFJckcsT0FBU3lHLEVBQVNILEdBQ2xDdkcsRUFBSSxFQUFHQSxFQUFJc0csRUFBSXJHLE9BQVN5RyxFQUFRMUcsR0FBSyxFQUM1Q3lHLEVBQUt6RyxHQUFLc0csRUFBSXRHLEVBQUkwRyxFQUVwQixPQUFPRCxNQUdMRyxJQTRDSixPQTFDQUEsR0FBTUMsTUFBUSxTQUFTQyxHQUNyQixNQUFPTCxHQUFLSyxJQUdkRixFQUFNRyxVQUFZLFdBQ2hCLE1BQU9OLEdBQUt4RyxRQUdkMkcsRUFBTUksU0FBVyxTQUFTeEIsR0FJeEIsSUFBSyxHQUZEYyxHQUFNLEdBQUlLLE9BQU1DLEVBQU1HLFlBQWN2QixFQUFFdUIsWUFBYyxHQUUvQy9HLEVBQUksRUFBR0EsRUFBSTRHLEVBQU1HLFlBQWEvRyxHQUFLLEVBQzFDLElBQUssR0FBSVksR0FBSSxFQUFHQSxFQUFJNEUsRUFBRXVCLFlBQWFuRyxHQUFLLEVBQ3RDMEYsRUFBSXRHLEVBQUlZLElBQU1xRyxFQUFPQyxLQUFLRCxFQUFPRSxLQUFLUCxFQUFNQyxNQUFNN0csSUFBT2lILEVBQU9FLEtBQUszQixFQUFFcUIsTUFBTWpHLElBSWpGLE9BQU95RixHQUFhQyxFQUFLLElBRzNCTSxFQUFNUSxJQUFNLFNBQVM1QixHQUVuQixHQUFJb0IsRUFBTUcsWUFBY3ZCLEVBQUV1QixZQUFjLEVBQ3RDLE1BQU9ILEVBTVQsS0FBSyxHQUhEUyxHQUFRSixFQUFPRSxLQUFLUCxFQUFNQyxNQUFNLElBQU9JLEVBQU9FLEtBQUszQixFQUFFcUIsTUFBTSxJQUUzRFAsRUFBTSxHQUFJSyxPQUFNQyxFQUFNRyxhQUNqQi9HLEVBQUksRUFBR0EsRUFBSTRHLEVBQU1HLFlBQWEvRyxHQUFLLEVBQzFDc0csRUFBSXRHLEdBQUs0RyxFQUFNQyxNQUFNN0csRUFHdkIsS0FBSyxHQUFJQSxHQUFJLEVBQUdBLEVBQUl3RixFQUFFdUIsWUFBYS9HLEdBQUssRUFDdENzRyxFQUFJdEcsSUFBTWlILEVBQU9DLEtBQUtELEVBQU9FLEtBQUszQixFQUFFcUIsTUFBTTdHLElBQU9xSCxFQUluRCxPQUFPaEIsR0FBYUMsRUFBSyxHQUFHYyxJQUFJNUIsSUFHM0JvQixFQTkvQlQsR0FBSVIsR0FBUyxTQUFTa0IsRUFBWUMsR0FFaEMsR0FBSUMsR0FBTyxJQUNQQyxFQUFPLEdBRVBDLEVBQWNKLEVBQ2RLLEVBQXdCQyxFQUF1QkwsR0FDL0NNLEVBQVcsS0FDWEMsRUFBZSxFQUNmQyxFQUFhLEtBQ2JDLEVBQVksR0FBSXJCLE9BRWhCQyxLQUVBcUIsRUFBVyxTQUFTQyxFQUFNQyxHQUU1QkwsRUFBNkIsRUFBZEosRUFBa0IsR0FDakNHLEVBQVcsU0FBU08sR0FFbEIsSUFBSyxHQUREbE0sR0FBVSxHQUFJeUssT0FBTXlCLEdBQ2ZDLEVBQU0sRUFBR0EsRUFBTUQsRUFBYUMsR0FBTyxFQUFHLENBQzdDbk0sRUFBUW1NLEdBQU8sR0FBSTFCLE9BQU15QixFQUN6QixLQUFLLEdBQUlFLEdBQU0sRUFBR0EsRUFBTUYsRUFBYUUsR0FBTyxFQUMxQ3BNLEVBQVFtTSxHQUFLQyxHQUFPLEtBR3hCLE1BQU9wTSxJQUNQNEwsR0FFRlMsRUFBMEIsRUFBRyxHQUM3QkEsRUFBMEJULEVBQWUsRUFBRyxHQUM1Q1MsRUFBMEIsRUFBR1QsRUFBZSxHQUM1Q1UsSUFDQUMsSUFDQUMsRUFBY1IsRUFBTUMsR0FFaEJULEdBQWUsR0FDakJpQixFQUFnQlQsR0FHQSxNQUFkSCxJQUNGQSxFQUFhYSxFQUFXbEIsRUFBYUMsRUFBdUJLLElBRzlEYSxFQUFRZCxFQUFZSSxJQUdsQkksRUFBNEIsU0FBU0YsRUFBS0MsR0FFNUMsSUFBSyxHQUFJUSxJQUFJLEVBQUlBLEdBQUssRUFBR0EsR0FBSyxFQUU1QixLQUFJVCxFQUFNUyxJQUFLLEdBQU1oQixHQUFnQk8sRUFBTVMsR0FFM0MsSUFBSyxHQUFJcE0sSUFBSSxFQUFJQSxHQUFLLEVBQUdBLEdBQUssRUFFeEI0TCxFQUFNNUwsSUFBSyxHQUFNb0wsR0FBZ0JRLEVBQU01TCxJQUVyQyxHQUFLb00sR0FBS0EsR0FBSyxJQUFXLEdBQUxwTSxHQUFlLEdBQUxBLElBQzdCLEdBQUtBLEdBQUtBLEdBQUssSUFBVyxHQUFMb00sR0FBZSxHQUFMQSxJQUMvQixHQUFLQSxHQUFLQSxHQUFLLEdBQUssR0FBS3BNLEdBQUtBLEdBQUssRUFDekNtTCxFQUFTUSxFQUFNUyxHQUFHUixFQUFNNUwsSUFBSyxFQUU3Qm1MLEVBQVNRLEVBQU1TLEdBQUdSLEVBQU01TCxJQUFLLElBTWpDcU0sRUFBcUIsV0FLdkIsSUFBSyxHQUhEQyxHQUFlLEVBQ2ZDLEVBQVUsRUFFTGpKLEVBQUksRUFBR0EsRUFBSSxFQUFHQSxHQUFLLEVBQUcsQ0FFN0JpSSxHQUFTLEVBQU1qSSxFQUVmLElBQUlrSixHQUFZeEksRUFBT3lJLGFBQWF2QyxJQUUzQixHQUFMNUcsR0FBVWdKLEVBQWVFLEtBQzNCRixFQUFlRSxFQUNmRCxFQUFVakosR0FJZCxNQUFPaUosSUFHTFIsRUFBcUIsV0FFdkIsSUFBSyxHQUFJSyxHQUFJLEVBQUdBLEVBQUloQixFQUFlLEVBQUdnQixHQUFLLEVBQ25CLE1BQWxCakIsRUFBU2lCLEdBQUcsS0FHaEJqQixFQUFTaUIsR0FBRyxHQUFNQSxFQUFJLEdBQUssRUFHN0IsS0FBSyxHQUFJcE0sR0FBSSxFQUFHQSxFQUFJb0wsRUFBZSxFQUFHcEwsR0FBSyxFQUNuQixNQUFsQm1MLEVBQVMsR0FBR25MLEtBR2hCbUwsRUFBUyxHQUFHbkwsR0FBTUEsRUFBSSxHQUFLLElBSTNCOEwsRUFBNkIsV0FJL0IsSUFBSyxHQUZEWSxHQUFNMUksRUFBT0MsbUJBQW1CK0csR0FFM0IxSCxFQUFJLEVBQUdBLEVBQUlvSixFQUFJbkosT0FBUUQsR0FBSyxFQUVuQyxJQUFLLEdBQUlZLEdBQUksRUFBR0EsRUFBSXdJLEVBQUluSixPQUFRVyxHQUFLLEVBQUcsQ0FFdEMsR0FBSXlILEdBQU1lLEVBQUlwSixHQUNWc0ksRUFBTWMsRUFBSXhJLEVBRWQsSUFBMEIsTUFBdEJpSCxFQUFTUSxHQUFLQyxHQUlsQixJQUFLLEdBQUlRLElBQUksRUFBSUEsR0FBSyxFQUFHQSxHQUFLLEVBRTVCLElBQUssR0FBSXBNLElBQUksRUFBSUEsR0FBSyxFQUFHQSxHQUFLLEVBRXhCb00sSUFBSyxHQUFXLEdBQUxBLEdBQVVwTSxJQUFLLEdBQVcsR0FBTEEsR0FDdkIsR0FBTG9NLEdBQWUsR0FBTHBNLEVBQ2hCbUwsRUFBU1EsRUFBTVMsR0FBR1IsRUFBTTVMLElBQUssRUFFN0JtTCxFQUFTUSxFQUFNUyxHQUFHUixFQUFNNUwsSUFBSyxJQVFyQ2lNLEVBQWtCLFNBQVNULEdBSTdCLElBQUssR0FGRG1CLEdBQU8zSSxFQUFPNEksaUJBQWlCNUIsR0FFMUIxSCxFQUFJLEVBQUdBLEVBQUksR0FBSUEsR0FBSyxFQUFHLENBQzlCLEdBQUlvSCxJQUFRYyxHQUE4QixJQUFuQm1CLEdBQVFySixFQUFLLEVBQ3BDNkgsR0FBUzFILEtBQUtDLE1BQU1KLEVBQUksSUFBSUEsRUFBSSxFQUFJOEgsRUFBZSxFQUFJLEdBQUtWLEVBRzlELElBQUssR0FBSXBILEdBQUksRUFBR0EsRUFBSSxHQUFJQSxHQUFLLEVBQUcsQ0FDOUIsR0FBSW9ILElBQVFjLEdBQThCLElBQW5CbUIsR0FBUXJKLEVBQUssRUFDcEM2SCxHQUFTN0gsRUFBSSxFQUFJOEgsRUFBZSxFQUFJLEdBQUczSCxLQUFLQyxNQUFNSixFQUFJLElBQU1vSCxJQUk1RHNCLEVBQWdCLFNBQVNSLEVBQU1DLEdBTWpDLElBQUssR0FKRHRJLEdBQVE4SCxHQUF5QixFQUFLUSxFQUN0Q2tCLEVBQU8zSSxFQUFPNkksZUFBZTFKLEdBR3hCRyxFQUFJLEVBQUdBLEVBQUksR0FBSUEsR0FBSyxFQUFHLENBRTlCLEdBQUlvSCxJQUFRYyxHQUE4QixJQUFuQm1CLEdBQVFySixFQUFLLEVBRWhDQSxHQUFJLEVBQ042SCxFQUFTN0gsR0FBRyxHQUFLb0gsRUFDUnBILEVBQUksRUFDYjZILEVBQVM3SCxFQUFJLEdBQUcsR0FBS29ILEVBRXJCUyxFQUFTQyxFQUFlLEdBQUs5SCxHQUFHLEdBQUtvSCxFQUt6QyxJQUFLLEdBQUlwSCxHQUFJLEVBQUdBLEVBQUksR0FBSUEsR0FBSyxFQUFHLENBRTlCLEdBQUlvSCxJQUFRYyxHQUE4QixJQUFuQm1CLEdBQVFySixFQUFLLEVBRWhDQSxHQUFJLEVBQ042SCxFQUFTLEdBQUdDLEVBQWU5SCxFQUFJLEdBQUtvSCxFQUMzQnBILEVBQUksRUFDYjZILEVBQVMsR0FBRyxHQUFLN0gsRUFBSSxFQUFJLEdBQUtvSCxFQUU5QlMsRUFBUyxHQUFHLEdBQUs3SCxFQUFJLEdBQUtvSCxFQUs5QlMsRUFBU0MsRUFBZSxHQUFHLElBQU9JLEdBR2hDVyxFQUFVLFNBQVNoSixFQUFNc0ksR0FRM0IsSUFBSyxHQU5EcUIsSUFBTSxFQUNObkIsRUFBTVAsRUFBZSxFQUNyQjJCLEVBQVcsRUFDWEMsRUFBWSxFQUNaQyxFQUFXakosRUFBT2tKLGdCQUFnQnpCLEdBRTdCRyxFQUFNUixFQUFlLEVBQUdRLEVBQU0sRUFBR0EsR0FBTyxFQUkvQyxJQUZXLEdBQVBBLElBQVVBLEdBQU8sS0FFUixDQUVYLElBQUssR0FBSTVMLEdBQUksRUFBR0EsRUFBSSxFQUFHQSxHQUFLLEVBRTFCLEdBQThCLE1BQTFCbUwsRUFBU1EsR0FBS0MsRUFBTTVMLEdBQVksQ0FFbEMsR0FBSW1OLElBQU8sQ0FFUEgsR0FBWTdKLEVBQUtJLFNBQ25CNEosRUFBa0QsSUFBdENoSyxFQUFLNkosS0FBZUQsRUFBWSxHQUc5QyxJQUFJSyxHQUFPSCxFQUFTdEIsRUFBS0MsRUFBTTVMLEVBRTNCb04sS0FDRkQsR0FBUUEsR0FHVmhDLEVBQVNRLEdBQUtDLEVBQU01TCxHQUFLbU4sRUFDekJKLEdBQVksRUFFUkEsSUFBWSxJQUNkQyxHQUFhLEVBQ2JELEVBQVcsR0FPakIsR0FGQXBCLEdBQU9tQixFQUVIbkIsRUFBTSxHQUFLUCxHQUFnQk8sRUFBSyxDQUNsQ0EsR0FBT21CLEVBQ1BBLEdBQU9BLENBQ1AsVUFNSk8sRUFBYyxTQUFTQyxFQUFRQyxHQVVqQyxJQUFLLEdBUkR2RCxHQUFTLEVBRVR3RCxFQUFhLEVBQ2JDLEVBQWEsRUFFYkMsRUFBUyxHQUFJekQsT0FBTXNELEVBQVNoSyxRQUM1Qm9LLEVBQVMsR0FBSTFELE9BQU1zRCxFQUFTaEssUUFFdkI2SSxFQUFJLEVBQUdBLEVBQUltQixFQUFTaEssT0FBUTZJLEdBQUssRUFBRyxDQUUzQyxHQUFJd0IsR0FBVUwsRUFBU25CLEdBQUd5QixVQUN0QkMsRUFBVVAsRUFBU25CLEdBQUcyQixXQUFhSCxDQUV2Q0osR0FBYS9KLEtBQUt1SyxJQUFJUixFQUFZSSxHQUNsQ0gsRUFBYWhLLEtBQUt1SyxJQUFJUCxFQUFZSyxHQUVsQ0osRUFBT3RCLEdBQUssR0FBSW5DLE9BQU0yRCxFQUV0QixLQUFLLEdBQUl0SyxHQUFJLEVBQUdBLEVBQUlvSyxFQUFPdEIsR0FBRzdJLE9BQVFELEdBQUssRUFDekNvSyxFQUFPdEIsR0FBRzlJLEdBQUssSUFBT2dLLEVBQU9XLFlBQVkzSyxFQUFJMEcsRUFFL0NBLElBQVU0RCxDQUVWLElBQUlNLEdBQVNsSyxFQUFPbUssMEJBQTBCTCxHQUMxQ00sRUFBVXpFLEVBQWErRCxFQUFPdEIsR0FBSThCLEVBQU83RCxZQUFjLEdBRXZEZ0UsRUFBVUQsRUFBUTFELElBQUl3RCxFQUMxQlAsR0FBT3ZCLEdBQUssR0FBSW5DLE9BQU1pRSxFQUFPN0QsWUFBYyxFQUMzQyxLQUFLLEdBQUkvRyxHQUFJLEVBQUdBLEVBQUlxSyxFQUFPdkIsR0FBRzdJLE9BQVFELEdBQUssRUFBRyxDQUM1QyxHQUFJZ0wsR0FBV2hMLEVBQUkrSyxFQUFRaEUsWUFBY3NELEVBQU92QixHQUFHN0ksTUFDbkRvSyxHQUFPdkIsR0FBRzlJLEdBQU1nTCxHQUFZLEVBQUlELEVBQVFsRSxNQUFNbUUsR0FBWSxHQUs5RCxJQUFLLEdBRERDLEdBQWlCLEVBQ1pqTCxFQUFJLEVBQUdBLEVBQUlpSyxFQUFTaEssT0FBUUQsR0FBSyxFQUN4Q2lMLEdBQWtCaEIsRUFBU2pLLEdBQUd5SyxVQU1oQyxLQUFLLEdBSEQ1SyxHQUFPLEdBQUk4RyxPQUFNc0UsR0FDakJuRSxFQUFRLEVBRUg5RyxFQUFJLEVBQUdBLEVBQUlrSyxFQUFZbEssR0FBSyxFQUNuQyxJQUFLLEdBQUk4SSxHQUFJLEVBQUdBLEVBQUltQixFQUFTaEssT0FBUTZJLEdBQUssRUFDcEM5SSxFQUFJb0ssRUFBT3RCLEdBQUc3SSxTQUNoQkosRUFBS2lILEdBQVNzRCxFQUFPdEIsR0FBRzlJLEdBQ3hCOEcsR0FBUyxFQUtmLEtBQUssR0FBSTlHLEdBQUksRUFBR0EsRUFBSW1LLEVBQVluSyxHQUFLLEVBQ25DLElBQUssR0FBSThJLEdBQUksRUFBR0EsRUFBSW1CLEVBQVNoSyxPQUFRNkksR0FBSyxFQUNwQzlJLEVBQUlxSyxFQUFPdkIsR0FBRzdJLFNBQ2hCSixFQUFLaUgsR0FBU3VELEVBQU92QixHQUFHOUksR0FDeEI4RyxHQUFTLEVBS2YsT0FBT2pILElBR0wrSSxFQUFhLFNBQVN0QixFQUFZQyxFQUFzQjJELEdBTTFELElBQUssR0FKRGpCLEdBQVdrQixFQUFVQyxZQUFZOUQsRUFBWUMsR0FFN0N5QyxFQUFTcUIsSUFFSnJMLEVBQUksRUFBR0EsRUFBSWtMLEVBQVNqTCxPQUFRRCxHQUFLLEVBQUcsQ0FDM0MsR0FBSUgsR0FBT3FMLEVBQVNsTCxFQUNwQmdLLEdBQU9zQixJQUFJekwsRUFBSzBMLFVBQVcsR0FDM0J2QixFQUFPc0IsSUFBSXpMLEVBQUtrSCxZQUFhckcsRUFBTzhLLGdCQUFnQjNMLEVBQUswTCxVQUFXakUsSUFDcEV6SCxFQUFLNEwsTUFBTXpCLEdBS2IsSUFBSyxHQUREMEIsR0FBaUIsRUFDWjFMLEVBQUksRUFBR0EsRUFBSWlLLEVBQVNoSyxPQUFRRCxHQUFLLEVBQ3hDMEwsR0FBa0J6QixFQUFTakssR0FBR3VLLFNBR2hDLElBQUlQLEVBQU93QixrQkFBcUMsRUFBakJFLEVBQzdCLEtBQU0sSUFBSWxGLE9BQU0sMEJBQ1p3RCxFQUFPd0Isa0JBQ1AsSUFDaUIsRUFBakJFLEVBQ0EsSUFTTixLQUxJMUIsRUFBT3dCLGtCQUFvQixHQUFzQixFQUFqQkUsR0FDbEMxQixFQUFPc0IsSUFBSSxFQUFHLEdBSVR0QixFQUFPd0Isa0JBQW9CLEdBQUssR0FDckN4QixFQUFPMkIsUUFBTyxFQUloQixRQUFhLENBRVgsR0FBSTNCLEVBQU93QixtQkFBc0MsRUFBakJFLEVBQzlCLEtBSUYsSUFGQTFCLEVBQU9zQixJQUFJOUQsRUFBTSxHQUVid0MsRUFBT3dCLG1CQUFzQyxFQUFqQkUsRUFDOUIsS0FFRjFCLEdBQU9zQixJQUFJN0QsRUFBTSxHQUduQixNQUFPc0MsR0FBWUMsRUFBUUMsR0E4SjdCLE9BM0pBckQsR0FBTXJJLFFBQVUsU0FBU3NCLEVBQU0rTCxHQUU3QkEsRUFBT0EsR0FBUSxNQUVmLElBQUlDLEdBQVUsSUFFZCxRQUFPRCxHQUNQLElBQUssVUFDSEMsRUFBVUMsRUFBU2pNLEVBQ25CLE1BQ0YsS0FBSyxlQUNIZ00sRUFBVUUsRUFBV2xNLEVBQ3JCLE1BQ0YsS0FBSyxPQUNIZ00sRUFBVUcsRUFBV25NLEVBQ3JCLE1BQ0YsS0FBSyxRQUNIZ00sRUFBVUksRUFBUXBNLEVBQ2xCLE1BQ0YsU0FDRSxLQUFNLFFBQVUrTCxFQUdsQjVELEVBQVVrRSxLQUFLTCxHQUNmOUQsRUFBYSxNQUdmbkIsRUFBTXVGLE9BQVMsU0FBUzlELEVBQUtDLEdBQzNCLEdBQUlELEVBQU0sR0FBS1AsR0FBZ0JPLEdBQU9DLEVBQU0sR0FBS1IsR0FBZ0JRLEVBQy9ELEtBQU0sSUFBSTlCLE9BQU02QixFQUFNLElBQU1DLEVBRTlCLE9BQU9ULEdBQVNRLEdBQUtDLElBR3ZCMUIsRUFBTXdGLGVBQWlCLFdBQ3JCLE1BQU90RSxJQUdUbEIsRUFBTXBJLEtBQU8sV0FDWHlKLEdBQVMsRUFBT2MsTUFHbEJuQyxFQUFNeUYsZUFBaUIsU0FBU0MsRUFBVUMsR0FFeENELEVBQVdBLEdBQVksRUFDdkJDLEVBQTJCLG1CQUFWQSxHQUFtQyxFQUFYRCxFQUFlQyxDQUV4RCxJQUFJQyxHQUFTLEVBRWJBLElBQVUsaUJBQ1ZBLEdBQVUsMENBQ1ZBLEdBQVUsOEJBQ1ZBLEdBQVUsMEJBQTRCRCxFQUFTLE1BQy9DQyxHQUFVLEtBQ1ZBLEdBQVUsU0FFVixLQUFLLEdBQUkxRCxHQUFJLEVBQUdBLEVBQUlsQyxFQUFNd0YsaUJBQWtCdEQsR0FBSyxFQUFHLENBRWxEMEQsR0FBVSxNQUVWLEtBQUssR0FBSTlQLEdBQUksRUFBR0EsRUFBSWtLLEVBQU13RixpQkFBa0IxUCxHQUFLLEVBQy9DOFAsR0FBVSxjQUNWQSxHQUFVLDBDQUNWQSxHQUFVLDhCQUNWQSxHQUFVLDhCQUNWQSxHQUFVLFdBQWFGLEVBQVcsTUFDbENFLEdBQVUsWUFBY0YsRUFBVyxNQUNuQ0UsR0FBVSxzQkFDVkEsR0FBVTVGLEVBQU11RixPQUFPckQsRUFBR3BNLEdBQUksVUFBWSxVQUMxQzhQLEdBQVUsSUFDVkEsR0FBVSxLQUdaQSxJQUFVLFFBTVosTUFIQUEsSUFBVSxXQUNWQSxHQUFVLFlBS1o1RixFQUFNNkYsYUFBZSxTQUFTSCxFQUFVQyxHQUV0Q0QsRUFBV0EsR0FBWSxFQUN2QkMsRUFBMkIsbUJBQVZBLEdBQW1DLEVBQVhELEVBQWVDLENBQ3hELElBQ0k3UCxHQUFHZ1EsRUFBSTVELEVBQUc2RCxFQUFjQyxFQUR4QkMsRUFBT2pHLEVBQU13RixpQkFBbUJFLEVBQW9CLEVBQVRDLEVBQzdCTyxFQUFNLEVBWXhCLEtBVkFGLEVBQU8sSUFBTU4sRUFBVyxRQUFVQSxFQUNoQyxLQUFPQSxFQUFXLFNBQVdBLEVBQVcsS0FFMUNRLEdBQVMsT0FDVEEsR0FBUyxXQUFhRCxFQUFPLE1BQzdCQyxHQUFTLFlBQWNELEVBQU8sTUFDOUJDLEdBQVMsc0NBQ1RBLEdBQVMsSUFDVEEsR0FBUyxZQUVKaEUsRUFBSSxFQUFHQSxFQUFJbEMsRUFBTXdGLGlCQUFrQnRELEdBQUssRUFFM0MsSUFEQTZELEVBQUs3RCxFQUFJd0QsRUFBV0MsRUFDZjdQLEVBQUksRUFBR0EsRUFBSWtLLEVBQU13RixpQkFBa0IxUCxHQUFLLEVBQ3ZDa0ssRUFBTXVGLE9BQU9yRCxFQUFHcE0sS0FDbEJnUSxFQUFLaFEsRUFBRTRQLEVBQVNDLEVBQ2hCTyxHQUFTLElBQU1KLEVBQUssSUFBTUMsRUFBS0MsRUFRckMsT0FIQUUsSUFBUyx3Q0FDVEEsR0FBUyxVQUtYbEcsRUFBTW1HLGFBQWUsU0FBU1QsRUFBVUMsR0FFdENELEVBQVdBLEdBQVksRUFDdkJDLEVBQTJCLG1CQUFWQSxHQUFtQyxFQUFYRCxFQUFlQyxDQUV4RCxJQUFJTSxHQUFPakcsRUFBTXdGLGlCQUFtQkUsRUFBb0IsRUFBVEMsRUFDM0NTLEVBQU1ULEVBQ043QixFQUFNbUMsRUFBT04sQ0FFakIsT0FBT1EsR0FBYUYsRUFBTUEsRUFBTSxTQUFTM00sRUFBR0csR0FDMUMsR0FBSTJNLEdBQU85TSxHQUFLQSxFQUFJd0ssR0FBT3NDLEdBQU8zTSxHQUFLQSxFQUFJcUssRUFBSyxDQUM5QyxHQUFJaE8sR0FBSXlELEtBQUtDLE9BQVFGLEVBQUk4TSxHQUFPVixHQUM1QnhELEVBQUkzSSxLQUFLQyxPQUFRQyxFQUFJMk0sR0FBT1YsRUFDaEMsT0FBTzFGLEdBQU11RixPQUFPckQsRUFBR3BNLEdBQUksRUFBSSxFQUUvQixNQUFPLE1BS2JrSyxFQUFNbEksZ0JBQWtCLFNBQVM0TixFQUFVQyxHQUV6Q0QsRUFBV0EsR0FBWSxFQUN2QkMsRUFBMkIsbUJBQVZBLEdBQW1DLEVBQVhELEVBQWVDLENBRXhELElBQUlNLEdBQU9qRyxFQUFNd0YsaUJBQW1CRSxFQUFvQixFQUFUQyxFQUMzQ1MsRUFBTVQsRUFDTjdCLEVBQU1tQyxFQUFPTixDQUVqQixPQUFPN04sR0FBZ0JtTyxFQUFNQSxFQUFNLFNBQVMzTSxFQUFHRyxHQUM3QyxHQUFJMk0sR0FBTzlNLEdBQUtBLEVBQUl3SyxHQUFPc0MsR0FBTzNNLEdBQUtBLEVBQUlxSyxFQUFLLENBQzlDLEdBQUloTyxHQUFJeUQsS0FBS0MsT0FBUUYsRUFBSThNLEdBQU9WLEdBQzVCeEQsRUFBSTNJLEtBQUtDLE9BQVFDLEVBQUkyTSxHQUFPVixFQUNoQyxPQUFPMUYsR0FBTXVGLE9BQU9yRCxFQUFHcE0sR0FBSSxFQUFJLEVBRS9CLE1BQU8sTUFLTmtLLEVBT1RSLEdBQU82RyxjQUFnQixTQUFTQyxHQUU5QixJQUFLLEdBRERDLEdBQVEsR0FBSXhHLE9BQ1AzRyxFQUFJLEVBQUdBLEVBQUlrTixFQUFFak4sT0FBUUQsR0FBSyxFQUFHLENBQ3BDLEdBQUl0RCxHQUFJd1EsRUFBRUUsV0FBV3BOLEVBQ3JCbU4sR0FBTWpCLEtBQVMsSUFBSnhQLEdBRWIsTUFBT3lRLElBWVQvRyxFQUFPaUgsb0JBQXNCLFNBQVNDLEVBQWFDLEdBSWpELEdBQUlDLEdBQWEsV0FXZixJQVRBLEdBQUlDLEdBQU1DLEVBQXdCSixHQUM5QkssRUFBTyxXQUNULEdBQUl4SixHQUFJc0osRUFBSUUsTUFDWixJQUFJeEosSUFBSyxFQUFJLEtBQU0sSUFBSXFDLE1BQ3ZCLE9BQU9yQyxJQUdMeUosRUFBUSxFQUNSSixPQUNTLENBQ1gsR0FBSUssR0FBS0osRUFBSUUsTUFDYixJQUFJRSxJQUFNLEVBQUksS0FDZCxJQUFJQyxHQUFLSCxJQUNMSSxFQUFLSixJQUNMSyxFQUFLTCxJQUNMTSxFQUFJQyxPQUFPQyxhQUFlTixHQUFNLEVBQUtDLEdBQ3JDTSxFQUFLTCxHQUFNLEVBQUtDLENBQ3BCUixHQUFXUyxHQUFLRyxFQUNoQlIsR0FBUyxFQUVYLEdBQUlBLEdBQVNMLEVBQ1gsS0FBTSxJQUFJL0csT0FBTW9ILEVBQVEsT0FBU0wsRUFHbkMsT0FBT0MsTUFHTGEsRUFBYyxJQUFJakIsV0FBVyxFQUVqQyxPQUFPLFVBQVNGLEdBRWQsSUFBSyxHQUREQyxHQUFRLEdBQUl4RyxPQUNQM0csRUFBSSxFQUFHQSxFQUFJa04sRUFBRWpOLE9BQVFELEdBQUssRUFBRyxDQUNwQyxHQUFJdEQsR0FBSXdRLEVBQUVFLFdBQVdwTixFQUNyQixJQUFJdEQsRUFBSSxJQUNOeVEsRUFBTWpCLEtBQUt4UCxPQUNOLENBQ0wsR0FBSXlILEdBQUlxSixFQUFXTixFQUFFb0IsT0FBT3RPLEdBQ1osaUJBQUxtRSxJQUNDLElBQUpBLElBQWFBLEVBRWpCZ0osRUFBTWpCLEtBQUsvSCxJQUdYZ0osRUFBTWpCLEtBQUsvSCxJQUFNLEdBQ2pCZ0osRUFBTWpCLEtBQVMsSUFBSi9ILElBR2JnSixFQUFNakIsS0FBS21DLElBSWpCLE1BQU9sQixJQVFYLElBQUlvQixJQUNGQyxZQUFpQixFQUNqQkMsZUFBaUIsRUFDakJDLGVBQWlCLEVBQ2pCQyxXQUFpQixHQU9mL0csR0FDRmdILEVBQUksRUFDSkMsRUFBSSxFQUNKQyxFQUFJLEVBQ0pDLEVBQUksR0FPRkMsR0FDRkMsV0FBYSxFQUNiQyxXQUFhLEVBQ2JDLFdBQWEsRUFDYkMsV0FBYSxFQUNiQyxXQUFhLEVBQ2JDLFdBQWEsRUFDYkMsV0FBYSxFQUNiQyxXQUFhLEdBT1g5TyxFQUFTLFdBRVgsR0FBSStPLFFBRUQsRUFBRyxLQUNILEVBQUcsS0FDSCxFQUFHLEtBQ0gsRUFBRyxLQUNILEVBQUcsS0FDSCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksS0FDUCxFQUFHLEdBQUksR0FBSSxLQUNYLEVBQUcsR0FBSSxHQUFJLEtBQ1gsRUFBRyxHQUFJLEdBQUksS0FDWCxFQUFHLEdBQUksR0FBSSxLQUNYLEVBQUcsR0FBSSxHQUFJLEtBQ1gsRUFBRyxHQUFJLEdBQUksS0FDWCxFQUFHLEdBQUksR0FBSSxLQUNYLEVBQUcsR0FBSSxHQUFJLEdBQUksS0FDZixFQUFHLEdBQUksR0FBSSxHQUFJLEtBQ2YsRUFBRyxHQUFJLEdBQUksR0FBSSxNQUNmLEVBQUcsR0FBSSxHQUFJLEdBQUksTUFDZixFQUFHLEdBQUksR0FBSSxHQUFJLE1BQ2YsRUFBRyxHQUFJLEdBQUksR0FBSSxNQUNmLEVBQUcsR0FBSSxHQUFJLEdBQUksTUFDZixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksTUFDbkIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLE1BQ3BCLEVBQUcsR0FBSSxHQUFJLEdBQUksSUFBSyxNQUNwQixFQUFHLEdBQUksR0FBSSxHQUFJLElBQUssTUFDcEIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLE1BQ3BCLEVBQUcsR0FBSSxHQUFJLEdBQUksSUFBSyxNQUNwQixFQUFHLEdBQUksR0FBSSxHQUFJLElBQUssTUFDcEIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFDekIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFDekIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFDekIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFDekIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFDekIsRUFBRyxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFFeEJDLEVBQU8sS0FDUEMsRUFBTyxLQUNQQyxFQUFZLE1BRVpoSixLQUVBaUosRUFBYyxTQUFTaFEsR0FFekIsSUFEQSxHQUFJaVEsR0FBUSxFQUNHLEdBQVJqUSxHQUNMaVEsR0FBUyxFQUNUalEsS0FBVSxDQUVaLE9BQU9pUSxHQWdOVCxPQTdNQWxKLEdBQU0yQyxlQUFpQixTQUFTMUosR0FFOUIsSUFEQSxHQUFJa1EsR0FBSWxRLEdBQVEsR0FDVGdRLEVBQVlFLEdBQUtGLEVBQVlILElBQVEsR0FDMUNLLEdBQU1MLEdBQVFHLEVBQVlFLEdBQUtGLEVBQVlILEVBRTdDLFFBQVU3UCxHQUFRLEdBQU1rUSxHQUFLSCxHQUcvQmhKLEVBQU0wQyxpQkFBbUIsU0FBU3pKLEdBRWhDLElBREEsR0FBSWtRLEdBQUlsUSxHQUFRLEdBQ1RnUSxFQUFZRSxHQUFLRixFQUFZRixJQUFRLEdBQzFDSSxHQUFNSixHQUFRRSxFQUFZRSxHQUFLRixFQUFZRixFQUU3QyxPQUFROVAsSUFBUSxHQUFNa1EsR0FHeEJuSixFQUFNakcsbUJBQXFCLFNBQVMyRyxHQUNsQyxNQUFPbUksR0FBdUJuSSxFQUFhLElBRzdDVixFQUFNZ0QsZ0JBQWtCLFNBQVN6QixHQUUvQixPQUFRQSxHQUVSLElBQUs2RyxHQUFjQyxXQUNqQixNQUFPLFVBQVNqUCxFQUFHWSxHQUFLLE9BQVFaLEVBQUlZLEdBQUssR0FBSyxFQUNoRCxLQUFLb08sR0FBY0UsV0FDakIsTUFBTyxVQUFTbFAsRUFBR1ksR0FBSyxNQUFPWixHQUFJLEdBQUssRUFDMUMsS0FBS2dQLEdBQWNHLFdBQ2pCLE1BQU8sVUFBU25QLEVBQUdZLEdBQUssTUFBT0EsR0FBSSxHQUFLLEVBQzFDLEtBQUtvTyxHQUFjSSxXQUNqQixNQUFPLFVBQVNwUCxFQUFHWSxHQUFLLE9BQVFaLEVBQUlZLEdBQUssR0FBSyxFQUNoRCxLQUFLb08sR0FBY0ssV0FDakIsTUFBTyxVQUFTclAsRUFBR1ksR0FBSyxPQUFRVCxLQUFLQyxNQUFNSixFQUFJLEdBQUtHLEtBQUtDLE1BQU1RLEVBQUksSUFBTyxHQUFLLEVBQ2pGLEtBQUtvTyxHQUFjTSxXQUNqQixNQUFPLFVBQVN0UCxFQUFHWSxHQUFLLE1BQVFaLEdBQUlZLEVBQUssRUFBS1osRUFBSVksRUFBSyxHQUFLLEVBQzlELEtBQUtvTyxHQUFjTyxXQUNqQixNQUFPLFVBQVN2UCxFQUFHWSxHQUFLLE9BQVVaLEVBQUlZLEVBQUssRUFBS1osRUFBSVksRUFBSyxHQUFLLEdBQUssRUFDckUsS0FBS29PLEdBQWNRLFdBQ2pCLE1BQU8sVUFBU3hQLEVBQUdZLEdBQUssT0FBVVosRUFBSVksRUFBSyxHQUFLWixFQUFJWSxHQUFLLEdBQUssR0FBSyxFQUVyRSxTQUNFLEtBQU0sSUFBSTRGLE9BQU0sbUJBQXFCMkIsS0FJekN2QixFQUFNaUUsMEJBQTRCLFNBQVNtRixHQUV6QyxJQUFLLEdBREQ5TCxHQUFJbUMsR0FBYyxHQUFJLEdBQ2pCckcsRUFBSSxFQUFHQSxFQUFJZ1EsRUFBb0JoUSxHQUFLLEVBQzNDa0UsRUFBSUEsRUFBRThDLFNBQVNYLEdBQWMsRUFBR1ksRUFBT0MsS0FBS2xILElBQUssR0FFbkQsT0FBT2tFLElBR1QwQyxFQUFNNEUsZ0JBQWtCLFNBQVNJLEVBQU01SSxHQUVyQyxHQUFJLEdBQUtBLEdBQVFBLEVBQU8sR0FJdEIsT0FBTzRJLEdBQ1AsSUFBSzJDLEdBQU9DLFlBQWlCLE1BQU8sR0FDcEMsS0FBS0QsR0FBT0UsZUFBaUIsTUFBTyxFQUNwQyxLQUFLRixHQUFPRyxlQUFpQixNQUFPLEVBQ3BDLEtBQUtILEdBQU9JLFdBQWlCLE1BQU8sRUFDcEMsU0FDRSxLQUFNLElBQUluSSxPQUFNLFFBQVVvRixPQUd2QixJQUFJNUksRUFBTyxHQUloQixPQUFPNEksR0FDUCxJQUFLMkMsR0FBT0MsWUFBaUIsTUFBTyxHQUNwQyxLQUFLRCxHQUFPRSxlQUFpQixNQUFPLEdBQ3BDLEtBQUtGLEdBQU9HLGVBQWlCLE1BQU8sR0FDcEMsS0FBS0gsR0FBT0ksV0FBaUIsTUFBTyxHQUNwQyxTQUNFLEtBQU0sSUFBSW5JLE9BQU0sUUFBVW9GLE9BR3ZCLE1BQUk1SSxFQUFPLElBY2hCLEtBQU0sSUFBSXdELE9BQU0sUUFBVXhELEVBVjFCLFFBQU80SSxHQUNQLElBQUsyQyxHQUFPQyxZQUFpQixNQUFPLEdBQ3BDLEtBQUtELEdBQU9FLGVBQWlCLE1BQU8sR0FDcEMsS0FBS0YsR0FBT0csZUFBaUIsTUFBTyxHQUNwQyxLQUFLSCxHQUFPSSxXQUFpQixNQUFPLEdBQ3BDLFNBQ0UsS0FBTSxJQUFJbkksT0FBTSxRQUFVb0YsTUFRaENoRixFQUFNdUMsYUFBZSxTQUFTL0MsR0FRNUIsSUFBSyxHQU5EZ0MsR0FBY2hDLEVBQU9nRyxpQkFFckJsRCxFQUFZLEVBSVBiLEVBQU0sRUFBR0EsRUFBTUQsRUFBYUMsR0FBTyxFQUMxQyxJQUFLLEdBQUlDLEdBQU0sRUFBR0EsRUFBTUYsRUFBYUUsR0FBTyxFQUFHLENBSzdDLElBQUssR0FIRDJILEdBQVksRUFDWnBHLEVBQU96RCxFQUFPK0YsT0FBTzlELEVBQUtDLEdBRXJCUSxHQUFJLEVBQUlBLEdBQUssRUFBR0EsR0FBSyxFQUU1QixLQUFJVCxFQUFNUyxFQUFJLEdBQUtWLEdBQWVDLEVBQU1TLEdBSXhDLElBQUssR0FBSXBNLElBQUksRUFBSUEsR0FBSyxFQUFHQSxHQUFLLEVBRXhCNEwsRUFBTTVMLEVBQUksR0FBSzBMLEdBQWVFLEVBQU01TCxHQUkvQixHQUFMb00sR0FBZSxHQUFMcE0sR0FJVm1OLEdBQVF6RCxFQUFPK0YsT0FBTzlELEVBQU1TLEVBQUdSLEVBQU01TCxLQUN2Q3VULEdBQWEsRUFLZkEsR0FBWSxJQUNkL0csR0FBYyxFQUFJK0csRUFBWSxHQU9wQyxJQUFLLEdBQUk1SCxHQUFNLEVBQUdBLEVBQU1ELEVBQWMsRUFBR0MsR0FBTyxFQUM5QyxJQUFLLEdBQUlDLEdBQU0sRUFBR0EsRUFBTUYsRUFBYyxFQUFHRSxHQUFPLEVBQUcsQ0FDakQsR0FBSXNGLEdBQVEsQ0FDUnhILEdBQU8rRixPQUFPOUQsRUFBS0MsS0FBT3NGLEdBQVMsR0FDbkN4SCxFQUFPK0YsT0FBTzlELEVBQU0sRUFBR0MsS0FBT3NGLEdBQVMsR0FDdkN4SCxFQUFPK0YsT0FBTzlELEVBQUtDLEVBQU0sS0FBS3NGLEdBQVMsR0FDdkN4SCxFQUFPK0YsT0FBTzlELEVBQU0sRUFBR0MsRUFBTSxLQUFLc0YsR0FBUyxHQUNsQyxHQUFUQSxHQUF1QixHQUFUQSxJQUNoQjFFLEdBQWEsR0FPbkIsSUFBSyxHQUFJYixHQUFNLEVBQUdBLEVBQU1ELEVBQWFDLEdBQU8sRUFDMUMsSUFBSyxHQUFJQyxHQUFNLEVBQUdBLEVBQU1GLEVBQWMsRUFBR0UsR0FBTyxFQUMxQ2xDLEVBQU8rRixPQUFPOUQsRUFBS0MsS0FDZmxDLEVBQU8rRixPQUFPOUQsRUFBS0MsRUFBTSxJQUN6QmxDLEVBQU8rRixPQUFPOUQsRUFBS0MsRUFBTSxJQUN6QmxDLEVBQU8rRixPQUFPOUQsRUFBS0MsRUFBTSxJQUN6QmxDLEVBQU8rRixPQUFPOUQsRUFBS0MsRUFBTSxLQUN6QmxDLEVBQU8rRixPQUFPOUQsRUFBS0MsRUFBTSxJQUN6QmxDLEVBQU8rRixPQUFPOUQsRUFBS0MsRUFBTSxLQUMvQlksR0FBYSxHQUtuQixLQUFLLEdBQUlaLEdBQU0sRUFBR0EsRUFBTUYsRUFBYUUsR0FBTyxFQUMxQyxJQUFLLEdBQUlELEdBQU0sRUFBR0EsRUFBTUQsRUFBYyxFQUFHQyxHQUFPLEVBQzFDakMsRUFBTytGLE9BQU85RCxFQUFLQyxLQUNmbEMsRUFBTytGLE9BQU85RCxFQUFNLEVBQUdDLElBQ3ZCbEMsRUFBTytGLE9BQU85RCxFQUFNLEVBQUdDLElBQ3ZCbEMsRUFBTytGLE9BQU85RCxFQUFNLEVBQUdDLElBQ3ZCbEMsRUFBTytGLE9BQU85RCxFQUFNLEVBQUdDLEtBQ3ZCbEMsRUFBTytGLE9BQU85RCxFQUFNLEVBQUdDLElBQ3ZCbEMsRUFBTytGLE9BQU85RCxFQUFNLEVBQUdDLEtBQzdCWSxHQUFhLEdBU25CLEtBQUssR0FGRGdILEdBQVksRUFFUDVILEVBQU0sRUFBR0EsRUFBTUYsRUFBYUUsR0FBTyxFQUMxQyxJQUFLLEdBQUlELEdBQU0sRUFBR0EsRUFBTUQsRUFBYUMsR0FBTyxFQUN0Q2pDLEVBQU8rRixPQUFPOUQsRUFBS0MsS0FDckI0SCxHQUFhLEVBS25CLElBQUk3SSxHQUFRbEgsS0FBS2dRLElBQUksSUFBTUQsRUFBWTlILEVBQWNBLEVBQWMsSUFBTSxDQUd6RSxPQUZBYyxJQUFxQixHQUFSN0IsR0FLUlQsS0FPTEssRUFBUyxXQU1YLElBQUssR0FKRG1KLEdBQVksR0FBSXpKLE9BQU0sS0FDdEIwSixFQUFZLEdBQUkxSixPQUFNLEtBR2pCM0csRUFBSSxFQUFHQSxFQUFJLEVBQUdBLEdBQUssRUFDMUJvUSxFQUFVcFEsR0FBSyxHQUFLQSxDQUV0QixLQUFLLEdBQUlBLEdBQUksRUFBR0EsRUFBSSxJQUFLQSxHQUFLLEVBQzVCb1EsRUFBVXBRLEdBQUtvUSxFQUFVcFEsRUFBSSxHQUN6Qm9RLEVBQVVwUSxFQUFJLEdBQ2RvUSxFQUFVcFEsRUFBSSxHQUNkb1EsRUFBVXBRLEVBQUksRUFFcEIsS0FBSyxHQUFJQSxHQUFJLEVBQUdBLEVBQUksSUFBS0EsR0FBSyxFQUM1QnFRLEVBQVVELEVBQVVwUSxJQUFPQSxDQUc3QixJQUFJNEcsS0F3QkosT0F0QkFBLEdBQU1PLEtBQU8sU0FBU21KLEdBRXBCLEdBQUlBLEVBQUksRUFDTixLQUFNLElBQUk5SixPQUFNLFFBQVU4SixFQUFJLElBR2hDLE9BQU9ELEdBQVVDLElBR25CMUosRUFBTU0sS0FBTyxTQUFTb0osR0FFcEIsS0FBT0EsRUFBSSxHQUNUQSxHQUFLLEdBR1AsTUFBT0EsR0FBSyxLQUNWQSxHQUFLLEdBR1AsT0FBT0YsR0FBVUUsSUFHWjFKLEtBNEVMdUUsRUFBWSxXQUVkLEdBQUlvRixLQVFELEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxJQUdQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUdQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUdQLEVBQUcsSUFBSyxLQUNSLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxJQUdQLEVBQUcsSUFBSyxNQUNSLEVBQUcsR0FBSSxLQUNQLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FHbEIsRUFBRyxHQUFJLEtBQ1AsRUFBRyxHQUFJLEtBQ1AsRUFBRyxHQUFJLEtBQ1AsRUFBRyxHQUFJLEtBR1AsRUFBRyxHQUFJLEtBQ1AsRUFBRyxHQUFJLEtBQ1AsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUdsQixFQUFHLElBQUssS0FDUixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbEIsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUdsQixFQUFHLElBQUssTUFDUixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbEIsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUdsQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbEIsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FHbEIsRUFBRyxJQUFLLEtBQ1IsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FHbEIsRUFBRyxJQUFLLEdBQUksRUFBRyxJQUFLLEtBQ3BCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbEIsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBR2xCLEVBQUcsSUFBSyxNQUNSLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbEIsR0FBSSxHQUFJLEdBQUksRUFBRyxHQUFJLEtBR25CLEVBQUcsSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUNyQixFQUFHLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbEIsR0FBSSxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ25CLEdBQUksR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUduQixFQUFHLElBQUssR0FBSSxFQUFHLElBQUssS0FDcEIsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FHbkIsRUFBRyxJQUFLLEdBQUksRUFBRyxJQUFLLEtBQ3BCLEVBQUcsR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNsQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsRUFBRyxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR25CLEVBQUcsSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUNyQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsRUFBRyxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ25CLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUduQixFQUFHLElBQUssSUFBSyxFQUFHLElBQUssTUFDckIsRUFBRyxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ2xCLEdBQUksR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNuQixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksS0FHbkIsRUFBRyxJQUFLLElBQUssRUFBRyxJQUFLLE1BQ3JCLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNuQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsRUFBRyxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR25CLEVBQUcsSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUNyQixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ25CLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUdwQixFQUFHLElBQUssSUFBSyxFQUFHLElBQUssTUFDckIsR0FBSSxHQUFJLEtBQ1IsR0FBSSxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ25CLEdBQUksR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUduQixFQUFHLElBQUssSUFBSyxFQUFHLElBQUssTUFDckIsR0FBSSxHQUFJLEtBQ1IsRUFBRyxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ25CLEdBQUksR0FBSSxLQUdSLEVBQUcsSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUNyQixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUdwQixFQUFHLElBQUssSUFBSyxFQUFHLElBQUssTUFDckIsRUFBRyxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ25CLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FHbkIsRUFBRyxJQUFLLElBQUssRUFBRyxJQUFLLE1BQ3JCLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNuQixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR3BCLEdBQUksSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUN0QixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ25CLEdBQUksR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUduQixFQUFHLElBQUssSUFBSyxFQUFHLElBQUssTUFDckIsR0FBSSxHQUFJLEdBQUksRUFBRyxHQUFJLEtBQ25CLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNuQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FHcEIsRUFBRyxJQUFLLElBQUssR0FBSSxJQUFLLE1BQ3RCLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNuQixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR3BCLEVBQUcsSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUNyQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsRUFBRyxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ25CLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUdwQixFQUFHLElBQUssSUFBSyxHQUFJLElBQUssTUFDdEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FHcEIsR0FBSSxJQUFLLElBQUssRUFBRyxJQUFLLE1BQ3RCLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNuQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR3BCLEdBQUksSUFBSyxNQUNULEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDcEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR3BCLEdBQUksSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUN0QixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDcEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUdwQixHQUFJLElBQUssSUFBSyxFQUFHLElBQUssTUFDdEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEVBQUcsR0FBSSxLQUNuQixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FHbkIsR0FBSSxJQUFLLElBQUssRUFBRyxJQUFLLE1BQ3RCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDcEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR3BCLEVBQUcsSUFBSyxJQUFLLEdBQUksSUFBSyxNQUN0QixFQUFHLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEVBQUcsR0FBSSxHQUFJLEdBQUksR0FBSSxLQUduQixHQUFJLElBQUssSUFBSyxFQUFHLElBQUssTUFDdEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FHcEIsRUFBRyxJQUFLLElBQUssR0FBSSxJQUFLLE1BQ3RCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FDcEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBR3BCLEdBQUksSUFBSyxJQUFLLEVBQUcsSUFBSyxNQUN0QixHQUFJLEdBQUksR0FBSSxFQUFHLEdBQUksS0FDbkIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUdwQixHQUFJLElBQUssSUFBSyxFQUFHLElBQUssTUFDdEIsR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEtBQ3BCLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxLQUNwQixHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksS0FHbkJDLEVBQVksU0FBUy9GLEVBQVlGLEdBQ25DLEdBQUkzRCxLQUdKLE9BRkFBLEdBQU02RCxXQUFhQSxFQUNuQjdELEVBQU0yRCxVQUFZQSxFQUNYM0QsR0FHTEEsS0FFQTZKLEVBQWtCLFNBQVNuSixFQUFZQyxHQUV6QyxPQUFPQSxHQUNQLElBQUtLLEdBQXVCZ0gsRUFDMUIsTUFBTzJCLEdBQWtDLEdBQWxCakosRUFBYSxHQUFTLEVBQy9DLEtBQUtNLEdBQXVCaUgsRUFDMUIsTUFBTzBCLEdBQWtDLEdBQWxCakosRUFBYSxHQUFTLEVBQy9DLEtBQUtNLEdBQXVCa0gsRUFDMUIsTUFBT3lCLEdBQWtDLEdBQWxCakosRUFBYSxHQUFTLEVBQy9DLEtBQUtNLEdBQXVCbUgsRUFDMUIsTUFBT3dCLEdBQWtDLEdBQWxCakosRUFBYSxHQUFTLEVBQy9DLFNBQ0UsUUErQkosT0EzQkFWLEdBQU13RSxZQUFjLFNBQVM5RCxFQUFZQyxHQUV2QyxHQUFJbUosR0FBVUQsRUFBZ0JuSixFQUFZQyxFQUUxQyxJQUFzQixtQkFBWG1KLEdBQ1QsS0FBTSxJQUFJbEssT0FBTSw2QkFBK0JjLEVBQzNDLHlCQUEyQkMsRUFPakMsS0FBSyxHQUpEdEgsR0FBU3lRLEVBQVF6USxPQUFTLEVBRTFCMFEsRUFBTyxHQUFJaEssT0FFTjNHLEVBQUksRUFBR0EsRUFBSUMsRUFBUUQsR0FBSyxFQU0vQixJQUFLLEdBSkQ0TixHQUFROEMsRUFBWSxFQUFKMVEsRUFBUSxHQUN4QnlLLEVBQWFpRyxFQUFZLEVBQUoxUSxFQUFRLEdBQzdCdUssRUFBWW1HLEVBQVksRUFBSjFRLEVBQVEsR0FFdkJZLEVBQUksRUFBR0EsRUFBSWdOLEVBQU9oTixHQUFLLEVBQzlCK1AsRUFBS3pFLEtBQUtzRSxFQUFVL0YsRUFBWUYsR0FJcEMsT0FBT29HLElBR0YvSixLQU9MeUUsRUFBYyxXQUVoQixHQUFJdUYsR0FBVSxHQUFJakssT0FDZGtLLEVBQVUsRUFFVmpLLElBbUNKLE9BakNBQSxHQUFNK0QsVUFBWSxXQUNoQixNQUFPaUcsSUFHVGhLLEVBQU1DLE1BQVEsU0FBU0MsR0FDckIsR0FBSWdLLEdBQVczUSxLQUFLQyxNQUFNMEcsRUFBUSxFQUNsQyxPQUEwRCxLQUFoRDhKLEVBQVFFLEtBQWUsRUFBSWhLLEVBQVEsRUFBTyxJQUd0REYsRUFBTTBFLElBQU0sU0FBU2hGLEVBQUtyRyxHQUN4QixJQUFLLEdBQUlELEdBQUksRUFBR0EsRUFBSUMsRUFBUUQsR0FBSyxFQUMvQjRHLEVBQU0rRSxPQUE4QyxJQUFuQ3JGLElBQVNyRyxFQUFTRCxFQUFJLEVBQU8sS0FJbEQ0RyxFQUFNNEUsZ0JBQWtCLFdBQ3RCLE1BQU9xRixJQUdUakssRUFBTStFLE9BQVMsU0FBU29GLEdBRXRCLEdBQUlELEdBQVczUSxLQUFLQyxNQUFNeVEsRUFBVSxFQUNoQ0QsR0FBUTNRLFFBQVU2USxHQUNwQkYsRUFBUTFFLEtBQUssR0FHWDZFLElBQ0ZILEVBQVFFLElBQWMsTUFBVUQsRUFBVSxHQUc1Q0EsR0FBVyxHQUdOakssR0FPTGtGLEVBQVcsU0FBU2pNLEdBRXRCLEdBQUltUixHQUFRekMsRUFBT0MsWUFDZnlDLEVBQVFwUixFQUVSK0csSUFFSkEsR0FBTTJFLFFBQVUsV0FDZCxNQUFPeUYsSUFHVHBLLEVBQU1HLFVBQVksU0FBU2lELEdBQ3pCLE1BQU9pSCxHQUFNaFIsUUFHZjJHLEVBQU02RSxNQUFRLFNBQVN6QixHQU1yQixJQUpBLEdBQUluSyxHQUFPb1IsRUFFUGpSLEVBQUksRUFFREEsRUFBSSxFQUFJSCxFQUFLSSxRQUNsQitKLEVBQU9zQixJQUFJNEYsRUFBU3JSLEVBQUtzUixVQUFVblIsRUFBR0EsRUFBSSxJQUFNLElBQ2hEQSxHQUFLLENBR0hBLEdBQUlILEVBQUtJLFNBQ1BKLEVBQUtJLE9BQVNELEdBQUssRUFDckJnSyxFQUFPc0IsSUFBSTRGLEVBQVNyUixFQUFLc1IsVUFBVW5SLEVBQUdBLEVBQUksSUFBTSxHQUN2Q0gsRUFBS0ksT0FBU0QsR0FBSyxHQUM1QmdLLEVBQU9zQixJQUFJNEYsRUFBU3JSLEVBQUtzUixVQUFVblIsRUFBR0EsRUFBSSxJQUFNLElBS3RELElBQUlrUixHQUFXLFNBQVNoRSxHQUV0QixJQUFLLEdBREQ1RyxHQUFNLEVBQ0R0RyxFQUFJLEVBQUdBLEVBQUlrTixFQUFFak4sT0FBUUQsR0FBSyxFQUNqQ3NHLEVBQVksR0FBTkEsRUFBVzhLLEVBQVVsRSxFQUFFb0IsT0FBT3RPLEdBRXRDLE9BQU9zRyxJQUdMOEssRUFBWSxTQUFTMVUsR0FDdkIsR0FBSSxLQUFPQSxHQUFLQSxHQUFLLElBQ25CLE1BQU9BLEdBQUUwUSxXQUFXLEdBQUssSUFBSUEsV0FBVyxFQUUxQyxNQUFNLGlCQUFtQjFRLEVBRzNCLE9BQU9rSyxJQU9MbUYsRUFBYSxTQUFTbE0sR0FFeEIsR0FBSW1SLEdBQVF6QyxFQUFPRSxlQUNmd0MsRUFBUXBSLEVBRVIrRyxJQUVKQSxHQUFNMkUsUUFBVSxXQUNkLE1BQU95RixJQUdUcEssRUFBTUcsVUFBWSxTQUFTaUQsR0FDekIsTUFBT2lILEdBQU1oUixRQUdmMkcsRUFBTTZFLE1BQVEsU0FBU3pCLEdBTXJCLElBSkEsR0FBSWtELEdBQUkrRCxFQUVKalIsRUFBSSxFQUVEQSxFQUFJLEVBQUlrTixFQUFFak4sUUFDZitKLEVBQU9zQixJQUNtQixHQUF4QitGLEVBQVFuRSxFQUFFb0IsT0FBT3RPLElBQ2pCcVIsRUFBUW5FLEVBQUVvQixPQUFPdE8sRUFBSSxJQUFNLElBQzdCQSxHQUFLLENBR0hBLEdBQUlrTixFQUFFak4sUUFDUitKLEVBQU9zQixJQUFJK0YsRUFBUW5FLEVBQUVvQixPQUFPdE8sSUFBTSxHQUl0QyxJQUFJcVIsR0FBVSxTQUFTM1UsR0FFckIsR0FBSSxLQUFPQSxHQUFLQSxHQUFLLElBQ25CLE1BQU9BLEdBQUUwUSxXQUFXLEdBQUssSUFBSUEsV0FBVyxFQUNuQyxJQUFJLEtBQU8xUSxHQUFLQSxHQUFLLElBQzFCLE1BQU9BLEdBQUUwUSxXQUFXLEdBQUssSUFBSUEsV0FBVyxHQUFLLEVBRTdDLFFBQVExUSxHQUNSLElBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLEtBQUssSUFBTSxNQUFPLEdBQ2xCLFNBQ0UsS0FBTSxpQkFBbUJBLEdBSy9CLE9BQU9rSyxJQU9Mb0YsRUFBYSxTQUFTbk0sR0FFeEIsR0FBSW1SLEdBQVF6QyxFQUFPRyxlQUVmNEMsRUFBU2xMLEVBQU82RyxjQUFjcE4sR0FFOUIrRyxJQWdCSixPQWRBQSxHQUFNMkUsUUFBVSxXQUNkLE1BQU95RixJQUdUcEssRUFBTUcsVUFBWSxTQUFTaUQsR0FDekIsTUFBT3NILEdBQU9yUixRQUdoQjJHLEVBQU02RSxNQUFRLFNBQVN6QixHQUNyQixJQUFLLEdBQUloSyxHQUFJLEVBQUdBLEVBQUlzUixFQUFPclIsT0FBUUQsR0FBSyxFQUN0Q2dLLEVBQU9zQixJQUFJZ0csRUFBT3RSLEdBQUksSUFJbkI0RyxHQU9McUYsRUFBVSxTQUFTcE0sR0FFckIsR0FBSW1SLEdBQVF6QyxFQUFPSSxXQUVmMkMsRUFBU2xMLEVBQU82RyxjQUFjcE4sSUFFakMsU0FBU25ELEVBQUc2VSxHQUVYLEdBQUlySixHQUFPOUIsRUFBTzZHLGNBQWN2USxFQUNoQyxJQUFtQixHQUFmd0wsRUFBS2pJLFNBQWtCaUksRUFBSyxJQUFNLEVBQUtBLEVBQUssS0FBT3FKLEVBQ3JELEtBQU0sdUJBRVIsSUFBVSxNQUVaLElBQUkzSyxLQXdDSixPQXRDQUEsR0FBTTJFLFFBQVUsV0FDZCxNQUFPeUYsSUFHVHBLLEVBQU1HLFVBQVksU0FBU2lELEdBQ3pCLFNBQVVzSCxFQUFPclIsT0FBUyxJQUc1QjJHLEVBQU02RSxNQUFRLFNBQVN6QixHQU1yQixJQUpBLEdBQUluSyxHQUFPeVIsRUFFUHRSLEVBQUksRUFFREEsRUFBSSxFQUFJSCxFQUFLSSxRQUFRLENBRTFCLEdBQUl2RCxJQUFPLElBQU9tRCxFQUFLRyxLQUFPLEVBQU0sSUFBT0gsRUFBS0csRUFBSSxFQUVwRCxJQUFJLE9BQVV0RCxHQUFLQSxHQUFLLE1BQ3RCQSxHQUFLLFVBQ0EsTUFBSSxPQUFVQSxHQUFLQSxHQUFLLE9BRzdCLEtBQU0sb0JBQXNCc0QsRUFBSSxHQUFLLElBQU10RCxDQUYzQ0EsSUFBSyxNQUtQQSxFQUEwQixLQUFuQkEsSUFBTSxFQUFLLE1BQW9CLElBQUpBLEdBRWxDc04sRUFBT3NCLElBQUk1TyxFQUFHLElBRWRzRCxHQUFLLEVBR1AsR0FBSUEsRUFBSUgsRUFBS0ksT0FDWCxLQUFNLG9CQUFzQkQsRUFBSSxJQUk3QjRHLEdBV0w0SyxFQUF3QixXQUUxQixHQUFJRixHQUFTLEdBQUkzSyxPQUViQyxJQTBDSixPQXhDQUEsR0FBTTZLLFVBQVksU0FBU3ROLEdBQ3pCbU4sRUFBT3BGLEtBQVMsSUFBSi9ILElBR2R5QyxFQUFNOEssV0FBYSxTQUFTMVIsR0FDMUI0RyxFQUFNNkssVUFBVXpSLEdBQ2hCNEcsRUFBTTZLLFVBQVV6UixJQUFNLElBR3hCNEcsRUFBTStLLFdBQWEsU0FBU3hOLEVBQUd5TixFQUFLQyxHQUNsQ0QsRUFBTUEsR0FBTyxFQUNiQyxFQUFNQSxHQUFPMU4sRUFBRWxFLE1BQ2YsS0FBSyxHQUFJRCxHQUFJLEVBQUdBLEVBQUk2UixFQUFLN1IsR0FBSyxFQUM1QjRHLEVBQU02SyxVQUFVdE4sRUFBRW5FLEVBQUk0UixLQUkxQmhMLEVBQU1rTCxZQUFjLFNBQVM1RSxHQUMzQixJQUFLLEdBQUlsTixHQUFJLEVBQUdBLEVBQUlrTixFQUFFak4sT0FBUUQsR0FBSyxFQUNqQzRHLEVBQU02SyxVQUFVdkUsRUFBRUUsV0FBV3BOLEtBSWpDNEcsRUFBTW1MLFlBQWMsV0FDbEIsTUFBT1QsSUFHVDFLLEVBQU1mLFNBQVcsV0FDZixHQUFJcUgsR0FBSSxFQUNSQSxJQUFLLEdBQ0wsS0FBSyxHQUFJbE4sR0FBSSxFQUFHQSxFQUFJc1IsRUFBT3JSLE9BQVFELEdBQUssRUFDbENBLEVBQUksSUFDTmtOLEdBQUssS0FFUEEsR0FBS29FLEVBQU90UixFQUdkLE9BREFrTixJQUFLLEtBSUF0RyxHQU9Mb0wsRUFBMkIsV0FFN0IsR0FBSXBCLEdBQVUsRUFDVnFCLEVBQVUsRUFDVnBCLEVBQVUsRUFDVnFCLEVBQVUsR0FFVnRMLEtBRUF1TCxFQUFlLFNBQVNoTyxHQUMxQitOLEdBQVdoRSxPQUFPQyxhQUFhaUUsRUFBVyxHQUFKak8sS0FHcENpTyxFQUFTLFNBQVM5QixHQUNwQixHQUFJQSxFQUFJLE9BRUQsSUFBSUEsRUFBSSxHQUNiLE1BQU8sSUFBT0EsQ0FDVCxJQUFJQSxFQUFJLEdBQ2IsTUFBTyxLQUFRQSxFQUFJLEdBQ2QsSUFBSUEsRUFBSSxHQUNiLE1BQU8sS0FBUUEsRUFBSSxHQUNkLElBQVMsSUFBTEEsRUFDVCxNQUFPLEdBQ0YsSUFBUyxJQUFMQSxFQUNULE1BQU8sSUFFVCxLQUFNLElBQUk5SixPQUFNLEtBQU84SixHQW9DekIsT0FqQ0ExSixHQUFNNkssVUFBWSxTQUFTbkIsR0FNekIsSUFKQU0sRUFBV0EsR0FBVyxFQUFVLElBQUpOLEVBQzVCMkIsR0FBVyxFQUNYcEIsR0FBVyxFQUVKb0IsR0FBVyxHQUNoQkUsRUFBYXZCLElBQWFxQixFQUFVLEdBQ3BDQSxHQUFXLEdBSWZyTCxFQUFNeUwsTUFBUSxXQVFaLEdBTklKLEVBQVUsSUFDWkUsRUFBYXZCLEdBQVksRUFBSXFCLEdBQzdCckIsRUFBVSxFQUNWcUIsRUFBVSxHQUdScEIsRUFBVSxHQUFLLEVBR2pCLElBQUssR0FERHlCLEdBQVMsRUFBSXpCLEVBQVUsRUFDbEI3USxFQUFJLEVBQUdBLEVBQUlzUyxFQUFRdFMsR0FBSyxFQUMvQmtTLEdBQVcsS0FLakJ0TCxFQUFNZixTQUFXLFdBQ2YsTUFBT3FNLElBR0Z0TCxHQU9MOEcsRUFBMEIsU0FBUzZFLEdBRXJDLEdBQUlDLEdBQU9ELEVBQ1BFLEVBQU8sRUFDUDdCLEVBQVUsRUFDVnFCLEVBQVUsRUFFVnJMLElBRUpBLEdBQU0rRyxLQUFPLFdBRVgsS0FBT3NFLEVBQVUsR0FBRyxDQUVsQixHQUFJUSxHQUFRRCxFQUFLdlMsT0FBUSxDQUN2QixHQUFlLEdBQVhnUyxFQUNGLE9BQU8sQ0FFVCxNQUFNLElBQUl6TCxPQUFNLDJCQUE2QnlMLEdBRy9DLEdBQUl2VixHQUFJOFYsRUFBS2xFLE9BQU9tRSxFQUdwQixJQUZBQSxHQUFRLEVBRUMsS0FBTC9WLEVBRUYsTUFEQXVWLEdBQVUsR0FDSCxDQUNFdlYsR0FBRWdXLE1BQU0sVUFLbkI5QixFQUFXQSxHQUFXLEVBQUsrQixFQUFPalcsRUFBRTBRLFdBQVcsSUFDL0M2RSxHQUFXLEdBR2IsR0FBSTNCLEdBQUtNLElBQWFxQixFQUFVLEVBQU8sR0FFdkMsT0FEQUEsSUFBVyxFQUNKM0IsRUFHVCxJQUFJcUMsR0FBUyxTQUFTalcsR0FDcEIsR0FBSSxJQUFRQSxHQUFLQSxHQUFLLEdBQ3BCLE1BQU9BLEdBQUksRUFDTixJQUFJLElBQVFBLEdBQUtBLEdBQUssSUFDM0IsTUFBT0EsR0FBSSxHQUFPLEVBQ2IsSUFBSSxJQUFRQSxHQUFLQSxHQUFLLEdBQzNCLE1BQU9BLEdBQUksR0FBTyxFQUNiLElBQVMsSUFBTEEsRUFDVCxNQUFPLEdBQ0YsSUFBUyxJQUFMQSxFQUNULE1BQU8sR0FFUCxNQUFNLElBQUk4SixPQUFNLEtBQU85SixHQUkzQixPQUFPa0ssSUFPTGdNLEVBQVcsU0FBU3pULEVBQU9DLEdBRTdCLEdBQUl5VCxHQUFTMVQsRUFDVDJULEVBQVUxVCxFQUNWNlIsRUFBUSxHQUFJdEssT0FBTXhILEVBQVFDLEdBRTFCd0gsSUFFSkEsR0FBTW1NLFNBQVcsU0FBUzdTLEVBQUdHLEVBQUcyUyxHQUM5Qi9CLEVBQU01USxFQUFJd1MsRUFBUzNTLEdBQUs4UyxHQUcxQnBNLEVBQU02RSxNQUFRLFNBQVNySSxHQUtyQkEsRUFBSTBPLFlBQVksVUFLaEIxTyxFQUFJc08sV0FBV21CLEdBQ2Z6UCxFQUFJc08sV0FBV29CLEdBRWYxUCxFQUFJcU8sVUFBVSxLQUNkck8sRUFBSXFPLFVBQVUsR0FDZHJPLEVBQUlxTyxVQUFVLEdBTWRyTyxFQUFJcU8sVUFBVSxHQUNkck8sRUFBSXFPLFVBQVUsR0FDZHJPLEVBQUlxTyxVQUFVLEdBR2RyTyxFQUFJcU8sVUFBVSxLQUNkck8sRUFBSXFPLFVBQVUsS0FDZHJPLEVBQUlxTyxVQUFVLEtBS2RyTyxFQUFJME8sWUFBWSxLQUNoQjFPLEVBQUlzTyxXQUFXLEdBQ2Z0TyxFQUFJc08sV0FBVyxHQUNmdE8sRUFBSXNPLFdBQVdtQixHQUNmelAsRUFBSXNPLFdBQVdvQixHQUNmMVAsRUFBSXFPLFVBQVUsRUFRZCxJQUFJd0IsR0FBaUIsRUFDakJDLEVBQVNDLEVBQWFGLEVBRTFCN1AsR0FBSXFPLFVBQVV3QixFQUlkLEtBRkEsR0FBSXZNLEdBQVMsRUFFTndNLEVBQU9qVCxPQUFTeUcsRUFBUyxLQUM5QnRELEVBQUlxTyxVQUFVLEtBQ2RyTyxFQUFJdU8sV0FBV3VCLEVBQVF4TSxFQUFRLEtBQy9CQSxHQUFVLEdBR1p0RCxHQUFJcU8sVUFBVXlCLEVBQU9qVCxPQUFTeUcsR0FDOUJ0RCxFQUFJdU8sV0FBV3VCLEVBQVF4TSxFQUFRd00sRUFBT2pULE9BQVN5RyxHQUMvQ3RELEVBQUlxTyxVQUFVLEdBSWRyTyxFQUFJME8sWUFBWSxLQUdsQixJQUFJc0IsR0FBa0IsU0FBU2hRLEdBRTdCLEdBQUlpUSxHQUFPalEsRUFDUGtRLEVBQWEsRUFDYkMsRUFBYSxFQUViM00sSUEwQkosT0F4QkFBLEdBQU02RSxNQUFRLFNBQVM1TCxFQUFNSSxHQUUzQixHQUFNSixJQUFTSSxHQUFXLEVBQ3hCLEtBQU0sSUFBSXVHLE9BQU0sY0FHbEIsTUFBTzhNLEVBQWFyVCxHQUFVLEdBQzVCb1QsRUFBSzVCLFVBQVUsS0FBVTVSLEdBQVF5VCxFQUFjQyxJQUMvQ3RULEdBQVcsRUFBSXFULEVBQ2Z6VCxLQUFXLEVBQUl5VCxFQUNmQyxFQUFhLEVBQ2JELEVBQWEsQ0FHZkMsSUFBYzFULEdBQVF5VCxFQUN0QkEsR0FBMEJyVCxHQUc1QjJHLEVBQU15TCxNQUFRLFdBQ1JpQixFQUFhLEdBQ2ZELEVBQUs1QixVQUFVOEIsSUFJWjNNLEdBR0x1TSxFQUFlLFNBQVNGLEdBUzFCLElBQUssR0FQRE8sR0FBWSxHQUFLUCxFQUNqQlEsR0FBVyxHQUFLUixHQUFrQixFQUNsQ1MsRUFBWVQsRUFBaUIsRUFHN0JVLEVBQVFDLElBRUg1VCxFQUFJLEVBQUdBLEVBQUl3VCxFQUFXeFQsR0FBSyxFQUNsQzJULEVBQU1FLElBQUkzRixPQUFPQyxhQUFhbk8sR0FFaEMyVCxHQUFNRSxJQUFJM0YsT0FBT0MsYUFBYXFGLElBQzlCRyxFQUFNRSxJQUFJM0YsT0FBT0MsYUFBYXNGLEdBRTlCLElBQUlLLEdBQVV0QyxJQUNWdUMsRUFBU1gsRUFBZ0JVLEVBRzdCQyxHQUFPdEksTUFBTStILEVBQVdFLEVBRXhCLElBQUlNLEdBQVksRUFFWjlHLEVBQUlnQixPQUFPQyxhQUFhOEMsRUFBTStDLEdBR2xDLEtBRkFBLEdBQWEsRUFFTkEsRUFBWS9DLEVBQU1oUixRQUFRLENBRS9CLEdBQUl2RCxHQUFJd1IsT0FBT0MsYUFBYThDLEVBQU0rQyxHQUNsQ0EsSUFBYSxFQUVUTCxFQUFNTSxTQUFTL0csRUFBSXhRLEdBRXJCd1EsR0FBUXhRLEdBSVJxWCxFQUFPdEksTUFBTWtJLEVBQU1PLFFBQVFoSCxHQUFJd0csR0FFM0JDLEVBQU05RyxPQUFTLE9BRWI4RyxFQUFNOUcsUUFBVyxHQUFLNkcsSUFDeEJBLEdBQWEsR0FHZkMsRUFBTUUsSUFBSTNHLEVBQUl4USxJQUdoQndRLEVBQUl4USxHQVdSLE1BUEFxWCxHQUFPdEksTUFBTWtJLEVBQU1PLFFBQVFoSCxHQUFJd0csR0FHL0JLLEVBQU90SSxNQUFNZ0ksRUFBU0MsR0FFdEJLLEVBQU8xQixRQUVBeUIsRUFBUS9CLGVBR2I2QixFQUFXLFdBRWIsR0FBSU8sTUFDQUMsRUFBUSxFQUVSeE4sSUFzQkosT0FwQkFBLEdBQU1pTixJQUFNLFNBQVM3VixHQUNuQixHQUFJNEksRUFBTXFOLFNBQVNqVyxHQUNqQixLQUFNLElBQUl3SSxPQUFNLFdBQWF4SSxFQUUvQm1XLEdBQUtuVyxHQUFPb1csRUFDWkEsR0FBUyxHQUdYeE4sRUFBTWlHLEtBQU8sV0FDWCxNQUFPdUgsSUFHVHhOLEVBQU1zTixRQUFVLFNBQVNsVyxHQUN2QixNQUFPbVcsR0FBS25XLElBR2Q0SSxFQUFNcU4sU0FBVyxTQUFTalcsR0FDeEIsTUFBMkIsbUJBQWJtVyxHQUFLblcsSUFHZDRJLEVBR1QsT0FBT0EsSUFHTG1HLEVBQWUsU0FBUzVOLEVBQU9DLEVBQVFpVixFQUFVQyxHQUduRCxJQUFLLEdBRERDLEdBQU0zQixFQUFTelQsRUFBT0MsR0FDakJpQixFQUFJLEVBQUdBLEVBQUlqQixFQUFRaUIsR0FBSyxFQUMvQixJQUFLLEdBQUlILEdBQUksRUFBR0EsRUFBSWYsRUFBT2UsR0FBSyxFQUM5QnFVLEVBQUl4QixTQUFTN1MsRUFBR0csRUFBR2dVLEVBQVNuVSxFQUFHRyxHQUluQyxJQUFJOEQsR0FBSXFOLEdBQ1IrQyxHQUFJOUksTUFBTXRILEVBSVYsS0FBSyxHQUZEcVEsR0FBU3hDLElBQ1Q3RSxFQUFRaEosRUFBRTROLGNBQ0wvUixFQUFJLEVBQUdBLEVBQUltTixFQUFNbE4sT0FBUUQsR0FBSyxFQUNyQ3dVLEVBQU8vQyxVQUFVdEUsRUFBTW5OLEdBRXpCd1UsR0FBT25DLE9BRVAsSUFBSW9DLEdBQU0sRUFtQlYsT0FsQkFBLElBQU8sT0FDUEEsR0FBTyxTQUNQQSxHQUFPLHlCQUNQQSxHQUFPRCxFQUNQQyxHQUFPLElBQ1BBLEdBQU8sV0FDUEEsR0FBT3RWLEVBQ1BzVixHQUFPLElBQ1BBLEdBQU8sWUFDUEEsR0FBT3JWLEVBQ1BxVixHQUFPLElBQ0hILElBQ0ZHLEdBQU8sU0FDUEEsR0FBT0gsRUFDUEcsR0FBTyxLQUVUQSxHQUFPLE1BS0wvVixFQUFrQixTQUFTUyxFQUFPQyxFQUFRaVYsR0FHNUMsSUFBSyxHQURERSxHQUFNM0IsRUFBU3pULEVBQU9DLEdBQ2pCaUIsRUFBSSxFQUFHQSxFQUFJakIsRUFBUWlCLEdBQUssRUFDL0IsSUFBSyxHQUFJSCxHQUFJLEVBQUdBLEVBQUlmLEVBQU9lLEdBQUssRUFDOUJxVSxFQUFJeEIsU0FBUzdTLEVBQUdHLEVBQUdnVSxFQUFTblUsRUFBR0csR0FJbkMsSUFBSThELEdBQUlxTixHQUNSK0MsR0FBSTlJLE1BQU10SCxFQUlWLEtBQUssR0FGRHFRLEdBQVN4QyxJQUNUN0UsRUFBUWhKLEVBQUU0TixjQUNML1IsRUFBSSxFQUFHQSxFQUFJbU4sRUFBTWxOLE9BQVFELEdBQUssRUFDckN3VSxFQUFPL0MsVUFBVXRFLEVBQU1uTixHQUV6QndVLEdBQU9uQyxPQUVQLElBQUlvQyxHQUFNLEdBQUkzVixNQUtkLE9BSkEyVixHQUFJMVYsSUFBTSx5QkFBMkJ5VixFQUNyQ0MsRUFBSXRWLE1BQVFBLEVBQ1pzVixFQUFJclYsT0FBU0EsRUFFTnFWLEVBTVQsUUFDRW5XLE9BQVE4SCxFQUNSMUYsT0FBUUEsUUFJWCxTQUFVOUUsR0FFTHFLLEtBQUFELEVBQUEsRUFBQUUsRUFBQSxrQkFBQUYsS0FBQTNCLE1BQUF4SSxFQUFBb0ssR0FBQUQsSUFBQWhDLFNBQUFrQyxJQUFBcEssRUFBQUQsUUFBQXFLLEtBSUosV0FDRSxPQUNFNUgsT0FBUThILEVBQU85SCxPQUNmb0MsT0FBUTBGLEVBQU8xRixXdkJ3RmYsU0FBUzVFLEVBQVFELEVBQVNNLEd3QnJwRWhDLFlBY0EsU0FBQVMsR0FBQUMsR0FBc0MsTUFBQUEsTUFBQUMsV0FBQUQsR0FBdUNFLFFBQUFGLEdBWjdFaEIsRUFBQWlCLFlBQUEsQ0FFQSxJQUFBNFgsR0FBQXZZLEVBQUEsSUFFQXdZLEVBQUEvWCxFQUFBOFgsR0FFQUUsRUFBQXpZLEVBQUEsSUFFQTBZLEVBQUFqWSxFQUFBZ1ksR0FFQUUsRUFBQSxrQkFBQUQsR0FBQTlYLFNBQUEsZ0JBQUE0WCxHQUFBNVgsUUFBQSxTQUFBRixHQUFpSCxhQUFBQSxJQUFxQixTQUFBQSxHQUFtQixNQUFBQSxJQUFBLGtCQUFBZ1ksR0FBQTlYLFNBQUFGLEVBQUFrWSxjQUFBRixFQUFBOVgsU0FBQUYsSUFBQWdZLEVBQUE5WCxRQUFBb0YsVUFBQSxlQUFBdEYsR0FJekpoQixHQUFBa0IsUUFBQSxrQkFBQThYLEdBQUE5WCxTQUFBLFdBQUErWCxFQUFBSCxFQUFBNVgsU0FBQSxTQUFBRixHQUNBLHlCQUFBQSxHQUFBLFlBQUFpWSxFQUFBalksSUFDQyxTQUFBQSxHQUNELE1BQUFBLElBQUEsa0JBQUFnWSxHQUFBOVgsU0FBQUYsRUFBQWtZLGNBQUFGLEVBQUE5WCxTQUFBRixJQUFBZ1ksRUFBQTlYLFFBQUFvRixVQUFBLDRCQUFBdEYsR0FBQSxZQUFBaVksRUFBQWpZLEt4QjRwRU0sU0FBU2YsRUFBUUQsRUFBU00sR3lCL3FFaENMLEVBQUFELFNBQWtCa0IsUUFBQVosRUFBQSxJQUFBVyxZQUFBLEl6QnFyRVosU0FBU2hCLEVBQVFELEVBQVNNLEcwQnJyRWhDQSxFQUFBLElBQ0FBLEVBQUEsSUFDQUwsRUFBQUQsUUFBQU0sRUFBQSxJQUFBdUcsRUFBQSxhMUIyckVNLFNBQVM1RyxFQUFRRCxFQUFTTSxHMkI3ckVoQyxZQUNBLElBQUE2WSxHQUFBN1ksRUFBQSxPQUdBQSxHQUFBLElBQUErUixPQUFBLGtCQUFBK0csR0FDQWhaLEtBQUFpWixHQUFBaEgsT0FBQStHLEdBQ0FoWixLQUFBa1osR0FBQSxHQUVDLFdBQ0QsR0FFQUMsR0FGQTlQLEVBQUFySixLQUFBaVosR0FDQXBPLEVBQUE3SyxLQUFBa1osRUFFQSxPQUFBck8sSUFBQXhCLEVBQUFyRixRQUErQi9DLE1BQUE4RyxPQUFBcVIsTUFBQSxJQUMvQkQsRUFBQUosRUFBQTFQLEVBQUF3QixHQUNBN0ssS0FBQWtaLElBQUFDLEVBQUFuVixRQUNVL0MsTUFBQWtZLEVBQUFDLE1BQUEsTzNCb3NFSixTQUFTdlosRUFBUUQsRUFBU00sRzRCbnRFaEMsR0FBQW1aLEdBQUFuWixFQUFBLElBQ0FvWixFQUFBcFosRUFBQSxHQUdBTCxHQUFBRCxRQUFBLFNBQUEyWixHQUNBLGdCQUFBelEsRUFBQXFFLEdBQ0EsR0FHQWxGLEdBQUFDLEVBSEErSSxFQUFBZ0IsT0FBQXFILEVBQUF4USxJQUNBL0UsRUFBQXNWLEVBQUFsTSxHQUNBcU0sRUFBQXZJLEVBQUFqTixNQUVBLE9BQUFELEdBQUEsR0FBQUEsR0FBQXlWLEVBQUFELEVBQUEsR0FBQXhSLFFBQ0FFLEVBQUFnSixFQUFBRSxXQUFBcE4sR0FDQWtFLEVBQUEsT0FBQUEsRUFBQSxPQUFBbEUsRUFBQSxJQUFBeVYsSUFBQXRSLEVBQUErSSxFQUFBRSxXQUFBcE4sRUFBQSxXQUFBbUUsRUFBQSxNQUNBcVIsRUFBQXRJLEVBQUFvQixPQUFBdE8sR0FBQWtFLEVBQ0FzUixFQUFBdEksRUFBQXdJLE1BQUExVixJQUFBLElBQUFrRSxFQUFBLFlBQUFDLEVBQUEsaUI1QjJ0RU0sU0FBU3JJLEVBQVFELEc2Qnh1RXZCLEdBQUE4WixHQUFBeFYsS0FBQXdWLEtBQ0F2VixFQUFBRCxLQUFBQyxLQUNBdEUsR0FBQUQsUUFBQSxTQUFBd0csR0FDQSxNQUFBdVQsT0FBQXZULE1BQUEsR0FBQUEsRUFBQSxFQUFBakMsRUFBQXVWLEdBQUF0VCxLN0JndkVNLFNBQVN2RyxFQUFRRCxHOEJudkV2QkMsRUFBQUQsUUFBQSxTQUFBd0csR0FDQSxHQUFBMkIsUUFBQTNCLEVBQUEsS0FBQXpFLFdBQUEseUJBQUF5RSxFQUNBLE9BQUFBLEs5QjJ2RU0sU0FBU3ZHLEVBQVFELEVBQVNNLEcrQjl2RWhDLFlBQ0EsSUFBQTBaLEdBQUExWixFQUFBLElBQ0FvRyxFQUFBcEcsRUFBQSxHQUNBMlosRUFBQTNaLEVBQUEsSUFDQTJHLEVBQUEzRyxFQUFBLElBQ0E0WixFQUFBNVosRUFBQSxJQUNBNlosRUFBQTdaLEVBQUEsSUFDQThaLEVBQUE5WixFQUFBLElBQ0ErWixFQUFBL1osRUFBQSxJQUNBZ2EsRUFBQWhhLEVBQUEsSUFDQWlhLEVBQUFqYSxFQUFBLGdCQUNBa2EsT0FBQUMsTUFBQSxXQUFBQSxRQUNBQyxFQUFBLGFBQ0FDLEVBQUEsT0FDQUMsRUFBQSxTQUVBQyxFQUFBLFdBQTRCLE1BQUF6YSxNQUU1QkgsR0FBQUQsUUFBQSxTQUFBOGEsRUFBQUMsRUFBQXJWLEVBQUFzVixFQUFBQyxFQUFBQyxFQUFBQyxHQUNBZixFQUFBMVUsRUFBQXFWLEVBQUFDLEVBQ0EsSUFlQUksR0FBQWpaLEVBQUFrWixFQWZBQyxFQUFBLFNBQUFDLEdBQ0EsSUFBQWYsR0FBQWUsSUFBQUMsR0FBQSxNQUFBQSxHQUFBRCxFQUNBLFFBQUFBLEdBQ0EsSUFBQVosR0FBQSxrQkFBd0MsVUFBQWpWLEdBQUF0RixLQUFBbWIsR0FDeEMsS0FBQVgsR0FBQSxrQkFBNEMsVUFBQWxWLEdBQUF0RixLQUFBbWIsSUFDdkMsa0JBQTJCLFVBQUE3VixHQUFBdEYsS0FBQW1iLEtBRWhDRSxFQUFBVixFQUFBLFlBQ0FXLEVBQUFULEdBQUFMLEVBQ0FlLEdBQUEsRUFDQUgsRUFBQVYsRUFBQXhVLFVBQ0FzVixFQUFBSixFQUFBakIsSUFBQWlCLEVBQUFkLElBQUFPLEdBQUFPLEVBQUFQLEdBQ0FZLEVBQUFELEdBQUFOLEVBQUFMLEdBQ0FhLEVBQUFiLEVBQUFTLEVBQUFKLEVBQUEsV0FBQU8sRUFBQTFULE9BQ0E0VCxFQUFBLFNBQUFoQixFQUFBUyxFQUFBUSxTQUFBSixHQXdCQSxJQXJCQUcsSUFDQVYsRUFBQWYsRUFBQXlCLEVBQUFwYixLQUFBLEdBQUFtYSxLQUNBTyxJQUFBbGEsT0FBQW1GLFlBRUErVCxFQUFBZ0IsRUFBQUksR0FBQSxHQUVBekIsR0FBQUUsRUFBQW1CLEVBQUFkLElBQUF0VCxFQUFBb1UsRUFBQWQsRUFBQU0sS0FJQWEsR0FBQUUsS0FBQXhVLE9BQUF3VCxJQUNBZSxHQUFBLEVBQ0FFLEVBQUEsV0FBaUMsTUFBQUQsR0FBQWpiLEtBQUFQLFFBR2pDNFosSUFBQW1CLElBQUFYLElBQUFtQixHQUFBSCxFQUFBakIsSUFDQXRULEVBQUF1VSxFQUFBakIsRUFBQXNCLEdBR0ExQixFQUFBWSxHQUFBYyxFQUNBMUIsRUFBQXNCLEdBQUFaLEVBQ0FJLEVBTUEsR0FMQUcsR0FDQWEsT0FBQVAsRUFBQUcsRUFBQVAsRUFBQVYsR0FDQUgsS0FBQVMsRUFBQVcsRUFBQVAsRUFBQVgsR0FDQXFCLFFBQUFGLEdBRUFYLEVBQUEsSUFBQWhaLElBQUFpWixHQUNBalosSUFBQXFaLElBQUF2QixFQUFBdUIsRUFBQXJaLEVBQUFpWixFQUFBalosUUFDS3VFLEtBQUFtQixFQUFBbkIsRUFBQUUsR0FBQTRULEdBQUFtQixHQUFBWixFQUFBSyxFQUVMLE9BQUFBLEsvQnF3RU0sU0FBU25iLEVBQVFELEdnQ3owRXZCQyxFQUFBRCxTQUFBLEdoQyswRU0sU0FBU0MsRUFBUUQsRUFBU00sR2lDLzBFaENMLEVBQUFELFFBQUFNLEVBQUEsS2pDcTFFTSxTQUFTTCxFQUFRRCxHa0NyMUV2QixHQUFBa2MsTUFBdUJBLGNBQ3ZCamMsR0FBQUQsUUFBQSxTQUFBd0csRUFBQXJFLEdBQ0EsTUFBQStaLEdBQUF2YixLQUFBNkYsRUFBQXJFLEtsQzQxRU0sU0FBU2xDLEVBQVFELEdtQzkxRXZCQyxFQUFBRCxZbkNvMkVNLFNBQVNDLEVBQVFELEVBQVNNLEdvQ3AyRWhDLFlBQ0EsSUFBQTZiLEdBQUE3YixFQUFBLElBQ0EwRixFQUFBMUYsRUFBQSxJQUNBK1osRUFBQS9aLEVBQUEsSUFDQSthLElBR0EvYSxHQUFBLElBQUErYSxFQUFBL2EsRUFBQSwyQkFBZ0YsTUFBQUYsUUFFaEZILEVBQUFELFFBQUEsU0FBQTBGLEVBQUFxVixFQUFBQyxHQUNBdFYsRUFBQVksVUFBQTZWLEVBQUFkLEdBQXFETCxLQUFBaFYsRUFBQSxFQUFBZ1YsS0FDckRYLEVBQUEzVSxFQUFBcVYsRUFBQSxlcEMyMkVNLFNBQVM5YSxFQUFRRCxFQUFTTSxHcUNyM0VoQyxHQUFBZ0osR0FBQWhKLEVBQUEsSUFDQThiLEVBQUE5YixFQUFBLElBQ0ErYixFQUFBL2IsRUFBQSxJQUNBZ2MsRUFBQWhjLEVBQUEsZ0JBQ0FpYyxFQUFBLGFBQ0FyVixFQUFBLFlBR0FzVixFQUFBLFdBRUEsR0FJQUMsR0FKQUMsRUFBQXBjLEVBQUEsY0FDQTZELEVBQUFrWSxFQUFBalksT0FDQXVZLEVBQUEsSUFDQUMsRUFBQSxHQVlBLEtBVkFGLEVBQUFHLE1BQUFDLFFBQUEsT0FDQXhjLEVBQUEsSUFBQWdGLFlBQUFvWCxHQUNBQSxFQUFBeFosSUFBQSxjQUdBdVosRUFBQUMsRUFBQUssY0FBQXRaLFNBQ0FnWixFQUFBTyxPQUNBUCxFQUFBN00sTUFBQStNLEVBQUEsU0FBQUMsRUFBQSxvQkFBQUQsRUFBQSxVQUFBQyxHQUNBSCxFQUFBUSxRQUNBVCxFQUFBQyxFQUFBN1YsRUFDQXpDLFdBQUFxWSxHQUFBdFYsR0FBQW1WLEVBQUFsWSxHQUNBLE9BQUFxWSxLQUdBdmMsR0FBQUQsUUFBQW1CLE9BQUFnYixRQUFBLFNBQUExUyxFQUFBeVQsR0FDQSxHQUFBQyxFQVFBLE9BUEEsUUFBQTFULEdBQ0E4UyxFQUFBclYsR0FBQW9DLEVBQUFHLEdBQ0EwVCxFQUFBLEdBQUFaLEdBQ0FBLEVBQUFyVixHQUFBLEtBRUFpVyxFQUFBYixHQUFBN1MsR0FDRzBULEVBQUFYLElBQ0hyVSxTQUFBK1UsRUFBQUMsRUFBQWYsRUFBQWUsRUFBQUQsS3JDODNFTSxTQUFTamQsRUFBUUQsRUFBU00sR3NDcjZFaEMsR0FBQTZJLEdBQUE3SSxFQUFBLElBQ0FnSixFQUFBaEosRUFBQSxJQUNBOGMsRUFBQTljLEVBQUEsR0FFQUwsR0FBQUQsUUFBQU0sRUFBQSxJQUFBYSxPQUFBMEUsaUJBQUEsU0FBQTRELEVBQUF5VCxHQUNBNVQsRUFBQUcsRUFLQSxLQUpBLEdBR0E1QixHQUhBNFMsRUFBQTJDLEVBQUFGLEdBQ0E5WSxFQUFBcVcsRUFBQXJXLE9BQ0FELEVBQUEsRUFFQUMsRUFBQUQsR0FBQWdGLEVBQUF0QyxFQUFBNEMsRUFBQTVCLEVBQUE0UyxFQUFBdFcsS0FBQStZLEVBQUFyVixHQUNBLE9BQUE0QixLdEM0NkVNLFNBQVN4SixFQUFRRCxFQUFTTSxHdUN0N0VoQyxHQUFBK2MsR0FBQS9jLEVBQUEsSUFDQStiLEVBQUEvYixFQUFBLEdBRUFMLEdBQUFELFFBQUFtQixPQUFBc1osTUFBQSxTQUFBaFIsR0FDQSxNQUFBNFQsR0FBQTVULEVBQUE0UyxLdkM4N0VNLFNBQVNwYyxFQUFRRCxFQUFTTSxHd0NuOEVoQyxHQUFBNFosR0FBQTVaLEVBQUEsSUFDQWdkLEVBQUFoZCxFQUFBLElBQ0FpZCxFQUFBamQsRUFBQSxRQUNBZ2MsRUFBQWhjLEVBQUEsZUFFQUwsR0FBQUQsUUFBQSxTQUFBcUosRUFBQW1VLEdBQ0EsR0FHQXJiLEdBSEFzSCxFQUFBNlQsRUFBQWpVLEdBQ0FsRixFQUFBLEVBQ0FnWixJQUVBLEtBQUFoYixJQUFBc0gsR0FBQXRILEdBQUFtYSxHQUFBcEMsRUFBQXpRLEVBQUF0SCxJQUFBZ2IsRUFBQTlNLEtBQUFsTyxFQUVBLE1BQUFxYixFQUFBcFosT0FBQUQsR0FBQStWLEVBQUF6USxFQUFBdEgsRUFBQXFiLEVBQUFyWixTQUNBb1osRUFBQUosRUFBQWhiLElBQUFnYixFQUFBOU0sS0FBQWxPLEdBRUEsT0FBQWdiLEt4QzA4RU0sU0FBU2xkLEVBQVFELEVBQVNNLEd5Q3g5RWhDLEdBQUFtZCxHQUFBbmQsRUFBQSxJQUNBb1osRUFBQXBaLEVBQUEsR0FDQUwsR0FBQUQsUUFBQSxTQUFBd0csR0FDQSxNQUFBaVgsR0FBQS9ELEVBQUFsVCxNekNnK0VNLFNBQVN2RyxFQUFRRCxFQUFTTSxHMENuK0VoQyxHQUFBb2QsR0FBQXBkLEVBQUEsR0FDQUwsR0FBQUQsUUFBQW1CLE9BQUEsS0FBQXdjLHFCQUFBLEdBQUF4YyxPQUFBLFNBQUFxRixHQUNBLGdCQUFBa1gsRUFBQWxYLEtBQUFvWCxNQUFBLElBQUF6YyxPQUFBcUYsSzFDMitFTSxTQUFTdkcsRUFBUUQsRzJDOStFdkIsR0FBQWdLLE1BQWlCQSxRQUVqQi9KLEdBQUFELFFBQUEsU0FBQXdHLEdBQ0EsTUFBQXdELEdBQUFySixLQUFBNkYsR0FBQXFULE1BQUEsUTNDcS9FTSxTQUFTNVosRUFBUUQsRUFBU00sRzRDdC9FaEMsR0FBQWdkLEdBQUFoZCxFQUFBLElBQ0F1ZCxFQUFBdmQsRUFBQSxJQUNBd2QsRUFBQXhkLEVBQUEsR0FDQUwsR0FBQUQsUUFBQSxTQUFBK2QsR0FDQSxnQkFBQUMsRUFBQTViLEVBQUE2YixHQUNBLEdBR0E1YyxHQUhBb0ksRUFBQTZULEVBQUFVLEdBQ0E1WixFQUFBeVosRUFBQXBVLEVBQUFyRixRQUNBNkcsRUFBQTZTLEVBQUFHLEVBQUE3WixFQUdBLElBQUEyWixHQUFBM2IsTUFBQSxLQUFBZ0MsRUFBQTZHLEdBRUEsR0FEQTVKLEVBQUFvSSxFQUFBd0IsS0FDQTVKLEtBQUEsYUFFSyxNQUFXK0MsRUFBQTZHLEVBQWVBLElBQUEsSUFBQThTLEdBQUE5UyxJQUFBeEIsS0FDL0JBLEVBQUF3QixLQUFBN0ksRUFBQSxNQUFBMmIsSUFBQTlTLEdBQUEsQ0FDSyxRQUFBOFMsSUFBQSxLNUNnZ0ZDLFNBQVM5ZCxFQUFRRCxFQUFTTSxHNkNqaEZoQyxHQUFBbVosR0FBQW5aLEVBQUEsSUFDQTZRLEVBQUE3TSxLQUFBNk0sR0FDQWxSLEdBQUFELFFBQUEsU0FBQXdHLEdBQ0EsTUFBQUEsR0FBQSxFQUFBMkssRUFBQXNJLEVBQUFqVCxHQUFBLHNCN0N5aEZNLFNBQVN2RyxFQUFRRCxFQUFTTSxHOEM3aEZoQyxHQUFBbVosR0FBQW5aLEVBQUEsSUFDQXVPLEVBQUF2SyxLQUFBdUssSUFDQXNDLEVBQUE3TSxLQUFBNk0sR0FDQWxSLEdBQUFELFFBQUEsU0FBQWlMLEVBQUE3RyxHQUVBLE1BREE2RyxHQUFBd08sRUFBQXhPLEdBQ0FBLEVBQUEsRUFBQTRELEVBQUE1RCxFQUFBN0csRUFBQSxHQUFBK00sRUFBQWxHLEVBQUE3RyxLOUNvaUZNLFNBQVNuRSxFQUFRRCxFQUFTTSxHK0N6aUZoQyxHQUFBNGQsR0FBQTVkLEVBQUEsWUFDQTZkLEVBQUE3ZCxFQUFBLEdBQ0FMLEdBQUFELFFBQUEsU0FBQW1DLEdBQ0EsTUFBQStiLEdBQUEvYixLQUFBK2IsRUFBQS9iLEdBQUFnYyxFQUFBaGMsTS9DZ2pGTSxTQUFTbEMsRUFBUUQsRUFBU00sR2dEbmpGaEMsR0FBQXdHLEdBQUF4RyxFQUFBLEdBQ0E4ZCxFQUFBLHFCQUNBQyxFQUFBdlgsRUFBQXNYLEtBQUF0WCxFQUFBc1gsTUFDQW5lLEdBQUFELFFBQUEsU0FBQW1DLEdBQ0EsTUFBQWtjLEdBQUFsYyxLQUFBa2MsRUFBQWxjLFNoRDBqRk0sU0FBU2xDLEVBQVFELEdpRDlqRnZCLEdBQUFTLEdBQUEsRUFDQTZkLEVBQUFoYSxLQUFBaWEsUUFDQXRlLEdBQUFELFFBQUEsU0FBQW1DLEdBQ0EsZ0JBQUFxYyxPQUFBclcsU0FBQWhHLEVBQUEsR0FBQUEsRUFBQSxRQUFBMUIsRUFBQTZkLEdBQUF0VSxTQUFBLE9qRHFrRk0sU0FBUy9KLEVBQVFELEdrRHZrRnZCQyxFQUFBRCxRQUFBLGdHQUVBNGQsTUFBQSxNbEQ4a0ZNLFNBQVMzZCxFQUFRRCxFQUFTTSxHbURqbEZoQ0wsRUFBQUQsUUFBQU0sRUFBQSxHQUFBbUQsbUJBQUFnYixpQm5EdWxGTSxTQUFTeGUsRUFBUUQsRUFBU00sR29EdmxGaEMsR0FBQW9lLEdBQUFwZSxFQUFBLElBQUF1RyxFQUNBcVQsRUFBQTVaLEVBQUEsSUFDQW1iLEVBQUFuYixFQUFBLGtCQUVBTCxHQUFBRCxRQUFBLFNBQUF3RyxFQUFBbVksRUFBQUMsR0FDQXBZLElBQUEwVCxFQUFBMVQsRUFBQW9ZLEVBQUFwWSxJQUFBRixVQUFBbVYsSUFBQWlELEVBQUFsWSxFQUFBaVYsR0FBa0V2VixjQUFBLEVBQUE3RSxNQUFBc2QsTXBEOGxGNUQsU0FBUzFlLEVBQVFELEVBQVNNLEdxRG5tRmhDLEdBQUErZCxHQUFBL2QsRUFBQSxXQUNBNmQsRUFBQTdkLEVBQUEsSUFDQXVlLEVBQUF2ZSxFQUFBLEdBQUF1ZSxPQUNBQyxFQUFBLGtCQUFBRCxHQUVBRSxFQUFBOWUsRUFBQUQsUUFBQSxTQUFBb0gsR0FDQSxNQUFBaVgsR0FBQWpYLEtBQUFpWCxFQUFBalgsR0FDQTBYLEdBQUFELEVBQUF6WCxLQUFBMFgsRUFBQUQsRUFBQVYsR0FBQSxVQUFBL1csSUFHQTJYLEdBQUFWLFNyRHltRk0sU0FBU3BlLEVBQVFELEVBQVNNLEdzRGxuRmhDLEdBQUE0WixHQUFBNVosRUFBQSxJQUNBMGUsRUFBQTFlLEVBQUEsSUFDQWdjLEVBQUFoYyxFQUFBLGdCQUNBMmUsRUFBQTlkLE9BQUFtRixTQUVBckcsR0FBQUQsUUFBQW1CLE9BQUFtWixnQkFBQSxTQUFBN1EsR0FFQSxNQURBQSxHQUFBdVYsRUFBQXZWLEdBQ0F5USxFQUFBelEsRUFBQTZTLEdBQUE3UyxFQUFBNlMsR0FDQSxrQkFBQTdTLEdBQUF5UCxhQUFBelAsZUFBQXlQLFlBQ0F6UCxFQUFBeVAsWUFBQTVTLFVBQ0dtRCxZQUFBdEksUUFBQThkLEVBQUEsT3REMG5GRyxTQUFTaGYsRUFBUUQsRUFBU00sR3VEcG9GaEMsR0FBQW9aLEdBQUFwWixFQUFBLEdBQ0FMLEdBQUFELFFBQUEsU0FBQXdHLEdBQ0EsTUFBQXJGLFFBQUF1WSxFQUFBbFQsTXZENG9GTSxTQUFTdkcsRUFBUUQsRUFBU00sR3dEL29GaENBLEVBQUEsR0FNQSxRQUxBd0csR0FBQXhHLEVBQUEsR0FDQTJHLEVBQUEzRyxFQUFBLElBQ0E2WixFQUFBN1osRUFBQSxJQUNBNGUsRUFBQTVlLEVBQUEsbUJBRUE2ZSxHQUFBLHNFQUFBaGIsRUFBQSxFQUF3R0EsRUFBQSxFQUFPQSxJQUFBLENBQy9HLEdBQUE0VyxHQUFBb0UsRUFBQWhiLEdBQ0FpYixFQUFBdFksRUFBQWlVLEdBQ0FTLEVBQUE0RCxLQUFBOVksU0FDQWtWLE9BQUEwRCxJQUFBalksRUFBQXVVLEVBQUEwRCxFQUFBbkUsR0FDQVosRUFBQVksR0FBQVosRUFBQXJQLFF4RHNwRk0sU0FBUzdLLEVBQVFELEVBQVNNLEd5RGpxRmhDLFlBQ0EsSUFBQStlLEdBQUEvZSxFQUFBLElBQ0FnZixFQUFBaGYsRUFBQSxJQUNBNlosRUFBQTdaLEVBQUEsSUFDQWdkLEVBQUFoZCxFQUFBLEdBTUFMLEdBQUFELFFBQUFNLEVBQUEsSUFBQXdLLE1BQUEsaUJBQUFzTyxFQUFBbUMsR0FDQW5iLEtBQUFpWixHQUFBaUUsRUFBQWxFLEdBQ0FoWixLQUFBa1osR0FBQSxFQUNBbFosS0FBQW1mLEdBQUFoRSxHQUVDLFdBQ0QsR0FBQTlSLEdBQUFySixLQUFBaVosR0FDQWtDLEVBQUFuYixLQUFBbWYsR0FDQXRVLEVBQUE3SyxLQUFBa1osSUFDQSxRQUFBN1AsR0FBQXdCLEdBQUF4QixFQUFBckYsUUFDQWhFLEtBQUFpWixHQUFBbFIsT0FDQW1YLEVBQUEsSUFFQSxRQUFBL0QsRUFBQStELEVBQUEsRUFBQXJVLEdBQ0EsVUFBQXNRLEVBQUErRCxFQUFBLEVBQUE3VixFQUFBd0IsSUFDQXFVLEVBQUEsR0FBQXJVLEVBQUF4QixFQUFBd0IsTUFDQyxVQUdEa1AsRUFBQXFGLFVBQUFyRixFQUFBclAsTUFFQXVVLEVBQUEsUUFDQUEsRUFBQSxVQUNBQSxFQUFBLFl6RHVxRk0sU0FBU3BmLEVBQVFELEcwRHhzRnZCQyxFQUFBRCxRQUFBLGMxRDhzRk0sU0FBU0MsRUFBUUQsRzJEOXNGdkJDLEVBQUFELFFBQUEsU0FBQXdaLEVBQUFuWSxHQUNBLE9BQVVBLFFBQUFtWSxZM0RxdEZKLFNBQVN2WixFQUFRRCxFQUFTTSxHNER0dEZoQ04sRUFBQTZHLEVBQUF2RyxFQUFBLEs1RDR0Rk0sU0FBU0wsRUFBUUQsRUFBU00sRzZENXRGaENMLEVBQUFELFNBQWtCa0IsUUFBQVosRUFBQSxJQUFBVyxZQUFBLEk3RGt1RlosU0FBU2hCLEVBQVFELEVBQVNNLEc4RGx1RmhDQSxFQUFBLElBQ0FBLEVBQUEsSUFDQUEsRUFBQSxJQUNBQSxFQUFBLElBQ0FMLEVBQUFELFFBQUFNLEVBQUEsR0FBQXVlLFE5RHd1Rk0sU0FBUzVlLEVBQVFELEVBQVNNLEcrRDV1RmhDLFlBRUEsSUFBQXdHLEdBQUF4RyxFQUFBLEdBQ0E0WixFQUFBNVosRUFBQSxJQUNBbWYsRUFBQW5mLEVBQUEsSUFDQW9HLEVBQUFwRyxFQUFBLEdBQ0EyWixFQUFBM1osRUFBQSxJQUNBb2YsRUFBQXBmLEVBQUEsSUFBQXFmLElBQ0FDLEVBQUF0ZixFQUFBLElBQ0E0ZCxFQUFBNWQsRUFBQSxJQUNBK1osRUFBQS9aLEVBQUEsSUFDQTZkLEVBQUE3ZCxFQUFBLElBQ0F1ZixFQUFBdmYsRUFBQSxJQUNBd2YsRUFBQXhmLEVBQUEsSUFDQXlmLEVBQUF6ZixFQUFBLElBQ0EwZixFQUFBMWYsRUFBQSxJQUNBMmYsRUFBQTNmLEVBQUEsSUFDQTRmLEVBQUE1ZixFQUFBLElBQ0FnSixFQUFBaEosRUFBQSxJQUNBZ2QsRUFBQWhkLEVBQUEsSUFDQWtKLEVBQUFsSixFQUFBLElBQ0E4SSxFQUFBOUksRUFBQSxJQUNBNmYsRUFBQTdmLEVBQUEsSUFDQThmLEVBQUE5ZixFQUFBLElBQ0ErZixFQUFBL2YsRUFBQSxJQUNBZ2dCLEVBQUFoZ0IsRUFBQSxJQUNBK2MsRUFBQS9jLEVBQUEsSUFDQWlnQixFQUFBRixFQUFBeFosRUFDQXNDLEVBQUFtWCxFQUFBelosRUFDQTJaLEVBQUFKLEVBQUF2WixFQUNBNFosRUFBQTNaLEVBQUErWCxPQUNBNkIsRUFBQTVaLEVBQUE2WixLQUNBQyxFQUFBRixLQUFBRyxVQUNBM1osRUFBQSxZQUNBNFosRUFBQWpCLEVBQUEsV0FDQWtCLEVBQUFsQixFQUFBLGVBQ0FtQixLQUF1QnJELHFCQUN2QnNELEVBQUEvQyxFQUFBLG1CQUNBZ0QsRUFBQWhELEVBQUEsV0FDQWlELEVBQUFqRCxFQUFBLGNBQ0FlLEVBQUE5ZCxPQUFBK0YsR0FDQWthLEVBQUEsa0JBQUFYLEdBQ0FZLEVBQUF2YSxFQUFBdWEsUUFFQUMsR0FBQUQsTUFBQW5hLEtBQUFtYSxFQUFBbmEsR0FBQXFhLFVBR0FDLEVBQUEvQixHQUFBRyxFQUFBO0FBQ0EsTUFFRyxJQUZITyxFQUFBaFgsS0FBc0IsS0FDdEI1RCxJQUFBLFdBQW9CLE1BQUE0RCxHQUFBL0ksS0FBQSxLQUF1QmlCLE1BQUEsSUFBU2dILE1BQ2pEQSxJQUNGLFNBQUE3QixFQUFBckUsRUFBQXNmLEdBQ0QsR0FBQUMsR0FBQW5CLEVBQUF0QixFQUFBOWMsRUFDQXVmLFVBQUF6QyxHQUFBOWMsR0FDQWdILEVBQUEzQyxFQUFBckUsRUFBQXNmLEdBQ0FDLEdBQUFsYixJQUFBeVksR0FBQTlWLEVBQUE4VixFQUFBOWMsRUFBQXVmLElBQ0N2WSxFQUVEd1ksRUFBQSxTQUFBaEQsR0FDQSxHQUFBaUQsR0FBQVYsRUFBQXZDLEdBQUF3QixFQUFBTSxFQUFBdlosR0FFQSxPQURBMGEsR0FBQXJDLEdBQUFaLEVBQ0FpRCxHQUdBQyxFQUFBVCxHQUFBLGdCQUFBWCxHQUFBcUIsU0FBQSxTQUFBdGIsR0FDQSxzQkFBQUEsSUFDQyxTQUFBQSxHQUNELE1BQUFBLGFBQUFpYSxJQUdBc0IsRUFBQSxTQUFBdmIsRUFBQXJFLEVBQUFzZixHQUtBLE1BSkFqYixLQUFBeVksR0FBQThDLEVBQUFaLEVBQUFoZixFQUFBc2YsR0FDQW5ZLEVBQUE5QyxHQUNBckUsRUFBQXFILEVBQUFySCxHQUFBLEdBQ0FtSCxFQUFBbVksR0FDQXZILEVBQUFnSCxFQUFBL2UsSUFDQXNmLEVBQUF4YixZQUlBaVUsRUFBQTFULEVBQUFzYSxJQUFBdGEsRUFBQXNhLEdBQUEzZSxLQUFBcUUsRUFBQXNhLEdBQUEzZSxJQUFBLEdBQ0FzZixFQUFBdEIsRUFBQXNCLEdBQXNCeGIsV0FBQW1ELEVBQUEsVUFKdEI4USxFQUFBMVQsRUFBQXNhLElBQUEzWCxFQUFBM0MsRUFBQXNhLEVBQUExWCxFQUFBLE9BQ0E1QyxFQUFBc2EsR0FBQTNlLElBQUEsR0FJS3FmLEVBQUFoYixFQUFBckUsRUFBQXNmLElBQ0Z0WSxFQUFBM0MsRUFBQXJFLEVBQUFzZixJQUVITyxFQUFBLFNBQUF4YixFQUFBcUIsR0FDQXlCLEVBQUE5QyxFQUtBLEtBSkEsR0FHQXJFLEdBSEFzWSxFQUFBd0YsRUFBQXBZLEVBQUF5VixFQUFBelYsSUFDQTFELEVBQUEsRUFDQXlWLEVBQUFhLEVBQUFyVyxPQUVBd1YsRUFBQXpWLEdBQUE0ZCxFQUFBdmIsRUFBQXJFLEVBQUFzWSxFQUFBdFcsS0FBQTBELEVBQUExRixHQUNBLE9BQUFxRSxJQUVBeWIsRUFBQSxTQUFBemIsRUFBQXFCLEdBQ0EsTUFBQU0sVUFBQU4sRUFBQXNZLEVBQUEzWixHQUFBd2IsRUFBQTdCLEVBQUEzWixHQUFBcUIsSUFFQXFhLEVBQUEsU0FBQS9mLEdBQ0EsR0FBQWdnQixHQUFBbkIsRUFBQXJnQixLQUFBUCxLQUFBK0IsRUFBQXFILEVBQUFySCxHQUFBLEdBQ0EsU0FBQS9CLE9BQUE2ZSxHQUFBL0UsRUFBQWdILEVBQUEvZSxLQUFBK1gsRUFBQWlILEVBQUFoZixRQUNBZ2dCLElBQUFqSSxFQUFBOVosS0FBQStCLEtBQUErWCxFQUFBZ0gsRUFBQS9lLElBQUErWCxFQUFBOVosS0FBQTBnQixJQUFBMWdCLEtBQUEwZ0IsR0FBQTNlLEtBQUFnZ0IsSUFFQUMsRUFBQSxTQUFBNWIsRUFBQXJFLEdBR0EsR0FGQXFFLEVBQUE4VyxFQUFBOVcsR0FDQXJFLEVBQUFxSCxFQUFBckgsR0FBQSxHQUNBcUUsSUFBQXlZLElBQUEvRSxFQUFBZ0gsRUFBQS9lLElBQUErWCxFQUFBaUgsRUFBQWhmLEdBQUEsQ0FDQSxHQUFBc2YsR0FBQWxCLEVBQUEvWixFQUFBckUsRUFFQSxRQURBc2YsSUFBQXZILEVBQUFnSCxFQUFBL2UsSUFBQStYLEVBQUExVCxFQUFBc2EsSUFBQXRhLEVBQUFzYSxHQUFBM2UsS0FBQXNmLEVBQUF4YixZQUFBLEdBQ0F3YixJQUVBWSxFQUFBLFNBQUE3YixHQUtBLElBSkEsR0FHQXJFLEdBSEFxYixFQUFBZ0QsRUFBQWxELEVBQUE5VyxJQUNBMlcsS0FDQWhaLEVBQUEsRUFFQXFaLEVBQUFwWixPQUFBRCxHQUNBK1YsRUFBQWdILEVBQUEvZSxFQUFBcWIsRUFBQXJaLE9BQUFoQyxHQUFBMmUsR0FBQTNlLEdBQUF1ZCxHQUFBdkMsRUFBQTlNLEtBQUFsTyxFQUNHLE9BQUFnYixJQUVIbUYsR0FBQSxTQUFBOWIsR0FNQSxJQUxBLEdBSUFyRSxHQUpBb2dCLEVBQUEvYixJQUFBeVksRUFDQXpCLEVBQUFnRCxFQUFBK0IsRUFBQXBCLEVBQUE3RCxFQUFBOVcsSUFDQTJXLEtBQ0FoWixFQUFBLEVBRUFxWixFQUFBcFosT0FBQUQsSUFDQStWLEVBQUFnSCxFQUFBL2UsRUFBQXFiLEVBQUFyWixPQUFBb2UsSUFBQXJJLEVBQUErRSxFQUFBOWMsSUFBQWdiLEVBQUE5TSxLQUFBNlEsRUFBQS9lLEdBQ0csT0FBQWdiLEdBSUhpRSxLQUNBWCxFQUFBLFdBQ0EsR0FBQXJnQixlQUFBcWdCLEdBQUEsS0FBQTFlLFdBQUEsK0JBQ0EsSUFBQTRjLEdBQUFSLEVBQUE1VixVQUFBbkUsT0FBQSxFQUFBbUUsVUFBQSxHQUFBSixRQUNBcWEsRUFBQSxTQUFBbmhCLEdBQ0FqQixPQUFBNmUsR0FBQXVELEVBQUE3aEIsS0FBQXdnQixFQUFBOWYsR0FDQTZZLEVBQUE5WixLQUFBMGdCLElBQUE1RyxFQUFBOVosS0FBQTBnQixHQUFBbkMsS0FBQXZlLEtBQUEwZ0IsR0FBQW5DLElBQUEsR0FDQTZDLEVBQUFwaEIsS0FBQXVlLEVBQUF2VixFQUFBLEVBQUEvSCxJQUdBLE9BREFvZSxJQUFBNkIsR0FBQUUsRUFBQXZDLEVBQUFOLEdBQThEelksY0FBQSxFQUFBdWMsSUFBQUQsSUFDOURiLEVBQUFoRCxJQUVBMUUsRUFBQXdHLEVBQUF2WixHQUFBLHNCQUNBLE1BQUE5RyxNQUFBbWYsS0FHQWMsRUFBQXhaLEVBQUF1YixFQUNBOUIsRUFBQXpaLEVBQUFrYixFQUNBemhCLEVBQUEsSUFBQXVHLEVBQUF1WixFQUFBdlosRUFBQXdiLEVBQ0EvaEIsRUFBQSxJQUFBdUcsRUFBQXFiLEVBQ0E1aEIsRUFBQSxJQUFBdUcsRUFBQXliLEdBRUE3QyxJQUFBbmYsRUFBQSxLQUNBMlosRUFBQWdGLEVBQUEsdUJBQUFpRCxHQUFBLEdBR0FwQyxFQUFBalosRUFBQSxTQUFBTyxHQUNBLE1BQUF1YSxHQUFBOUIsRUFBQXpZLE1BSUFWLElBQUFnQixFQUFBaEIsRUFBQXVCLEVBQUF2QixFQUFBRSxHQUFBd2EsR0FBMER2QyxPQUFBNEIsR0FFMUQsUUFBQWlDLElBQUEsaUhBR0E5RSxNQUFBLEtBQUF6WixHQUFBLEVBQW9CdWUsR0FBQXRlLE9BQUFELElBQW9CMGIsRUFBQTZDLEdBQUF2ZSxNQUV4QyxRQUFBdWUsSUFBQXJGLEVBQUF3QyxFQUFBeEIsT0FBQWxhLEdBQUEsRUFBMEN1ZSxHQUFBdGUsT0FBQUQsSUFBb0I0YixFQUFBMkMsR0FBQXZlLE1BRTlEdUMsS0FBQUMsRUFBQUQsRUFBQUUsR0FBQXdhLEVBQUEsVUFFQXVCLElBQUEsU0FBQXhnQixHQUNBLE1BQUErWCxHQUFBK0csRUFBQTllLEdBQUEsSUFDQThlLEVBQUE5ZSxHQUNBOGUsRUFBQTllLEdBQUFzZSxFQUFBdGUsSUFHQXlnQixPQUFBLFNBQUF6Z0IsR0FDQSxHQUFBMGYsRUFBQTFmLEdBQUEsTUFBQTZkLEdBQUFpQixFQUFBOWUsRUFDQSxNQUFBSixXQUFBSSxFQUFBLHNCQUVBMGdCLFVBQUEsV0FBd0J2QixHQUFBLEdBQ3hCd0IsVUFBQSxXQUF3QnhCLEdBQUEsS0FHeEI1YSxJQUFBQyxFQUFBRCxFQUFBRSxHQUFBd2EsRUFBQSxVQUVBakYsT0FBQThGLEVBRUE3Z0IsZUFBQTJnQixFQUVBbGMsaUJBQUFtYyxFQUVBZSx5QkFBQVgsRUFFQVksb0JBQUFYLEVBRUFZLHNCQUFBWCxLQUlBNUIsR0FBQWhhLElBQUFDLEVBQUFELEVBQUFFLElBQUF3YSxHQUFBeEIsRUFBQSxXQUNBLEdBQUFqWixHQUFBOFosR0FJQSxpQkFBQUcsR0FBQWphLEtBQXlELE1BQXpEaWEsR0FBb0R2WSxFQUFBMUIsS0FBYSxNQUFBaWEsRUFBQXpmLE9BQUF3RixPQUNoRSxRQUNEa2EsVUFBQSxTQUFBcmEsR0FDQSxHQUFBMkIsU0FBQTNCLElBQUFxYixFQUFBcmIsR0FBQSxDQUlBLElBSEEsR0FFQTBjLEdBQUFDLEVBRkFDLEdBQUE1YyxHQUNBckMsRUFBQSxFQUVBb0UsVUFBQW5FLE9BQUFELEdBQUFpZixFQUFBL1MsS0FBQTlILFVBQUFwRSxLQVFBLE9BUEErZSxHQUFBRSxFQUFBLEdBQ0Esa0JBQUFGLEtBQUFDLEVBQUFELElBQ0FDLEdBQUFqRCxFQUFBZ0QsT0FBQSxTQUFBL2dCLEVBQUFkLEdBRUEsR0FEQThoQixJQUFBOWhCLEVBQUE4aEIsRUFBQXhpQixLQUFBUCxLQUFBK0IsRUFBQWQsS0FDQXdnQixFQUFBeGdCLEdBQUEsTUFBQUEsS0FFQStoQixFQUFBLEdBQUFGLEVBQ0F0QyxFQUFBcFksTUFBQWtZLEVBQUEwQyxPQUtBM0MsRUFBQXZaLEdBQUE2WixJQUFBemdCLEVBQUEsSUFBQW1nQixFQUFBdlosR0FBQTZaLEVBQUFOLEVBQUF2WixHQUFBK0MsU0FFQW9RLEVBQUFvRyxFQUFBLFVBRUFwRyxFQUFBL1YsS0FBQSxXQUVBK1YsRUFBQXZULEVBQUE2WixLQUFBLFkvRGt2Rk0sU0FBUzFnQixFQUFRRCxFQUFTTSxHZ0U1OUZoQyxHQUFBb2YsR0FBQXBmLEVBQUEsWUFDQXNKLEVBQUF0SixFQUFBLElBQ0E0WixFQUFBNVosRUFBQSxJQUNBK2lCLEVBQUEvaUIsRUFBQSxJQUFBdUcsRUFDQXBHLEVBQUEsRUFDQTZpQixFQUFBbmlCLE9BQUFtaUIsY0FBQSxXQUNBLFVBRUFDLEdBQUFqakIsRUFBQSxlQUNBLE1BQUFnakIsR0FBQW5pQixPQUFBcWlCLHlCQUVBQyxFQUFBLFNBQUFqZCxHQUNBNmMsRUFBQTdjLEVBQUFrWixHQUFxQnJlLE9BQ3JCOEMsRUFBQSxPQUFBMUQsRUFDQWlqQixTQUdBQyxFQUFBLFNBQUFuZCxFQUFBMlYsR0FFQSxJQUFBdlMsRUFBQXBELEdBQUEsc0JBQUFBLE1BQUEsZ0JBQUFBLEdBQUEsU0FBQUEsQ0FDQSxLQUFBMFQsRUFBQTFULEVBQUFrWixHQUFBLENBRUEsSUFBQTRELEVBQUE5YyxHQUFBLFNBRUEsS0FBQTJWLEVBQUEsU0FFQXNILEdBQUFqZCxHQUVHLE1BQUFBLEdBQUFrWixHQUFBdmIsR0FFSHlmLEVBQUEsU0FBQXBkLEVBQUEyVixHQUNBLElBQUFqQyxFQUFBMVQsRUFBQWtaLEdBQUEsQ0FFQSxJQUFBNEQsRUFBQTljLEdBQUEsUUFFQSxLQUFBMlYsRUFBQSxRQUVBc0gsR0FBQWpkLEdBRUcsTUFBQUEsR0FBQWtaLEdBQUFnRSxHQUdIRyxFQUFBLFNBQUFyZCxHQUVBLE1BREErYyxJQUFBTyxFQUFBQyxNQUFBVCxFQUFBOWMsS0FBQTBULEVBQUExVCxFQUFBa1osSUFBQStELEVBQUFqZCxHQUNBQSxHQUVBc2QsRUFBQTdqQixFQUFBRCxTQUNBMmYsSUFBQUQsRUFDQXFFLE1BQUEsRUFDQUosVUFDQUMsVUFDQUMsYWhFbStGTSxTQUFTNWpCLEVBQVFELEVBQVNNLEdpRXRoR2hDLEdBQUF3RyxHQUFBeEcsRUFBQSxHQUNBeUcsRUFBQXpHLEVBQUEsR0FDQTBaLEVBQUExWixFQUFBLElBQ0F3ZixFQUFBeGYsRUFBQSxJQUNBYyxFQUFBZCxFQUFBLElBQUF1RyxDQUNBNUcsR0FBQUQsUUFBQSxTQUFBb0gsR0FDQSxHQUFBcVosR0FBQTFaLEVBQUE4WCxTQUFBOVgsRUFBQThYLE9BQUE3RSxLQUEwRGxULEVBQUErWCxXQUMxRCxNQUFBelgsRUFBQXFMLE9BQUEsSUFBQXJMLElBQUFxWixJQUFBcmYsRUFBQXFmLEVBQUFyWixHQUFnRi9GLE1BQUF5ZSxFQUFBalosRUFBQU8sT2pFNmhHMUUsU0FBU25ILEVBQVFELEVBQVNNLEdrRXBpR2hDLEdBQUE4YyxHQUFBOWMsRUFBQSxJQUNBZ2QsRUFBQWhkLEVBQUEsR0FDQUwsR0FBQUQsUUFBQSxTQUFBcUosRUFBQWpILEdBTUEsSUFMQSxHQUlBRCxHQUpBc0gsRUFBQTZULEVBQUFqVSxHQUNBb1IsRUFBQTJDLEVBQUEzVCxHQUNBckYsRUFBQXFXLEVBQUFyVyxPQUNBNkcsRUFBQSxFQUVBN0csRUFBQTZHLEdBQUEsR0FBQXhCLEVBQUF0SCxFQUFBc1ksRUFBQXhQLFFBQUE3SSxFQUFBLE1BQUFELEtsRTJpR00sU0FBU2xDLEVBQVFELEVBQVNNLEdtRWxqR2hDLEdBQUE4YyxHQUFBOWMsRUFBQSxJQUNBMGpCLEVBQUExakIsRUFBQSxJQUNBMmpCLEVBQUEzakIsRUFBQSxHQUNBTCxHQUFBRCxRQUFBLFNBQUF3RyxHQUNBLEdBQUEyVyxHQUFBQyxFQUFBNVcsR0FDQTBkLEVBQUFGLEVBQUFuZCxDQUNBLElBQUFxZCxFQUtBLElBSkEsR0FHQS9oQixHQUhBdWdCLEVBQUF3QixFQUFBMWQsR0FDQXdhLEVBQUFpRCxFQUFBcGQsRUFDQTFDLEVBQUEsRUFFQXVlLEVBQUF0ZSxPQUFBRCxHQUFBNmMsRUFBQXJnQixLQUFBNkYsRUFBQXJFLEVBQUF1Z0IsRUFBQXZlLE9BQUFnWixFQUFBOU0sS0FBQWxPLEVBQ0csT0FBQWdiLEtuRTBqR0csU0FBU2xkLEVBQVFELEdvRXZrR3ZCQSxFQUFBNkcsRUFBQTFGLE9BQUE4aEIsdUJwRTZrR00sU0FBU2hqQixFQUFRRCxHcUU3a0d2QkEsRUFBQTZHLEtBQWM4VyxzQnJFbWxHUixTQUFTMWQsRUFBUUQsRUFBU00sR3NFbGxHaEMsR0FBQW9kLEdBQUFwZCxFQUFBLEdBQ0FMLEdBQUFELFFBQUE4SyxNQUFBb1YsU0FBQSxTQUFBaUUsR0FDQSxlQUFBekcsRUFBQXlHLEt0RTBsR00sU0FBU2xrQixFQUFRRCxFQUFTTSxHdUU1bEdoQyxHQUFBZ2QsR0FBQWhkLEVBQUEsSUFDQWtnQixFQUFBbGdCLEVBQUEsSUFBQXVHLEVBQ0FtRCxLQUFrQkEsU0FFbEJvYSxFQUFBLGdCQUFBNWUsaUJBQUFyRSxPQUFBNmhCLG9CQUNBN2hCLE9BQUE2aEIsb0JBQUF4ZCxXQUVBNmUsRUFBQSxTQUFBN2QsR0FDQSxJQUNBLE1BQUFnYSxHQUFBaGEsR0FDRyxNQUFBbUQsR0FDSCxNQUFBeWEsR0FBQXZLLFNBSUE1WixHQUFBRCxRQUFBNkcsRUFBQSxTQUFBTCxHQUNBLE1BQUE0ZCxJQUFBLG1CQUFBcGEsRUFBQXJKLEtBQUE2RixHQUFBNmQsRUFBQTdkLEdBQUFnYSxFQUFBbEQsRUFBQTlXLE12RXFtR00sU0FBU3ZHLEVBQVFELEVBQVNNLEd3RXJuR2hDLEdBQUErYyxHQUFBL2MsRUFBQSxJQUNBZ2tCLEVBQUFoa0IsRUFBQSxJQUFBa2UsT0FBQSxxQkFFQXhlLEdBQUE2RyxFQUFBMUYsT0FBQTZoQixxQkFBQSxTQUFBdlosR0FDQSxNQUFBNFQsR0FBQTVULEVBQUE2YSxLeEU2bkdNLFNBQVNya0IsRUFBUUQsRUFBU00sR3lFbG9HaEMsR0FBQTJqQixHQUFBM2pCLEVBQUEsSUFDQThJLEVBQUE5SSxFQUFBLElBQ0FnZCxFQUFBaGQsRUFBQSxJQUNBa0osRUFBQWxKLEVBQUEsSUFDQTRaLEVBQUE1WixFQUFBLElBQ0FpSixFQUFBakosRUFBQSxJQUNBaWdCLEVBQUFwZixPQUFBNGhCLHdCQUVBL2lCLEdBQUE2RyxFQUFBdkcsRUFBQSxJQUFBaWdCLEVBQUEsU0FBQTlXLEVBQUE1QixHQUdBLEdBRkE0QixFQUFBNlQsRUFBQTdULEdBQ0E1QixFQUFBMkIsRUFBQTNCLEdBQUEsR0FDQTBCLEVBQUEsSUFDQSxNQUFBZ1gsR0FBQTlXLEVBQUE1QixHQUNHLE1BQUE4QixJQUNILEdBQUF1USxFQUFBelEsRUFBQTVCLEdBQUEsTUFBQXVCLElBQUE2YSxFQUFBcGQsRUFBQWxHLEtBQUE4SSxFQUFBNUIsR0FBQTRCLEVBQUE1QixNekV5b0dNLFNBQVM1SCxFQUFRRCxLQU1qQixTQUFTQyxFQUFRRCxFQUFTTSxHMEU3cEdoQ0EsRUFBQSxzQjFFbXFHTSxTQUFTTCxFQUFRRCxFQUFTTSxHMkVucUdoQ0EsRUFBQSxtQjNFeXFHTSxTQUFTTCxFQUFRRCxFQUFTTSxHQUUvQixZQWNBLFNBQVNTLEdBQXVCQyxHQUFPLE1BQU9BLElBQU9BLEVBQUlDLFdBQWFELEdBQVFFLFFBQVNGLEdBWnZGRyxPQUFPQyxlQUFlcEIsRUFBUyxjQUM3QnFCLE9BQU8sR0FHVCxJQUFJQyxHQUFtQmhCLEVBQW9CLEdBRXZDaUIsRUFBbUJSLEVBQXVCTyxHQUUxQ0UsRUFBZ0JsQixFQUFvQixHQUVwQ21CLEVBQWdCVixFQUF1QlMsRzRFdnJHdEMraUIsRTVFMnJHTSxXQUNULFFBQVNBLE1BQ1AsRUFBSWhqQixFQUFpQkwsU0FBU2QsS0FBTW1rQixHQWtCdEMsT0FmQSxFQUFJOWlCLEVBQWNQLFNBQVNxakIsRUFBTSxPQUMvQnBpQixJQUFLLGVBQ0xkLE1BQU8sUzRFanNHVTJQLEVBQU13VCxHQUN4QixHQUFJQyxHQUFTaGhCLFNBQVNDLGNBQWMsU0FJcEMsT0FIQStnQixHQUFPbmhCLE1BQVEwTixFQUNmeVQsRUFBT2xoQixPQUFTeU4sRUFDaEJ5VCxFQUFPOWdCLFdBQVcsTUFBTUMsVUFBVTRnQixFQUFPLEVBQUcsRUFBR3hULEVBQU1BLEdBQzlDeVQsSzVFb3NHTnRpQixJQUFLLFlBQ0xkLE1BQU8sUzRFbHNHTzRMLEVBQUd5WCxFQUFHcGMsRUFBR2pILEdBQ3hCLE1BQVEsTUFBTzRMLEVBQUksTUFBT3lYLEVBQUksTUFBT3BjLEdBQUtqSCxFQUFTLElBQU0sTTVFcXNHbkRrakIsSUFHVHZrQixHQUFRa0IsUTRFcHNHTXFqQiIsImZpbGUiOiJxYXJ0Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInFhcnRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicWFydFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJxYXJ0XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInFhcnRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIuLi9kaXN0L1wiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblx0XG5cdHZhciBfcXJjb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cdFxuXHR2YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblx0XG5cdHZhciBfdXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgUUFydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFFBcnQob3B0aW9ucykge1xuXHQgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFFBcnQpO1xuXHRcblx0ICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1FBcnQgcmVxdWlyZWQgYG9wdGlvbnNgLicpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1FBcnQgcmVxdWlyZWQgYHZhbHVlYCBvcHRpb24uJyk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbWFnZVBhdGggPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1FBcnQgcmVxdWlyZWQgYGltYWdlUGF0aGAgb3B0aW9uLicpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICd1bmRlZmluZWQnID8gUUFydC5ERUZBVUxUUy5maWx0ZXIgOiBvcHRpb25zLmZpbHRlcjtcblx0ICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblx0ICAgICAgICB0aGlzLmltYWdlUGF0aCA9IG9wdGlvbnMuaW1hZ2VQYXRoO1xuXHQgICAgfVxuXHRcblx0ICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFFBcnQsIFt7XG5cdCAgICAgICAga2V5OiAnbWFrZScsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2UoZWwpIHtcblx0ICAgICAgICAgICAgdmFyIGltYWdlU2l6ZSA9IDE5NTtcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAxMjtcblx0ICAgICAgICAgICAgdmFyIGxldmVsID0gMTA7XG5cdFxuXHQgICAgICAgICAgICB2YXIgcXIgPSAoMCwgX3FyY29kZS5RUkNvZGUpKGxldmVsLCAnSCcpO1xuXHQgICAgICAgICAgICBxci5hZGREYXRhKHRoaXMudmFsdWUpO1xuXHQgICAgICAgICAgICBxci5tYWtlKCk7XG5cdCAgICAgICAgICAgIHZhciBxckltYWdlID0gcXIuY3JlYXRlSW1nT2JqZWN0KDMpO1xuXHRcblx0ICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICAgICAgICBxckltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb3ZlckltYWdlID0gbmV3IEltYWdlKCk7XG5cdCAgICAgICAgICAgICAgICBjb3ZlckltYWdlLnNyYyA9IHNlbGYuaW1hZ2VQYXRoO1xuXHRcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHRDYW52YXMgPSBfdXRpbDIuZGVmYXVsdC5jcmVhdGVDYW52YXMoaW1hZ2VTaXplLCBxckltYWdlKTtcblx0ICAgICAgICAgICAgICAgIHZhciBxckNhbnZhcyA9IF91dGlsMi5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhpbWFnZVNpemUsIHFySW1hZ2UpO1xuXHRcblx0ICAgICAgICAgICAgICAgIGNvdmVySW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlckltYWdlLndpZHRoIDwgY292ZXJJbWFnZS5oZWlnaHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJJbWFnZS5oZWlnaHQgPSAoaW1hZ2VTaXplIC0gcGFkZGluZyAqIDIpICogKDEuMCAqIGNvdmVySW1hZ2UuaGVpZ2h0IC8gY292ZXJJbWFnZS53aWR0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVySW1hZ2Uud2lkdGggPSBpbWFnZVNpemUgLSBwYWRkaW5nICogMjtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3ZlckltYWdlLndpZHRoID0gKGltYWdlU2l6ZSAtIHBhZGRpbmcgKiAyKSAqICgxLjAgKiBjb3ZlckltYWdlLndpZHRoIC8gY292ZXJJbWFnZS5oZWlnaHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3ZlckltYWdlLmhlaWdodCA9IGltYWdlU2l6ZSAtIHBhZGRpbmcgKiAyO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvdmVyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgY292ZXJDYW52YXMud2lkdGggPSBpbWFnZVNpemU7XG5cdCAgICAgICAgICAgICAgICAgICAgY292ZXJDYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvdmVyQ2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNvdmVySW1hZ2UsIHBhZGRpbmcsIHBhZGRpbmcsIGltYWdlU2l6ZSAtIHBhZGRpbmcgKiAyLCBpbWFnZVNpemUgLSBwYWRkaW5nICogMik7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb3ZlckltYWdlRGF0YSA9IGNvdmVyQ2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlU2l6ZSwgaW1hZ2VTaXplKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY292ZXJJbWFnZUJpbmFyeSA9IGNvdmVySW1hZ2VEYXRhLmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdEltYWdlRGF0YSA9IHJlc3VsdENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZVNpemUsIGltYWdlU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdEltYWdlQmluYXJ5ID0gcmVzdWx0SW1hZ2VEYXRhLmRhdGE7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJJbWFnZUJpbmFyeS5sZW5ndGg7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoaSAvIDQpICUgaW1hZ2VTaXplO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoTWF0aC5mbG9vcihpIC8gNCkgLyBpbWFnZVNpemUpO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPCBwYWRkaW5nIHx8IHkgPCBwYWRkaW5nIHx8IHggPj0gaW1hZ2VTaXplIC0gcGFkZGluZyB8fCB5ID49IGltYWdlU2l6ZSAtIHBhZGRpbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2kgKyAzXSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCAlIDMgPT0gMSAmJiB5ICUgMyA9PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IDM2ICYmICh5IDwgMzYgfHwgeSA+PSBpbWFnZVNpemUgLSAzNikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID49IGltYWdlU2l6ZSAtIDM2ICYmIHkgPCAzNikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmZpbHRlciA9PSAndGhyZXNob2xkJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IF91dGlsMi5kZWZhdWx0LnRocmVzaG9sZChjb3ZlckltYWdlQmluYXJ5W2ldLCBjb3ZlckltYWdlQmluYXJ5W2kgKyAxXSwgY292ZXJJbWFnZUJpbmFyeVtpICsgMl0sIDEyNyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJbWFnZUJpbmFyeVtpXSA9IGZhY3Rvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2kgKyAxXSA9IGZhY3Rvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2kgKyAyXSA9IGZhY3Rvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmZpbHRlciA9PSAnY29sb3InKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJbWFnZUJpbmFyeVtpXSA9IGNvdmVySW1hZ2VCaW5hcnlbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJbWFnZUJpbmFyeVtpICsgMV0gPSBjb3ZlckltYWdlQmluYXJ5W2kgKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2kgKyAyXSA9IGNvdmVySW1hZ2VCaW5hcnlbaSArIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2kgKyAzXSA9IGNvdmVySW1hZ2VCaW5hcnlbaSArIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FudmFzLmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKHJlc3VsdEltYWdlRGF0YSwgMCwgMCk7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuUG9zdGlvbiA9IF9xcmNvZGUuUVJVdGlsLmdldFBhdHRlcm5Qb3NpdGlvbihsZXZlbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuUG9zdGlvbi5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5Qb3N0aW9uLmxlbmd0aDsgaiArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHBhdHRlcm5Qb3N0aW9uW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBwYXR0ZXJuUG9zdGlvbltqXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHggPT0gNiAmJiB5ID09IDUwIHx8IHkgPT0gNiAmJiB4ID09IDUwIHx8IHggPT0gNiAmJiB5ID09IDYpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RYID0gMyAqICh4IC0gMikgKyAxMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFkgPSAzICogKHkgLSAyKSArIDEyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0V2lkdGggPSAzICogKHggKyAzKSArIDEyIC0gcmVjdFg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSAzICogKHkgKyAzKSArIDEyIC0gcmVjdFk7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0RGF0YSA9IHFyQ2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKHJlY3RYLCByZWN0WSwgcmVjdFdpZHRoLCByZWN0SGVpZ2h0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEocmVjdERhdGEsIHJlY3RYLCByZWN0WSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuXHQgICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHJlc3VsdENhbnZhcyk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH1dLCBbe1xuXHQgICAgICAgIGtleTogJ0RFRkFVTFRTJyxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcblx0ICAgICAgICAgICAgICAgIGZpbHRlcjogJ3RocmVzaG9sZCdcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9XSk7XG5cdCAgICByZXR1cm4gUUFydDtcblx0fSgpO1xuXHRcblx0d2luZG93LlFBcnQgPSBRQXJ0O1xuXHRleHBvcnRzLmRlZmF1bHQgPSB3aW5kb3cuUUFydDtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcblx0ICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX2RlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcblx0ICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuXHQgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdCAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cdCAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcblx0ICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cdCAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcblx0ICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcblx0ICB9O1xuXHR9KCk7XG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oNCksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciAkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5PYmplY3Q7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG5cdCAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdC8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG5cdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIV9fd2VicGFja19yZXF1aXJlX18oMTYpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mfSk7XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2xvYmFsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KVxuXHQgICwgY29yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxuXHQgICwgY3R4ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KVxuXHQgICwgaGlkZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSlcblx0ICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXHRcblx0dmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuXHQgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG5cdCAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkdcblx0ICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuXHQgICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG5cdCAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcblx0ICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuXHQgICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuXHQgICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cblx0ICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuXHQgICAgLCBrZXksIG93biwgb3V0O1xuXHQgIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuXHQgIGZvcihrZXkgaW4gc291cmNlKXtcblx0ICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuXHQgICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcblx0ICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcblx0ICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG5cdCAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuXHQgICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG5cdCAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuXHQgICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblx0ICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG5cdCAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuXHQgICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcblx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcblx0ICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG5cdCAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG5cdCAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuXHQgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcblx0ICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG5cdCAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcblx0ICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH07XG5cdCAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcblx0ICAgICAgcmV0dXJuIEY7XG5cdCAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcblx0ICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcblx0ICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuXHQgICAgaWYoSVNfUFJPVE8pe1xuXHQgICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG5cdCAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG5cdCAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0Ly8gdHlwZSBiaXRtYXBcblx0JGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcblx0JGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcblx0JGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcblx0JGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuXHQkZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcblx0JGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG5cdCRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuXHQkZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5cdG1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5cdHZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0aWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5cdGlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cdHZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcblx0ICBhRnVuY3Rpb24oZm4pO1xuXHQgIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG5cdCAgc3dpdGNoKGxlbmd0aCl7XG5cdCAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGRQICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKVxuXHQgICwgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcblx0ICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuXHR9IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcblx0ICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuXHQgIHJldHVybiBvYmplY3Q7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGFuT2JqZWN0ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcblx0ICAsIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSlcblx0ICAsIHRvUHJpbWl0aXZlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcblx0ICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcblx0ZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNikgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcblx0ICBhbk9iamVjdChPKTtcblx0ICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG5cdCAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG5cdCAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcblx0ICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcblx0ICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cdCAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG5cdCAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuXHQgIHJldHVybiBPO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygxNykoZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19yZXF1aXJlX18oMTgpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcblx0fSk7XG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxuXHRtb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KShmdW5jdGlvbigpe1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG5cdH0pO1xuXG4vKioqLyB9LFxuLyogMTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiAhIWV4ZWMoKTtcblx0ICB9IGNhdGNoKGUpe1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXG5cdCAgLCBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNykuZG9jdW1lbnRcblx0ICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcblx0ICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxuXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0Ly8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcblx0Ly8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG5cdCAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG5cdCAgdmFyIGZuLCB2YWw7XG5cdCAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuXHQgIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcblx0ICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuXHQgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuXHQgIHJldHVybiB7XG5cdCAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG5cdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG5cdCAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG5cdCAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDIxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblx0XG5cdHZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdHZhciBxcmNvZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHFyY29kZSA9IGZ1bmN0aW9uIHFyY29kZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuXHRcblx0ICAgIHZhciBQQUQwID0gMHhFQztcblx0ICAgIHZhciBQQUQxID0gMHgxMTtcblx0XG5cdCAgICB2YXIgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuXHQgICAgdmFyIF9lcnJvckNvcnJlY3Rpb25MZXZlbCA9IFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWxbZXJyb3JDb3JyZWN0aW9uTGV2ZWxdO1xuXHQgICAgdmFyIF9tb2R1bGVzID0gbnVsbDtcblx0ICAgIHZhciBfbW9kdWxlQ291bnQgPSAwO1xuXHQgICAgdmFyIF9kYXRhQ2FjaGUgPSBudWxsO1xuXHQgICAgdmFyIF9kYXRhTGlzdCA9IG5ldyBBcnJheSgpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIHZhciBtYWtlSW1wbCA9IGZ1bmN0aW9uIG1ha2VJbXBsKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHQgICAgICBfbW9kdWxlQ291bnQgPSBfdHlwZU51bWJlciAqIDQgKyAxNztcblx0ICAgICAgX21vZHVsZXMgPSBmdW5jdGlvbiAobW9kdWxlQ291bnQpIHtcblx0ICAgICAgICB2YXIgbW9kdWxlcyA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG5cdCAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG5cdCAgICAgICAgICBtb2R1bGVzW3Jvd10gPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuXHQgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG5cdCAgICAgICAgICAgIG1vZHVsZXNbcm93XVtjb2xdID0gbnVsbDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG1vZHVsZXM7XG5cdCAgICAgIH0oX21vZHVsZUNvdW50KTtcblx0XG5cdCAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgMCk7XG5cdCAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oX21vZHVsZUNvdW50IC0gNywgMCk7XG5cdCAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgX21vZHVsZUNvdW50IC0gNyk7XG5cdCAgICAgIHNldHVwUG9zaXRpb25BZGp1c3RQYXR0ZXJuKCk7XG5cdCAgICAgIHNldHVwVGltaW5nUGF0dGVybigpO1xuXHQgICAgICBzZXR1cFR5cGVJbmZvKHRlc3QsIG1hc2tQYXR0ZXJuKTtcblx0XG5cdCAgICAgIGlmIChfdHlwZU51bWJlciA+PSA3KSB7XG5cdCAgICAgICAgc2V0dXBUeXBlTnVtYmVyKHRlc3QpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoX2RhdGFDYWNoZSA9PSBudWxsKSB7XG5cdCAgICAgICAgX2RhdGFDYWNoZSA9IGNyZWF0ZURhdGEoX3R5cGVOdW1iZXIsIF9lcnJvckNvcnJlY3Rpb25MZXZlbCwgX2RhdGFMaXN0KTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgbWFwRGF0YShfZGF0YUNhY2hlLCBtYXNrUGF0dGVybik7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuID0gZnVuY3Rpb24gc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybihyb3csIGNvbCkge1xuXHRcblx0ICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDc7IHIgKz0gMSkge1xuXHRcblx0ICAgICAgICBpZiAocm93ICsgciA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gcm93ICsgcikgY29udGludWU7XG5cdFxuXHQgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjICs9IDEpIHtcblx0XG5cdCAgICAgICAgICBpZiAoY29sICsgYyA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gY29sICsgYykgY29udGludWU7XG5cdFxuXHQgICAgICAgICAgaWYgKDAgPD0gciAmJiByIDw9IDYgJiYgKGMgPT0gMCB8fCBjID09IDYpIHx8IDAgPD0gYyAmJiBjIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIHx8IDIgPD0gciAmJiByIDw9IDQgJiYgMiA8PSBjICYmIGMgPD0gNCkge1xuXHQgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IGZhbHNlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgZ2V0QmVzdE1hc2tQYXR0ZXJuID0gZnVuY3Rpb24gZ2V0QmVzdE1hc2tQYXR0ZXJuKCkge1xuXHRcblx0ICAgICAgdmFyIG1pbkxvc3RQb2ludCA9IDA7XG5cdCAgICAgIHZhciBwYXR0ZXJuID0gMDtcblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG5cdFxuXHQgICAgICAgIG1ha2VJbXBsKHRydWUsIGkpO1xuXHRcblx0ICAgICAgICB2YXIgbG9zdFBvaW50ID0gUVJVdGlsLmdldExvc3RQb2ludChfdGhpcyk7XG5cdFxuXHQgICAgICAgIGlmIChpID09IDAgfHwgbWluTG9zdFBvaW50ID4gbG9zdFBvaW50KSB7XG5cdCAgICAgICAgICBtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG5cdCAgICAgICAgICBwYXR0ZXJuID0gaTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBwYXR0ZXJuO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgc2V0dXBUaW1pbmdQYXR0ZXJuID0gZnVuY3Rpb24gc2V0dXBUaW1pbmdQYXR0ZXJuKCkge1xuXHRcblx0ICAgICAgZm9yICh2YXIgciA9IDg7IHIgPCBfbW9kdWxlQ291bnQgLSA4OyByICs9IDEpIHtcblx0ICAgICAgICBpZiAoX21vZHVsZXNbcl1bNl0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9tb2R1bGVzW3JdWzZdID0gciAlIDIgPT0gMDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgZm9yICh2YXIgYyA9IDg7IGMgPCBfbW9kdWxlQ291bnQgLSA4OyBjICs9IDEpIHtcblx0ICAgICAgICBpZiAoX21vZHVsZXNbNl1bY10gIT0gbnVsbCkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9tb2R1bGVzWzZdW2NdID0gYyAlIDIgPT0gMDtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4gPSBmdW5jdGlvbiBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpIHtcblx0XG5cdCAgICAgIHZhciBwb3MgPSBRUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKF90eXBlTnVtYmVyKTtcblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFxuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zLmxlbmd0aDsgaiArPSAxKSB7XG5cdFxuXHQgICAgICAgICAgdmFyIHJvdyA9IHBvc1tpXTtcblx0ICAgICAgICAgIHZhciBjb2wgPSBwb3Nbal07XG5cdFxuXHQgICAgICAgICAgaWYgKF9tb2R1bGVzW3Jvd11bY29sXSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgIGZvciAodmFyIHIgPSAtMjsgciA8PSAyOyByICs9IDEpIHtcblx0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMjsgYyA8PSAyOyBjICs9IDEpIHtcblx0XG5cdCAgICAgICAgICAgICAgaWYgKHIgPT0gLTIgfHwgciA9PSAyIHx8IGMgPT0gLTIgfHwgYyA9PSAyIHx8IHIgPT0gMCAmJiBjID09IDApIHtcblx0ICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIHNldHVwVHlwZU51bWJlciA9IGZ1bmN0aW9uIHNldHVwVHlwZU51bWJlcih0ZXN0KSB7XG5cdFxuXHQgICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlTnVtYmVyKF90eXBlTnVtYmVyKTtcblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpICYgMSkgPT0gMTtcblx0ICAgICAgICBfbW9kdWxlc1tNYXRoLmZsb29yKGkgLyAzKV1baSAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM10gPSBtb2Q7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpICYgMSkgPT0gMTtcblx0ICAgICAgICBfbW9kdWxlc1tpICUgMyArIF9tb2R1bGVDb3VudCAtIDggLSAzXVtNYXRoLmZsb29yKGkgLyAzKV0gPSBtb2Q7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIHNldHVwVHlwZUluZm8gPSBmdW5jdGlvbiBzZXR1cFR5cGVJbmZvKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHQgICAgICB2YXIgZGF0YSA9IF9lcnJvckNvcnJlY3Rpb25MZXZlbCA8PCAzIHwgbWFza1BhdHRlcm47XG5cdCAgICAgIHZhciBiaXRzID0gUVJVdGlsLmdldEJDSFR5cGVJbmZvKGRhdGEpO1xuXHRcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSArPSAxKSB7XG5cdFxuXHQgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpICYgMSkgPT0gMTtcblx0XG5cdCAgICAgICAgaWYgKGkgPCA2KSB7XG5cdCAgICAgICAgICBfbW9kdWxlc1tpXVs4XSA9IG1vZDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGkgPCA4KSB7XG5cdCAgICAgICAgICBfbW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDE1ICsgaV1bOF0gPSBtb2Q7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpICs9IDEpIHtcblx0XG5cdCAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkgJiAxKSA9PSAxO1xuXHRcblx0ICAgICAgICBpZiAoaSA8IDgpIHtcblx0ICAgICAgICAgIF9tb2R1bGVzWzhdW19tb2R1bGVDb3VudCAtIGkgLSAxXSA9IG1vZDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGkgPCA5KSB7XG5cdCAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkgLSAxICsgMV0gPSBtb2Q7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaSAtIDFdID0gbW9kO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgX21vZHVsZXNbX21vZHVsZUNvdW50IC0gOF1bOF0gPSAhdGVzdDtcblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiBtYXBEYXRhKGRhdGEsIG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHQgICAgICB2YXIgaW5jID0gLTE7XG5cdCAgICAgIHZhciByb3cgPSBfbW9kdWxlQ291bnQgLSAxO1xuXHQgICAgICB2YXIgYml0SW5kZXggPSA3O1xuXHQgICAgICB2YXIgYnl0ZUluZGV4ID0gMDtcblx0ICAgICAgdmFyIG1hc2tGdW5jID0gUVJVdGlsLmdldE1hc2tGdW5jdGlvbihtYXNrUGF0dGVybik7XG5cdFxuXHQgICAgICBmb3IgKHZhciBjb2wgPSBfbW9kdWxlQ291bnQgLSAxOyBjb2wgPiAwOyBjb2wgLT0gMikge1xuXHRcblx0ICAgICAgICBpZiAoY29sID09IDYpIGNvbCAtPSAxO1xuXHRcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHRcblx0ICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYyArPSAxKSB7XG5cdFxuXHQgICAgICAgICAgICBpZiAoX21vZHVsZXNbcm93XVtjb2wgLSBjXSA9PSBudWxsKSB7XG5cdFxuXHQgICAgICAgICAgICAgIHZhciBkYXJrID0gZmFsc2U7XG5cdFxuXHQgICAgICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgZGFyayA9IChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4ICYgMSkgPT0gMTtcblx0ICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgIHZhciBtYXNrID0gbWFza0Z1bmMocm93LCBjb2wgLSBjKTtcblx0XG5cdCAgICAgICAgICAgICAgaWYgKG1hc2spIHtcblx0ICAgICAgICAgICAgICAgIGRhcmsgPSAhZGFyaztcblx0ICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgIF9tb2R1bGVzW3Jvd11bY29sIC0gY10gPSBkYXJrO1xuXHQgICAgICAgICAgICAgIGJpdEluZGV4IC09IDE7XG5cdFxuXHQgICAgICAgICAgICAgIGlmIChiaXRJbmRleCA9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgYnl0ZUluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgICAgICBiaXRJbmRleCA9IDc7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgcm93ICs9IGluYztcblx0XG5cdCAgICAgICAgICBpZiAocm93IDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gcm93KSB7XG5cdCAgICAgICAgICAgIHJvdyAtPSBpbmM7XG5cdCAgICAgICAgICAgIGluYyA9IC1pbmM7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgY3JlYXRlQnl0ZXMgPSBmdW5jdGlvbiBjcmVhdGVCeXRlcyhidWZmZXIsIHJzQmxvY2tzKSB7XG5cdFxuXHQgICAgICB2YXIgb2Zmc2V0ID0gMDtcblx0XG5cdCAgICAgIHZhciBtYXhEY0NvdW50ID0gMDtcblx0ICAgICAgdmFyIG1heEVjQ291bnQgPSAwO1xuXHRcblx0ICAgICAgdmFyIGRjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuXHQgICAgICB2YXIgZWNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG5cdFxuXHQgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG5cdFxuXHQgICAgICAgIHZhciBkY0NvdW50ID0gcnNCbG9ja3Nbcl0uZGF0YUNvdW50O1xuXHQgICAgICAgIHZhciBlY0NvdW50ID0gcnNCbG9ja3Nbcl0udG90YWxDb3VudCAtIGRjQ291bnQ7XG5cdFxuXHQgICAgICAgIG1heERjQ291bnQgPSBNYXRoLm1heChtYXhEY0NvdW50LCBkY0NvdW50KTtcblx0ICAgICAgICBtYXhFY0NvdW50ID0gTWF0aC5tYXgobWF4RWNDb3VudCwgZWNDb3VudCk7XG5cdFxuXHQgICAgICAgIGRjZGF0YVtyXSA9IG5ldyBBcnJheShkY0NvdW50KTtcblx0XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkY2RhdGFbcl0ubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgIGRjZGF0YVtyXVtpXSA9IDB4ZmYgJiBidWZmZXIuZ2V0QnVmZmVyKClbaSArIG9mZnNldF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG9mZnNldCArPSBkY0NvdW50O1xuXHRcblx0ICAgICAgICB2YXIgcnNQb2x5ID0gUVJVdGlsLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwoZWNDb3VudCk7XG5cdCAgICAgICAgdmFyIHJhd1BvbHkgPSBxclBvbHlub21pYWwoZGNkYXRhW3JdLCByc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcblx0XG5cdCAgICAgICAgdmFyIG1vZFBvbHkgPSByYXdQb2x5Lm1vZChyc1BvbHkpO1xuXHQgICAgICAgIGVjZGF0YVtyXSA9IG5ldyBBcnJheShyc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjZGF0YVtyXS5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgICAgdmFyIG1vZEluZGV4ID0gaSArIG1vZFBvbHkuZ2V0TGVuZ3RoKCkgLSBlY2RhdGFbcl0ubGVuZ3RoO1xuXHQgICAgICAgICAgZWNkYXRhW3JdW2ldID0gbW9kSW5kZXggPj0gMCA/IG1vZFBvbHkuZ2V0QXQobW9kSW5kZXgpIDogMDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tpXS50b3RhbENvdW50O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgZGF0YSA9IG5ldyBBcnJheSh0b3RhbENvZGVDb3VudCk7XG5cdCAgICAgIHZhciBpbmRleCA9IDA7XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERjQ291bnQ7IGkgKz0gMSkge1xuXHQgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcblx0ICAgICAgICAgIGlmIChpIDwgZGNkYXRhW3JdLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBkYXRhW2luZGV4XSA9IGRjZGF0YVtyXVtpXTtcblx0ICAgICAgICAgICAgaW5kZXggKz0gMTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RWNDb3VudDsgaSArPSAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuXHQgICAgICAgICAgaWYgKGkgPCBlY2RhdGFbcl0ubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZWNkYXRhW3JdW2ldO1xuXHQgICAgICAgICAgICBpbmRleCArPSAxO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBjcmVhdGVEYXRhID0gZnVuY3Rpb24gY3JlYXRlRGF0YSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgZGF0YUxpc3QpIHtcblx0XG5cdCAgICAgIHZhciByc0Jsb2NrcyA9IFFSUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG5cdFxuXHQgICAgICB2YXIgYnVmZmVyID0gcXJCaXRCdWZmZXIoKTtcblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxpc3QubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2ldO1xuXHQgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRNb2RlKCksIDQpO1xuXHQgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcikpO1xuXHQgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByc0Jsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+IHRvdGFsRGF0YUNvdW50ICogOCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignY29kZSBsZW5ndGggb3ZlcmZsb3cuICgnICsgYnVmZmVyLmdldExlbmd0aEluQml0cygpICsgJz4nICsgdG90YWxEYXRhQ291bnQgKiA4ICsgJyknKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArIDQgPD0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdCAgICAgICAgYnVmZmVyLnB1dCgwLCA0KTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgd2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT0gMCkge1xuXHQgICAgICAgIGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB3aGlsZSAodHJ1ZSkge1xuXHRcblx0ICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJ1ZmZlci5wdXQoUEFEMCwgOCk7XG5cdFxuXHQgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnVmZmVyLnB1dChQQUQxLCA4KTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIGNyZWF0ZUJ5dGVzKGJ1ZmZlciwgcnNCbG9ja3MpO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5hZGREYXRhID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcblx0XG5cdCAgICAgIG1vZGUgPSBtb2RlIHx8ICdCeXRlJztcblx0XG5cdCAgICAgIHZhciBuZXdEYXRhID0gbnVsbDtcblx0XG5cdCAgICAgIHN3aXRjaCAobW9kZSkge1xuXHQgICAgICAgIGNhc2UgJ051bWVyaWMnOlxuXHQgICAgICAgICAgbmV3RGF0YSA9IHFyTnVtYmVyKGRhdGEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAnQWxwaGFudW1lcmljJzpcblx0ICAgICAgICAgIG5ld0RhdGEgPSBxckFscGhhTnVtKGRhdGEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAnQnl0ZSc6XG5cdCAgICAgICAgICBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgJ0thbmppJzpcblx0ICAgICAgICAgIG5ld0RhdGEgPSBxckthbmppKGRhdGEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIHRocm93ICdtb2RlOicgKyBtb2RlO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBfZGF0YUxpc3QucHVzaChuZXdEYXRhKTtcblx0ICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLmlzRGFyayA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuXHQgICAgICBpZiAocm93IDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgX21vZHVsZUNvdW50IDw9IGNvbCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihyb3cgKyAnLCcgKyBjb2wpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBfbW9kdWxlc1tyb3ddW2NvbF07XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLmdldE1vZHVsZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gX21vZHVsZUNvdW50O1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5tYWtlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkpO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5jcmVhdGVUYWJsZVRhZyA9IGZ1bmN0aW9uIChjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cdFxuXHQgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG5cdCAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcgPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG5cdFxuXHQgICAgICB2YXIgcXJIdG1sID0gJyc7XG5cdFxuXHQgICAgICBxckh0bWwgKz0gJzx0YWJsZSBzdHlsZT1cIic7XG5cdCAgICAgIHFySHRtbCArPSAnIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7Jztcblx0ICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsnO1xuXHQgICAgICBxckh0bWwgKz0gJyBwYWRkaW5nOiAwcHg7IG1hcmdpbjogJyArIG1hcmdpbiArICdweDsnO1xuXHQgICAgICBxckh0bWwgKz0gJ1wiPic7XG5cdCAgICAgIHFySHRtbCArPSAnPHRib2R5Pic7XG5cdFxuXHQgICAgICBmb3IgKHZhciByID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuXHRcblx0ICAgICAgICBxckh0bWwgKz0gJzx0cj4nO1xuXHRcblx0ICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IGMgKz0gMSkge1xuXHQgICAgICAgICAgcXJIdG1sICs9ICc8dGQgc3R5bGU9XCInO1xuXHQgICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xuXHQgICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsnO1xuXHQgICAgICAgICAgcXJIdG1sICs9ICcgcGFkZGluZzogMHB4OyBtYXJnaW46IDBweDsnO1xuXHQgICAgICAgICAgcXJIdG1sICs9ICcgd2lkdGg6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuXHQgICAgICAgICAgcXJIdG1sICs9ICcgaGVpZ2h0OiAnICsgY2VsbFNpemUgKyAncHg7Jztcblx0ICAgICAgICAgIHFySHRtbCArPSAnIGJhY2tncm91bmQtY29sb3I6ICc7XG5cdCAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMpID8gJyMwMDAwMDAnIDogJyNmZmZmZmYnO1xuXHQgICAgICAgICAgcXJIdG1sICs9ICc7Jztcblx0ICAgICAgICAgIHFySHRtbCArPSAnXCIvPic7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBxckh0bWwgKz0gJzwvdHI+Jztcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcXJIdG1sICs9ICc8L3Rib2R5Pic7XG5cdCAgICAgIHFySHRtbCArPSAnPC90YWJsZT4nO1xuXHRcblx0ICAgICAgcmV0dXJuIHFySHRtbDtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuY3JlYXRlU3ZnVGFnID0gZnVuY3Rpb24gKGNlbGxTaXplLCBtYXJnaW4pIHtcblx0XG5cdCAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcblx0ICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcblx0ICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuXHQgICAgICB2YXIgYyxcblx0ICAgICAgICAgIG1jLFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIG1yLFxuXHQgICAgICAgICAgcXJTdmcgPSAnJyxcblx0ICAgICAgICAgIHJlY3Q7XG5cdFxuXHQgICAgICByZWN0ID0gJ2wnICsgY2VsbFNpemUgKyAnLDAgMCwnICsgY2VsbFNpemUgKyAnIC0nICsgY2VsbFNpemUgKyAnLDAgMCwtJyArIGNlbGxTaXplICsgJ3ogJztcblx0XG5cdCAgICAgIHFyU3ZnICs9ICc8c3ZnJztcblx0ICAgICAgcXJTdmcgKz0gJyB3aWR0aD1cIicgKyBzaXplICsgJ3B4XCInO1xuXHQgICAgICBxclN2ZyArPSAnIGhlaWdodD1cIicgKyBzaXplICsgJ3B4XCInO1xuXHQgICAgICBxclN2ZyArPSAnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIic7XG5cdCAgICAgIHFyU3ZnICs9ICc+Jztcblx0ICAgICAgcXJTdmcgKz0gJzxwYXRoIGQ9XCInO1xuXHRcblx0ICAgICAgZm9yIChyID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuXHQgICAgICAgIG1yID0gciAqIGNlbGxTaXplICsgbWFyZ2luO1xuXHQgICAgICAgIGZvciAoYyA9IDA7IGMgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjICs9IDEpIHtcblx0ICAgICAgICAgIGlmIChfdGhpcy5pc0RhcmsociwgYykpIHtcblx0ICAgICAgICAgICAgbWMgPSBjICogY2VsbFNpemUgKyBtYXJnaW47XG5cdCAgICAgICAgICAgIHFyU3ZnICs9ICdNJyArIG1jICsgJywnICsgbXIgKyByZWN0O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgcXJTdmcgKz0gJ1wiIHN0cm9rZT1cInRyYW5zcGFyZW50XCIgZmlsbD1cImJsYWNrXCIvPic7XG5cdCAgICAgIHFyU3ZnICs9ICc8L3N2Zz4nO1xuXHRcblx0ICAgICAgcmV0dXJuIHFyU3ZnO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5jcmVhdGVJbWdUYWcgPSBmdW5jdGlvbiAoY2VsbFNpemUsIG1hcmdpbikge1xuXHRcblx0ICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuXHQgICAgICBtYXJnaW4gPSB0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXHRcblx0ICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuXHQgICAgICB2YXIgbWluID0gbWFyZ2luO1xuXHQgICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblx0XG5cdCAgICAgIHJldHVybiBjcmVhdGVJbWdUYWcoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSAmJiB5IDwgbWF4KSB7XG5cdCAgICAgICAgICB2YXIgYyA9IE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpO1xuXHQgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCh5IC0gbWluKSAvIGNlbGxTaXplKTtcblx0ICAgICAgICAgIHJldHVybiBfdGhpcy5pc0RhcmsociwgYykgPyAwIDogMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuY3JlYXRlSW1nT2JqZWN0ID0gZnVuY3Rpb24gKGNlbGxTaXplLCBtYXJnaW4pIHtcblx0XG5cdCAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcblx0ICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcblx0XG5cdCAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcblx0ICAgICAgdmFyIG1pbiA9IG1hcmdpbjtcblx0ICAgICAgdmFyIG1heCA9IHNpemUgLSBtYXJnaW47XG5cdFxuXHQgICAgICByZXR1cm4gY3JlYXRlSW1nT2JqZWN0KHNpemUsIHNpemUsIGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkgJiYgeSA8IG1heCkge1xuXHQgICAgICAgICAgdmFyIGMgPSBNYXRoLmZsb29yKCh4IC0gbWluKSAvIGNlbGxTaXplKTtcblx0ICAgICAgICAgIHZhciByID0gTWF0aC5mbG9vcigoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG5cdCAgICAgICAgICByZXR1cm4gX3RoaXMuaXNEYXJrKHIsIGMpID8gMCA6IDE7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICBxcmNvZGUuc3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uIChzKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgICAgYnl0ZXMucHVzaChjICYgMHhmZik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnl0ZXM7XG5cdCAgfTtcblx0XG5cdCAgcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAodW5pY29kZURhdGEsIG51bUNoYXJzKSB7XG5cdFxuXHQgICAgdmFyIHVuaWNvZGVNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgICAgICB2YXIgYmluID0gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0odW5pY29kZURhdGEpO1xuXHQgICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uIHJlYWQoKSB7XG5cdCAgICAgICAgdmFyIGIgPSBiaW4ucmVhZCgpO1xuXHQgICAgICAgIGlmIChiID09IC0xKSB0aHJvdyBuZXcgRXJyb3IoKTtcblx0ICAgICAgICByZXR1cm4gYjtcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIHZhciBjb3VudCA9IDA7XG5cdCAgICAgIHZhciB1bmljb2RlTWFwID0ge307XG5cdCAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgdmFyIGIwID0gYmluLnJlYWQoKTtcblx0ICAgICAgICBpZiAoYjAgPT0gLTEpIGJyZWFrO1xuXHQgICAgICAgIHZhciBiMSA9IHJlYWQoKTtcblx0ICAgICAgICB2YXIgYjIgPSByZWFkKCk7XG5cdCAgICAgICAgdmFyIGIzID0gcmVhZCgpO1xuXHQgICAgICAgIHZhciBrID0gU3RyaW5nLmZyb21DaGFyQ29kZShiMCA8PCA4IHwgYjEpO1xuXHQgICAgICAgIHZhciB2ID0gYjIgPDwgOCB8IGIzO1xuXHQgICAgICAgIHVuaWNvZGVNYXBba10gPSB2O1xuXHQgICAgICAgIGNvdW50ICs9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGNvdW50ICE9IG51bUNoYXJzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvdW50ICsgJyAhPSAnICsgbnVtQ2hhcnMpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gdW5pY29kZU1hcDtcblx0ICAgIH0oKTtcblx0XG5cdCAgICB2YXIgdW5rbm93bkNoYXIgPSAnPycuY2hhckNvZGVBdCgwKTtcblx0XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKHMpIHtcblx0ICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KCk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgIGlmIChjIDwgMTI4KSB7XG5cdCAgICAgICAgICBieXRlcy5wdXNoKGMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgYiA9IHVuaWNvZGVNYXBbcy5jaGFyQXQoaSldO1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiBiID09ICdudW1iZXInKSB7XG5cdCAgICAgICAgICAgIGlmICgoYiAmIDB4ZmYpID09IGIpIHtcblx0ICAgICAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiA+Pj4gOCk7XG5cdCAgICAgICAgICAgICAgYnl0ZXMucHVzaChiICYgMHhmZik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGJ5dGVzLnB1c2godW5rbm93bkNoYXIpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYnl0ZXM7XG5cdCAgICB9O1xuXHQgIH07XG5cdFxuXHQgIHZhciBRUk1vZGUgPSB7XG5cdCAgICBNT0RFX05VTUJFUjogMSA8PCAwLFxuXHQgICAgTU9ERV9BTFBIQV9OVU06IDEgPDwgMSxcblx0ICAgIE1PREVfOEJJVF9CWVRFOiAxIDw8IDIsXG5cdCAgICBNT0RFX0tBTkpJOiAxIDw8IDNcblx0ICB9O1xuXHRcblx0ICB2YXIgUVJFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHtcblx0ICAgIEw6IDEsXG5cdCAgICBNOiAwLFxuXHQgICAgUTogMyxcblx0ICAgIEg6IDJcblx0ICB9O1xuXHRcblx0ICB2YXIgUVJNYXNrUGF0dGVybiA9IHtcblx0ICAgIFBBVFRFUk4wMDA6IDAsXG5cdCAgICBQQVRURVJOMDAxOiAxLFxuXHQgICAgUEFUVEVSTjAxMDogMixcblx0ICAgIFBBVFRFUk4wMTE6IDMsXG5cdCAgICBQQVRURVJOMTAwOiA0LFxuXHQgICAgUEFUVEVSTjEwMTogNSxcblx0ICAgIFBBVFRFUk4xMTA6IDYsXG5cdCAgICBQQVRURVJOMTExOiA3XG5cdCAgfTtcblx0XG5cdCAgdmFyIFFSVXRpbCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICB2YXIgUEFUVEVSTl9QT1NJVElPTl9UQUJMRSA9IFtbXSwgWzYsIDE4XSwgWzYsIDIyXSwgWzYsIDI2XSwgWzYsIDMwXSwgWzYsIDM0XSwgWzYsIDIyLCAzOF0sIFs2LCAyNCwgNDJdLCBbNiwgMjYsIDQ2XSwgWzYsIDI4LCA1MF0sIFs2LCAzMCwgNTRdLCBbNiwgMzIsIDU4XSwgWzYsIDM0LCA2Ml0sIFs2LCAyNiwgNDYsIDY2XSwgWzYsIDI2LCA0OCwgNzBdLCBbNiwgMjYsIDUwLCA3NF0sIFs2LCAzMCwgNTQsIDc4XSwgWzYsIDMwLCA1NiwgODJdLCBbNiwgMzAsIDU4LCA4Nl0sIFs2LCAzNCwgNjIsIDkwXSwgWzYsIDI4LCA1MCwgNzIsIDk0XSwgWzYsIDI2LCA1MCwgNzQsIDk4XSwgWzYsIDMwLCA1NCwgNzgsIDEwMl0sIFs2LCAyOCwgNTQsIDgwLCAxMDZdLCBbNiwgMzIsIDU4LCA4NCwgMTEwXSwgWzYsIDMwLCA1OCwgODYsIDExNF0sIFs2LCAzNCwgNjIsIDkwLCAxMThdLCBbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0sIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sIFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0sIFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0sIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0Ml0sIFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0sIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSwgWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdLCBbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0sIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSwgWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdLCBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF1dO1xuXHQgICAgdmFyIEcxNSA9IDEgPDwgMTAgfCAxIDw8IDggfCAxIDw8IDUgfCAxIDw8IDQgfCAxIDw8IDIgfCAxIDw8IDEgfCAxIDw8IDA7XG5cdCAgICB2YXIgRzE4ID0gMSA8PCAxMiB8IDEgPDwgMTEgfCAxIDw8IDEwIHwgMSA8PCA5IHwgMSA8PCA4IHwgMSA8PCA1IHwgMSA8PCAyIHwgMSA8PCAwO1xuXHQgICAgdmFyIEcxNV9NQVNLID0gMSA8PCAxNCB8IDEgPDwgMTIgfCAxIDw8IDEwIHwgMSA8PCA0IHwgMSA8PCAxO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIHZhciBnZXRCQ0hEaWdpdCA9IGZ1bmN0aW9uIGdldEJDSERpZ2l0KGRhdGEpIHtcblx0ICAgICAgdmFyIGRpZ2l0ID0gMDtcblx0ICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xuXHQgICAgICAgIGRpZ2l0ICs9IDE7XG5cdCAgICAgICAgZGF0YSA+Pj49IDE7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGRpZ2l0O1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5nZXRCQ0hUeXBlSW5mbyA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgIHZhciBkID0gZGF0YSA8PCAxMDtcblx0ICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KSA+PSAwKSB7XG5cdCAgICAgICAgZCBePSBHMTUgPDwgZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTUpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAoZGF0YSA8PCAxMCB8IGQpIF4gRzE1X01BU0s7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLmdldEJDSFR5cGVOdW1iZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICB2YXIgZCA9IGRhdGEgPDwgMTI7XG5cdCAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCkgPj0gMCkge1xuXHQgICAgICAgIGQgXj0gRzE4IDw8IGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZGF0YSA8PCAxMiB8IGQ7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLmdldFBhdHRlcm5Qb3NpdGlvbiA9IGZ1bmN0aW9uICh0eXBlTnVtYmVyKSB7XG5cdCAgICAgIHJldHVybiBQQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0TWFza0Z1bmN0aW9uID0gZnVuY3Rpb24gKG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHQgICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHQgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAwOlxuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBqKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoaSArIGopICUgMiA9PSAwO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMTpcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xuXHQgICAgICAgICAgICByZXR1cm4gaSAlIDIgPT0gMDtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMTA6XG5cdCAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGogJSAzID09IDA7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDExOlxuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBqKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoaSArIGopICUgMyA9PSAwO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMDpcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xuXHQgICAgICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykpICUgMiA9PSAwO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMTpcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xuXHQgICAgICAgICAgICByZXR1cm4gaSAqIGogJSAyICsgaSAqIGogJSAzID09IDA7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTEwOlxuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBqKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoaSAqIGogJSAyICsgaSAqIGogJSAzKSAlIDIgPT0gMDtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTE6XG5cdCAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChpICogaiAlIDMgKyAoaSArIGopICUgMikgJSAyID09IDA7XG5cdCAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgbWFza1BhdHRlcm46JyArIG1hc2tQYXR0ZXJuKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5nZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsID0gZnVuY3Rpb24gKGVycm9yQ29ycmVjdExlbmd0aCkge1xuXHQgICAgICB2YXIgYSA9IHFyUG9seW5vbWlhbChbMV0sIDApO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9yQ29ycmVjdExlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgYSA9IGEubXVsdGlwbHkocXJQb2x5bm9taWFsKFsxLCBRUk1hdGguZ2V4cChpKV0sIDApKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24gKG1vZGUsIHR5cGUpIHtcblx0XG5cdCAgICAgIGlmICgxIDw9IHR5cGUgJiYgdHlwZSA8IDEwKSB7XG5cdFxuXHQgICAgICAgIHN3aXRjaCAobW9kZSkge1xuXHQgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XG5cdCAgICAgICAgICAgIHJldHVybiAxMDtcblx0ICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxuXHQgICAgICAgICAgICByZXR1cm4gOTtcblx0ICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFOlxuXHQgICAgICAgICAgICByZXR1cm4gODtcblx0ICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkk6XG5cdCAgICAgICAgICAgIHJldHVybiA4O1xuXHQgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDI3KSB7XG5cdFxuXHQgICAgICAgIHN3aXRjaCAobW9kZSkge1xuXHQgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XG5cdCAgICAgICAgICAgIHJldHVybiAxMjtcblx0ICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxuXHQgICAgICAgICAgICByZXR1cm4gMTE7XG5cdCAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcblx0ICAgICAgICAgICAgcmV0dXJuIDE2O1xuXHQgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSTpcblx0ICAgICAgICAgICAgcmV0dXJuIDEwO1xuXHQgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDQxKSB7XG5cdFxuXHQgICAgICAgIHN3aXRjaCAobW9kZSkge1xuXHQgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XG5cdCAgICAgICAgICAgIHJldHVybiAxNDtcblx0ICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxuXHQgICAgICAgICAgICByZXR1cm4gMTM7XG5cdCAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcblx0ICAgICAgICAgICAgcmV0dXJuIDE2O1xuXHQgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSTpcblx0ICAgICAgICAgICAgcmV0dXJuIDEyO1xuXHQgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlOicgKyB0eXBlKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5nZXRMb3N0UG9pbnQgPSBmdW5jdGlvbiAocXJjb2RlKSB7XG5cdFxuXHQgICAgICB2YXIgbW9kdWxlQ291bnQgPSBxcmNvZGUuZ2V0TW9kdWxlQ291bnQoKTtcblx0XG5cdCAgICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuXHRcblx0ICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG5cdFxuXHQgICAgICAgICAgdmFyIHNhbWVDb3VudCA9IDA7XG5cdCAgICAgICAgICB2YXIgZGFyayA9IHFyY29kZS5pc0Rhcmsocm93LCBjb2wpO1xuXHRcblx0ICAgICAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSAxOyByICs9IDEpIHtcblx0XG5cdCAgICAgICAgICAgIGlmIChyb3cgKyByIDwgMCB8fCBtb2R1bGVDb3VudCA8PSByb3cgKyByKSB7XG5cdCAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSAxOyBjICs9IDEpIHtcblx0XG5cdCAgICAgICAgICAgICAgaWYgKGNvbCArIGMgPCAwIHx8IG1vZHVsZUNvdW50IDw9IGNvbCArIGMpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgaWYgKHIgPT0gMCAmJiBjID09IDApIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgaWYgKGRhcmsgPT0gcXJjb2RlLmlzRGFyayhyb3cgKyByLCBjb2wgKyBjKSkge1xuXHQgICAgICAgICAgICAgICAgc2FtZUNvdW50ICs9IDE7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgaWYgKHNhbWVDb3VudCA+IDUpIHtcblx0ICAgICAgICAgICAgbG9zdFBvaW50ICs9IDMgKyBzYW1lQ291bnQgLSA1O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0XG5cdCAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50IC0gMTsgcm93ICs9IDEpIHtcblx0ICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDE7IGNvbCArPSAxKSB7XG5cdCAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXHQgICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpKSBjb3VudCArPSAxO1xuXHQgICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSkgY291bnQgKz0gMTtcblx0ICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMSkpIGNvdW50ICs9IDE7XG5cdCAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wgKyAxKSkgY291bnQgKz0gMTtcblx0ICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IGNvdW50ID09IDQpIHtcblx0ICAgICAgICAgICAgbG9zdFBvaW50ICs9IDM7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcblx0ICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDY7IGNvbCArPSAxKSB7XG5cdCAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkgJiYgIXFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKSAmJiBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMikgJiYgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDMpICYmIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyA0KSAmJiAhcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDUpICYmIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyA2KSkge1xuXHQgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcblx0ICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDY7IHJvdyArPSAxKSB7XG5cdCAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkgJiYgIXFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSAmJiBxcmNvZGUuaXNEYXJrKHJvdyArIDIsIGNvbCkgJiYgcXJjb2RlLmlzRGFyayhyb3cgKyAzLCBjb2wpICYmIHFyY29kZS5pc0Rhcmsocm93ICsgNCwgY29sKSAmJiAhcXJjb2RlLmlzRGFyayhyb3cgKyA1LCBjb2wpICYmIHFyY29kZS5pc0Rhcmsocm93ICsgNiwgY29sKSkge1xuXHQgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgZGFya0NvdW50ID0gMDtcblx0XG5cdCAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuXHQgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuXHQgICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpKSB7XG5cdCAgICAgICAgICAgIGRhcmtDb3VudCArPSAxO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMoMTAwICogZGFya0NvdW50IC8gbW9kdWxlQ291bnQgLyBtb2R1bGVDb3VudCAtIDUwKSAvIDU7XG5cdCAgICAgIGxvc3RQb2ludCArPSByYXRpbyAqIDEwO1xuXHRcblx0ICAgICAgcmV0dXJuIGxvc3RQb2ludDtcblx0ICAgIH07XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH0oKTtcblx0XG5cdCAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICB2YXIgRVhQX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cdCAgICB2YXIgTE9HX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcblx0ICAgICAgRVhQX1RBQkxFW2ldID0gMSA8PCBpO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDg7IGkgPCAyNTY7IGkgKz0gMSkge1xuXHQgICAgICBFWFBfVEFCTEVbaV0gPSBFWFBfVEFCTEVbaSAtIDRdIF4gRVhQX1RBQkxFW2kgLSA1XSBeIEVYUF9UQUJMRVtpIC0gNl0gXiBFWFBfVEFCTEVbaSAtIDhdO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkgKz0gMSkge1xuXHQgICAgICBMT0dfVEFCTEVbRVhQX1RBQkxFW2ldXSA9IGk7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIF90aGlzID0ge307XG5cdFxuXHQgICAgX3RoaXMuZ2xvZyA9IGZ1bmN0aW9uIChuKSB7XG5cdFxuXHQgICAgICBpZiAobiA8IDEpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsb2coJyArIG4gKyAnKScpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gTE9HX1RBQkxFW25dO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5nZXhwID0gZnVuY3Rpb24gKG4pIHtcblx0XG5cdCAgICAgIHdoaWxlIChuIDwgMCkge1xuXHQgICAgICAgIG4gKz0gMjU1O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB3aGlsZSAobiA+PSAyNTYpIHtcblx0ICAgICAgICBuIC09IDI1NTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIEVYUF9UQUJMRVtuXTtcblx0ICAgIH07XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH0oKTtcblx0XG5cdCAgZnVuY3Rpb24gcXJQb2x5bm9taWFsKG51bSwgc2hpZnQpIHtcblx0XG5cdCAgICBpZiAodHlwZW9mIG51bS5sZW5ndGggPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKG51bS5sZW5ndGggKyAnLycgKyBzaGlmdCk7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIF9udW0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBvZmZzZXQgPSAwO1xuXHQgICAgICB3aGlsZSAob2Zmc2V0IDwgbnVtLmxlbmd0aCAmJiBudW1bb2Zmc2V0XSA9PSAwKSB7XG5cdCAgICAgICAgb2Zmc2V0ICs9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIF9udW0gPSBuZXcgQXJyYXkobnVtLmxlbmd0aCAtIG9mZnNldCArIHNoaWZ0KTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoIC0gb2Zmc2V0OyBpICs9IDEpIHtcblx0ICAgICAgICBfbnVtW2ldID0gbnVtW2kgKyBvZmZzZXRdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBfbnVtO1xuXHQgICAgfSgpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIF90aGlzLmdldEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdCAgICAgIHJldHVybiBfbnVtW2luZGV4XTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gX251bS5sZW5ndGg7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLm11bHRpcGx5ID0gZnVuY3Rpb24gKGUpIHtcblx0XG5cdCAgICAgIHZhciBudW0gPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkgKyBlLmdldExlbmd0aCgpIC0gMSk7XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmdldExlbmd0aCgpOyBpICs9IDEpIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGUuZ2V0TGVuZ3RoKCk7IGogKz0gMSkge1xuXHQgICAgICAgICAgbnVtW2kgKyBqXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdChpKSkgKyBRUk1hdGguZ2xvZyhlLmdldEF0KGopKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bSwgMCk7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLm1vZCA9IGZ1bmN0aW9uIChlKSB7XG5cdFxuXHQgICAgICBpZiAoX3RoaXMuZ2V0TGVuZ3RoKCkgLSBlLmdldExlbmd0aCgpIDwgMCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIHJhdGlvID0gUVJNYXRoLmdsb2coX3RoaXMuZ2V0QXQoMCkpIC0gUVJNYXRoLmdsb2coZS5nZXRBdCgwKSk7XG5cdFxuXHQgICAgICB2YXIgbnVtID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG5cdCAgICAgICAgbnVtW2ldID0gX3RoaXMuZ2V0QXQoaSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG5cdCAgICAgICAgbnVtW2ldIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKGUuZ2V0QXQoaSkpICsgcmF0aW8pO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bSwgMCkubW9kKGUpO1xuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdmFyIFFSUlNCbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICB2YXIgUlNfQkxPQ0tfVEFCTEUgPSBbWzEsIDI2LCAxOV0sIFsxLCAyNiwgMTZdLCBbMSwgMjYsIDEzXSwgWzEsIDI2LCA5XSwgWzEsIDQ0LCAzNF0sIFsxLCA0NCwgMjhdLCBbMSwgNDQsIDIyXSwgWzEsIDQ0LCAxNl0sIFsxLCA3MCwgNTVdLCBbMSwgNzAsIDQ0XSwgWzIsIDM1LCAxN10sIFsyLCAzNSwgMTNdLCBbMSwgMTAwLCA4MF0sIFsyLCA1MCwgMzJdLCBbMiwgNTAsIDI0XSwgWzQsIDI1LCA5XSwgWzEsIDEzNCwgMTA4XSwgWzIsIDY3LCA0M10sIFsyLCAzMywgMTUsIDIsIDM0LCAxNl0sIFsyLCAzMywgMTEsIDIsIDM0LCAxMl0sIFsyLCA4NiwgNjhdLCBbNCwgNDMsIDI3XSwgWzQsIDQzLCAxOV0sIFs0LCA0MywgMTVdLCBbMiwgOTgsIDc4XSwgWzQsIDQ5LCAzMV0sIFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sIFs0LCAzOSwgMTMsIDEsIDQwLCAxNF0sIFsyLCAxMjEsIDk3XSwgWzIsIDYwLCAzOCwgMiwgNjEsIDM5XSwgWzQsIDQwLCAxOCwgMiwgNDEsIDE5XSwgWzQsIDQwLCAxNCwgMiwgNDEsIDE1XSwgWzIsIDE0NiwgMTE2XSwgWzMsIDU4LCAzNiwgMiwgNTksIDM3XSwgWzQsIDM2LCAxNiwgNCwgMzcsIDE3XSwgWzQsIDM2LCAxMiwgNCwgMzcsIDEzXSwgWzIsIDg2LCA2OCwgMiwgODcsIDY5XSwgWzQsIDY5LCA0MywgMSwgNzAsIDQ0XSwgWzYsIDQzLCAxOSwgMiwgNDQsIDIwXSwgWzYsIDQzLCAxNSwgMiwgNDQsIDE2XSwgWzQsIDEwMSwgODFdLCBbMSwgODAsIDUwLCA0LCA4MSwgNTFdLCBbNCwgNTAsIDIyLCA0LCA1MSwgMjNdLCBbMywgMzYsIDEyLCA4LCAzNywgMTNdLCBbMiwgMTE2LCA5MiwgMiwgMTE3LCA5M10sIFs2LCA1OCwgMzYsIDIsIDU5LCAzN10sIFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sIFs3LCA0MiwgMTQsIDQsIDQzLCAxNV0sIFs0LCAxMzMsIDEwN10sIFs4LCA1OSwgMzcsIDEsIDYwLCAzOF0sIFs4LCA0NCwgMjAsIDQsIDQ1LCAyMV0sIFsxMiwgMzMsIDExLCA0LCAzNCwgMTJdLCBbMywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSwgWzQsIDY0LCA0MCwgNSwgNjUsIDQxXSwgWzExLCAzNiwgMTYsIDUsIDM3LCAxN10sIFsxMSwgMzYsIDEyLCA1LCAzNywgMTNdLCBbNSwgMTA5LCA4NywgMSwgMTEwLCA4OF0sIFs1LCA2NSwgNDEsIDUsIDY2LCA0Ml0sIFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sIFsxMSwgMzYsIDEyLCA3LCAzNywgMTNdLCBbNSwgMTIyLCA5OCwgMSwgMTIzLCA5OV0sIFs3LCA3MywgNDUsIDMsIDc0LCA0Nl0sIFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLCBbMywgNDUsIDE1LCAxMywgNDYsIDE2XSwgWzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sIFsxMCwgNzQsIDQ2LCAxLCA3NSwgNDddLCBbMSwgNTAsIDIyLCAxNSwgNTEsIDIzXSwgWzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sIFs1LCAxNTAsIDEyMCwgMSwgMTUxLCAxMjFdLCBbOSwgNjksIDQzLCA0LCA3MCwgNDRdLCBbMTcsIDUwLCAyMiwgMSwgNTEsIDIzXSwgWzIsIDQyLCAxNCwgMTksIDQzLCAxNV0sIFszLCAxNDEsIDExMywgNCwgMTQyLCAxMTRdLCBbMywgNzAsIDQ0LCAxMSwgNzEsIDQ1XSwgWzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sIFs5LCAzOSwgMTMsIDE2LCA0MCwgMTRdLCBbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSwgWzMsIDY3LCA0MSwgMTMsIDY4LCA0Ml0sIFsxNSwgNTQsIDI0LCA1LCA1NSwgMjVdLCBbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sIFs0LCAxNDQsIDExNiwgNCwgMTQ1LCAxMTddLCBbMTcsIDY4LCA0Ml0sIFsxNywgNTAsIDIyLCA2LCA1MSwgMjNdLCBbMTksIDQ2LCAxNiwgNiwgNDcsIDE3XSwgWzIsIDEzOSwgMTExLCA3LCAxNDAsIDExMl0sIFsxNywgNzQsIDQ2XSwgWzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sIFszNCwgMzcsIDEzXSwgWzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sIFs0LCA3NSwgNDcsIDE0LCA3NiwgNDhdLCBbMTEsIDU0LCAyNCwgMTQsIDU1LCAyNV0sIFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSwgWzYsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sIFs2LCA3MywgNDUsIDE0LCA3NCwgNDZdLCBbMTEsIDU0LCAyNCwgMTYsIDU1LCAyNV0sIFszMCwgNDYsIDE2LCAyLCA0NywgMTddLCBbOCwgMTMyLCAxMDYsIDQsIDEzMywgMTA3XSwgWzgsIDc1LCA0NywgMTMsIDc2LCA0OF0sIFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLCBbMjIsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sIFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSwgWzE5LCA3NCwgNDYsIDQsIDc1LCA0N10sIFsyOCwgNTAsIDIyLCA2LCA1MSwgMjNdLCBbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSwgWzgsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sIFsyMiwgNzMsIDQ1LCAzLCA3NCwgNDZdLCBbOCwgNTMsIDIzLCAyNiwgNTQsIDI0XSwgWzEyLCA0NSwgMTUsIDI4LCA0NiwgMTZdLCBbMywgMTQ3LCAxMTcsIDEwLCAxNDgsIDExOF0sIFszLCA3MywgNDUsIDIzLCA3NCwgNDZdLCBbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSwgWzExLCA0NSwgMTUsIDMxLCA0NiwgMTZdLCBbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSwgWzIxLCA3MywgNDUsIDcsIDc0LCA0Nl0sIFsxLCA1MywgMjMsIDM3LCA1NCwgMjRdLCBbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sIFs1LCAxNDUsIDExNSwgMTAsIDE0NiwgMTE2XSwgWzE5LCA3NSwgNDcsIDEwLCA3NiwgNDhdLCBbMTUsIDU0LCAyNCwgMjUsIDU1LCAyNV0sIFsyMywgNDUsIDE1LCAyNSwgNDYsIDE2XSwgWzEzLCAxNDUsIDExNSwgMywgMTQ2LCAxMTZdLCBbMiwgNzQsIDQ2LCAyOSwgNzUsIDQ3XSwgWzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sIFsyMywgNDUsIDE1LCAyOCwgNDYsIDE2XSwgWzE3LCAxNDUsIDExNV0sIFsxMCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSwgWzEwLCA1NCwgMjQsIDM1LCA1NSwgMjVdLCBbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sIFsxNywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSwgWzE0LCA3NCwgNDYsIDIxLCA3NSwgNDddLCBbMjksIDU0LCAyNCwgMTksIDU1LCAyNV0sIFsxMSwgNDUsIDE1LCA0NiwgNDYsIDE2XSwgWzEzLCAxNDUsIDExNSwgNiwgMTQ2LCAxMTZdLCBbMTQsIDc0LCA0NiwgMjMsIDc1LCA0N10sIFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLCBbNTksIDQ2LCAxNiwgMSwgNDcsIDE3XSwgWzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLCBbMTIsIDc1LCA0NywgMjYsIDc2LCA0OF0sIFszOSwgNTQsIDI0LCAxNCwgNTUsIDI1XSwgWzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLCBbNiwgMTUxLCAxMjEsIDE0LCAxNTIsIDEyMl0sIFs2LCA3NSwgNDcsIDM0LCA3NiwgNDhdLCBbNDYsIDU0LCAyNCwgMTAsIDU1LCAyNV0sIFsyLCA0NSwgMTUsIDY0LCA0NiwgMTZdLCBbMTcsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sIFsyOSwgNzQsIDQ2LCAxNCwgNzUsIDQ3XSwgWzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLCBbMjQsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sIFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSwgWzEzLCA3NCwgNDYsIDMyLCA3NSwgNDddLCBbNDgsIDU0LCAyNCwgMTQsIDU1LCAyNV0sIFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSwgWzIwLCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLCBbNDAsIDc1LCA0NywgNywgNzYsIDQ4XSwgWzQzLCA1NCwgMjQsIDIyLCA1NSwgMjVdLCBbMTAsIDQ1LCAxNSwgNjcsIDQ2LCAxNl0sIFsxOSwgMTQ4LCAxMTgsIDYsIDE0OSwgMTE5XSwgWzE4LCA3NSwgNDcsIDMxLCA3NiwgNDhdLCBbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sIFsyMCwgNDUsIDE1LCA2MSwgNDYsIDE2XV07XG5cdFxuXHQgICAgdmFyIHFyUlNCbG9jayA9IGZ1bmN0aW9uIHFyUlNCbG9jayh0b3RhbENvdW50LCBkYXRhQ291bnQpIHtcblx0ICAgICAgdmFyIF90aGlzID0ge307XG5cdCAgICAgIF90aGlzLnRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuXHQgICAgICBfdGhpcy5kYXRhQ291bnQgPSBkYXRhQ291bnQ7XG5cdCAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIF90aGlzID0ge307XG5cdFxuXHQgICAgdmFyIGdldFJzQmxvY2tUYWJsZSA9IGZ1bmN0aW9uIGdldFJzQmxvY2tUYWJsZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuXHRcblx0ICAgICAgc3dpdGNoIChlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuXHQgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5MOlxuXHQgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XG5cdCAgICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLk06XG5cdCAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcblx0ICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUTpcblx0ICAgICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDJdO1xuXHQgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5IOlxuXHQgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0UlNCbG9ja3MgPSBmdW5jdGlvbiAodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblx0XG5cdCAgICAgIHZhciByc0Jsb2NrID0gZ2V0UnNCbG9ja1RhYmxlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcblx0XG5cdCAgICAgIGlmICh0eXBlb2YgcnNCbG9jayA9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHJzIGJsb2NrIEAgdHlwZU51bWJlcjonICsgdHlwZU51bWJlciArICcvZXJyb3JDb3JyZWN0aW9uTGV2ZWw6JyArIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcblx0XG5cdCAgICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KCk7XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFxuXHQgICAgICAgIHZhciBjb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAwXTtcblx0ICAgICAgICB2YXIgdG90YWxDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAxXTtcblx0ICAgICAgICB2YXIgZGF0YUNvdW50ID0gcnNCbG9ja1tpICogMyArIDJdO1xuXHRcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqICs9IDEpIHtcblx0ICAgICAgICAgIGxpc3QucHVzaChxclJTQmxvY2sodG90YWxDb3VudCwgZGF0YUNvdW50KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gbGlzdDtcblx0ICAgIH07XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH0oKTtcblx0XG5cdCAgdmFyIHFyQml0QnVmZmVyID0gZnVuY3Rpb24gcXJCaXRCdWZmZXIoKSB7XG5cdFxuXHQgICAgdmFyIF9idWZmZXIgPSBuZXcgQXJyYXkoKTtcblx0ICAgIHZhciBfbGVuZ3RoID0gMDtcblx0XG5cdCAgICB2YXIgX3RoaXMgPSB7fTtcblx0XG5cdCAgICBfdGhpcy5nZXRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfYnVmZmVyO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5nZXRBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gOCk7XG5cdCAgICAgIHJldHVybiAoX2J1ZmZlcltidWZJbmRleF0gPj4+IDcgLSBpbmRleCAlIDggJiAxKSA9PSAxO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5wdXQgPSBmdW5jdGlvbiAobnVtLCBsZW5ndGgpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIF90aGlzLnB1dEJpdCgobnVtID4+PiBsZW5ndGggLSBpIC0gMSAmIDEpID09IDEpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLmdldExlbmd0aEluQml0cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF9sZW5ndGg7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLnB1dEJpdCA9IGZ1bmN0aW9uIChiaXQpIHtcblx0XG5cdCAgICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoX2xlbmd0aCAvIDgpO1xuXHQgICAgICBpZiAoX2J1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcblx0ICAgICAgICBfYnVmZmVyLnB1c2goMCk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChiaXQpIHtcblx0ICAgICAgICBfYnVmZmVyW2J1ZkluZGV4XSB8PSAweDgwID4+PiBfbGVuZ3RoICUgODtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgX2xlbmd0aCArPSAxO1xuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdmFyIHFyTnVtYmVyID0gZnVuY3Rpb24gcXJOdW1iZXIoZGF0YSkge1xuXHRcblx0ICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX05VTUJFUjtcblx0ICAgIHZhciBfZGF0YSA9IGRhdGE7XG5cdFxuXHQgICAgdmFyIF90aGlzID0ge307XG5cdFxuXHQgICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF9tb2RlO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgIHJldHVybiBfZGF0YS5sZW5ndGg7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcblx0ICAgICAgdmFyIGRhdGEgPSBfZGF0YTtcblx0XG5cdCAgICAgIHZhciBpID0gMDtcblx0XG5cdCAgICAgIHdoaWxlIChpICsgMiA8IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgYnVmZmVyLnB1dChzdHJUb051bShkYXRhLnN1YnN0cmluZyhpLCBpICsgMykpLCAxMCk7XG5cdCAgICAgICAgaSArPSAzO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoaSA8IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoIC0gaSA9PSAxKSB7XG5cdCAgICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEuc3Vic3RyaW5nKGksIGkgKyAxKSksIDQpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggLSBpID09IDIpIHtcblx0ICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDIpKSwgNyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBzdHJUb051bSA9IGZ1bmN0aW9uIHN0clRvTnVtKHMpIHtcblx0ICAgICAgdmFyIG51bSA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIG51bSA9IG51bSAqIDEwICsgY2hhdFRvTnVtKHMuY2hhckF0KGkpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVtO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgY2hhdFRvTnVtID0gZnVuY3Rpb24gY2hhdFRvTnVtKGMpIHtcblx0ICAgICAgaWYgKCcwJyA8PSBjICYmIGMgPD0gJzknKSB7XG5cdCAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuXHQgICAgICB9XG5cdCAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgOicgKyBjO1xuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdmFyIHFyQWxwaGFOdW0gPSBmdW5jdGlvbiBxckFscGhhTnVtKGRhdGEpIHtcblx0XG5cdCAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9BTFBIQV9OVU07XG5cdCAgICB2YXIgX2RhdGEgPSBkYXRhO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfbW9kZTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XG5cdCAgICAgIHZhciBzID0gX2RhdGE7XG5cdFxuXHQgICAgICB2YXIgaSA9IDA7XG5cdFxuXHQgICAgICB3aGlsZSAoaSArIDEgPCBzLmxlbmd0aCkge1xuXHQgICAgICAgIGJ1ZmZlci5wdXQoZ2V0Q29kZShzLmNoYXJBdChpKSkgKiA0NSArIGdldENvZGUocy5jaGFyQXQoaSArIDEpKSwgMTEpO1xuXHQgICAgICAgIGkgKz0gMjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKGkgPCBzLmxlbmd0aCkge1xuXHQgICAgICAgIGJ1ZmZlci5wdXQoZ2V0Q29kZShzLmNoYXJBdChpKSksIDYpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBnZXRDb2RlID0gZnVuY3Rpb24gZ2V0Q29kZShjKSB7XG5cdFxuXHQgICAgICBpZiAoJzAnIDw9IGMgJiYgYyA8PSAnOScpIHtcblx0ICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoJ0EnIDw9IGMgJiYgYyA8PSAnWicpIHtcblx0ICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gJ0EnLmNoYXJDb2RlQXQoMCkgKyAxMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICAgIGNhc2UgJyAnOlxuXHQgICAgICAgICAgICByZXR1cm4gMzY7XG5cdCAgICAgICAgICBjYXNlICckJzpcblx0ICAgICAgICAgICAgcmV0dXJuIDM3O1xuXHQgICAgICAgICAgY2FzZSAnJSc6XG5cdCAgICAgICAgICAgIHJldHVybiAzODtcblx0ICAgICAgICAgIGNhc2UgJyonOlxuXHQgICAgICAgICAgICByZXR1cm4gMzk7XG5cdCAgICAgICAgICBjYXNlICcrJzpcblx0ICAgICAgICAgICAgcmV0dXJuIDQwO1xuXHQgICAgICAgICAgY2FzZSAnLSc6XG5cdCAgICAgICAgICAgIHJldHVybiA0MTtcblx0ICAgICAgICAgIGNhc2UgJy4nOlxuXHQgICAgICAgICAgICByZXR1cm4gNDI7XG5cdCAgICAgICAgICBjYXNlICcvJzpcblx0ICAgICAgICAgICAgcmV0dXJuIDQzO1xuXHQgICAgICAgICAgY2FzZSAnOic6XG5cdCAgICAgICAgICAgIHJldHVybiA0NDtcblx0ICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgOicgKyBjO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdmFyIHFyOEJpdEJ5dGUgPSBmdW5jdGlvbiBxcjhCaXRCeXRlKGRhdGEpIHtcblx0XG5cdCAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV84QklUX0JZVEU7XG5cdCAgICB2YXIgX2RhdGEgPSBkYXRhO1xuXHQgICAgdmFyIF9ieXRlcyA9IHFyY29kZS5zdHJpbmdUb0J5dGVzKGRhdGEpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfbW9kZTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2J5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgYnVmZmVyLnB1dChfYnl0ZXNbaV0sIDgpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICB2YXIgcXJLYW5qaSA9IGZ1bmN0aW9uIHFyS2FuamkoZGF0YSkge1xuXHRcblx0ICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX0tBTkpJO1xuXHQgICAgdmFyIF9kYXRhID0gZGF0YTtcblx0ICAgIHZhciBfYnl0ZXMgPSBxcmNvZGUuc3RyaW5nVG9CeXRlcyhkYXRhKTtcblx0XG5cdCAgICAhZnVuY3Rpb24gKGMsIGNvZGUpIHtcblx0ICAgICAgdmFyIHRlc3QgPSBxcmNvZGUuc3RyaW5nVG9CeXRlcyhjKTtcblx0ICAgICAgaWYgKHRlc3QubGVuZ3RoICE9IDIgfHwgKHRlc3RbMF0gPDwgOCB8IHRlc3RbMV0pICE9IGNvZGUpIHtcblx0ICAgICAgICB0aHJvdyAnc2ppcyBub3Qgc3VwcG9ydGVkLic7XG5cdCAgICAgIH1cblx0ICAgIH0oJ1xcdTUzQ0InLCAweDk3NDYpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfbW9kZTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICByZXR1cm4gfn4oX2J5dGVzLmxlbmd0aCAvIDIpO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XG5cdCAgICAgIHZhciBkYXRhID0gX2J5dGVzO1xuXHRcblx0ICAgICAgdmFyIGkgPSAwO1xuXHRcblx0ICAgICAgd2hpbGUgKGkgKyAxIDwgZGF0YS5sZW5ndGgpIHtcblx0XG5cdCAgICAgICAgdmFyIGMgPSAoMHhmZiAmIGRhdGFbaV0pIDw8IDggfCAweGZmICYgZGF0YVtpICsgMV07XG5cdFxuXHQgICAgICAgIGlmICgweDgxNDAgPD0gYyAmJiBjIDw9IDB4OUZGQykge1xuXHQgICAgICAgICAgYyAtPSAweDgxNDA7XG5cdCAgICAgICAgfSBlbHNlIGlmICgweEUwNDAgPD0gYyAmJiBjIDw9IDB4RUJCRikge1xuXHQgICAgICAgICAgYyAtPSAweEMxNDA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgYXQgJyArIChpICsgMSkgKyAnLycgKyBjO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgYyA9IChjID4+PiA4ICYgMHhmZikgKiAweEMwICsgKGMgJiAweGZmKTtcblx0XG5cdCAgICAgICAgYnVmZmVyLnB1dChjLCAxMyk7XG5cdFxuXHQgICAgICAgIGkgKz0gMjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKGkgPCBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgYXQgJyArIChpICsgMSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH07XG5cdFxuXHQgIHZhciBieXRlQXJyYXlPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbiBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKSB7XG5cdFxuXHQgICAgdmFyIF9ieXRlcyA9IG5ldyBBcnJheSgpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uIChiKSB7XG5cdCAgICAgIF9ieXRlcy5wdXNoKGIgJiAweGZmKTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgIF90aGlzLndyaXRlQnl0ZShpKTtcblx0ICAgICAgX3RoaXMud3JpdGVCeXRlKGkgPj4+IDgpO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy53cml0ZUJ5dGVzID0gZnVuY3Rpb24gKGIsIG9mZiwgbGVuKSB7XG5cdCAgICAgIG9mZiA9IG9mZiB8fCAwO1xuXHQgICAgICBsZW4gPSBsZW4gfHwgYi5sZW5ndGg7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0ICAgICAgICBfdGhpcy53cml0ZUJ5dGUoYltpICsgb2ZmXSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAocykge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICBfdGhpcy53cml0ZUJ5dGUocy5jaGFyQ29kZUF0KGkpKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy50b0J5dGVBcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF9ieXRlcztcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBzID0gJyc7XG5cdCAgICAgIHMgKz0gJ1snO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIGlmIChpID4gMCkge1xuXHQgICAgICAgICAgcyArPSAnLCc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHMgKz0gX2J5dGVzW2ldO1xuXHQgICAgICB9XG5cdCAgICAgIHMgKz0gJ10nO1xuXHQgICAgICByZXR1cm4gcztcblx0ICAgIH07XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH07XG5cdFxuXHQgIHZhciBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbiBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0oKSB7XG5cdFxuXHQgICAgdmFyIF9idWZmZXIgPSAwO1xuXHQgICAgdmFyIF9idWZsZW4gPSAwO1xuXHQgICAgdmFyIF9sZW5ndGggPSAwO1xuXHQgICAgdmFyIF9iYXNlNjQgPSAnJztcblx0XG5cdCAgICB2YXIgX3RoaXMgPSB7fTtcblx0XG5cdCAgICB2YXIgd3JpdGVFbmNvZGVkID0gZnVuY3Rpb24gd3JpdGVFbmNvZGVkKGIpIHtcblx0ICAgICAgX2Jhc2U2NCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVuY29kZShiICYgMHgzZikpO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG4pIHtcblx0ICAgICAgaWYgKG4gPCAwKSB7fSBlbHNlIGlmIChuIDwgMjYpIHtcblx0ICAgICAgICByZXR1cm4gMHg0MSArIG47XG5cdCAgICAgIH0gZWxzZSBpZiAobiA8IDUyKSB7XG5cdCAgICAgICAgcmV0dXJuIDB4NjEgKyAobiAtIDI2KTtcblx0ICAgICAgfSBlbHNlIGlmIChuIDwgNjIpIHtcblx0ICAgICAgICByZXR1cm4gMHgzMCArIChuIC0gNTIpO1xuXHQgICAgICB9IGVsc2UgaWYgKG4gPT0gNjIpIHtcblx0ICAgICAgICByZXR1cm4gMHgyYjtcblx0ICAgICAgfSBlbHNlIGlmIChuID09IDYzKSB7XG5cdCAgICAgICAgcmV0dXJuIDB4MmY7XG5cdCAgICAgIH1cblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCduOicgKyBuKTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMud3JpdGVCeXRlID0gZnVuY3Rpb24gKG4pIHtcblx0XG5cdCAgICAgIF9idWZmZXIgPSBfYnVmZmVyIDw8IDggfCBuICYgMHhmZjtcblx0ICAgICAgX2J1ZmxlbiArPSA4O1xuXHQgICAgICBfbGVuZ3RoICs9IDE7XG5cdFxuXHQgICAgICB3aGlsZSAoX2J1ZmxlbiA+PSA2KSB7XG5cdCAgICAgICAgd3JpdGVFbmNvZGVkKF9idWZmZXIgPj4+IF9idWZsZW4gLSA2KTtcblx0ICAgICAgICBfYnVmbGVuIC09IDY7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgICAgICBpZiAoX2J1ZmxlbiA+IDApIHtcblx0ICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA8PCA2IC0gX2J1Zmxlbik7XG5cdCAgICAgICAgX2J1ZmZlciA9IDA7XG5cdCAgICAgICAgX2J1ZmxlbiA9IDA7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChfbGVuZ3RoICUgMyAhPSAwKSB7XG5cdCAgICAgICAgdmFyIHBhZGxlbiA9IDMgLSBfbGVuZ3RoICUgMztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGxlbjsgaSArPSAxKSB7XG5cdCAgICAgICAgICBfYmFzZTY0ICs9ICc9Jztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfYmFzZTY0O1xuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdmFyIGJhc2U2NERlY29kZUlucHV0U3RyZWFtID0gZnVuY3Rpb24gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0oc3RyKSB7XG5cdFxuXHQgICAgdmFyIF9zdHIgPSBzdHI7XG5cdCAgICB2YXIgX3BvcyA9IDA7XG5cdCAgICB2YXIgX2J1ZmZlciA9IDA7XG5cdCAgICB2YXIgX2J1ZmxlbiA9IDA7XG5cdFxuXHQgICAgdmFyIF90aGlzID0ge307XG5cdFxuXHQgICAgX3RoaXMucmVhZCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICAgIHdoaWxlIChfYnVmbGVuIDwgOCkge1xuXHRcblx0ICAgICAgICBpZiAoX3BvcyA+PSBfc3RyLmxlbmd0aCkge1xuXHQgICAgICAgICAgaWYgKF9idWZsZW4gPT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUuLycgKyBfYnVmbGVuKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBjID0gX3N0ci5jaGFyQXQoX3Bvcyk7XG5cdCAgICAgICAgX3BvcyArPSAxO1xuXHRcblx0ICAgICAgICBpZiAoYyA9PSAnPScpIHtcblx0ICAgICAgICAgIF9idWZsZW4gPSAwO1xuXHQgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYy5tYXRjaCgvXlxccyQvKSkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBfYnVmZmVyID0gX2J1ZmZlciA8PCA2IHwgZGVjb2RlKGMuY2hhckNvZGVBdCgwKSk7XG5cdCAgICAgICAgX2J1ZmxlbiArPSA2O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgbiA9IF9idWZmZXIgPj4+IF9idWZsZW4gLSA4ICYgMHhmZjtcblx0ICAgICAgX2J1ZmxlbiAtPSA4O1xuXHQgICAgICByZXR1cm4gbjtcblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShjKSB7XG5cdCAgICAgIGlmICgweDQxIDw9IGMgJiYgYyA8PSAweDVhKSB7XG5cdCAgICAgICAgcmV0dXJuIGMgLSAweDQxO1xuXHQgICAgICB9IGVsc2UgaWYgKDB4NjEgPD0gYyAmJiBjIDw9IDB4N2EpIHtcblx0ICAgICAgICByZXR1cm4gYyAtIDB4NjEgKyAyNjtcblx0ICAgICAgfSBlbHNlIGlmICgweDMwIDw9IGMgJiYgYyA8PSAweDM5KSB7XG5cdCAgICAgICAgcmV0dXJuIGMgLSAweDMwICsgNTI7XG5cdCAgICAgIH0gZWxzZSBpZiAoYyA9PSAweDJiKSB7XG5cdCAgICAgICAgcmV0dXJuIDYyO1xuXHQgICAgICB9IGVsc2UgaWYgKGMgPT0gMHgyZikge1xuXHQgICAgICAgIHJldHVybiA2Mztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2M6JyArIGMpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICB2YXIgZ2lmSW1hZ2UgPSBmdW5jdGlvbiBnaWZJbWFnZSh3aWR0aCwgaGVpZ2h0KSB7XG5cdFxuXHQgICAgdmFyIF93aWR0aCA9IHdpZHRoO1xuXHQgICAgdmFyIF9oZWlnaHQgPSBoZWlnaHQ7XG5cdCAgICB2YXIgX2RhdGEgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IHt9O1xuXHRcblx0ICAgIF90aGlzLnNldFBpeGVsID0gZnVuY3Rpb24gKHgsIHksIHBpeGVsKSB7XG5cdCAgICAgIF9kYXRhW3kgKiBfd2lkdGggKyB4XSA9IHBpeGVsO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uIChvdXQpIHtcblx0XG5cdCAgICAgIG91dC53cml0ZVN0cmluZygnR0lGODdhJyk7XG5cdFxuXHQgICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuXHQgICAgICBvdXQud3JpdGVTaG9ydChfaGVpZ2h0KTtcblx0XG5cdCAgICAgIG91dC53cml0ZUJ5dGUoMHg4MCk7XG5cdCAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG5cdCAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG5cdFxuXHQgICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXHQgICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXHQgICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXHRcblx0ICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcblx0ICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcblx0ICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcblx0XG5cdCAgICAgIG91dC53cml0ZVN0cmluZygnLCcpO1xuXHQgICAgICBvdXQud3JpdGVTaG9ydCgwKTtcblx0ICAgICAgb3V0LndyaXRlU2hvcnQoMCk7XG5cdCAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XG5cdCAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuXHQgICAgICBvdXQud3JpdGVCeXRlKDApO1xuXHRcblx0ICAgICAgdmFyIGx6d01pbkNvZGVTaXplID0gMjtcblx0ICAgICAgdmFyIHJhc3RlciA9IGdldExaV1Jhc3RlcihsendNaW5Db2RlU2l6ZSk7XG5cdFxuXHQgICAgICBvdXQud3JpdGVCeXRlKGx6d01pbkNvZGVTaXplKTtcblx0XG5cdCAgICAgIHZhciBvZmZzZXQgPSAwO1xuXHRcblx0ICAgICAgd2hpbGUgKHJhc3Rlci5sZW5ndGggLSBvZmZzZXQgPiAyNTUpIHtcblx0ICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XG5cdCAgICAgICAgb3V0LndyaXRlQnl0ZXMocmFzdGVyLCBvZmZzZXQsIDI1NSk7XG5cdCAgICAgICAgb2Zmc2V0ICs9IDI1NTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcblx0ICAgICAgb3V0LndyaXRlQnl0ZXMocmFzdGVyLCBvZmZzZXQsIHJhc3Rlci5sZW5ndGggLSBvZmZzZXQpO1xuXHQgICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXHRcblx0ICAgICAgb3V0LndyaXRlU3RyaW5nKCc7Jyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBiaXRPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbiBiaXRPdXRwdXRTdHJlYW0ob3V0KSB7XG5cdFxuXHQgICAgICB2YXIgX291dCA9IG91dDtcblx0ICAgICAgdmFyIF9iaXRMZW5ndGggPSAwO1xuXHQgICAgICB2YXIgX2JpdEJ1ZmZlciA9IDA7XG5cdFxuXHQgICAgICB2YXIgX3RoaXMgPSB7fTtcblx0XG5cdCAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGxlbmd0aCkge1xuXHRcblx0ICAgICAgICBpZiAoZGF0YSA+Pj4gbGVuZ3RoICE9IDApIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG92ZXInKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHdoaWxlIChfYml0TGVuZ3RoICsgbGVuZ3RoID49IDgpIHtcblx0ICAgICAgICAgIF9vdXQud3JpdGVCeXRlKDB4ZmYgJiAoZGF0YSA8PCBfYml0TGVuZ3RoIHwgX2JpdEJ1ZmZlcikpO1xuXHQgICAgICAgICAgbGVuZ3RoIC09IDggLSBfYml0TGVuZ3RoO1xuXHQgICAgICAgICAgZGF0YSA+Pj49IDggLSBfYml0TGVuZ3RoO1xuXHQgICAgICAgICAgX2JpdEJ1ZmZlciA9IDA7XG5cdCAgICAgICAgICBfYml0TGVuZ3RoID0gMDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIF9iaXRCdWZmZXIgPSBkYXRhIDw8IF9iaXRMZW5ndGggfCBfYml0QnVmZmVyO1xuXHQgICAgICAgIF9iaXRMZW5ndGggPSBfYml0TGVuZ3RoICsgbGVuZ3RoO1xuXHQgICAgICB9O1xuXHRcblx0ICAgICAgX3RoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKF9iaXRMZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICBfb3V0LndyaXRlQnl0ZShfYml0QnVmZmVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBnZXRMWldSYXN0ZXIgPSBmdW5jdGlvbiBnZXRMWldSYXN0ZXIobHp3TWluQ29kZVNpemUpIHtcblx0XG5cdCAgICAgIHZhciBjbGVhckNvZGUgPSAxIDw8IGx6d01pbkNvZGVTaXplO1xuXHQgICAgICB2YXIgZW5kQ29kZSA9ICgxIDw8IGx6d01pbkNvZGVTaXplKSArIDE7XG5cdCAgICAgIHZhciBiaXRMZW5ndGggPSBsendNaW5Db2RlU2l6ZSArIDE7XG5cdFxuXHQgICAgICB2YXIgdGFibGUgPSBsendUYWJsZSgpO1xuXHRcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhckNvZGU7IGkgKz0gMSkge1xuXHQgICAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcblx0ICAgICAgfVxuXHQgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShjbGVhckNvZGUpKTtcblx0ICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kQ29kZSkpO1xuXHRcblx0ICAgICAgdmFyIGJ5dGVPdXQgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcblx0ICAgICAgdmFyIGJpdE91dCA9IGJpdE91dHB1dFN0cmVhbShieXRlT3V0KTtcblx0XG5cdCAgICAgIGJpdE91dC53cml0ZShjbGVhckNvZGUsIGJpdExlbmd0aCk7XG5cdFxuXHQgICAgICB2YXIgZGF0YUluZGV4ID0gMDtcblx0XG5cdCAgICAgIHZhciBzID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcblx0ICAgICAgZGF0YUluZGV4ICs9IDE7XG5cdFxuXHQgICAgICB3aGlsZSAoZGF0YUluZGV4IDwgX2RhdGEubGVuZ3RoKSB7XG5cdFxuXHQgICAgICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcblx0ICAgICAgICBkYXRhSW5kZXggKz0gMTtcblx0XG5cdCAgICAgICAgaWYgKHRhYmxlLmNvbnRhaW5zKHMgKyBjKSkge1xuXHRcblx0ICAgICAgICAgIHMgPSBzICsgYztcblx0ICAgICAgICB9IGVsc2Uge1xuXHRcblx0ICAgICAgICAgIGJpdE91dC53cml0ZSh0YWJsZS5pbmRleE9mKHMpLCBiaXRMZW5ndGgpO1xuXHRcblx0ICAgICAgICAgIGlmICh0YWJsZS5zaXplKCkgPCAweGZmZikge1xuXHRcblx0ICAgICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA9PSAxIDw8IGJpdExlbmd0aCkge1xuXHQgICAgICAgICAgICAgIGJpdExlbmd0aCArPSAxO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICB0YWJsZS5hZGQocyArIGMpO1xuXHQgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgIHMgPSBjO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgYml0T3V0LndyaXRlKHRhYmxlLmluZGV4T2YocyksIGJpdExlbmd0aCk7XG5cdFxuXHQgICAgICBiaXRPdXQud3JpdGUoZW5kQ29kZSwgYml0TGVuZ3RoKTtcblx0XG5cdCAgICAgIGJpdE91dC5mbHVzaCgpO1xuXHRcblx0ICAgICAgcmV0dXJuIGJ5dGVPdXQudG9CeXRlQXJyYXkoKTtcblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIGx6d1RhYmxlID0gZnVuY3Rpb24gbHp3VGFibGUoKSB7XG5cdFxuXHQgICAgICB2YXIgX21hcCA9IHt9O1xuXHQgICAgICB2YXIgX3NpemUgPSAwO1xuXHRcblx0ICAgICAgdmFyIF90aGlzID0ge307XG5cdFxuXHQgICAgICBfdGhpcy5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgaWYgKF90aGlzLmNvbnRhaW5zKGtleSkpIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwIGtleTonICsga2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX21hcFtrZXldID0gX3NpemU7XG5cdCAgICAgICAgX3NpemUgKz0gMTtcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIF90aGlzLnNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zaXplO1xuXHQgICAgICB9O1xuXHRcblx0ICAgICAgX3RoaXMuaW5kZXhPZiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICByZXR1cm4gX21hcFtrZXldO1xuXHQgICAgICB9O1xuXHRcblx0ICAgICAgX3RoaXMuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBfbWFwW2tleV0gIT0gJ3VuZGVmaW5lZCc7XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9O1xuXHRcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICB2YXIgY3JlYXRlSW1nVGFnID0gZnVuY3Rpb24gY3JlYXRlSW1nVGFnKHdpZHRoLCBoZWlnaHQsIGdldFBpeGVsLCBhbHQpIHtcblx0XG5cdCAgICB2YXIgZ2lmID0gZ2lmSW1hZ2Uod2lkdGgsIGhlaWdodCk7XG5cdCAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSAxKSB7XG5cdCAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHggKz0gMSkge1xuXHQgICAgICAgIGdpZi5zZXRQaXhlbCh4LCB5LCBnZXRQaXhlbCh4LCB5KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICB2YXIgYiA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuXHQgICAgZ2lmLndyaXRlKGIpO1xuXHRcblx0ICAgIHZhciBiYXNlNjQgPSBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0oKTtcblx0ICAgIHZhciBieXRlcyA9IGIudG9CeXRlQXJyYXkoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgYmFzZTY0LndyaXRlQnl0ZShieXRlc1tpXSk7XG5cdCAgICB9XG5cdCAgICBiYXNlNjQuZmx1c2goKTtcblx0XG5cdCAgICB2YXIgaW1nID0gJyc7XG5cdCAgICBpbWcgKz0gJzxpbWcnO1xuXHQgICAgaW1nICs9ICcgc3JjPVwiJztcblx0ICAgIGltZyArPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LCc7XG5cdCAgICBpbWcgKz0gYmFzZTY0O1xuXHQgICAgaW1nICs9ICdcIic7XG5cdCAgICBpbWcgKz0gJyB3aWR0aD1cIic7XG5cdCAgICBpbWcgKz0gd2lkdGg7XG5cdCAgICBpbWcgKz0gJ1wiJztcblx0ICAgIGltZyArPSAnIGhlaWdodD1cIic7XG5cdCAgICBpbWcgKz0gaGVpZ2h0O1xuXHQgICAgaW1nICs9ICdcIic7XG5cdCAgICBpZiAoYWx0KSB7XG5cdCAgICAgIGltZyArPSAnIGFsdD1cIic7XG5cdCAgICAgIGltZyArPSBhbHQ7XG5cdCAgICAgIGltZyArPSAnXCInO1xuXHQgICAgfVxuXHQgICAgaW1nICs9ICcvPic7XG5cdFxuXHQgICAgcmV0dXJuIGltZztcblx0ICB9O1xuXHRcblx0ICB2YXIgY3JlYXRlSW1nT2JqZWN0ID0gZnVuY3Rpb24gY3JlYXRlSW1nT2JqZWN0KHdpZHRoLCBoZWlnaHQsIGdldFBpeGVsKSB7XG5cdFxuXHQgICAgdmFyIGdpZiA9IGdpZkltYWdlKHdpZHRoLCBoZWlnaHQpO1xuXHQgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gMSkge1xuXHQgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IDEpIHtcblx0ICAgICAgICBnaWYuc2V0UGl4ZWwoeCwgeSwgZ2V0UGl4ZWwoeCwgeSkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIGIgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcblx0ICAgIGdpZi53cml0ZShiKTtcblx0XG5cdCAgICB2YXIgYmFzZTY0ID0gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtKCk7XG5cdCAgICB2YXIgYnl0ZXMgPSBiLnRvQnl0ZUFycmF5KCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgIGJhc2U2NC53cml0ZUJ5dGUoYnl0ZXNbaV0pO1xuXHQgICAgfVxuXHQgICAgYmFzZTY0LmZsdXNoKCk7XG5cdFxuXHQgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuXHQgICAgaW1nLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsJyArIGJhc2U2NDtcblx0ICAgIGltZy53aWR0aCA9IHdpZHRoO1xuXHQgICAgaW1nLmhlaWdodCA9IGhlaWdodDtcblx0XG5cdCAgICByZXR1cm4gaW1nO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiB7XG5cdCAgICBRUkNvZGU6IHFyY29kZSxcblx0ICAgIFFSVXRpbDogUVJVdGlsXG5cdCAgfTtcblx0fSgpO1xuXHRcblx0KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdCAgaWYgKHRydWUpIHtcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0ICB9IGVsc2UgaWYgKCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShleHBvcnRzKSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ICB9XG5cdH0pKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgUVJDb2RlOiBxcmNvZGUuUVJDb2RlLFxuXHQgICAgUVJVdGlsOiBxcmNvZGUuUVJVdGlsXG5cdCAgfTtcblx0fSk7XG5cbi8qKiovIH0sXG4vKiAyMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0dmFyIF9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHRcblx0dmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cdFxuXHR2YXIgX3N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXHRcblx0dmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xuXHR9IDogZnVuY3Rpb24gKG9iaikge1xuXHQgIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDIzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMjQpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpLmYoJ2l0ZXJhdG9yJyk7XG5cbi8qKiovIH0sXG4vKiAyNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgJGF0ICA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpKHRydWUpO1xuXHRcblx0Ly8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG5cdCAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuXHQgIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG5cdC8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcblx0fSwgZnVuY3Rpb24oKXtcblx0ICB2YXIgTyAgICAgPSB0aGlzLl90XG5cdCAgICAsIGluZGV4ID0gdGhpcy5faVxuXHQgICAgLCBwb2ludDtcblx0ICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuXHQgIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcblx0ICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcblx0ICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xuXHR9KTtcblxuLyoqKi8gfSxcbi8qIDI2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNylcblx0ICAsIGRlZmluZWQgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXHQvLyB0cnVlICAtPiBTdHJpbmcjYXRcblx0Ly8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcblx0ICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcblx0ICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG5cdCAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG5cdCAgICAgICwgbCA9IHMubGVuZ3RoXG5cdCAgICAgICwgYSwgYjtcblx0ICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG5cdCAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuXHQgICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcblx0ICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcblx0ICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDI3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyA3LjEuNCBUb0ludGVnZXJcblx0dmFyIGNlaWwgID0gTWF0aC5jZWlsXG5cdCAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIExJQlJBUlkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcblx0ICAsICRleHBvcnQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KVxuXHQgICwgcmVkZWZpbmUgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKVxuXHQgICwgaGlkZSAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKVxuXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxuXHQgICwgSXRlcmF0b3JzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKVxuXHQgICwgJGl0ZXJDcmVhdGUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KVxuXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKVxuXHQgICwgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKVxuXHQgICwgSVRFUkFUT1IgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSgnaXRlcmF0b3InKVxuXHQgICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuXHQgICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcblx0ICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG5cdCAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXHRcblx0dmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcblx0ICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cdCAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuXHQgICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuXHQgICAgc3dpdGNoKGtpbmQpe1xuXHQgICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG5cdCAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG5cdCAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG5cdCAgfTtcblx0ICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuXHQgICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcblx0ICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG5cdCAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuXHQgICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG5cdCAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuXHQgICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuXHQgICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuXHQgICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuXHQgIC8vIEZpeCBuYXRpdmVcblx0ICBpZigkYW55TmF0aXZlKXtcblx0ICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG5cdCAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG5cdCAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcblx0ICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG5cdCAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuXHQgICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG5cdCAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcblx0ICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuXHQgICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcblx0ICB9XG5cdCAgLy8gRGVmaW5lIGl0ZXJhdG9yXG5cdCAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuXHQgICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcblx0ICB9XG5cdCAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuXHQgIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuXHQgIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG5cdCAgaWYoREVGQVVMVCl7XG5cdCAgICBtZXRob2RzID0ge1xuXHQgICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcblx0ICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuXHQgICAgICBlbnRyaWVzOiAkZW50cmllc1xuXHQgICAgfTtcblx0ICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuXHQgICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcblx0ICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG5cdCAgfVxuXHQgIHJldHVybiBtZXRob2RzO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4vKioqLyB9LFxuLyogMzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuXHQgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0sXG4vKiAzNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgY3JlYXRlICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVxuXHQgICwgZGVzY3JpcHRvciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxuXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKVxuXHQgICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblx0XG5cdC8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTEpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG5cdCAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuXHQgIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuXHR2YXIgYW5PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKVxuXHQgICwgZFBzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxuXHQgICwgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KVxuXHQgICwgSUVfUFJPVE8gICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSgnSUVfUFJPVE8nKVxuXHQgICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG5cdCAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXHRcblx0Ly8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXHR2YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG5cdCAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcblx0ICB2YXIgaWZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCkoJ2lmcmFtZScpXG5cdCAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuXHQgICAgLCBsdCAgICAgPSAnPCdcblx0ICAgICwgZ3QgICAgID0gJz4nXG5cdCAgICAsIGlmcmFtZURvY3VtZW50O1xuXHQgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHQgIF9fd2VicGFja19yZXF1aXJlX18oNDkpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuXHQgIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG5cdCAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuXHQgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG5cdCAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuXHQgIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcblx0ICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuXHQgIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuXHQgIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcblx0ICByZXR1cm4gY3JlYXRlRGljdCgpO1xuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmKE8gIT09IG51bGwpe1xuXHQgICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuXHQgICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuXHQgICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG5cdCAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cdCAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcblx0ICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuXHQgIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBkUCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXG5cdCAgLCBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXG5cdCAgLCBnZXRLZXlzICA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcblx0ICBhbk9iamVjdChPKTtcblx0ICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuXHQgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHQgICAgLCBpID0gMFxuXHQgICAgLCBQO1xuXHQgIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcblx0ICByZXR1cm4gTztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcblx0dmFyICRrZXlzICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOClcblx0ICAsIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG5cdCAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDM4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgaGFzICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMilcblx0ICAsIHRvSU9iamVjdCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpXG5cdCAgLCBhcnJheUluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKShmYWxzZSlcblx0ICAsIElFX1BST1RPICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpKCdJRV9QUk9UTycpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcblx0ICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcblx0ICAgICwgaSAgICAgID0gMFxuXHQgICAgLCByZXN1bHQgPSBbXVxuXHQgICAgLCBrZXk7XG5cdCAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuXHQgIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcblx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG5cdCAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xuXHR2YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApXG5cdCAgLCBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXHR2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG5cdC8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG5cdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KVxuXHQgICwgdG9MZW5ndGggID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mylcblx0ICAsIHRvSW5kZXggICA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcblx0ICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuXHQgICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcblx0ICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcblx0ICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuXHQgICAgICAsIHZhbHVlO1xuXHQgICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuXHQgICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuXHQgICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG5cdCAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuXHQgICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuXHQgICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG5cdCAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcblx0ICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcblx0ICB9O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDcuMS4xNSBUb0xlbmd0aFxuXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNylcblx0ICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXHR9O1xuXG4vKioqLyB9LFxuLyogNDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KVxuXHQgICwgbWF4ICAgICAgID0gTWF0aC5tYXhcblx0ICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuXHQgIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcblx0ICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQ1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NikoJ2tleXMnKVxuXHQgICwgdWlkICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcblx0ICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpXG5cdCAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuXHQgICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG5cdCAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA0NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIGlkID0gMFxuXHQgICwgcHggPSBNYXRoLnJhbmRvbSgpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG5cdCAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5cdG1vZHVsZS5leHBvcnRzID0gKFxuXHQgICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG5cdCkuc3BsaXQoJywnKTtcblxuLyoqKi8gfSxcbi8qIDQ5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKioqLyB9LFxuLyogNTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mXG5cdCAgLCBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxuXHQgICwgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSkoJ3RvU3RyaW5nVGFnJyk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuXHQgIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDUxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgc3RvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpKCd3a3MnKVxuXHQgICwgdWlkICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpXG5cdCAgLCBTeW1ib2wgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5TeW1ib2xcblx0ICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cdFxuXHR2YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuXHQgIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuXHQgICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcblx0fTtcblx0XG5cdCRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cbi8qKiovIH0sXG4vKiA1MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcblx0dmFyIGhhcyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMilcblx0ICAsIHRvT2JqZWN0ICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mylcblx0ICAsIElFX1BST1RPICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSkoJ0lFX1BST1RPJylcblx0ICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuXHQgIE8gPSB0b09iamVjdChPKTtcblx0ICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcblx0ICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcblx0ICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcblx0dmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA1NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cdHZhciBnbG9iYWwgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KVxuXHQgICwgaGlkZSAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpXG5cdCAgLCBJdGVyYXRvcnMgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMylcblx0ICAsIFRPX1NUUklOR19UQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSgndG9TdHJpbmdUYWcnKTtcblx0XG5cdGZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuXHQgIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cblx0ICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuXHQgICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblx0ICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG5cdCAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xuXHR9XG5cbi8qKiovIH0sXG4vKiA1NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpXG5cdCAgLCBzdGVwICAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nylcblx0ICAsIEl0ZXJhdG9ycyAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKVxuXHQgICwgdG9JT2JqZWN0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHRcblx0Ly8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuXHQvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuXHQvLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG5cdC8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG5cdCAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuXHQgIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG5cdCAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcblx0Ly8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG5cdH0sIGZ1bmN0aW9uKCl7XG5cdCAgdmFyIE8gICAgID0gdGhpcy5fdFxuXHQgICAgLCBraW5kICA9IHRoaXMuX2tcblx0ICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG5cdCAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuXHQgICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiBzdGVwKDEpO1xuXHQgIH1cblx0ICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcblx0ICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcblx0ICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG5cdH0sICd2YWx1ZXMnKTtcblx0XG5cdC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcblx0SXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblx0XG5cdGFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcblx0YWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5cdGFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuLyoqKi8gfSxcbi8qIDU2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cbi8qKiovIH0sXG4vKiA1NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG5cdCAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG5cdH07XG5cbi8qKiovIH0sXG4vKiA1OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9LFxuLyogNjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oOCkuU3ltYm9sO1xuXG4vKioqLyB9LFxuLyogNjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0Ly8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxuXHR2YXIgZ2xvYmFsICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpXG5cdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpXG5cdCAgLCBERVNDUklQVE9SUyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpXG5cdCAgLCAkZXhwb3J0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNilcblx0ICAsIHJlZGVmaW5lICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSlcblx0ICAsIE1FVEEgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MikuS0VZXG5cdCAgLCAkZmFpbHMgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpXG5cdCAgLCBzaGFyZWQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpXG5cdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApXG5cdCAgLCB1aWQgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpXG5cdCAgLCB3a3MgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpXG5cdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpXG5cdCAgLCB3a3NEZWZpbmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpXG5cdCAgLCBrZXlPZiAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpXG5cdCAgLCBlbnVtS2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpXG5cdCAgLCBpc0FycmF5ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpXG5cdCAgLCBhbk9iamVjdCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXG5cdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpXG5cdCAgLCB0b1ByaW1pdGl2ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpXG5cdCAgLCBjcmVhdGVEZXNjICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjApXG5cdCAgLCBfY3JlYXRlICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpXG5cdCAgLCBnT1BORXh0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpXG5cdCAgLCAkR09QRCAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpXG5cdCAgLCAkRFAgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXG5cdCAgLCAka2V5cyAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpXG5cdCAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcblx0ICAsIGRQICAgICAgICAgICAgID0gJERQLmZcblx0ICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG5cdCAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcblx0ICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cblx0ICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG5cdCAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG5cdCAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG5cdCAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuXHQgICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuXHQgICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG5cdCAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG5cdCAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG5cdCAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG5cdCAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcblx0ICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG5cdC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXHR2YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblx0XG5cdC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXHR2YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuXHQgIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuXHQgIH0pKS5hICE9IDc7XG5cdH0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG5cdCAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG5cdCAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuXHQgIGRQKGl0LCBrZXksIEQpO1xuXHQgIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcblx0fSA6IGRQO1xuXHRcblx0dmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuXHQgIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG5cdCAgc3ltLl9rID0gdGFnO1xuXHQgIHJldHVybiBzeW07XG5cdH07XG5cdFxuXHR2YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG5cdH0gOiBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcblx0fTtcblx0XG5cdHZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcblx0ICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcblx0ICBhbk9iamVjdChpdCk7XG5cdCAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcblx0ICBhbk9iamVjdChEKTtcblx0ICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG5cdCAgICBpZighRC5lbnVtZXJhYmxlKXtcblx0ICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG5cdCAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuXHQgICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcblx0ICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG5cdCAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG5cdH07XG5cdHZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuXHQgIGFuT2JqZWN0KGl0KTtcblx0ICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG5cdCAgICAsIGkgICAgPSAwXG5cdCAgICAsIGwgPSBrZXlzLmxlbmd0aFxuXHQgICAgLCBrZXk7XG5cdCAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXHR2YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG5cdCAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xuXHR9O1xuXHR2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcblx0ICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuXHQgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcblx0ICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG5cdH07XG5cdHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuXHQgIGl0ICA9IHRvSU9iamVjdChpdCk7XG5cdCAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcblx0ICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuXHQgIHZhciBEID0gZ09QRChpdCwga2V5KTtcblx0ICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0ICByZXR1cm4gRDtcblx0fTtcblx0dmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG5cdCAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcblx0ICAgICwgcmVzdWx0ID0gW11cblx0ICAgICwgaSAgICAgID0gMFxuXHQgICAgLCBrZXk7XG5cdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG5cdCAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcblx0ICB9IHJldHVybiByZXN1bHQ7XG5cdH07XG5cdHZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcblx0ICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG5cdCAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuXHQgICAgLCByZXN1bHQgPSBbXVxuXHQgICAgLCBpICAgICAgPSAwXG5cdCAgICAsIGtleTtcblx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcblx0ICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuXHQgIH0gcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0XG5cdC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuXHRpZighVVNFX05BVElWRSl7XG5cdCAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuXHQgICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG5cdCAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcblx0ICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuXHQgICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG5cdCAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcblx0ICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcblx0ICAgIHJldHVybiB3cmFwKHRhZyk7XG5cdCAgfTtcblx0ICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG5cdCAgICByZXR1cm4gdGhpcy5faztcblx0ICB9KTtcblx0XG5cdCAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cdCAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2NykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2NikuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdFxuXHQgIGlmKERFU0NSSVBUT1JTICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSl7XG5cdCAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcblx0ICB9XG5cdFxuXHQgIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG5cdCAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuXHQgIH1cblx0fVxuXHRcblx0JGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXHRcblx0Zm9yKHZhciBzeW1ib2xzID0gKFxuXHQgIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG5cdCAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuXHQpLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblx0XG5cdGZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblx0XG5cdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG5cdCAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG5cdCAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG5cdCAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG5cdCAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuXHQgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG5cdCAgfSxcblx0ICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcblx0ICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuXHQgICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG5cdCAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG5cdCAgfSxcblx0ICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG5cdCAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxuXHR9KTtcblx0XG5cdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG5cdCAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuXHQgIGNyZWF0ZTogJGNyZWF0ZSxcblx0ICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcblx0ICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuXHQgIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG5cdCAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG5cdCAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuXHQgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcblx0ICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuXHQgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuXHQgIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcblx0ICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0fSk7XG5cdFxuXHQvLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcblx0JEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG5cdCAgdmFyIFMgPSAkU3ltYm9sKCk7XG5cdCAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblx0ICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcblx0ICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuXHQgIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG5cdH0pKSwgJ0pTT04nLCB7XG5cdCAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuXHQgICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG5cdCAgICB2YXIgYXJncyA9IFtpdF1cblx0ICAgICAgLCBpICAgID0gMVxuXHQgICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG5cdCAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuXHQgICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuXHQgICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG5cdCAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdCAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG5cdCAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG5cdCAgfVxuXHR9KTtcblx0XG5cdC8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcblx0JFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygxMSkoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcblx0Ly8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuXHRzZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG5cdC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcblx0Ly8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbi8qKiovIH0sXG4vKiA2MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIE1FVEEgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NykoJ21ldGEnKVxuXHQgICwgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxuXHQgICwgaGFzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxuXHQgICwgc2V0RGVzYyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mXG5cdCAgLCBpZCAgICAgICA9IDA7XG5cdHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cdHZhciBGUkVFWkUgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygxNykoZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xuXHR9KTtcblx0dmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG5cdCAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG5cdCAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcblx0ICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cdCAgfX0pO1xuXHR9O1xuXHR2YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuXHQgIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcblx0ICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG5cdCAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuXHQgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3Rcblx0ICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG5cdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXHQgICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblx0ICAgIHNldE1ldGEoaXQpO1xuXHQgIC8vIHJldHVybiBvYmplY3QgSURcblx0ICB9IHJldHVybiBpdFtNRVRBXS5pO1xuXHR9O1xuXHR2YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuXHQgIGlmKCFoYXMoaXQsIE1FVEEpKXtcblx0ICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG5cdCAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcblx0ICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cdCAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcblx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cdCAgICBzZXRNZXRhKGl0KTtcblx0ICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXHQgIH0gcmV0dXJuIGl0W01FVEFdLnc7XG5cdH07XG5cdC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXHR2YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuXHQgIHJldHVybiBpdDtcblx0fTtcblx0dmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBLRVk6ICAgICAgTUVUQSxcblx0ICBORUVEOiAgICAgZmFsc2UsXG5cdCAgZmFzdEtleTogIGZhc3RLZXksXG5cdCAgZ2V0V2VhazogIGdldFdlYWssXG5cdCAgb25GcmVlemU6IG9uRnJlZXplXG5cdH07XG5cbi8qKiovIH0sXG4vKiA2MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGdsb2JhbCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KVxuXHQgICwgY29yZSAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpXG5cdCAgLCBMSUJSQVJZICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXG5cdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpXG5cdCAgLCBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpLmY7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG5cdCAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcblx0ICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDY0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2V0S2V5cyAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNylcblx0ICAsIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuXHQgIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuXHQgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG5cdCAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cdCAgICAsIGluZGV4ICA9IDBcblx0ICAgICwga2V5O1xuXHQgIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA2NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcblx0dmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KVxuXHQgICwgZ09QUyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpXG5cdCAgLCBwSUUgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcblx0ICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcblx0ICBpZihnZXRTeW1ib2xzKXtcblx0ICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcblx0ICAgICAgLCBpc0VudW0gID0gcElFLmZcblx0ICAgICAgLCBpICAgICAgID0gMFxuXHQgICAgICAsIGtleTtcblx0ICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuXHQgIH0gcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDY2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKioqLyB9LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKioqLyB9LFxuLyogNjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG5cdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcblx0ICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDY5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5cdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KVxuXHQgICwgZ09QTiAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCkuZlxuXHQgICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cdFxuXHR2YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuXHQgID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXHRcblx0dmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4gZ09QTihpdCk7XG5cdCAgfSBjYXRjaChlKXtcblx0ICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuXHQgIH1cblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcblx0ICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA3MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuXHR2YXIgJGtleXMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpXG5cdCAgLCBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cdFxuXHRleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuXHQgIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDcxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgcElFICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KVxuXHQgICwgY3JlYXRlRGVzYyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxuXHQgICwgdG9JT2JqZWN0ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KVxuXHQgICwgdG9QcmltaXRpdmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxuXHQgICwgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxuXHQgICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXHRcblx0ZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNikgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuXHQgIE8gPSB0b0lPYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG5cdCAgICByZXR1cm4gZ09QRChPLCBQKTtcblx0ICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cdCAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDcyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qKiovIH0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg2MykoJ2FzeW5jSXRlcmF0b3InKTtcblxuLyoqKi8gfSxcbi8qIDc0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKSgnb2JzZXJ2YWJsZScpO1xuXG4vKioqLyB9LFxuLyogNzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdHZhciBVdGlsID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFV0aWwoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBVdGlsKTtcblx0ICB9XG5cdFxuXHQgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFV0aWwsIG51bGwsIFt7XG5cdCAgICBrZXk6ICdjcmVhdGVDYW52YXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhzaXplLCBpbWFnZSkge1xuXHQgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdCAgICAgIGNhbnZhcy53aWR0aCA9IHNpemU7XG5cdCAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuXHQgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHNpemUsIHNpemUpO1xuXHQgICAgICByZXR1cm4gY2FudmFzO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3RocmVzaG9sZCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdGhyZXNob2xkKHIsIGcsIGIsIHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGIgPj0gdmFsdWUgPyAyNTUgOiAwO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0ICByZXR1cm4gVXRpbDtcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gVXRpbDtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBxYXJ0Lm1pbi5qcyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi4uL2Rpc3QvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNmY4MjhkN2E2YjMwZWNkOGQzZDkiLCJpbXBvcnQge1FSQ29kZSwgUVJVdGlsfSBmcm9tICcuL3FyY29kZSc7XG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnO1xuXG5jbGFzcyBRQXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUUFydCByZXF1aXJlZCBgb3B0aW9uc2AuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUUFydCByZXF1aXJlZCBgdmFsdWVgIG9wdGlvbi4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmltYWdlUGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUUFydCByZXF1aXJlZCBgaW1hZ2VQYXRoYCBvcHRpb24uJylcbiAgICB9XG5cbiAgICAvLyB0aGlzLnNpemUgPSAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpID8gUUFydC5ERUZBVUxUUy5zaXplIDogb3B0aW9ucy5zaXplO1xuICAgIHRoaXMuZmlsdGVyID0gKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ3VuZGVmaW5lZCcpID8gUUFydC5ERUZBVUxUUy5maWx0ZXIgOiBvcHRpb25zLmZpbHRlcjtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmltYWdlUGF0aCA9IG9wdGlvbnMuaW1hZ2VQYXRoO1xuICB9XG5cbiAgc3RhdGljIGdldCBERUZBVUxUUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gc2l6ZTogMTk1LFxuICAgICAgdmFsdWU6ICcnLFxuICAgICAgZmlsdGVyOiAndGhyZXNob2xkJ1xuICAgIH1cbiAgfVxuXG4gIG1ha2UoZWwpIHtcbiAgICB2YXIgaW1hZ2VTaXplID0gMTk1O1xuICAgIHZhciBwYWRkaW5nID0gMTI7XG4gICAgdmFyIGxldmVsID0gMTA7XG5cbiAgICB2YXIgcXIgPSBRUkNvZGUobGV2ZWwsICdIJyk7XG4gICAgcXIuYWRkRGF0YSh0aGlzLnZhbHVlKTtcbiAgICBxci5tYWtlKCk7XG4gICAgdmFyIHFySW1hZ2UgPSBxci5jcmVhdGVJbWdPYmplY3QoMyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcXJJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdmVySW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY292ZXJJbWFnZS5zcmMgPSBzZWxmLmltYWdlUGF0aDtcblxuICAgICAgICB2YXIgcmVzdWx0Q2FudmFzID0gVXRpbC5jcmVhdGVDYW52YXMoaW1hZ2VTaXplLCBxckltYWdlKTtcbiAgICAgICAgdmFyIHFyQ2FudmFzID0gVXRpbC5jcmVhdGVDYW52YXMoaW1hZ2VTaXplLCBxckltYWdlKTtcblxuICAgICAgICBjb3ZlckltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNvdmVySW1hZ2Uud2lkdGggPCBjb3ZlckltYWdlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNvdmVySW1hZ2UuaGVpZ2h0ID0gKGltYWdlU2l6ZSAtIHBhZGRpbmcgKiAyKSAqICgxLjAgKiBjb3ZlckltYWdlLmhlaWdodCAvIGNvdmVySW1hZ2Uud2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvdmVySW1hZ2Uud2lkdGggPSBpbWFnZVNpemUgLSBwYWRkaW5nICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY292ZXJJbWFnZS53aWR0aCA9IChpbWFnZVNpemUgLSBwYWRkaW5nICogMikgKiAoMS4wICogY292ZXJJbWFnZS53aWR0aCAvIGNvdmVySW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb3ZlckltYWdlLmhlaWdodCA9IGltYWdlU2l6ZSAtIHBhZGRpbmcgKiAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY292ZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNvdmVyQ2FudmFzLndpZHRoID0gaW1hZ2VTaXplO1xuICAgICAgICAgICAgY292ZXJDYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplO1xuICAgICAgICAgICAgY292ZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY292ZXJJbWFnZSwgcGFkZGluZywgcGFkZGluZywgaW1hZ2VTaXplIC0gcGFkZGluZyAqIDIsIGltYWdlU2l6ZSAtIHBhZGRpbmcgKiAyKVxuXG4gICAgICAgICAgICB2YXIgY292ZXJJbWFnZURhdGEgPSBjb3ZlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZVNpemUsIGltYWdlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgY292ZXJJbWFnZUJpbmFyeSA9IGNvdmVySW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICB2YXIgcmVzdWx0SW1hZ2VEYXRhID0gcmVzdWx0Q2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlU2l6ZSwgaW1hZ2VTaXplKTtcbiAgICAgICAgICAgIHZhciByZXN1bHRJbWFnZUJpbmFyeSA9IHJlc3VsdEltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVySW1hZ2VCaW5hcnkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoaSAvIDQpICUgaW1hZ2VTaXplO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihNYXRoLmZsb29yKGkgLyA0KSAvIGltYWdlU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoeCA8IHBhZGRpbmcgfHwgeSA8IHBhZGRpbmcgfHwgeCA+PSBpbWFnZVNpemUtcGFkZGluZyB8fCB5ID49IGltYWdlU2l6ZS1wYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2krM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHglMyA9PSAxICYmIHklMyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA8IDM2ICYmICh5IDwgMzYgfHwgeSA+PSBpbWFnZVNpemUtMzYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA+PSBpbWFnZVNpemUtMzYgJiYgeSA8IDM2KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmZpbHRlciA9PSAndGhyZXNob2xkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gVXRpbC50aHJlc2hvbGQoY292ZXJJbWFnZUJpbmFyeVtpXSwgY292ZXJJbWFnZUJpbmFyeVtpKzFdLCBjb3ZlckltYWdlQmluYXJ5W2krMl0sIDEyNyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2ldID0gZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbWFnZUJpbmFyeVtpKzFdID0gZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbWFnZUJpbmFyeVtpKzJdID0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5maWx0ZXIgPT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbWFnZUJpbmFyeVtpXSA9IGNvdmVySW1hZ2VCaW5hcnlbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2krMV0gPSBjb3ZlckltYWdlQmluYXJ5W2krMV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2krMl0gPSBjb3ZlckltYWdlQmluYXJ5W2krMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdEltYWdlQmluYXJ5W2krM10gPSBjb3ZlckltYWdlQmluYXJ5W2krM107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShyZXN1bHRJbWFnZURhdGEsIDAsIDApO1xuXG4gICAgICAgICAgICB2YXIgcGF0dGVyblBvc3Rpb24gPSBRUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKGxldmVsKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVyblBvc3Rpb24ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5Qb3N0aW9uLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcGF0dGVyblBvc3Rpb25baV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gcGF0dGVyblBvc3Rpb25bal07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKCh4ID09IDYgJiYgeSA9PSA1MCkgfHwgKHkgPT0gNiAmJiB4ID09IDUwKSB8fCAoeCA9PSA2ICYmIHkgPT0gNikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFggPSAzICogKHgtMikgKyAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0WSA9IDMgKiAoeS0yKSArIDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RXaWR0aCA9ICgzICogKHgrMykgKyAxMikgLSByZWN0WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0ID0gKDMgKiAoeSszKSArIDEyKSAtIHJlY3RZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdERhdGEgPSBxckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YShyZWN0WCwgcmVjdFksIHJlY3RXaWR0aCwgcmVjdEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEocmVjdERhdGEsIHJlY3RYLCByZWN0WSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc3VsdENhbnZhcy53aWR0aCA9IHNlbGYuc2l6ZTtcbiAgICAgICAgICAgIC8vIHJlc3VsdENhbnZhcy5oZWlnaHQgPSBzZWxmLnNpemU7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHJlc3VsdENhbnZhcyk7XG4gICAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5RQXJ0ID0gUUFydDtcbmV4cG9ydCBkZWZhdWx0IHdpbmRvdy5RQXJ0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3FhcnQuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gUVIgQ29kZSBHZW5lcmF0b3IgZm9yIEphdmFTY3JpcHRcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgS2F6dWhpa28gQXJhc2Vcbi8vXG4vLyBVUkw6IGh0dHA6Ly93d3cuZC1wcm9qZWN0LmNvbS9cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4vLyAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbi8vXG4vLyBUaGUgd29yZCAnUVIgQ29kZScgaXMgcmVnaXN0ZXJlZCB0cmFkZW1hcmsgb2Zcbi8vIERFTlNPIFdBVkUgSU5DT1JQT1JBVEVEXG4vLyAgaHR0cDovL3d3dy5kZW5zby13YXZlLmNvbS9xcmNvZGUvZmFxcGF0ZW50LWUuaHRtbFxuLy9cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBxcmNvZGUgPSBmdW5jdGlvbigpIHtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcmNvZGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogcXJjb2RlXG4gICAqIEBwYXJhbSB0eXBlTnVtYmVyIDEgdG8gNDBcbiAgICogQHBhcmFtIGVycm9yQ29ycmVjdGlvbkxldmVsICdMJywnTScsJ1EnLCdIJ1xuICAgKi9cbiAgdmFyIHFyY29kZSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cbiAgICB2YXIgUEFEMCA9IDB4RUM7XG4gICAgdmFyIFBBRDEgPSAweDExO1xuXG4gICAgdmFyIF90eXBlTnVtYmVyID0gdHlwZU51bWJlcjtcbiAgICB2YXIgX2Vycm9yQ29ycmVjdGlvbkxldmVsID0gUVJFcnJvckNvcnJlY3Rpb25MZXZlbFtlcnJvckNvcnJlY3Rpb25MZXZlbF07XG4gICAgdmFyIF9tb2R1bGVzID0gbnVsbDtcbiAgICB2YXIgX21vZHVsZUNvdW50ID0gMDtcbiAgICB2YXIgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgdmFyIF9kYXRhTGlzdCA9IG5ldyBBcnJheSgpO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICB2YXIgbWFrZUltcGwgPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXG4gICAgICBfbW9kdWxlQ291bnQgPSBfdHlwZU51bWJlciAqIDQgKyAxNztcbiAgICAgIF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlQ291bnQpIHtcbiAgICAgICAgdmFyIG1vZHVsZXMgPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICBtb2R1bGVzW3Jvd10gPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgbW9kdWxlc1tyb3ddW2NvbF0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlcztcbiAgICAgIH0oX21vZHVsZUNvdW50KTtcblxuICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCAwKTtcbiAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oX21vZHVsZUNvdW50IC0gNywgMCk7XG4gICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIF9tb2R1bGVDb3VudCAtIDcpO1xuICAgICAgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4oKTtcbiAgICAgIHNldHVwVGltaW5nUGF0dGVybigpO1xuICAgICAgc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XG5cbiAgICAgIGlmIChfdHlwZU51bWJlciA+PSA3KSB7XG4gICAgICAgIHNldHVwVHlwZU51bWJlcih0ZXN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9kYXRhQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgICBfZGF0YUNhY2hlID0gY3JlYXRlRGF0YShfdHlwZU51bWJlciwgX2Vycm9yQ29ycmVjdGlvbkxldmVsLCBfZGF0YUxpc3QpO1xuICAgICAgfVxuXG4gICAgICBtYXBEYXRhKF9kYXRhQ2FjaGUsIG1hc2tQYXR0ZXJuKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4gPSBmdW5jdGlvbihyb3csIGNvbCkge1xuXG4gICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgciArPSAxKSB7XG5cbiAgICAgICAgaWYgKHJvdyArIHIgPD0gLTEgfHwgX21vZHVsZUNvdW50IDw9IHJvdyArIHIpIGNvbnRpbnVlO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjICs9IDEpIHtcblxuICAgICAgICAgIGlmIChjb2wgKyBjIDw9IC0xIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wgKyBjKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmICggKDAgPD0gciAmJiByIDw9IDYgJiYgKGMgPT0gMCB8fCBjID09IDYpIClcbiAgICAgICAgICAgICAgfHwgKDAgPD0gYyAmJiBjIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIClcbiAgICAgICAgICAgICAgfHwgKDIgPD0gciAmJiByIDw9IDQgJiYgMiA8PSBjICYmIGMgPD0gNCkgKSB7XG4gICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRCZXN0TWFza1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG1pbkxvc3RQb2ludCA9IDA7XG4gICAgICB2YXIgcGF0dGVybiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG5cbiAgICAgICAgbWFrZUltcGwodHJ1ZSwgaSk7XG5cbiAgICAgICAgdmFyIGxvc3RQb2ludCA9IFFSVXRpbC5nZXRMb3N0UG9pbnQoX3RoaXMpO1xuXG4gICAgICAgIGlmIChpID09IDAgfHwgbWluTG9zdFBvaW50ID4gbG9zdFBvaW50KSB7XG4gICAgICAgICAgbWluTG9zdFBvaW50ID0gbG9zdFBvaW50O1xuICAgICAgICAgIHBhdHRlcm4gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXBUaW1pbmdQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGZvciAodmFyIHIgPSA4OyByIDwgX21vZHVsZUNvdW50IC0gODsgciArPSAxKSB7XG4gICAgICAgIGlmIChfbW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgX21vZHVsZXNbcl1bNl0gPSAociAlIDIgPT0gMCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGMgPSA4OyBjIDwgX21vZHVsZUNvdW50IC0gODsgYyArPSAxKSB7XG4gICAgICAgIGlmIChfbW9kdWxlc1s2XVtjXSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgX21vZHVsZXNbNl1bY10gPSAoYyAlIDIgPT0gMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcG9zID0gUVJVdGlsLmdldFBhdHRlcm5Qb3NpdGlvbihfdHlwZU51bWJlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSArPSAxKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqICs9IDEpIHtcblxuICAgICAgICAgIHZhciByb3cgPSBwb3NbaV07XG4gICAgICAgICAgdmFyIGNvbCA9IHBvc1tqXTtcblxuICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgciA9IC0yOyByIDw9IDI7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gLTI7IGMgPD0gMjsgYyArPSAxKSB7XG5cbiAgICAgICAgICAgICAgaWYgKHIgPT0gLTIgfHwgciA9PSAyIHx8IGMgPT0gLTIgfHwgYyA9PSAyXG4gICAgICAgICAgICAgICAgICB8fCAociA9PSAwICYmIGMgPT0gMCkgKSB7XG4gICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldHVwVHlwZU51bWJlciA9IGZ1bmN0aW9uKHRlc3QpIHtcblxuICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZU51bWJlcihfdHlwZU51bWJlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcbiAgICAgICAgX21vZHVsZXNbTWF0aC5mbG9vcihpIC8gMyldW2kgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdID0gbW9kO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE4OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG4gICAgICAgIF9tb2R1bGVzW2kgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdW01hdGguZmxvb3IoaSAvIDMpXSA9IG1vZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldHVwVHlwZUluZm8gPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXG4gICAgICB2YXIgZGF0YSA9IChfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPDwgMykgfCBtYXNrUGF0dGVybjtcbiAgICAgIHZhciBiaXRzID0gUVJVdGlsLmdldEJDSFR5cGVJbmZvKGRhdGEpO1xuXG4gICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSArPSAxKSB7XG5cbiAgICAgICAgdmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cbiAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgX21vZHVsZXNbaV1bOF0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IDgpIHtcbiAgICAgICAgICBfbW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vZHVsZXNbX21vZHVsZUNvdW50IC0gMTUgKyBpXVs4XSA9IG1vZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBob3Jpem9udGFsXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpICs9IDEpIHtcblxuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuICAgICAgICBpZiAoaSA8IDgpIHtcbiAgICAgICAgICBfbW9kdWxlc1s4XVtfbW9kdWxlQ291bnQgLSBpIC0gMV0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IDkpIHtcbiAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkgLSAxICsgMV0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vZHVsZXNbOF1bMTUgLSBpIC0gMV0gPSBtb2Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZml4ZWQgbW9kdWxlXG4gICAgICBfbW9kdWxlc1tfbW9kdWxlQ291bnQgLSA4XVs4XSA9ICghdGVzdCk7XG4gICAgfTtcblxuICAgIHZhciBtYXBEYXRhID0gZnVuY3Rpb24oZGF0YSwgbWFza1BhdHRlcm4pIHtcblxuICAgICAgdmFyIGluYyA9IC0xO1xuICAgICAgdmFyIHJvdyA9IF9tb2R1bGVDb3VudCAtIDE7XG4gICAgICB2YXIgYml0SW5kZXggPSA3O1xuICAgICAgdmFyIGJ5dGVJbmRleCA9IDA7XG4gICAgICB2YXIgbWFza0Z1bmMgPSBRUlV0aWwuZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKTtcblxuICAgICAgZm9yICh2YXIgY29sID0gX21vZHVsZUNvdW50IC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcblxuICAgICAgICBpZiAoY29sID09IDYpIGNvbCAtPSAxO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMgKz0gMSkge1xuXG4gICAgICAgICAgICBpZiAoX21vZHVsZXNbcm93XVtjb2wgLSBjXSA9PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgdmFyIGRhcmsgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoYnl0ZUluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkYXJrID0gKCAoIChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4KSAmIDEpID09IDEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXNrRnVuYyhyb3csIGNvbCAtIGMpO1xuXG4gICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgZGFyayA9ICFkYXJrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX21vZHVsZXNbcm93XVtjb2wgLSBjXSA9IGRhcms7XG4gICAgICAgICAgICAgIGJpdEluZGV4IC09IDE7XG5cbiAgICAgICAgICAgICAgaWYgKGJpdEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgYml0SW5kZXggPSA3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ICs9IGluYztcblxuICAgICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgIHJvdyAtPSBpbmM7XG4gICAgICAgICAgICBpbmMgPSAtaW5jO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVCeXRlcyA9IGZ1bmN0aW9uKGJ1ZmZlciwgcnNCbG9ja3MpIHtcblxuICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgIHZhciBtYXhEY0NvdW50ID0gMDtcbiAgICAgIHZhciBtYXhFY0NvdW50ID0gMDtcblxuICAgICAgdmFyIGRjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuICAgICAgdmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG5cbiAgICAgICAgdmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG4gICAgICAgIHZhciBlY0NvdW50ID0gcnNCbG9ja3Nbcl0udG90YWxDb3VudCAtIGRjQ291bnQ7XG5cbiAgICAgICAgbWF4RGNDb3VudCA9IE1hdGgubWF4KG1heERjQ291bnQsIGRjQ291bnQpO1xuICAgICAgICBtYXhFY0NvdW50ID0gTWF0aC5tYXgobWF4RWNDb3VudCwgZWNDb3VudCk7XG5cbiAgICAgICAgZGNkYXRhW3JdID0gbmV3IEFycmF5KGRjQ291bnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGNkYXRhW3JdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgZGNkYXRhW3JdW2ldID0gMHhmZiAmIGJ1ZmZlci5nZXRCdWZmZXIoKVtpICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gZGNDb3VudDtcblxuICAgICAgICB2YXIgcnNQb2x5ID0gUVJVdGlsLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwoZWNDb3VudCk7XG4gICAgICAgIHZhciByYXdQb2x5ID0gcXJQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG5cbiAgICAgICAgdmFyIG1vZFBvbHkgPSByYXdQb2x5Lm1vZChyc1BvbHkpO1xuICAgICAgICBlY2RhdGFbcl0gPSBuZXcgQXJyYXkocnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNkYXRhW3JdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIG1vZEluZGV4ID0gaSArIG1vZFBvbHkuZ2V0TGVuZ3RoKCkgLSBlY2RhdGFbcl0ubGVuZ3RoO1xuICAgICAgICAgIGVjZGF0YVtyXVtpXSA9IChtb2RJbmRleCA+PSAwKT8gbW9kUG9seS5nZXRBdChtb2RJbmRleCkgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRvdGFsQ29kZUNvdW50ICs9IHJzQmxvY2tzW2ldLnRvdGFsQ291bnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gbmV3IEFycmF5KHRvdGFsQ29kZUNvdW50KTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGNDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA8IGRjZGF0YVtyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZGNkYXRhW3JdW2ldO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhFY0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIGlmIChpIDwgZWNkYXRhW3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBlY2RhdGFbcl1baV07XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURhdGEgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgZGF0YUxpc3QpIHtcblxuICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcblxuICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpXTtcbiAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldE1vZGUoKSwgNCk7XG4gICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcikgKTtcbiAgICAgICAgZGF0YS53cml0ZShidWZmZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxjIG51bSBtYXggZGF0YS5cbiAgICAgIHZhciB0b3RhbERhdGFDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvZGUgbGVuZ3RoIG92ZXJmbG93LiAoJ1xuICAgICAgICAgICsgYnVmZmVyLmdldExlbmd0aEluQml0cygpXG4gICAgICAgICAgKyAnPidcbiAgICAgICAgICArIHRvdGFsRGF0YUNvdW50ICogOFxuICAgICAgICAgICsgJyknKTtcbiAgICAgIH1cblxuICAgICAgLy8gZW5kIGNvZGVcbiAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICBidWZmZXIucHV0KDAsIDQpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYWRkaW5nXG4gICAgICB3aGlsZSAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICUgOCAhPSAwKSB7XG4gICAgICAgIGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYWRkaW5nXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1dChQQUQwLCA4KTtcblxuICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXQoUEFEMSwgOCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVCeXRlcyhidWZmZXIsIHJzQmxvY2tzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHtcblxuICAgICAgbW9kZSA9IG1vZGUgfHwgJ0J5dGUnO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IG51bGw7XG5cbiAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICBjYXNlICdOdW1lcmljJyA6XG4gICAgICAgIG5ld0RhdGEgPSBxck51bWJlcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBbHBoYW51bWVyaWMnIDpcbiAgICAgICAgbmV3RGF0YSA9IHFyQWxwaGFOdW0oZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQnl0ZScgOlxuICAgICAgICBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdLYW5qaScgOlxuICAgICAgICBuZXdEYXRhID0gcXJLYW5qaShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgdGhyb3cgJ21vZGU6JyArIG1vZGU7XG4gICAgICB9XG5cbiAgICAgIF9kYXRhTGlzdC5wdXNoKG5ld0RhdGEpO1xuICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLmlzRGFyayA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG4gICAgICBpZiAocm93IDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgX21vZHVsZUNvdW50IDw9IGNvbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocm93ICsgJywnICsgY29sKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfbW9kdWxlc1tyb3ddW2NvbF07XG4gICAgfTtcblxuICAgIF90aGlzLmdldE1vZHVsZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX21vZHVsZUNvdW50O1xuICAgIH07XG5cbiAgICBfdGhpcy5tYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkgKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlVGFibGVUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgcXJIdG1sID0gJyc7XG5cbiAgICAgIHFySHRtbCArPSAnPHRhYmxlIHN0eWxlPVwiJztcbiAgICAgIHFySHRtbCArPSAnIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7JztcbiAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcbiAgICAgIHFySHRtbCArPSAnIHBhZGRpbmc6IDBweDsgbWFyZ2luOiAnICsgbWFyZ2luICsgJ3B4Oyc7XG4gICAgICBxckh0bWwgKz0gJ1wiPic7XG4gICAgICBxckh0bWwgKz0gJzx0Ym9keT4nO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuXG4gICAgICAgIHFySHRtbCArPSAnPHRyPic7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjICs9IDEpIHtcbiAgICAgICAgICBxckh0bWwgKz0gJzx0ZCBzdHlsZT1cIic7XG4gICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcbiAgICAgICAgICBxckh0bWwgKz0gJyBwYWRkaW5nOiAwcHg7IG1hcmdpbjogMHB4Oyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgd2lkdGg6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGhlaWdodDogJyArIGNlbGxTaXplICsgJ3B4Oyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgYmFja2dyb3VuZC1jb2xvcjogJztcbiAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMpPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZic7XG4gICAgICAgICAgcXJIdG1sICs9ICc7JztcbiAgICAgICAgICBxckh0bWwgKz0gJ1wiLz4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcXJIdG1sICs9ICc8L3RyPic7XG4gICAgICB9XG5cbiAgICAgIHFySHRtbCArPSAnPC90Ym9keT4nO1xuICAgICAgcXJIdG1sICs9ICc8L3RhYmxlPic7XG5cbiAgICAgIHJldHVybiBxckh0bWw7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZVN2Z1RhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcblxuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgYywgbWMsIHIsIG1yLCBxclN2Zz0nJywgcmVjdDtcblxuICAgICAgcmVjdCA9ICdsJyArIGNlbGxTaXplICsgJywwIDAsJyArIGNlbGxTaXplICtcbiAgICAgICAgJyAtJyArIGNlbGxTaXplICsgJywwIDAsLScgKyBjZWxsU2l6ZSArICd6ICc7XG5cbiAgICAgIHFyU3ZnICs9ICc8c3ZnJztcbiAgICAgIHFyU3ZnICs9ICcgd2lkdGg9XCInICsgc2l6ZSArICdweFwiJztcbiAgICAgIHFyU3ZnICs9ICcgaGVpZ2h0PVwiJyArIHNpemUgKyAncHhcIic7XG4gICAgICBxclN2ZyArPSAnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIic7XG4gICAgICBxclN2ZyArPSAnPic7XG4gICAgICBxclN2ZyArPSAnPHBhdGggZD1cIic7XG5cbiAgICAgIGZvciAociA9IDA7IHIgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyByICs9IDEpIHtcbiAgICAgICAgbXIgPSByICogY2VsbFNpemUgKyBtYXJnaW47XG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjICs9IDEpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNEYXJrKHIsIGMpICkge1xuICAgICAgICAgICAgbWMgPSBjKmNlbGxTaXplK21hcmdpbjtcbiAgICAgICAgICAgIHFyU3ZnICs9ICdNJyArIG1jICsgJywnICsgbXIgKyByZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxclN2ZyArPSAnXCIgc3Ryb2tlPVwidHJhbnNwYXJlbnRcIiBmaWxsPVwiYmxhY2tcIi8+JztcbiAgICAgIHFyU3ZnICs9ICc8L3N2Zz4nO1xuXG4gICAgICByZXR1cm4gcXJTdmc7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZUltZ1RhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcblxuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG5cbiAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBtaW4gPSBtYXJnaW47XG4gICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUltZ1RhZyhzaXplLCBzaXplLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmIChtaW4gPD0geCAmJiB4IDwgbWF4ICYmIG1pbiA8PSB5ICYmIHkgPCBtYXgpIHtcbiAgICAgICAgICB2YXIgYyA9IE1hdGguZmxvb3IoICh4IC0gbWluKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICB2YXIgciA9IE1hdGguZmxvb3IoICh5IC0gbWluKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaXNEYXJrKHIsIGMpPyAwIDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH07XG5cbiAgICBfdGhpcy5jcmVhdGVJbWdPYmplY3QgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgbWluID0gbWFyZ2luO1xuICAgICAgdmFyIG1heCA9IHNpemUgLSBtYXJnaW47XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbWdPYmplY3Qoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSAmJiB5IDwgbWF4KSB7XG4gICAgICAgICAgdmFyIGMgPSBNYXRoLmZsb29yKCAoeCAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCAoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmlzRGFyayhyLCBjKT8gMCA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyY29kZS5zdHJpbmdUb0J5dGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcXJjb2RlLnN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgIGJ5dGVzLnB1c2goYyAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQHBhcmFtIHVuaWNvZGVEYXRhIGJhc2U2NCBzdHJpbmcgb2YgYnl0ZSBhcnJheS5cbiAgICogWzE2Yml0IFVuaWNvZGVdLFsxNmJpdCBCeXRlc10sIC4uLlxuICAgKiBAcGFyYW0gbnVtQ2hhcnNcbiAgICovXG4gIHFyY29kZS5jcmVhdGVTdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24odW5pY29kZURhdGEsIG51bUNoYXJzKSB7XG5cbiAgICAvLyBjcmVhdGUgY29udmVyc2lvbiBtYXAuXG5cbiAgICB2YXIgdW5pY29kZU1hcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYmluID0gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0odW5pY29kZURhdGEpO1xuICAgICAgdmFyIHJlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSBiaW4ucmVhZCgpO1xuICAgICAgICBpZiAoYiA9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHZhciB1bmljb2RlTWFwID0ge307XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgYjAgPSBiaW4ucmVhZCgpO1xuICAgICAgICBpZiAoYjAgPT0gLTEpIGJyZWFrO1xuICAgICAgICB2YXIgYjEgPSByZWFkKCk7XG4gICAgICAgIHZhciBiMiA9IHJlYWQoKTtcbiAgICAgICAgdmFyIGIzID0gcmVhZCgpO1xuICAgICAgICB2YXIgayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIChiMCA8PCA4KSB8IGIxKTtcbiAgICAgICAgdmFyIHYgPSAoYjIgPDwgOCkgfCBiMztcbiAgICAgICAgdW5pY29kZU1hcFtrXSA9IHY7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgIT0gbnVtQ2hhcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvdW50ICsgJyAhPSAnICsgbnVtQ2hhcnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pY29kZU1hcDtcbiAgICB9KCk7XG5cbiAgICB2YXIgdW5rbm93bkNoYXIgPSAnPycuY2hhckNvZGVBdCgwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICBieXRlcy5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiID0gdW5pY29kZU1hcFtzLmNoYXJBdChpKV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBiID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoIChiICYgMHhmZikgPT0gYikge1xuICAgICAgICAgICAgICAvLyAxYnl0ZVxuICAgICAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gMmJ5dGVzXG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiA+Pj4gOCk7XG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiAmIDB4ZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHVua25vd25DaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTW9kZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUk1vZGUgPSB7XG4gICAgTU9ERV9OVU1CRVIgOiAgICAxIDw8IDAsXG4gICAgTU9ERV9BTFBIQV9OVU0gOiAxIDw8IDEsXG4gICAgTU9ERV84QklUX0JZVEUgOiAxIDw8IDIsXG4gICAgTU9ERV9LQU5KSSA6ICAgICAxIDw8IDNcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUkVycm9yQ29ycmVjdGlvbkxldmVsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSB7XG4gICAgTCA6IDEsXG4gICAgTSA6IDAsXG4gICAgUSA6IDMsXG4gICAgSCA6IDJcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUk1hc2tQYXR0ZXJuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSTWFza1BhdHRlcm4gPSB7XG4gICAgUEFUVEVSTjAwMCA6IDAsXG4gICAgUEFUVEVSTjAwMSA6IDEsXG4gICAgUEFUVEVSTjAxMCA6IDIsXG4gICAgUEFUVEVSTjAxMSA6IDMsXG4gICAgUEFUVEVSTjEwMCA6IDQsXG4gICAgUEFUVEVSTjEwMSA6IDUsXG4gICAgUEFUVEVSTjExMCA6IDYsXG4gICAgUEFUVEVSTjExMSA6IDdcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUlV0aWxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgUVJVdGlsID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgUEFUVEVSTl9QT1NJVElPTl9UQUJMRSA9IFtcbiAgICAgIFtdLFxuICAgICAgWzYsIDE4XSxcbiAgICAgIFs2LCAyMl0sXG4gICAgICBbNiwgMjZdLFxuICAgICAgWzYsIDMwXSxcbiAgICAgIFs2LCAzNF0sXG4gICAgICBbNiwgMjIsIDM4XSxcbiAgICAgIFs2LCAyNCwgNDJdLFxuICAgICAgWzYsIDI2LCA0Nl0sXG4gICAgICBbNiwgMjgsIDUwXSxcbiAgICAgIFs2LCAzMCwgNTRdLFxuICAgICAgWzYsIDMyLCA1OF0sXG4gICAgICBbNiwgMzQsIDYyXSxcbiAgICAgIFs2LCAyNiwgNDYsIDY2XSxcbiAgICAgIFs2LCAyNiwgNDgsIDcwXSxcbiAgICAgIFs2LCAyNiwgNTAsIDc0XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4XSxcbiAgICAgIFs2LCAzMCwgNTYsIDgyXSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2XSxcbiAgICAgIFs2LCAzNCwgNjIsIDkwXSxcbiAgICAgIFs2LCAyOCwgNTAsIDcyLCA5NF0sXG4gICAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuICAgICAgWzYsIDMwLCA1NCwgNzgsIDEwMl0sXG4gICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2XSxcbiAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuICAgICAgWzYsIDMwLCA1OCwgODYsIDExNF0sXG4gICAgICBbNiwgMzQsIDYyLCA5MCwgMTE4XSxcbiAgICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sXG4gICAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLFxuICAgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcbiAgICAgIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sXG4gICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLFxuICAgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSxcbiAgICAgIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSxcbiAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcbiAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSxcbiAgICAgIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgIF07XG4gICAgdmFyIEcxNSA9ICgxIDw8IDEwKSB8ICgxIDw8IDgpIHwgKDEgPDwgNSkgfCAoMSA8PCA0KSB8ICgxIDw8IDIpIHwgKDEgPDwgMSkgfCAoMSA8PCAwKTtcbiAgICB2YXIgRzE4ID0gKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKTtcbiAgICB2YXIgRzE1X01BU0sgPSAoMSA8PCAxNCkgfCAoMSA8PCAxMikgfCAoMSA8PCAxMCkgfCAoMSA8PCA0KSB8ICgxIDw8IDEpO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICB2YXIgZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZGlnaXQgPSAwO1xuICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xuICAgICAgICBkaWdpdCArPSAxO1xuICAgICAgICBkYXRhID4+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWdpdDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QkNIVHlwZUluZm8gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICB3aGlsZSAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTUpID49IDApIHtcbiAgICAgICAgZCBePSAoRzE1IDw8IChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSkgKSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICggKGRhdGEgPDwgMTApIHwgZCkgXiBHMTVfTUFTSztcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QkNIVHlwZU51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBkID0gZGF0YSA8PCAxMjtcbiAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCkgPj0gMCkge1xuICAgICAgICBkIF49IChHMTggPDwgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSApICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGRhdGEgPDwgMTIpIHwgZDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0UGF0dGVyblBvc2l0aW9uID0gZnVuY3Rpb24odHlwZU51bWJlcikge1xuICAgICAgcmV0dXJuIFBBVFRFUk5fUE9TSVRJT05fVEFCTEVbdHlwZU51bWJlciAtIDFdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRNYXNrRnVuY3Rpb24gPSBmdW5jdGlvbihtYXNrUGF0dGVybikge1xuXG4gICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAwIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICsgaikgJSAyID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMSA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiBpICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMTAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gaiAlIDMgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDExIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICsgaikgJSAzID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMCA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSApICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDEgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMyA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKCAoaSAqIGopICUgMiArIChpICogaikgJSAzKSAlIDIgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTExIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuICggKGkgKiBqKSAlIDMgKyAoaSArIGopICUgMikgJSAyID09IDA7IH07XG5cbiAgICAgIGRlZmF1bHQgOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBtYXNrUGF0dGVybjonICsgbWFza1BhdHRlcm4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsID0gZnVuY3Rpb24oZXJyb3JDb3JyZWN0TGVuZ3RoKSB7XG4gICAgICB2YXIgYSA9IHFyUG9seW5vbWlhbChbMV0sIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvckNvcnJlY3RMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhID0gYS5tdWx0aXBseShxclBvbHlub21pYWwoWzEsIFFSTWF0aC5nZXhwKGkpXSwgMCkgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbihtb2RlLCB0eXBlKSB7XG5cbiAgICAgIGlmICgxIDw9IHR5cGUgJiYgdHlwZSA8IDEwKSB7XG5cbiAgICAgICAgLy8gMSAtIDlcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxMDtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gOTtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEUgOiByZXR1cm4gODtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSSAgICAgOiByZXR1cm4gODtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPCAyNykge1xuXG4gICAgICAgIC8vIDEwIC0gMjZcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxMjtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gMTE7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiAxMDtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPCA0MSkge1xuXG4gICAgICAgIC8vIDI3IC0gNDBcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxNDtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gMTM7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiAxMjtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGU6JyArIHR5cGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMb3N0UG9pbnQgPSBmdW5jdGlvbihxcmNvZGUpIHtcblxuICAgICAgdmFyIG1vZHVsZUNvdW50ID0gcXJjb2RlLmdldE1vZHVsZUNvdW50KCk7XG5cbiAgICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuXG4gICAgICAvLyBMRVZFTDFcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuXG4gICAgICAgICAgdmFyIHNhbWVDb3VudCA9IDA7XG4gICAgICAgICAgdmFyIGRhcmsgPSBxcmNvZGUuaXNEYXJrKHJvdywgY29sKTtcblxuICAgICAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSAxOyByICs9IDEpIHtcblxuICAgICAgICAgICAgaWYgKHJvdyArIHIgPCAwIHx8IG1vZHVsZUNvdW50IDw9IHJvdyArIHIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSAxOyBjICs9IDEpIHtcblxuICAgICAgICAgICAgICBpZiAoY29sICsgYyA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHIgPT0gMCAmJiBjID09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkYXJrID09IHFyY29kZS5pc0Rhcmsocm93ICsgciwgY29sICsgYykgKSB7XG4gICAgICAgICAgICAgICAgc2FtZUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2FtZUNvdW50ID4gNSkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9ICgzICsgc2FtZUNvdW50IC0gNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBMRVZFTDJcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSAxOyByb3cgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDE7IGNvbCArPSAxKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMSkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCArIDEpICkgY291bnQgKz0gMTtcbiAgICAgICAgICBpZiAoY291bnQgPT0gMCB8fCBjb3VudCA9PSA0KSB7XG4gICAgICAgICAgICBsb3N0UG9pbnQgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTEVWRUwzXG5cbiAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDY7IGNvbCArPSAxKSB7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpXG4gICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMSlcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAyKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDMpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNClcbiAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyA1KVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDYpICkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9IDQwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3cgKz0gMSkge1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKVxuICAgICAgICAgICAgICAmJiAhcXJjb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdyArIDIsIGNvbClcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgMywgY29sKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3cgKyA0LCBjb2wpXG4gICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdyArIDUsIGNvbClcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgNiwgY29sKSApIHtcbiAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTEVWRUw0XG5cbiAgICAgIHZhciBkYXJrQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpICkge1xuICAgICAgICAgICAgZGFya0NvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByYXRpbyA9IE1hdGguYWJzKDEwMCAqIGRhcmtDb3VudCAvIG1vZHVsZUNvdW50IC8gbW9kdWxlQ291bnQgLSA1MCkgLyA1O1xuICAgICAgbG9zdFBvaW50ICs9IHJhdGlvICogMTA7XG5cbiAgICAgIHJldHVybiBsb3N0UG9pbnQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTWF0aFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUk1hdGggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBFWFBfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICB2YXIgTE9HX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbiAgICAvLyBpbml0aWFsaXplIHRhYmxlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgICBFWFBfVEFCTEVbaV0gPSAxIDw8IGk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSA4OyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgICAgIEVYUF9UQUJMRVtpXSA9IEVYUF9UQUJMRVtpIC0gNF1cbiAgICAgICAgXiBFWFBfVEFCTEVbaSAtIDVdXG4gICAgICAgIF4gRVhQX1RBQkxFW2kgLSA2XVxuICAgICAgICBeIEVYUF9UQUJMRVtpIC0gOF07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU1OyBpICs9IDEpIHtcbiAgICAgIExPR19UQUJMRVtFWFBfVEFCTEVbaV0gXSA9IGk7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nbG9nID0gZnVuY3Rpb24obikge1xuXG4gICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbG9nKCcgKyBuICsgJyknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIExPR19UQUJMRVtuXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V4cCA9IGZ1bmN0aW9uKG4pIHtcblxuICAgICAgd2hpbGUgKG4gPCAwKSB7XG4gICAgICAgIG4gKz0gMjU1O1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobiA+PSAyNTYpIHtcbiAgICAgICAgbiAtPSAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBFWFBfVEFCTEVbbl07XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyUG9seW5vbWlhbFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGZ1bmN0aW9uIHFyUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG5cbiAgICBpZiAodHlwZW9mIG51bS5sZW5ndGggPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihudW0ubGVuZ3RoICsgJy8nICsgc2hpZnQpO1xuICAgIH1cblxuICAgIHZhciBfbnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBudW0ubGVuZ3RoICYmIG51bVtvZmZzZXRdID09IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICB2YXIgX251bSA9IG5ldyBBcnJheShudW0ubGVuZ3RoIC0gb2Zmc2V0ICsgc2hpZnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoIC0gb2Zmc2V0OyBpICs9IDEpIHtcbiAgICAgICAgX251bVtpXSA9IG51bVtpICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfbnVtO1xuICAgIH0oKTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIF9udW1baW5kZXhdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbnVtLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMubXVsdGlwbHkgPSBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciBudW0gPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkgKyBlLmdldExlbmd0aCgpIC0gMSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuZ2V0TGVuZ3RoKCk7IGkgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGUuZ2V0TGVuZ3RoKCk7IGogKz0gMSkge1xuICAgICAgICAgIG51bVtpICsgal0gXj0gUVJNYXRoLmdleHAoUVJNYXRoLmdsb2coX3RoaXMuZ2V0QXQoaSkgKSArIFFSTWF0aC5nbG9nKGUuZ2V0QXQoaikgKSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtLCAwKTtcbiAgICB9O1xuXG4gICAgX3RoaXMubW9kID0gZnVuY3Rpb24oZSkge1xuXG4gICAgICBpZiAoX3RoaXMuZ2V0TGVuZ3RoKCkgLSBlLmdldExlbmd0aCgpIDwgMCkge1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciByYXRpbyA9IFFSTWF0aC5nbG9nKF90aGlzLmdldEF0KDApICkgLSBRUk1hdGguZ2xvZyhlLmdldEF0KDApICk7XG5cbiAgICAgIHZhciBudW0gPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuZ2V0TGVuZ3RoKCk7IGkgKz0gMSkge1xuICAgICAgICBudW1baV0gPSBfdGhpcy5nZXRBdChpKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmdldExlbmd0aCgpOyBpICs9IDEpIHtcbiAgICAgICAgbnVtW2ldIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKGUuZ2V0QXQoaSkgKSArIHJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVjdXJzaXZlIGNhbGxcbiAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtLCAwKS5tb2QoZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUlJTQmxvY2tcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgUVJSU0Jsb2NrID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgUlNfQkxPQ0tfVEFCTEUgPSBbXG5cbiAgICAgIC8vIExcbiAgICAgIC8vIE1cbiAgICAgIC8vIFFcbiAgICAgIC8vIEhcblxuICAgICAgLy8gMVxuICAgICAgWzEsIDI2LCAxOV0sXG4gICAgICBbMSwgMjYsIDE2XSxcbiAgICAgIFsxLCAyNiwgMTNdLFxuICAgICAgWzEsIDI2LCA5XSxcblxuICAgICAgLy8gMlxuICAgICAgWzEsIDQ0LCAzNF0sXG4gICAgICBbMSwgNDQsIDI4XSxcbiAgICAgIFsxLCA0NCwgMjJdLFxuICAgICAgWzEsIDQ0LCAxNl0sXG5cbiAgICAgIC8vIDNcbiAgICAgIFsxLCA3MCwgNTVdLFxuICAgICAgWzEsIDcwLCA0NF0sXG4gICAgICBbMiwgMzUsIDE3XSxcbiAgICAgIFsyLCAzNSwgMTNdLFxuXG4gICAgICAvLyA0XG4gICAgICBbMSwgMTAwLCA4MF0sXG4gICAgICBbMiwgNTAsIDMyXSxcbiAgICAgIFsyLCA1MCwgMjRdLFxuICAgICAgWzQsIDI1LCA5XSxcblxuICAgICAgLy8gNVxuICAgICAgWzEsIDEzNCwgMTA4XSxcbiAgICAgIFsyLCA2NywgNDNdLFxuICAgICAgWzIsIDMzLCAxNSwgMiwgMzQsIDE2XSxcbiAgICAgIFsyLCAzMywgMTEsIDIsIDM0LCAxMl0sXG5cbiAgICAgIC8vIDZcbiAgICAgIFsyLCA4NiwgNjhdLFxuICAgICAgWzQsIDQzLCAyN10sXG4gICAgICBbNCwgNDMsIDE5XSxcbiAgICAgIFs0LCA0MywgMTVdLFxuXG4gICAgICAvLyA3XG4gICAgICBbMiwgOTgsIDc4XSxcbiAgICAgIFs0LCA0OSwgMzFdLFxuICAgICAgWzIsIDMyLCAxNCwgNCwgMzMsIDE1XSxcbiAgICAgIFs0LCAzOSwgMTMsIDEsIDQwLCAxNF0sXG5cbiAgICAgIC8vIDhcbiAgICAgIFsyLCAxMjEsIDk3XSxcbiAgICAgIFsyLCA2MCwgMzgsIDIsIDYxLCAzOV0sXG4gICAgICBbNCwgNDAsIDE4LCAyLCA0MSwgMTldLFxuICAgICAgWzQsIDQwLCAxNCwgMiwgNDEsIDE1XSxcblxuICAgICAgLy8gOVxuICAgICAgWzIsIDE0NiwgMTE2XSxcbiAgICAgIFszLCA1OCwgMzYsIDIsIDU5LCAzN10sXG4gICAgICBbNCwgMzYsIDE2LCA0LCAzNywgMTddLFxuICAgICAgWzQsIDM2LCAxMiwgNCwgMzcsIDEzXSxcblxuICAgICAgLy8gMTBcbiAgICAgIFsyLCA4NiwgNjgsIDIsIDg3LCA2OV0sXG4gICAgICBbNCwgNjksIDQzLCAxLCA3MCwgNDRdLFxuICAgICAgWzYsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgIFs2LCA0MywgMTUsIDIsIDQ0LCAxNl0sXG5cbiAgICAgIC8vIDExXG4gICAgICBbNCwgMTAxLCA4MV0sXG4gICAgICBbMSwgODAsIDUwLCA0LCA4MSwgNTFdLFxuICAgICAgWzQsIDUwLCAyMiwgNCwgNTEsIDIzXSxcbiAgICAgIFszLCAzNiwgMTIsIDgsIDM3LCAxM10sXG5cbiAgICAgIC8vIDEyXG4gICAgICBbMiwgMTE2LCA5MiwgMiwgMTE3LCA5M10sXG4gICAgICBbNiwgNTgsIDM2LCAyLCA1OSwgMzddLFxuICAgICAgWzQsIDQ2LCAyMCwgNiwgNDcsIDIxXSxcbiAgICAgIFs3LCA0MiwgMTQsIDQsIDQzLCAxNV0sXG5cbiAgICAgIC8vIDEzXG4gICAgICBbNCwgMTMzLCAxMDddLFxuICAgICAgWzgsIDU5LCAzNywgMSwgNjAsIDM4XSxcbiAgICAgIFs4LCA0NCwgMjAsIDQsIDQ1LCAyMV0sXG4gICAgICBbMTIsIDMzLCAxMSwgNCwgMzQsIDEyXSxcblxuICAgICAgLy8gMTRcbiAgICAgIFszLCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuICAgICAgWzQsIDY0LCA0MCwgNSwgNjUsIDQxXSxcbiAgICAgIFsxMSwgMzYsIDE2LCA1LCAzNywgMTddLFxuICAgICAgWzExLCAzNiwgMTIsIDUsIDM3LCAxM10sXG5cbiAgICAgIC8vIDE1XG4gICAgICBbNSwgMTA5LCA4NywgMSwgMTEwLCA4OF0sXG4gICAgICBbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLFxuICAgICAgWzUsIDU0LCAyNCwgNywgNTUsIDI1XSxcbiAgICAgIFsxMSwgMzYsIDEyLCA3LCAzNywgMTNdLFxuXG4gICAgICAvLyAxNlxuICAgICAgWzUsIDEyMiwgOTgsIDEsIDEyMywgOTldLFxuICAgICAgWzcsIDczLCA0NSwgMywgNzQsIDQ2XSxcbiAgICAgIFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuICAgICAgWzMsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDE3XG4gICAgICBbMSwgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcbiAgICAgIFsxMCwgNzQsIDQ2LCAxLCA3NSwgNDddLFxuICAgICAgWzEsIDUwLCAyMiwgMTUsIDUxLCAyM10sXG4gICAgICBbMiwgNDIsIDE0LCAxNywgNDMsIDE1XSxcblxuICAgICAgLy8gMThcbiAgICAgIFs1LCAxNTAsIDEyMCwgMSwgMTUxLCAxMjFdLFxuICAgICAgWzksIDY5LCA0MywgNCwgNzAsIDQ0XSxcbiAgICAgIFsxNywgNTAsIDIyLCAxLCA1MSwgMjNdLFxuICAgICAgWzIsIDQyLCAxNCwgMTksIDQzLCAxNV0sXG5cbiAgICAgIC8vIDE5XG4gICAgICBbMywgMTQxLCAxMTMsIDQsIDE0MiwgMTE0XSxcbiAgICAgIFszLCA3MCwgNDQsIDExLCA3MSwgNDVdLFxuICAgICAgWzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sXG4gICAgICBbOSwgMzksIDEzLCAxNiwgNDAsIDE0XSxcblxuICAgICAgLy8gMjBcbiAgICAgIFszLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLFxuICAgICAgWzMsIDY3LCA0MSwgMTMsIDY4LCA0Ml0sXG4gICAgICBbMTUsIDU0LCAyNCwgNSwgNTUsIDI1XSxcbiAgICAgIFsxNSwgNDMsIDE1LCAxMCwgNDQsIDE2XSxcblxuICAgICAgLy8gMjFcbiAgICAgIFs0LCAxNDQsIDExNiwgNCwgMTQ1LCAxMTddLFxuICAgICAgWzE3LCA2OCwgNDJdLFxuICAgICAgWzE3LCA1MCwgMjIsIDYsIDUxLCAyM10sXG4gICAgICBbMTksIDQ2LCAxNiwgNiwgNDcsIDE3XSxcblxuICAgICAgLy8gMjJcbiAgICAgIFsyLCAxMzksIDExMSwgNywgMTQwLCAxMTJdLFxuICAgICAgWzE3LCA3NCwgNDZdLFxuICAgICAgWzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICBbMzQsIDM3LCAxM10sXG5cbiAgICAgIC8vIDIzXG4gICAgICBbNCwgMTUxLCAxMjEsIDUsIDE1MiwgMTIyXSxcbiAgICAgIFs0LCA3NSwgNDcsIDE0LCA3NiwgNDhdLFxuICAgICAgWzExLCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgWzE2LCA0NSwgMTUsIDE0LCA0NiwgMTZdLFxuXG4gICAgICAvLyAyNFxuICAgICAgWzYsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sXG4gICAgICBbNiwgNzMsIDQ1LCAxNCwgNzQsIDQ2XSxcbiAgICAgIFsxMSwgNTQsIDI0LCAxNiwgNTUsIDI1XSxcbiAgICAgIFszMCwgNDYsIDE2LCAyLCA0NywgMTddLFxuXG4gICAgICAvLyAyNVxuICAgICAgWzgsIDEzMiwgMTA2LCA0LCAxMzMsIDEwN10sXG4gICAgICBbOCwgNzUsIDQ3LCAxMywgNzYsIDQ4XSxcbiAgICAgIFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgWzIyLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxuXG4gICAgICAvLyAyNlxuICAgICAgWzEwLCAxNDIsIDExNCwgMiwgMTQzLCAxMTVdLFxuICAgICAgWzE5LCA3NCwgNDYsIDQsIDc1LCA0N10sXG4gICAgICBbMjgsIDUwLCAyMiwgNiwgNTEsIDIzXSxcbiAgICAgIFszMywgNDYsIDE2LCA0LCA0NywgMTddLFxuXG4gICAgICAvLyAyN1xuICAgICAgWzgsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG4gICAgICBbMjIsIDczLCA0NSwgMywgNzQsIDQ2XSxcbiAgICAgIFs4LCA1MywgMjMsIDI2LCA1NCwgMjRdLFxuICAgICAgWzEyLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxuXG4gICAgICAvLyAyOFxuICAgICAgWzMsIDE0NywgMTE3LCAxMCwgMTQ4LCAxMThdLFxuICAgICAgWzMsIDczLCA0NSwgMjMsIDc0LCA0Nl0sXG4gICAgICBbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSxcbiAgICAgIFsxMSwgNDUsIDE1LCAzMSwgNDYsIDE2XSxcblxuICAgICAgLy8gMjlcbiAgICAgIFs3LCAxNDYsIDExNiwgNywgMTQ3LCAxMTddLFxuICAgICAgWzIxLCA3MywgNDUsIDcsIDc0LCA0Nl0sXG4gICAgICBbMSwgNTMsIDIzLCAzNywgNTQsIDI0XSxcbiAgICAgIFsxOSwgNDUsIDE1LCAyNiwgNDYsIDE2XSxcblxuICAgICAgLy8gMzBcbiAgICAgIFs1LCAxNDUsIDExNSwgMTAsIDE0NiwgMTE2XSxcbiAgICAgIFsxOSwgNzUsIDQ3LCAxMCwgNzYsIDQ4XSxcbiAgICAgIFsxNSwgNTQsIDI0LCAyNSwgNTUsIDI1XSxcbiAgICAgIFsyMywgNDUsIDE1LCAyNSwgNDYsIDE2XSxcblxuICAgICAgLy8gMzFcbiAgICAgIFsxMywgMTQ1LCAxMTUsIDMsIDE0NiwgMTE2XSxcbiAgICAgIFsyLCA3NCwgNDYsIDI5LCA3NSwgNDddLFxuICAgICAgWzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sXG4gICAgICBbMjMsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMyXG4gICAgICBbMTcsIDE0NSwgMTE1XSxcbiAgICAgIFsxMCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSxcbiAgICAgIFsxMCwgNTQsIDI0LCAzNSwgNTUsIDI1XSxcbiAgICAgIFsxOSwgNDUsIDE1LCAzNSwgNDYsIDE2XSxcblxuICAgICAgLy8gMzNcbiAgICAgIFsxNywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSxcbiAgICAgIFsxNCwgNzQsIDQ2LCAyMSwgNzUsIDQ3XSxcbiAgICAgIFsyOSwgNTQsIDI0LCAxOSwgNTUsIDI1XSxcbiAgICAgIFsxMSwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcblxuICAgICAgLy8gMzRcbiAgICAgIFsxMywgMTQ1LCAxMTUsIDYsIDE0NiwgMTE2XSxcbiAgICAgIFsxNCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSxcbiAgICAgIFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuICAgICAgWzU5LCA0NiwgMTYsIDEsIDQ3LCAxN10sXG5cbiAgICAgIC8vIDM1XG4gICAgICBbMTIsIDE1MSwgMTIxLCA3LCAxNTIsIDEyMl0sXG4gICAgICBbMTIsIDc1LCA0NywgMjYsIDc2LCA0OF0sXG4gICAgICBbMzksIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICBbMjIsIDQ1LCAxNSwgNDEsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDM2XG4gICAgICBbNiwgMTUxLCAxMjEsIDE0LCAxNTIsIDEyMl0sXG4gICAgICBbNiwgNzUsIDQ3LCAzNCwgNzYsIDQ4XSxcbiAgICAgIFs0NiwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcbiAgICAgIFsyLCA0NSwgMTUsIDY0LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzN1xuICAgICAgWzE3LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuICAgICAgWzI5LCA3NCwgNDYsIDE0LCA3NSwgNDddLFxuICAgICAgWzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuICAgICAgWzI0LCA0NSwgMTUsIDQ2LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzOFxuICAgICAgWzQsIDE1MiwgMTIyLCAxOCwgMTUzLCAxMjNdLFxuICAgICAgWzEzLCA3NCwgNDYsIDMyLCA3NSwgNDddLFxuICAgICAgWzQ4LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgWzQyLCA0NSwgMTUsIDMyLCA0NiwgMTZdLFxuXG4gICAgICAvLyAzOVxuICAgICAgWzIwLCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuICAgICAgWzQwLCA3NSwgNDcsIDcsIDc2LCA0OF0sXG4gICAgICBbNDMsIDU0LCAyNCwgMjIsIDU1LCAyNV0sXG4gICAgICBbMTAsIDQ1LCAxNSwgNjcsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDQwXG4gICAgICBbMTksIDE0OCwgMTE4LCA2LCAxNDksIDExOV0sXG4gICAgICBbMTgsIDc1LCA0NywgMzEsIDc2LCA0OF0sXG4gICAgICBbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sXG4gICAgICBbMjAsIDQ1LCAxNSwgNjEsIDQ2LCAxNl1cbiAgICBdO1xuXG4gICAgdmFyIHFyUlNCbG9jayA9IGZ1bmN0aW9uKHRvdGFsQ291bnQsIGRhdGFDb3VudCkge1xuICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICBfdGhpcy50b3RhbENvdW50ID0gdG90YWxDb3VudDtcbiAgICAgIF90aGlzLmRhdGFDb3VudCA9IGRhdGFDb3VudDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICB2YXIgZ2V0UnNCbG9ja1RhYmxlID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblxuICAgICAgc3dpdGNoKGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTCA6XG4gICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDBdO1xuICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLk0gOlxuICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcbiAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5RIDpcbiAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMl07XG4gICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSCA6XG4gICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDNdO1xuICAgICAgZGVmYXVsdCA6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldFJTQmxvY2tzID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblxuICAgICAgdmFyIHJzQmxvY2sgPSBnZXRSc0Jsb2NrVGFibGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuXG4gICAgICBpZiAodHlwZW9mIHJzQmxvY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOicgKyB0eXBlTnVtYmVyICtcbiAgICAgICAgICAgICcvZXJyb3JDb3JyZWN0aW9uTGV2ZWw6JyArIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcblxuICAgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXG4gICAgICAgIHZhciBjb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAwXTtcbiAgICAgICAgdmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMV07XG4gICAgICAgIHZhciBkYXRhQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMl07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKHFyUlNCbG9jayh0b3RhbENvdW50LCBkYXRhQ291bnQpICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyQml0QnVmZmVyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyQml0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX2J1ZmZlciA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBfbGVuZ3RoID0gMDtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2J1ZmZlcjtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgcmV0dXJuICggKF9idWZmZXJbYnVmSW5kZXhdID4+PiAoNyAtIGluZGV4ICUgOCkgKSAmIDEpID09IDE7XG4gICAgfTtcblxuICAgIF90aGlzLnB1dCA9IGZ1bmN0aW9uKG51bSwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIF90aGlzLnB1dEJpdCggKCAobnVtID4+PiAobGVuZ3RoIC0gaSAtIDEpICkgJiAxKSA9PSAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2xlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMucHV0Qml0ID0gZnVuY3Rpb24oYml0KSB7XG5cbiAgICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoX2xlbmd0aCAvIDgpO1xuICAgICAgaWYgKF9idWZmZXIubGVuZ3RoIDw9IGJ1ZkluZGV4KSB7XG4gICAgICAgIF9idWZmZXIucHVzaCgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdCkge1xuICAgICAgICBfYnVmZmVyW2J1ZkluZGV4XSB8PSAoMHg4MCA+Pj4gKF9sZW5ndGggJSA4KSApO1xuICAgICAgfVxuXG4gICAgICBfbGVuZ3RoICs9IDE7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxck51bWJlclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBxck51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX05VTUJFUjtcbiAgICB2YXIgX2RhdGEgPSBkYXRhO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX21vZGU7XG4gICAgfTtcblxuICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIF9kYXRhLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcblxuICAgICAgdmFyIGRhdGEgPSBfZGF0YTtcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSArIDIgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEuc3Vic3RyaW5nKGksIGkgKyAzKSApLCAxMCk7XG4gICAgICAgIGkgKz0gMztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggLSBpID09IDEpIHtcbiAgICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEuc3Vic3RyaW5nKGksIGkgKyAxKSApLCA0KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCAtIGkgPT0gMikge1xuICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDIpICksIDcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdHJUb051bSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBudW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIG51bSA9IG51bSAqIDEwICsgY2hhdFRvTnVtKHMuY2hhckF0KGkpICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH07XG5cbiAgICB2YXIgY2hhdFRvTnVtID0gZnVuY3Rpb24oYykge1xuICAgICAgaWYgKCcwJyA8PSBjICYmIGMgPD0gJzknKSB7XG4gICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgOicgKyBjO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJBbHBoYU51bVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBxckFscGhhTnVtID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfQUxQSEFfTlVNO1xuICAgIHZhciBfZGF0YSA9IGRhdGE7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXG4gICAgICB2YXIgcyA9IF9kYXRhO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMSA8IHMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoXG4gICAgICAgICAgZ2V0Q29kZShzLmNoYXJBdChpKSApICogNDUgK1xuICAgICAgICAgIGdldENvZGUocy5jaGFyQXQoaSArIDEpICksIDExKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IHMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoZ2V0Q29kZShzLmNoYXJBdChpKSApLCA2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldENvZGUgPSBmdW5jdGlvbihjKSB7XG5cbiAgICAgIGlmICgnMCcgPD0gYyAmJiBjIDw9ICc5Jykge1xuICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9IGVsc2UgaWYgKCdBJyA8PSBjICYmIGMgPD0gJ1onKSB7XG4gICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSAnQScuY2hhckNvZGVBdCgwKSArIDEwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJyAnIDogcmV0dXJuIDM2O1xuICAgICAgICBjYXNlICckJyA6IHJldHVybiAzNztcbiAgICAgICAgY2FzZSAnJScgOiByZXR1cm4gMzg7XG4gICAgICAgIGNhc2UgJyonIDogcmV0dXJuIDM5O1xuICAgICAgICBjYXNlICcrJyA6IHJldHVybiA0MDtcbiAgICAgICAgY2FzZSAnLScgOiByZXR1cm4gNDE7XG4gICAgICAgIGNhc2UgJy4nIDogcmV0dXJuIDQyO1xuICAgICAgICBjYXNlICcvJyA6IHJldHVybiA0MztcbiAgICAgICAgY2FzZSAnOicgOiByZXR1cm4gNDQ7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgOicgKyBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcjhCaXRCeXRlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyOEJpdEJ5dGUgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV84QklUX0JZVEU7XG4gICAgdmFyIF9kYXRhID0gZGF0YTtcbiAgICB2YXIgX2J5dGVzID0gcXJjb2RlLnN0cmluZ1RvQnl0ZXMoZGF0YSk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2J5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoX2J5dGVzW2ldLCA4KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyS2FuamlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgcXJLYW5qaSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX0tBTkpJO1xuICAgIHZhciBfZGF0YSA9IGRhdGE7XG4gICAgdmFyIF9ieXRlcyA9IHFyY29kZS5zdHJpbmdUb0J5dGVzKGRhdGEpO1xuXG4gICAgIWZ1bmN0aW9uKGMsIGNvZGUpIHtcbiAgICAgIC8vIHNlbGYgdGVzdCBmb3Igc2ppcyBzdXBwb3J0LlxuICAgICAgdmFyIHRlc3QgPSBxcmNvZGUuc3RyaW5nVG9CeXRlcyhjKTtcbiAgICAgIGlmICh0ZXN0Lmxlbmd0aCAhPSAyIHx8ICggKHRlc3RbMF0gPDwgOCkgfCB0ZXN0WzFdKSAhPSBjb2RlKSB7XG4gICAgICAgIHRocm93ICdzamlzIG5vdCBzdXBwb3J0ZWQuJztcbiAgICAgIH1cbiAgICB9KCdcXHU1M2NiJywgMHg5NzQ2KTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiB+fihfYnl0ZXMubGVuZ3RoIC8gMik7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG5cbiAgICAgIHZhciBkYXRhID0gX2J5dGVzO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMSA8IGRhdGEubGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGMgPSAoICgweGZmICYgZGF0YVtpXSkgPDwgOCkgfCAoMHhmZiAmIGRhdGFbaSArIDFdKTtcblxuICAgICAgICBpZiAoMHg4MTQwIDw9IGMgJiYgYyA8PSAweDlGRkMpIHtcbiAgICAgICAgICBjIC09IDB4ODE0MDtcbiAgICAgICAgfSBlbHNlIGlmICgweEUwNDAgPD0gYyAmJiBjIDw9IDB4RUJCRikge1xuICAgICAgICAgIGMgLT0gMHhDMTQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgYXQgJyArIChpICsgMSkgKyAnLycgKyBjO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9ICggKGMgPj4+IDgpICYgMHhmZikgKiAweEMwICsgKGMgJiAweGZmKTtcblxuICAgICAgICBidWZmZXIucHV0KGMsIDEzKTtcblxuICAgICAgICBpICs9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciBhdCAnICsgKGkgKyAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEdJRiBTdXBwb3J0IGV0Yy5cbiAgLy9cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBieXRlQXJyYXlPdXRwdXRTdHJlYW1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgYnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX2J5dGVzID0gbmV3IEFycmF5KCk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIF9ieXRlcy5wdXNoKGIgJiAweGZmKTtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIF90aGlzLndyaXRlQnl0ZShpKTtcbiAgICAgIF90aGlzLndyaXRlQnl0ZShpID4+PiA4KTtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVCeXRlcyA9IGZ1bmN0aW9uKGIsIG9mZiwgbGVuKSB7XG4gICAgICBvZmYgPSBvZmYgfHwgMDtcbiAgICAgIGxlbiA9IGxlbiB8fCBiLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlKGJbaSArIG9mZl0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfdGhpcy53cml0ZUJ5dGUocy5jaGFyQ29kZUF0KGkpICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2J5dGVzO1xuICAgIH07XG5cbiAgICBfdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHMgKz0gJ1snO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcyArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBfYnl0ZXNbaV07XG4gICAgICB9XG4gICAgICBzICs9ICddJztcbiAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9idWZmZXIgPSAwO1xuICAgIHZhciBfYnVmbGVuID0gMDtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9iYXNlNjQgPSAnJztcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgdmFyIHdyaXRlRW5jb2RlZCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIF9iYXNlNjQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlbmNvZGUoYiAmIDB4M2YpICk7XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICB9IGVsc2UgaWYgKG4gPCAyNikge1xuICAgICAgICByZXR1cm4gMHg0MSArIG47XG4gICAgICB9IGVsc2UgaWYgKG4gPCA1Mikge1xuICAgICAgICByZXR1cm4gMHg2MSArIChuIC0gMjYpO1xuICAgICAgfSBlbHNlIGlmIChuIDwgNjIpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgKyAobiAtIDUyKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mikge1xuICAgICAgICByZXR1cm4gMHgyYjtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mykge1xuICAgICAgICByZXR1cm4gMHgyZjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbjonICsgbik7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKG4pIHtcblxuICAgICAgX2J1ZmZlciA9IChfYnVmZmVyIDw8IDgpIHwgKG4gJiAweGZmKTtcbiAgICAgIF9idWZsZW4gKz0gODtcbiAgICAgIF9sZW5ndGggKz0gMTtcblxuICAgICAgd2hpbGUgKF9idWZsZW4gPj0gNikge1xuICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA+Pj4gKF9idWZsZW4gLSA2KSApO1xuICAgICAgICBfYnVmbGVuIC09IDY7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmIChfYnVmbGVuID4gMCkge1xuICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA8PCAoNiAtIF9idWZsZW4pICk7XG4gICAgICAgIF9idWZmZXIgPSAwO1xuICAgICAgICBfYnVmbGVuID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9sZW5ndGggJSAzICE9IDApIHtcbiAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB2YXIgcGFkbGVuID0gMyAtIF9sZW5ndGggJSAzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgX2Jhc2U2NCArPSAnPSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfYmFzZTY0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0gPSBmdW5jdGlvbihzdHIpIHtcblxuICAgIHZhciBfc3RyID0gc3RyO1xuICAgIHZhciBfcG9zID0gMDtcbiAgICB2YXIgX2J1ZmZlciA9IDA7XG4gICAgdmFyIF9idWZsZW4gPSAwO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5yZWFkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHdoaWxlIChfYnVmbGVuIDwgOCkge1xuXG4gICAgICAgIGlmIChfcG9zID49IF9zdHIubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKF9idWZsZW4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUuLycgKyBfYnVmbGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gX3N0ci5jaGFyQXQoX3Bvcyk7XG4gICAgICAgIF9wb3MgKz0gMTtcblxuICAgICAgICBpZiAoYyA9PSAnPScpIHtcbiAgICAgICAgICBfYnVmbGVuID0gMDtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5tYXRjaCgvXlxccyQvKSApIHtcbiAgICAgICAgICAvLyBpZ25vcmUgaWYgd2hpdGVzcGFjZS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9idWZmZXIgPSAoX2J1ZmZlciA8PCA2KSB8IGRlY29kZShjLmNoYXJDb2RlQXQoMCkgKTtcbiAgICAgICAgX2J1ZmxlbiArPSA2O1xuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IChfYnVmZmVyID4+PiAoX2J1ZmxlbiAtIDgpICkgJiAweGZmO1xuICAgICAgX2J1ZmxlbiAtPSA4O1xuICAgICAgcmV0dXJuIG47XG4gICAgfTtcblxuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoMHg0MSA8PSBjICYmIGMgPD0gMHg1YSkge1xuICAgICAgICByZXR1cm4gYyAtIDB4NDE7XG4gICAgICB9IGVsc2UgaWYgKDB4NjEgPD0gYyAmJiBjIDw9IDB4N2EpIHtcbiAgICAgICAgcmV0dXJuIGMgLSAweDYxICsgMjY7XG4gICAgICB9IGVsc2UgaWYgKDB4MzAgPD0gYyAmJiBjIDw9IDB4MzkpIHtcbiAgICAgICAgcmV0dXJuIGMgLSAweDMwICsgNTI7XG4gICAgICB9IGVsc2UgaWYgKGMgPT0gMHgyYikge1xuICAgICAgICByZXR1cm4gNjI7XG4gICAgICB9IGVsc2UgaWYgKGMgPT0gMHgyZikge1xuICAgICAgICByZXR1cm4gNjM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2M6JyArIGMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZ2lmSW1hZ2UgKEIvVylcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgZ2lmSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB2YXIgX3dpZHRoID0gd2lkdGg7XG4gICAgdmFyIF9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIF9kYXRhID0gbmV3IEFycmF5KHdpZHRoICogaGVpZ2h0KTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuc2V0UGl4ZWwgPSBmdW5jdGlvbih4LCB5LCBwaXhlbCkge1xuICAgICAgX2RhdGFbeSAqIF93aWR0aCArIHhdID0gcGl4ZWw7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHSUYgU2lnbmF0dXJlXG5cbiAgICAgIG91dC53cml0ZVN0cmluZygnR0lGODdhJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTY3JlZW4gRGVzY3JpcHRvclxuXG4gICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG5cbiAgICAgIG91dC53cml0ZUJ5dGUoMHg4MCk7IC8vIDJiaXRcbiAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gR2xvYmFsIENvbG9yIE1hcFxuXG4gICAgICAvLyBibGFja1xuICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXG4gICAgICAvLyB3aGl0ZVxuICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHhmZik7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4ZmYpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gSW1hZ2UgRGVzY3JpcHRvclxuXG4gICAgICBvdXQud3JpdGVTdHJpbmcoJywnKTtcbiAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgb3V0LndyaXRlU2hvcnQoMCk7XG4gICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTG9jYWwgQ29sb3IgTWFwXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBSYXN0ZXIgRGF0YVxuXG4gICAgICB2YXIgbHp3TWluQ29kZVNpemUgPSAyO1xuICAgICAgdmFyIHJhc3RlciA9IGdldExaV1Jhc3RlcihsendNaW5Db2RlU2l6ZSk7XG5cbiAgICAgIG91dC53cml0ZUJ5dGUobHp3TWluQ29kZVNpemUpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgd2hpbGUgKHJhc3Rlci5sZW5ndGggLSBvZmZzZXQgPiAyNTUpIHtcbiAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgMjU1KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI1NTtcbiAgICAgIH1cblxuICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCByYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHSUYgVGVybWluYXRvclxuICAgICAgb3V0LndyaXRlU3RyaW5nKCc7Jyk7XG4gICAgfTtcblxuICAgIHZhciBiaXRPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbihvdXQpIHtcblxuICAgICAgdmFyIF9vdXQgPSBvdXQ7XG4gICAgICB2YXIgX2JpdExlbmd0aCA9IDA7XG4gICAgICB2YXIgX2JpdEJ1ZmZlciA9IDA7XG5cbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGxlbmd0aCkge1xuXG4gICAgICAgIGlmICggKGRhdGEgPj4+IGxlbmd0aCkgIT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG92ZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChfYml0TGVuZ3RoICsgbGVuZ3RoID49IDgpIHtcbiAgICAgICAgICBfb3V0LndyaXRlQnl0ZSgweGZmICYgKCAoZGF0YSA8PCBfYml0TGVuZ3RoKSB8IF9iaXRCdWZmZXIpICk7XG4gICAgICAgICAgbGVuZ3RoIC09ICg4IC0gX2JpdExlbmd0aCk7XG4gICAgICAgICAgZGF0YSA+Pj49ICg4IC0gX2JpdExlbmd0aCk7XG4gICAgICAgICAgX2JpdEJ1ZmZlciA9IDA7XG4gICAgICAgICAgX2JpdExlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBfYml0QnVmZmVyID0gKGRhdGEgPDwgX2JpdExlbmd0aCkgfCBfYml0QnVmZmVyO1xuICAgICAgICBfYml0TGVuZ3RoID0gX2JpdExlbmd0aCArIGxlbmd0aDtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfYml0TGVuZ3RoID4gMCkge1xuICAgICAgICAgIF9vdXQud3JpdGVCeXRlKF9iaXRCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHZhciBnZXRMWldSYXN0ZXIgPSBmdW5jdGlvbihsendNaW5Db2RlU2l6ZSkge1xuXG4gICAgICB2YXIgY2xlYXJDb2RlID0gMSA8PCBsendNaW5Db2RlU2l6ZTtcbiAgICAgIHZhciBlbmRDb2RlID0gKDEgPDwgbHp3TWluQ29kZVNpemUpICsgMTtcbiAgICAgIHZhciBiaXRMZW5ndGggPSBsendNaW5Db2RlU2l6ZSArIDE7XG5cbiAgICAgIC8vIFNldHVwIExaV1RhYmxlXG4gICAgICB2YXIgdGFibGUgPSBsendUYWJsZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsZWFyQ29kZTsgaSArPSAxKSB7XG4gICAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gICAgICB9XG4gICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShjbGVhckNvZGUpICk7XG4gICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShlbmRDb2RlKSApO1xuXG4gICAgICB2YXIgYnl0ZU91dCA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuICAgICAgdmFyIGJpdE91dCA9IGJpdE91dHB1dFN0cmVhbShieXRlT3V0KTtcblxuICAgICAgLy8gY2xlYXIgY29kZVxuICAgICAgYml0T3V0LndyaXRlKGNsZWFyQ29kZSwgYml0TGVuZ3RoKTtcblxuICAgICAgdmFyIGRhdGFJbmRleCA9IDA7XG5cbiAgICAgIHZhciBzID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcbiAgICAgIGRhdGFJbmRleCArPSAxO1xuXG4gICAgICB3aGlsZSAoZGF0YUluZGV4IDwgX2RhdGEubGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKF9kYXRhW2RhdGFJbmRleF0pO1xuICAgICAgICBkYXRhSW5kZXggKz0gMTtcblxuICAgICAgICBpZiAodGFibGUuY29udGFpbnMocyArIGMpICkge1xuXG4gICAgICAgICAgcyA9IHMgKyBjO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzKSwgYml0TGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0YWJsZS5zaXplKCkgPCAweGZmZikge1xuXG4gICAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpID09ICgxIDw8IGJpdExlbmd0aCkgKSB7XG4gICAgICAgICAgICAgIGJpdExlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YWJsZS5hZGQocyArIGMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHMgPSBjO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJpdE91dC53cml0ZSh0YWJsZS5pbmRleE9mKHMpLCBiaXRMZW5ndGgpO1xuXG4gICAgICAvLyBlbmQgY29kZVxuICAgICAgYml0T3V0LndyaXRlKGVuZENvZGUsIGJpdExlbmd0aCk7XG5cbiAgICAgIGJpdE91dC5mbHVzaCgpO1xuXG4gICAgICByZXR1cm4gYnl0ZU91dC50b0J5dGVBcnJheSgpO1xuICAgIH07XG5cbiAgICB2YXIgbHp3VGFibGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIF9tYXAgPSB7fTtcbiAgICAgIHZhciBfc2l6ZSA9IDA7XG5cbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICBfdGhpcy5hZGQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKF90aGlzLmNvbnRhaW5zKGtleSkgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXAga2V5OicgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIF9tYXBba2V5XSA9IF9zaXplO1xuICAgICAgICBfc2l6ZSArPSAxO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5pbmRleE9mID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfbWFwW2tleV07XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5jb250YWlucyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIF9tYXBba2V5XSAhPSAndW5kZWZpbmVkJztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIHZhciBjcmVhdGVJbWdUYWcgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBnZXRQaXhlbCwgYWx0KSB7XG5cbiAgICB2YXIgZ2lmID0gZ2lmSW1hZ2Uod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gMSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCArPSAxKSB7XG4gICAgICAgIGdpZi5zZXRQaXhlbCh4LCB5LCBnZXRQaXhlbCh4LCB5KSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgZ2lmLndyaXRlKGIpO1xuXG4gICAgdmFyIGJhc2U2NCA9IGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSgpO1xuICAgIHZhciBieXRlcyA9IGIudG9CeXRlQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBiYXNlNjQud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICB9XG4gICAgYmFzZTY0LmZsdXNoKCk7XG5cbiAgICB2YXIgaW1nID0gJyc7XG4gICAgaW1nICs9ICc8aW1nJztcbiAgICBpbWcgKz0gJ1xcdTAwMjBzcmM9XCInO1xuICAgIGltZyArPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LCc7XG4gICAgaW1nICs9IGJhc2U2NDtcbiAgICBpbWcgKz0gJ1wiJztcbiAgICBpbWcgKz0gJ1xcdTAwMjB3aWR0aD1cIic7XG4gICAgaW1nICs9IHdpZHRoO1xuICAgIGltZyArPSAnXCInO1xuICAgIGltZyArPSAnXFx1MDAyMGhlaWdodD1cIic7XG4gICAgaW1nICs9IGhlaWdodDtcbiAgICBpbWcgKz0gJ1wiJztcbiAgICBpZiAoYWx0KSB7XG4gICAgICBpbWcgKz0gJ1xcdTAwMjBhbHQ9XCInO1xuICAgICAgaW1nICs9IGFsdDtcbiAgICAgIGltZyArPSAnXCInO1xuICAgIH1cbiAgICBpbWcgKz0gJy8+JztcblxuICAgIHJldHVybiBpbWc7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUltZ09iamVjdCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGdldFBpeGVsKSB7XG5cbiAgICB2YXIgZ2lmID0gZ2lmSW1hZ2Uod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gMSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCArPSAxKSB7XG4gICAgICAgIGdpZi5zZXRQaXhlbCh4LCB5LCBnZXRQaXhlbCh4LCB5KSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgZ2lmLndyaXRlKGIpO1xuXG4gICAgdmFyIGJhc2U2NCA9IGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSgpO1xuICAgIHZhciBieXRlcyA9IGIudG9CeXRlQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBiYXNlNjQud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICB9XG4gICAgYmFzZTY0LmZsdXNoKCk7XG5cbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsJyArIGJhc2U2NDtcbiAgICBpbWcud2lkdGggPSB3aWR0aDtcbiAgICBpbWcuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgcmV0dXJuIGltZztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyByZXR1cm5zIHFyY29kZSBmdW5jdGlvbi5cblxuICByZXR1cm4ge1xuICAgIFFSQ29kZTogcXJjb2RlLFxuICAgIFFSVXRpbDogUVJVdGlsXG4gIH07XG59KCk7XG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1cbn0oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBRUkNvZGU6IHFyY29kZS5RUkNvZGUsXG4gICAgICBRUlV0aWw6IHFyY29kZS5RUlV0aWxcbiAgICB9O1xufSkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9xcmNvZGUuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjbGFzcyBVdGlsIHtcbiAgc3RhdGljIGNyZWF0ZUNhbnZhcyhzaXplLCBpbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSBzaXplO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIHN0YXRpYyB0aHJlc2hvbGQociwgZywgYiwgdmFsdWUpIHtcbiAgICByZXR1cm4gKDAuMjEyNipyICsgMC43MTUyKmcgKyAwLjA3MjIqYiA+PSB2YWx1ZSkgPyAyNTUgOiAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3FhcnRqcy9kaXN0L3FhcnQubWluLmpzP2VkYTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxpSUFBNkssaUJBQWlCLG1CQUFtQixjQUFjLDRCQUE0QixZQUFZLFVBQVUsaUJBQWlCLGdFQUFnRSxTQUFTLHVDQUF1QyxrQkFBa0IsYUFBYSxjQUFjLDBCQUEwQixXQUFXLHNDQUFzQyxTQUFTLEVBQUUsb0VBQW9FLGNBQWMsK0ZBQStGLG9GQUFvRiw0RkFBNEYsa0hBQWtILHdCQUF3Qiw2QkFBNkIsMENBQTBDLCtCQUErQixrQ0FBa0Msb0JBQW9CLGdCQUFnQixrQkFBa0IsZ0VBQWdFLG9CQUFvQiw2SEFBNkgsdUNBQXVDLHFFQUFxRSxvSEFBb0gsV0FBVyxNQUFNLHdEQUF3RCxxQ0FBcUMsbUVBQW1FLDBCQUEwQixrREFBa0QseUJBQXlCLCtEQUErRCxlQUFlLHVDQUF1Qyw2Q0FBNkMsV0FBVyxpQkFBaUIsV0FBVyxNQUFNLGtCQUFrQiw0Q0FBNEMsdUdBQXVHLHdDQUF3QyxtQ0FBbUMsSUFBSSw4QkFBOEIsT0FBTyw4QkFBOEIsS0FBSyxHQUFHLG9DQUFvQyxlQUFlLGFBQWEsd0NBQXdDLCtFQUErRSxpQkFBaUIsYUFBYSxjQUFjLDBCQUEwQixXQUFXLGdCQUFnQixrQkFBa0IscUJBQXFCLGdCQUFnQixZQUFZLFdBQVcsS0FBSyxXQUFXLHVHQUF1Ryx1QkFBdUIsd0NBQXdDLEdBQUcsaUJBQWlCLFdBQVcsNEJBQTRCLGlCQUFpQixLQUFLLGtCQUFrQiwwQkFBMEIsZ0NBQWdDLGlCQUFpQixXQUFXLDJCQUEyQix1QkFBdUIsRUFBRSxpQkFBaUIsaUVBQWlFLDhFQUE4RSwrQkFBK0IsS0FBSyxTQUFTLG9JQUFvSSxzQkFBc0Isc0JBQXNCLHlCQUF5QixvQkFBb0IsdUJBQXVCLHlCQUF5QixvQkFBb0IsZ0NBQWdDLG1CQUFtQiw4RUFBOEUscUNBQXFDLGlFQUFpRSxlQUFlLDhJQUE4SSw4QkFBOEIsZUFBZSxpQkFBaUIsaUJBQWlCLDhCQUE4QixpQkFBaUIsWUFBWSwwQkFBMEIsNEJBQTRCLFVBQVUsMEJBQTBCLG9CQUFvQiw0QkFBNEIsc0JBQXNCLDhCQUE4Qix3QkFBd0Isa0JBQWtCLDhCQUE4QixlQUFlLHNCQUFzQixpRUFBaUUsVUFBVSxpQkFBaUIsb0JBQW9CLGdDQUFnQyx1QkFBdUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsb0RBQW9ELGdEQUFnRCw2QkFBNkIsZ0JBQWdCLFVBQVUsb0VBQW9FLHFDQUFxQyxpQkFBaUIsWUFBWSxzQkFBc0IsaURBQWlELFVBQVUsZUFBZSxzQkFBc0Isd0RBQXdELGlCQUFpQixvQ0FBb0Msa0RBQWtELGVBQWUsVUFBVSxJQUFJLEVBQUUsaUJBQWlCLDRCQUE0QixrQ0FBa0MsTUFBTSxlQUFlLFVBQVUsSUFBSSxFQUFFLGVBQWUsc0JBQXNCLElBQUksWUFBWSxTQUFTLFdBQVcsaUJBQWlCLHVEQUF1RCxzQkFBc0IsZ0NBQWdDLGlCQUFpQixZQUFZLHdCQUF3QixrQkFBa0IsUUFBUSxpRUFBaUUsNkRBQTZELGtFQUFrRSw0REFBNEQsZUFBZSx3QkFBd0IsT0FBTyxnRUFBZ0UsaUJBQWlCLGNBQWMsMEJBQTBCLFdBQVcscUNBQXFDLGdCQUFnQixnRUFBZ0UsaUJBQWlCLFlBQVksb0JBQW9CLE1BQU0sc0NBQXNDLGFBQWEsaUJBQWlCLFNBQVMsUUFBUSwyQkFBMkIsWUFBWSx3QkFBd0IsZ0JBQWdCLHdCQUF3Qix1REFBdUQsZ0JBQWdCLGlCQUFpQixnQkFBZ0IsMkRBQTJELGNBQWMsbUJBQW1CLDBDQUEwQywrRUFBK0UsZ0JBQWdCLHFCQUFxQixZQUFZLGdCQUFnQix3Q0FBd0MscUJBQXFCLEdBQUcsb0JBQW9CLDREQUE0RCxpQkFBaUIsdUJBQXVCLDJCQUEyQixJQUFJLE1BQU0sa0JBQWtCLFlBQVksSUFBSSxrQkFBa0IsU0FBUyxvRkFBb0YsaUJBQWlCLGFBQWEsS0FBSyx3Q0FBd0MsS0FBSyxpSUFBaUksY0FBYyxvQkFBb0IsSUFBSSxNQUFNLFFBQVEsd0JBQXdCLHVCQUF1QixTQUFTLGNBQWMsWUFBWSxNQUFNLHFDQUFxQyxZQUFZLE1BQU0scUNBQXFDLGNBQWMsc0NBQXNDLFdBQVcsaUJBQWlCLFdBQVcsTUFBTSxrQkFBa0IsOEJBQThCLEtBQUssa0JBQWtCLEtBQUsseUVBQXlFLGVBQWUsb0NBQW9DLEtBQUssTUFBTSxzQkFBc0IsZ0NBQWdDLFlBQVksS0FBSyxNQUFNLHNCQUFzQixpQ0FBaUMsaUJBQWlCLDJDQUEyQyxLQUFLLE1BQU0sc0JBQXNCLDZDQUE2QyxZQUFZLEtBQUssTUFBTSxzQkFBc0Isc0RBQXNELGFBQWEsaUJBQWlCLHdEQUF3RCxJQUFJLHVCQUF1QixFQUFFLFlBQVksSUFBSSx5QkFBeUIsU0FBUyxnQ0FBZ0MsZUFBZSw2Q0FBNkMsbUJBQW1CLFVBQVUsUUFBUSxpQkFBaUIsb0VBQW9FLFdBQVcsTUFBTSx5Q0FBeUMsa0RBQWtELFlBQVksY0FBYyxvQ0FBb0MsS0FBSywwRUFBMEUsZ0NBQWdDLFlBQVksY0FBYyxNQUFNLGtDQUFrQywyQkFBMkIsZ0JBQWdCLFdBQVcsd0JBQXdCLCtCQUErQixJQUFJLGlCQUFpQixXQUFXLHdDQUF3QyxZQUFZLElBQUksaUJBQWlCLFdBQVcsd0NBQXdDLFNBQVMsbUJBQW1CLHVDQUF1QyxXQUFXLE1BQU0sV0FBVyxzRkFBc0YsZ0JBQWdCLFdBQVcsdUJBQXVCLHNHQUFzRywyQ0FBMkMseUJBQXlCLGNBQWMsTUFBTSxFQUFFLGtDQUFrQyw2Q0FBNkMsV0FBVyxlQUFlLCtCQUErQixZQUFZLFdBQVcsVUFBVSxxQkFBcUIsTUFBTSwwQkFBMEIsTUFBTSxrQkFBa0IsTUFBTSxtQkFBbUIsTUFBTSx1QkFBdUIsaUJBQWlCLHdCQUF3QixpREFBaUQsZUFBZSw2QkFBNkIsU0FBUyxtQkFBbUIsVUFBVSxnQ0FBZ0MscUNBQXFDLFNBQVMsMkNBQTJDLG9CQUFvQixpQ0FBaUMsb0JBQW9CLGlCQUFpQix1QkFBdUIsWUFBWSxxQkFBcUIsTUFBTSxVQUFVLFlBQVkscUJBQXFCLDZDQUE2QyxvQkFBb0IsaUNBQWlDLG9CQUFvQixhQUFhLHNCQUFzQix1QkFBdUIscUVBQXFFLFdBQVcsV0FBVyxtQ0FBbUMsOEJBQThCLHFDQUFxQyw4Q0FBOEMsdUtBQXVLLHFCQUFxQixxQkFBcUIscUJBQXFCLCtDQUErQyw4REFBOEQsOEJBQThCLHFDQUFxQyx5Q0FBeUMsMkJBQTJCLHlCQUF5QixnREFBZ0QseUJBQXlCLFNBQVMsRUFBRSxpQ0FBaUMscUNBQXFDLHlDQUF5QywyQkFBMkIseUJBQXlCLGdEQUFnRCx5QkFBeUIsU0FBUyxFQUFFLElBQUksNEJBQTRCLHdCQUF3QixXQUFXLE1BQU0sc0JBQXNCLGNBQWMsU0FBUyxxQ0FBcUMsaUJBQWlCLDRCQUE0QixlQUFlLHlCQUF5QixTQUFTLFdBQVcsRUFBRSxlQUFlLGVBQWUsNkRBQTZELFlBQVksb0NBQW9DLFNBQVMsdUJBQXVCLG1CQUFtQix3QkFBd0IsV0FBVyxNQUFNLHNCQUFzQixtQkFBbUIsS0FBSyxxQkFBcUIsaUZBQWlGLFdBQVcsT0FBTyw2REFBNkQsSUFBSSxnQkFBZ0IsSUFBSSx3R0FBd0csY0FBYyxzb0JBQXNvQixlQUFlLFlBQVksS0FBSyxhQUFhLFVBQVUsb0NBQW9DLGdCQUFnQixhQUFhLGlCQUFpQixrQkFBa0IsZ0NBQWdDLGdCQUFnQixhQUFhLGlCQUFpQixlQUFlLGtDQUFrQyxjQUFjLCtCQUErQixVQUFVLHVDQUF1QyxrQkFBa0IsdUNBQXVDLGVBQWUsdUNBQXVDLGVBQWUsdUNBQXVDLGtCQUFrQix1Q0FBdUMsOENBQThDLHVDQUF1Qyx1QkFBdUIsdUNBQXVDLDBCQUEwQix1Q0FBdUMsNEJBQTRCLCtDQUErQyx5Q0FBeUMsdUJBQXVCLElBQUksc0NBQXNDLFNBQVMsaUNBQWlDLHdCQUF3Qiw2QkFBNkIsK0JBQStCLCtCQUErQiwyQkFBMkIsbUNBQW1DLHVCQUF1Qiw2QkFBNkIsZ0NBQWdDLGdDQUFnQyw0QkFBNEIsbUNBQW1DLEtBQUssc0NBQXNDLFVBQVUsNkJBQTZCLGdDQUFnQyxnQ0FBZ0MsNEJBQTRCLHFDQUFxQyw0QkFBNEIscUNBQXFDLElBQUksaUJBQWlCLElBQUksTUFBTSxpQ0FBaUMsS0FBSyxzQ0FBc0MsS0FBSyw2REFBNkQsZ0JBQWdCLFlBQVksTUFBTSxpQkFBaUIsTUFBTSxNQUFNLFFBQVEsbUhBQW1ILFlBQVksSUFBSSxpQkFBaUIsTUFBTSxvSUFBb0ksWUFBWSxJQUFJLGlCQUFpQixNQUFNLG9JQUFvSSxnQkFBZ0IsSUFBSSxpQkFBaUIsSUFBSSwyQkFBMkIsK0JBQStCLGVBQWUsR0FBRyxnQkFBZ0IsOENBQThDLElBQUksZUFBZSxZQUFZLE1BQU0sc0NBQXNDLFlBQVksTUFBTSxlQUFlLFNBQVMsMEJBQTBCLHNDQUFzQyxZQUFZLG9CQUFvQixLQUFLLElBQUksUUFBUSxLQUFLLE9BQU8sUUFBUSxZQUFZLEdBQUcsZ0JBQWdCLG0wRkFBbTBGLFNBQVMsc0NBQXNDLEtBQUssaUJBQWlCLFVBQVUsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLGlCQUFpQixtQ0FBbUMsYUFBYSxvR0FBb0cscUNBQXFDLElBQUksa0RBQWtELElBQUksb0JBQW9CLFNBQVMsR0FBRyxnQkFBZ0IseUJBQXlCLDhCQUE4QixTQUFTLHFCQUFxQixzQkFBc0IsMkJBQTJCLHFCQUFxQixZQUFZLElBQUksZ0NBQWdDLDhCQUE4QixTQUFTLHNCQUFzQixzQkFBc0IsaURBQWlELEdBQUcsZUFBZSw2QkFBNkIscUJBQXFCLFNBQVMseUJBQXlCLGdCQUFnQixxQkFBcUIsZ0JBQWdCLGFBQWEsc0NBQXNDLDBHQUEwRyxrQkFBa0IsZ0JBQWdCLFdBQVcsMkJBQTJCLFNBQVMsZUFBZSwyREFBMkQseUJBQXlCLFNBQVMsZUFBZSxnQ0FBZ0MscUJBQXFCLFNBQVMseUJBQXlCLGdCQUFnQixxQkFBcUIsZ0JBQWdCLGFBQWEsbURBQW1ELHFDQUFxQyxrQkFBa0IsMkRBQTJELDhEQUE4RCxVQUFVLGtCQUFrQixrQkFBa0Isa0JBQWtCLGtCQUFrQixrQkFBa0Isa0JBQWtCLGtCQUFrQixrQkFBa0Isa0JBQWtCLGtDQUFrQyxTQUFTLGVBQWUsaURBQWlELDRCQUE0QixTQUFTLHlCQUF5QixnQkFBZ0IscUJBQXFCLFlBQVksV0FBVyxtQkFBbUIsR0FBRyxlQUFlLHdDQUF3QyxlQUFlLHlCQUF5Qiw2REFBNkQsWUFBWSxTQUFTLDRCQUE0QixTQUFTLHlCQUF5QixxQkFBcUIscUJBQXFCLGdCQUFnQixhQUFhLEVBQUUsK0JBQStCLCtCQUErQixLQUFLLDZEQUE2RCxTQUFTLDJDQUEyQyw0Q0FBNEMsR0FBRyxjQUFjLHFCQUFxQiwrQkFBK0IsY0FBYywwQkFBMEIsa0NBQWtDLDhCQUE4QixxQkFBcUIsWUFBWSxJQUFJLHlCQUF5QiwyQkFBMkIsWUFBWSxXQUFXLGtDQUFrQywwQkFBMEIsU0FBUyx1QkFBdUIsU0FBUyxPQUFPLFlBQVksV0FBVywyQkFBMkIsY0FBYyxHQUFHLGNBQWMseUJBQXlCLGVBQWUsZ0NBQWdDLGVBQWUsUUFBUSxLQUFLLG9CQUFvQix5QkFBeUIseUJBQXlCLG1CQUFtQixtQkFBbUIseUJBQXlCLCtCQUErQiwyQkFBMkIsS0FBSyxpQkFBaUIsb0JBQW9CLHVEQUF1RCxJQUFJLFlBQVksdUJBQXVCLFNBQVMsR0FBRyxlQUFlLHlCQUF5QixrQkFBa0IsS0FBSyxJQUFJLEVBQUUsZ0JBQWdCLGlCQUFpQiw4Q0FBOEMsa0JBQWtCLDZCQUE2QixrREFBa0Qsa0JBQWtCLGVBQWUsa0JBQWtCLDRCQUE0QixnQ0FBZ0MsK0JBQStCLG1CQUFtQixtQkFBbUIseUJBQXlCLFNBQVMsaUJBQWlCLGtDQUFrQywyQkFBMkIsV0FBVyxxQkFBcUIseVNBQXlTLGVBQWUsZUFBZSxZQUFZLGVBQWUsK0NBQStDLG9GQUFvRixJQUFJLGtCQUFrQixxQkFBcUIsNkJBQTZCLDJDQUEyQyxLQUFLLE9BQU8sbURBQW1ELGFBQWEsb0JBQW9CLG9CQUFvQixHQUFHLGVBQWUsMENBQTBDLElBQUksbUNBQW1DLDREQUE0RCxpQkFBaUIsYUFBYSxvQ0FBb0MsU0FBUyxXQUFXLEVBQUUsZ0NBQWdDLDJHQUEyRyxzRUFBc0UsY0FBYyxRQUFRLFVBQVUseUJBQXlCLCtDQUErQyxZQUFZLG1CQUFtQixTQUFTLHVCQUF1QixZQUFZLHdCQUF3QiwrQkFBK0IsSUFBSSxTQUFTLHFCQUFxQixxQkFBcUIsSUFBSSxpQkFBaUIsSUFBSSw0QkFBNEIsVUFBVSxXQUFXLG9DQUFvQyxXQUFXLHVCQUF1QixVQUFVLFNBQVMsZ0RBQWdELCtHQUErRyxtQkFBbUIscUJBQXFCLElBQUksaUJBQWlCLElBQUksNEJBQTRCLFVBQVUsV0FBVyxvQ0FBb0MsV0FBVyx1QkFBdUIsVUFBVSxnQkFBZ0IsNkJBQTZCLG1DQUFtQyxPQUFPLG1CQUFtQixJQUFJLGFBQWEsNEVBQTRFLFlBQVksT0FBTyxpQ0FBaUMsRUFBRSxpQkFBaUIsYUFBYSxjQUFjLDBCQUEwQixXQUFXLGdCQUFnQix5R0FBeUcsZ0JBQWdCLGFBQWEsOEdBQThHLDRFQUE0RSw2Q0FBNkMsYUFBYSw0SUFBNEksaUJBQWlCLFdBQVcsNkJBQTZCLGlCQUFpQiwwQ0FBMEMsaUJBQWlCLGFBQWEsZ0JBQWdCLGtDQUFrQyw0QkFBNEIsWUFBWSwwQkFBMEIsb0JBQW9CLHFCQUFxQiw4QkFBOEIsZ0JBQWdCLEVBQUUsRUFBRSxpQkFBaUIsb0JBQW9CLHNCQUFzQixxQkFBcUIseUNBQXlDLGtMQUFrTCxlQUFlLDZCQUE2QixzQkFBc0IsbUNBQW1DLGVBQWUsc0JBQXNCLHlEQUF5RCxVQUFVLGlCQUFpQixhQUFhLCtLQUErSyxhQUFhLGtDQUFrQyxTQUFTLHdCQUF3QiwwQkFBMEIsVUFBVSx5QkFBeUIsc0JBQXNCLHlCQUF5QixzQkFBc0Isa0JBQWtCLHNCQUFzQixtSUFBbUksc0hBQXNILG9CQUFvQixzREFBc0Qsd0NBQXdDLGtDQUFrQywyQkFBMkIsVUFBVSxlQUFlLGFBQWEsaUJBQWlCLGdCQUFnQixlQUFlLFFBQVEsZ0JBQWdCLHdCQUF3QixvQkFBb0IsZUFBZSxhQUFhLGlCQUFpQixhQUFhLGlDQUFpQyxxQ0FBcUMsWUFBWSw0QkFBNEIsaUJBQWlCLFlBQVksc0JBQXNCLGlCQUFpQiw4REFBOEQsNEJBQTRCLCtDQUErQyxnTEFBZ0wsSUFBSSxtQkFBbUIsWUFBWSx1Q0FBdUMsTUFBTSxnRkFBZ0YsaUJBQWlCLDRCQUE0QixzREFBc0QsS0FBSyxnQ0FBZ0MsSUFBSSxzQkFBc0IsVUFBVSxpQkFBaUIsb0JBQW9CLG1DQUFtQyxlQUFlLGlCQUFpQixvREFBb0Qsd0JBQXdCLHNCQUFzQixtQ0FBbUMsS0FBSyxXQUFXLHFDQUFxQyxVQUFVLGlCQUFpQixvQkFBb0Isc0JBQXNCLGdCQUFnQixpQkFBaUIsWUFBWSxpRUFBaUUsNENBQTRDLGVBQWUsUUFBUSxVQUFVLHNCQUFzQiw4QkFBOEIsaUJBQWlCLDRCQUE0QixzQkFBc0IsdUJBQXVCLG9DQUFvQyxZQUFZLEtBQUssSUFBSSwyQkFBMkIsVUFBVSxJQUFJLDRDQUE0QyxlQUFlLGlCQUFpQix1QkFBdUIsc0JBQXNCLHVDQUF1QyxpQkFBaUIsa0NBQWtDLHdCQUF3QixtQ0FBbUMsaUJBQWlCLDRCQUE0QixzQkFBc0IsMEJBQTBCLGlCQUFpQixrREFBa0QsRUFBRSxzQkFBc0IscUJBQXFCLEdBQUcsZUFBZSx3QkFBd0Isc0JBQXNCLG1FQUFtRSxlQUFlLHFIQUFxSCxpQkFBaUIsa0RBQWtELGlCQUFpQiw2Q0FBNkMsMEJBQTBCLG1DQUFtQyx3QkFBd0IsR0FBRyxpQkFBaUIsd0ZBQXdGLG1EQUFtRCxVQUFVLGlCQUFpQiwyREFBMkQsNkNBQTZDLDJJQUEySSxpQkFBaUIsWUFBWSxzQkFBc0IscUJBQXFCLGlCQUFpQixNQUFNLG1JQUFtSSxJQUFJLEtBQUssbUNBQW1DLGlDQUFpQyxpQkFBaUIsYUFBYSxvQ0FBb0MsNENBQTRDLGlDQUFpQyxZQUFZLG9DQUFvQyxpR0FBaUcsa0VBQWtFLGVBQWUsdUJBQXVCLGVBQWUsd0JBQXdCLE9BQU8sbUJBQW1CLGlCQUFpQixVQUFVLGlCQUFpQixXQUFXLDZCQUE2QixpQkFBaUIsOENBQThDLGlCQUFpQixhQUFhLHlUQUF5VDtBQUMzaS9CLGdCQUFnQixNQUFNLGVBQWUsbUJBQW1CLFFBQVEsS0FBSyxLQUFLLGtCQUFrQixhQUFhLDJDQUEyQyxpQkFBaUIsbUJBQW1CLGdCQUFnQiw4Q0FBOEMseUJBQXlCLGFBQWEsc0JBQXNCLG1CQUFtQixzR0FBc0csbUJBQW1CLHdCQUF3QixrQ0FBa0MsaUJBQWlCLEtBQUsscUNBQXFDLElBQUksb0JBQW9CLFNBQVMsaUJBQWlCLGlDQUFpQyxlQUFlLDZCQUE2QiwwRkFBMEYsaUJBQWlCLDRDQUE0QyxhQUFhLHlEQUF5RCxlQUFlLDZCQUE2QixXQUFXLHNDQUFzQyxTQUFTLGdCQUFnQix5Q0FBeUMsV0FBVywwQ0FBMEMsVUFBVSxpQkFBaUIscUVBQXFFLDhEQUE4RCxpRkFBaUYsb0JBQW9CLHNCQUFzQixPQUFPLDhCQUE4QixlQUFlLDZHQUE2RyxlQUFlLG9CQUFvQixTQUFTLEVBQUUsNElBQTRJLGFBQWEsYUFBYSwyQkFBMkIsYUFBYSxhQUFhLHVCQUF1QixnQkFBZ0IsaUNBQWlDLG9CQUFvQixzQkFBc0IsdUNBQXVDLHNCQUFzQixLQUFLLHNCQUFzQixNQUFNLHlCQUF5Qix1SEFBdUgsaUNBQWlDLFVBQVUsMkJBQTJCLE1BQU0sSUFBSSxNQUFNLGdCQUFnQixXQUFXLHNCQUFzQixzQkFBc0Isc0JBQXNCLG1CQUFtQix3QkFBd0IscUVBQXFFLDBDQUEwQyx3QkFBd0IsMEZBQTBGLGlCQUFpQixvRkFBb0YsU0FBUyxxQkFBcUIsb0NBQW9DLEdBQUcsZ0JBQWdCLE9BQU8sT0FBTyxpQkFBaUIsRUFBRSxpQkFBaUIsbUVBQW1FLFlBQVksbUJBQW1CLGdCQUFnQixLQUFLLGNBQWMsaUJBQWlCLFlBQVksa0JBQWtCLGVBQWUsS0FBSyxjQUFjLGVBQWUsd0NBQXdDLGNBQWMsOENBQThDLGlCQUFpQiw0Q0FBNEMsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsaUNBQWlDLGFBQWEsR0FBRyxpQkFBaUIsb0JBQW9CLHdCQUF3Qix1Q0FBdUMsSUFBSSw4QkFBOEIsaUJBQWlCLDRCQUE0QixzQkFBc0IsaUJBQWlCLGdDQUFnQyxXQUFXLCtCQUErQixVQUFVLGVBQWUsaUNBQWlDLGVBQWUsTUFBTSxzQkFBc0IsaUJBQWlCLFlBQVkscUNBQXFDLHFCQUFxQixpQkFBaUIsMEJBQTBCLDRIQUE0SCxJQUFJLFlBQVksU0FBUyxtQkFBbUIsd0JBQXdCLHFEQUFxRCxpQkFBaUIsaURBQWlELDRDQUE0QyxlQUFlLGlCQUFpQixzRkFBc0YsMEJBQTBCLDBCQUEwQixjQUFjLFVBQVUseUNBQXlDLGdCQUFnQixpQkFBaUIsdUJBQXVCLGlCQUFpQixvQkFBb0IsaUJBQWlCLGFBQWEsY0FBYywwQkFBMEIsV0FBVyxzQ0FBc0MsU0FBUyxFQUFFLDZDQUE2QyxhQUFhLHNCQUFzQiw2QkFBNkIsdUNBQXVDLHVDQUF1Qyx1RUFBdUUsRUFBRSx3Q0FBd0Msd0NBQXdDLEtBQUssR0FBRyxZQUFZLEdBQUc7QUFDOThKLDJDQUEyQyxjQUFjIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxyKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1yKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxyKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnFhcnQ9cigpOnQucWFydD1yKCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7ZnVuY3Rpb24gcihuKXtpZihlW25dKXJldHVybiBlW25dLmV4cG9ydHM7dmFyIG89ZVtuXT17ZXhwb3J0czp7fSxpZDpuLGxvYWRlZDohMX07cmV0dXJuIHRbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsciksby5sb2FkZWQ9ITAsby5leHBvcnRzfXZhciBlPXt9O3JldHVybiByLm09dCxyLmM9ZSxyLnA9XCIuLi9kaXN0L1wiLHIoMCl9KFtmdW5jdGlvbih0LHIsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89ZSgxKSxpPW4obyksdT1lKDIpLGY9bih1KSxhPWUoMjEpLGM9ZSg3NSkscz1uKGMpLGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHIpe2lmKCgwLGkuZGVmYXVsdCkodGhpcyx0KSxcInVuZGVmaW5lZFwiPT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiUUFydCByZXF1aXJlZCBgb3B0aW9uc2AuXCIpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiByLnZhbHVlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJRQXJ0IHJlcXVpcmVkIGB2YWx1ZWAgb3B0aW9uLlwiKTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2Ygci5pbWFnZVBhdGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlFBcnQgcmVxdWlyZWQgYGltYWdlUGF0aGAgb3B0aW9uLlwiKTt0aGlzLmZpbHRlcj1cInVuZGVmaW5lZFwiPT10eXBlb2Ygci5maWx0ZXI/dC5ERUZBVUxUUy5maWx0ZXI6ci5maWx0ZXIsdGhpcy52YWx1ZT1yLnZhbHVlLHRoaXMuaW1hZ2VQYXRoPXIuaW1hZ2VQYXRofXJldHVybigwLGYuZGVmYXVsdCkodCxbe2tleTpcIm1ha2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj0xOTUsZT0xMixuPTEwLG89KDAsYS5RUkNvZGUpKG4sXCJIXCIpO28uYWRkRGF0YSh0aGlzLnZhbHVlKSxvLm1ha2UoKTt2YXIgaT1vLmNyZWF0ZUltZ09iamVjdCgzKSx1PXRoaXM7aS5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgbz1uZXcgSW1hZ2U7by5zcmM9dS5pbWFnZVBhdGg7dmFyIGY9cy5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhyLGkpLGM9cy5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhyLGkpO28ub25sb2FkPWZ1bmN0aW9uKCl7by53aWR0aDxvLmhlaWdodD8oby5oZWlnaHQ9KHItMiplKSooMSpvLmhlaWdodC9vLndpZHRoKSxvLndpZHRoPXItMiplKTooby53aWR0aD0oci0yKmUpKigxKm8ud2lkdGgvby5oZWlnaHQpLG8uaGVpZ2h0PXItMiplKTt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2kud2lkdGg9cixpLmhlaWdodD1yLGkuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZShvLGUsZSxyLTIqZSxyLTIqZSk7Zm9yKHZhciBsPWkuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAscixyKSxoPWwuZGF0YSxnPWYuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAscixyKSx2PWcuZGF0YSxwPTA7cDxoLmxlbmd0aDtwKz00KXt2YXIgZD1NYXRoLmZsb29yKHAvNCklcix5PU1hdGguZmxvb3IoTWF0aC5mbG9vcihwLzQpL3IpO2lmKGQ8ZXx8eTxlfHxkPj1yLWV8fHk+PXItZSl2W3ArM109MDtlbHNlIGlmKChkJTMhPTF8fHklMyE9MSkmJiEoZDwzNiYmKHk8MzZ8fHk+PXItMzYpfHxkPj1yLTM2JiZ5PDM2KSl7aWYoXCJ0aHJlc2hvbGRcIj09dS5maWx0ZXIpe3ZhciB3PXMuZGVmYXVsdC50aHJlc2hvbGQoaFtwXSxoW3ArMV0saFtwKzJdLDEyNyk7dltwXT13LHZbcCsxXT13LHZbcCsyXT13fWVsc2VcImNvbG9yXCI9PXUuZmlsdGVyJiYodltwXT1oW3BdLHZbcCsxXT1oW3ArMV0sdltwKzJdPWhbcCsyXSk7dltwKzNdPWhbcCszXX19Zi5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGcsMCwwKTtmb3IodmFyIG09YS5RUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKG4pLHA9MDtwPG0ubGVuZ3RoO3ArPTEpZm9yKHZhciBiPTA7YjxtLmxlbmd0aDtiKz0xKXt2YXIgZD1tW3BdLHk9bVtiXTtpZighKDY9PWQmJjUwPT15fHw2PT15JiY1MD09ZHx8Nj09ZCYmNj09eSkpe3ZhciBBPTMqKGQtMikrMTIseD0zKih5LTIpKzEyLEU9MyooZCszKSsxMi1BLE09MyooeSszKSsxMi14LF89Yy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKEEseCxFLE0pO2YuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShfLEEseCl9fXQuaW5uZXJIVE1MPVwiXCIsdC5hcHBlbmRDaGlsZChmKX19fX1dLFt7a2V5OlwiREVGQVVMVFNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6XCJcIixmaWx0ZXI6XCJ0aHJlc2hvbGRcIn19fV0pLHR9KCk7d2luZG93LlFBcnQ9bCxyLmRlZmF1bHQ9d2luZG93LlFBcnR9LGZ1bmN0aW9uKHQscil7XCJ1c2Ugc3RyaWN0XCI7ci5fX2VzTW9kdWxlPSEwLHIuZGVmYXVsdD1mdW5jdGlvbih0LHIpe2lmKCEodCBpbnN0YW5jZW9mIHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9fSxmdW5jdGlvbih0LHIsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ci5fX2VzTW9kdWxlPSEwO3ZhciBvPWUoMyksaT1uKG8pO3IuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxyKXtmb3IodmFyIGU9MDtlPHIubGVuZ3RoO2UrKyl7dmFyIG49cltlXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksKDAsaS5kZWZhdWx0KSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24ocixlLG4pe3JldHVybiBlJiZ0KHIucHJvdG90eXBlLGUpLG4mJnQocixuKSxyfX0oKX0sZnVuY3Rpb24odCxyLGUpe3QuZXhwb3J0cz17ZGVmYXVsdDplKDQpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LHIsZSl7ZSg1KTt2YXIgbj1lKDgpLk9iamVjdDt0LmV4cG9ydHM9ZnVuY3Rpb24odCxyLGUpe3JldHVybiBuLmRlZmluZVByb3BlcnR5KHQscixlKX19LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDYpO24obi5TK24uRiohZSgxNiksXCJPYmplY3RcIix7ZGVmaW5lUHJvcGVydHk6ZSgxMikuZn0pfSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSg3KSxvPWUoOCksaT1lKDkpLHU9ZSgxMSksZj1cInByb3RvdHlwZVwiLGE9ZnVuY3Rpb24odCxyLGUpe3ZhciBjLHMsbCxoPXQmYS5GLGc9dCZhLkcsdj10JmEuUyxwPXQmYS5QLGQ9dCZhLkIseT10JmEuVyx3PWc/bzpvW3JdfHwob1tyXT17fSksbT13W2ZdLGI9Zz9uOnY/bltyXToobltyXXx8e30pW2ZdO2cmJihlPXIpO2ZvcihjIGluIGUpcz0haCYmYiYmdm9pZCAwIT09YltjXSxzJiZjIGluIHd8fChsPXM/YltjXTplW2NdLHdbY109ZyYmXCJmdW5jdGlvblwiIT10eXBlb2YgYltjXT9lW2NdOmQmJnM/aShsLG4pOnkmJmJbY109PWw/ZnVuY3Rpb24odCl7dmFyIHI9ZnVuY3Rpb24ocixlLG4pe2lmKHRoaXMgaW5zdGFuY2VvZiB0KXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgdDtjYXNlIDE6cmV0dXJuIG5ldyB0KHIpO2Nhc2UgMjpyZXR1cm4gbmV3IHQocixlKX1yZXR1cm4gbmV3IHQocixlLG4pfXJldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIHJbZl09dFtmXSxyfShsKTpwJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2koRnVuY3Rpb24uY2FsbCxsKTpsLHAmJigody52aXJ0dWFsfHwody52aXJ0dWFsPXt9KSlbY109bCx0JmEuUiYmbSYmIW1bY10mJnUobSxjLGwpKSl9O2EuRj0xLGEuRz0yLGEuUz00LGEuUD04LGEuQj0xNixhLlc9MzIsYS5VPTY0LGEuUj0xMjgsdC5leHBvcnRzPWF9LGZ1bmN0aW9uKHQscil7dmFyIGU9dC5leHBvcnRzPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1wibnVtYmVyXCI9PXR5cGVvZiBfX2cmJihfX2c9ZSl9LGZ1bmN0aW9uKHQscil7dmFyIGU9dC5leHBvcnRzPXt2ZXJzaW9uOlwiMi40LjBcIn07XCJudW1iZXJcIj09dHlwZW9mIF9fZSYmKF9fZT1lKX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMTApO3QuZXhwb3J0cz1mdW5jdGlvbih0LHIsZSl7aWYobih0KSx2b2lkIDA9PT1yKXJldHVybiB0O3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0LmNhbGwocixlKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihlLG4pe3JldHVybiB0LmNhbGwocixlLG4pfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKGUsbixvKXtyZXR1cm4gdC5jYWxsKHIsZSxuLG8pfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShyLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYSBmdW5jdGlvbiFcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSgxMiksbz1lKDIwKTt0LmV4cG9ydHM9ZSgxNik/ZnVuY3Rpb24odCxyLGUpe3JldHVybiBuLmYodCxyLG8oMSxlKSl9OmZ1bmN0aW9uKHQscixlKXtyZXR1cm4gdFtyXT1lLHR9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSgxMyksbz1lKDE1KSxpPWUoMTkpLHU9T2JqZWN0LmRlZmluZVByb3BlcnR5O3IuZj1lKDE2KT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24odCxyLGUpe2lmKG4odCkscj1pKHIsITApLG4oZSksbyl0cnl7cmV0dXJuIHUodCxyLGUpfWNhdGNoKHQpe31pZihcImdldFwiaW4gZXx8XCJzZXRcImluIGUpdGhyb3cgVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhXCIpO3JldHVyblwidmFsdWVcImluIGUmJih0W3JdPWUudmFsdWUpLHR9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSgxNCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKCFuKHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhbiBvYmplY3QhXCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT10eXBlb2YgdH19LGZ1bmN0aW9uKHQscixlKXt0LmV4cG9ydHM9IWUoMTYpJiYhZSgxNykoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUoMTgpKFwiZGl2XCIpLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSl9LGZ1bmN0aW9uKHQscixlKXt0LmV4cG9ydHM9IWUoMTcpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSxmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2godCl7cmV0dXJuITB9fX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMTQpLG89ZSg3KS5kb2N1bWVudCxpPW4obykmJm4oby5jcmVhdGVFbGVtZW50KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGk/by5jcmVhdGVFbGVtZW50KHQpOnt9fX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMTQpO3QuZXhwb3J0cz1mdW5jdGlvbih0LHIpe2lmKCFuKHQpKXJldHVybiB0O3ZhciBlLG87aWYociYmXCJmdW5jdGlvblwiPT10eXBlb2YoZT10LnRvU3RyaW5nKSYmIW4obz1lLmNhbGwodCkpKXJldHVybiBvO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9dC52YWx1ZU9mKSYmIW4obz1lLmNhbGwodCkpKXJldHVybiBvO2lmKCFyJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihlPXQudG9TdHJpbmcpJiYhbihvPWUuY2FsbCh0KSkpcmV0dXJuIG87dGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6cn19fSxmdW5jdGlvbih0LHIsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIG8saSx1LGY9ZSgyMiksYT0obihmKSxmdW5jdGlvbigpe2Z1bmN0aW9uIHQocixlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2Ygci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKHIubGVuZ3RoK1wiL1wiK2UpO3ZhciBuPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aCYmMD09clt0XTspdCs9MTtmb3IodmFyIG49bmV3IEFycmF5KHIubGVuZ3RoLXQrZSksbz0wO288ci5sZW5ndGgtdDtvKz0xKW5bb109cltvK3RdO3JldHVybiBufSgpLG89e307cmV0dXJuIG8uZ2V0QXQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5bdF19LG8uZ2V0TGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIG4ubGVuZ3RofSxvLm11bHRpcGx5PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1uZXcgQXJyYXkoby5nZXRMZW5ndGgoKStyLmdldExlbmd0aCgpLTEpLG49MDtuPG8uZ2V0TGVuZ3RoKCk7bis9MSlmb3IodmFyIGk9MDtpPHIuZ2V0TGVuZ3RoKCk7aSs9MSllW24raV1ePXUuZ2V4cCh1Lmdsb2coby5nZXRBdChuKSkrdS5nbG9nKHIuZ2V0QXQoaSkpKTtyZXR1cm4gdChlLDApfSxvLm1vZD1mdW5jdGlvbihyKXtpZihvLmdldExlbmd0aCgpLXIuZ2V0TGVuZ3RoKCk8MClyZXR1cm4gbztmb3IodmFyIGU9dS5nbG9nKG8uZ2V0QXQoMCkpLXUuZ2xvZyhyLmdldEF0KDApKSxuPW5ldyBBcnJheShvLmdldExlbmd0aCgpKSxpPTA7aTxvLmdldExlbmd0aCgpO2krPTEpbltpXT1vLmdldEF0KGkpO2Zvcih2YXIgaT0wO2k8ci5nZXRMZW5ndGgoKTtpKz0xKW5baV1ePXUuZ2V4cCh1Lmdsb2coci5nZXRBdChpKSkrZSk7cmV0dXJuIHQobiwwKS5tb2Qocil9LG99dmFyIHI9ZnVuY3Rpb24ocixlKXt2YXIgbz0yMzYsdT0xNyxnPXIsdj1uW2VdLHA9bnVsbCxkPTAsbT1udWxsLGI9bmV3IEFycmF5LEE9e30seD1mdW5jdGlvbih0LHIpe2Q9NCpnKzE3LHA9ZnVuY3Rpb24odCl7Zm9yKHZhciByPW5ldyBBcnJheSh0KSxlPTA7ZTx0O2UrPTEpe3JbZV09bmV3IEFycmF5KHQpO2Zvcih2YXIgbj0wO248dDtuKz0xKXJbZV1bbl09bnVsbH1yZXR1cm4gcn0oZCksRSgwLDApLEUoZC03LDApLEUoMCxkLTcpLE8oKSxfKCksQih0LHIpLGc+PTcmJlQodCksbnVsbD09bSYmKG09QyhnLHYsYikpLFMobSxyKX0sRT1mdW5jdGlvbih0LHIpe2Zvcih2YXIgZT0tMTtlPD03O2UrPTEpaWYoISh0K2U8PS0xfHxkPD10K2UpKWZvcih2YXIgbj0tMTtuPD03O24rPTEpcituPD0tMXx8ZDw9citufHwoMDw9ZSYmZTw9NiYmKDA9PW58fDY9PW4pfHwwPD1uJiZuPD02JiYoMD09ZXx8Nj09ZSl8fDI8PWUmJmU8PTQmJjI8PW4mJm48PTQ/cFt0K2VdW3Irbl09ITA6cFt0K2VdW3Irbl09ITEpfSxNPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAscj0wLGU9MDtlPDg7ZSs9MSl7eCghMCxlKTt2YXIgbj1pLmdldExvc3RQb2ludChBKTsoMD09ZXx8dD5uKSYmKHQ9bixyPWUpfXJldHVybiByfSxfPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTg7dDxkLTg7dCs9MSludWxsPT1wW3RdWzZdJiYocFt0XVs2XT10JTI9PTApO2Zvcih2YXIgcj04O3I8ZC04O3IrPTEpbnVsbD09cFs2XVtyXSYmKHBbNl1bcl09ciUyPT0wKX0sTz1mdW5jdGlvbigpe2Zvcih2YXIgdD1pLmdldFBhdHRlcm5Qb3NpdGlvbihnKSxyPTA7cjx0Lmxlbmd0aDtyKz0xKWZvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSs9MSl7dmFyIG49dFtyXSxvPXRbZV07aWYobnVsbD09cFtuXVtvXSlmb3IodmFyIHU9LTI7dTw9Mjt1Kz0xKWZvcih2YXIgZj0tMjtmPD0yO2YrPTEpdT09LTJ8fDI9PXV8fGY9PS0yfHwyPT1mfHwwPT11JiYwPT1mP3Bbbit1XVtvK2ZdPSEwOnBbbit1XVtvK2ZdPSExfX0sVD1mdW5jdGlvbih0KXtmb3IodmFyIHI9aS5nZXRCQ0hUeXBlTnVtYmVyKGcpLGU9MDtlPDE4O2UrPTEpe3ZhciBuPSF0JiYxPT0ocj4+ZSYxKTtwW01hdGguZmxvb3IoZS8zKV1bZSUzK2QtOC0zXT1ufWZvcih2YXIgZT0wO2U8MTg7ZSs9MSl7dmFyIG49IXQmJjE9PShyPj5lJjEpO3BbZSUzK2QtOC0zXVtNYXRoLmZsb29yKGUvMyldPW59fSxCPWZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXY8PDN8cixuPWkuZ2V0QkNIVHlwZUluZm8oZSksbz0wO288MTU7bys9MSl7dmFyIHU9IXQmJjE9PShuPj5vJjEpO288Nj9wW29dWzhdPXU6bzw4P3BbbysxXVs4XT11OnBbZC0xNStvXVs4XT11fWZvcih2YXIgbz0wO288MTU7bys9MSl7dmFyIHU9IXQmJjE9PShuPj5vJjEpO288OD9wWzhdW2Qtby0xXT11Om88OT9wWzhdWzE1LW8tMSsxXT11OnBbOF1bMTUtby0xXT11fXBbZC04XVs4XT0hdH0sUz1mdW5jdGlvbih0LHIpe2Zvcih2YXIgZT0tMSxuPWQtMSxvPTcsdT0wLGY9aS5nZXRNYXNrRnVuY3Rpb24ociksYT1kLTE7YT4wO2EtPTIpZm9yKDY9PWEmJihhLT0xKTs7KXtmb3IodmFyIGM9MDtjPDI7Yys9MSlpZihudWxsPT1wW25dW2EtY10pe3ZhciBzPSExO3U8dC5sZW5ndGgmJihzPTE9PSh0W3VdPj4+byYxKSk7dmFyIGw9ZihuLGEtYyk7bCYmKHM9IXMpLHBbbl1bYS1jXT1zLG8tPTEsbz09LTEmJih1Kz0xLG89Nyl9aWYobis9ZSxuPDB8fGQ8PW4pe24tPWUsZT0tZTticmVha319fSxQPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciBuPTAsbz0wLHU9MCxmPW5ldyBBcnJheShlLmxlbmd0aCksYT1uZXcgQXJyYXkoZS5sZW5ndGgpLGM9MDtjPGUubGVuZ3RoO2MrPTEpe3ZhciBzPWVbY10uZGF0YUNvdW50LGw9ZVtjXS50b3RhbENvdW50LXM7bz1NYXRoLm1heChvLHMpLHU9TWF0aC5tYXgodSxsKSxmW2NdPW5ldyBBcnJheShzKTtmb3IodmFyIGg9MDtoPGZbY10ubGVuZ3RoO2grPTEpZltjXVtoXT0yNTUmci5nZXRCdWZmZXIoKVtoK25dO24rPXM7dmFyIGc9aS5nZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsKGwpLHY9dChmW2NdLGcuZ2V0TGVuZ3RoKCktMSkscD12Lm1vZChnKTthW2NdPW5ldyBBcnJheShnLmdldExlbmd0aCgpLTEpO2Zvcih2YXIgaD0wO2g8YVtjXS5sZW5ndGg7aCs9MSl7dmFyIGQ9aCtwLmdldExlbmd0aCgpLWFbY10ubGVuZ3RoO2FbY11baF09ZD49MD9wLmdldEF0KGQpOjB9fWZvcih2YXIgeT0wLGg9MDtoPGUubGVuZ3RoO2grPTEpeSs9ZVtoXS50b3RhbENvdW50O2Zvcih2YXIgdz1uZXcgQXJyYXkoeSksbT0wLGg9MDtoPG87aCs9MSlmb3IodmFyIGM9MDtjPGUubGVuZ3RoO2MrPTEpaDxmW2NdLmxlbmd0aCYmKHdbbV09ZltjXVtoXSxtKz0xKTtmb3IodmFyIGg9MDtoPHU7aCs9MSlmb3IodmFyIGM9MDtjPGUubGVuZ3RoO2MrPTEpaDxhW2NdLmxlbmd0aCYmKHdbbV09YVtjXVtoXSxtKz0xKTtyZXR1cm4gd30sQz1mdW5jdGlvbih0LHIsZSl7Zm9yKHZhciBuPWYuZ2V0UlNCbG9ja3ModCxyKSxjPWEoKSxzPTA7czxlLmxlbmd0aDtzKz0xKXt2YXIgbD1lW3NdO2MucHV0KGwuZ2V0TW9kZSgpLDQpLGMucHV0KGwuZ2V0TGVuZ3RoKCksaS5nZXRMZW5ndGhJbkJpdHMobC5nZXRNb2RlKCksdCkpLGwud3JpdGUoYyl9Zm9yKHZhciBoPTAscz0wO3M8bi5sZW5ndGg7cys9MSloKz1uW3NdLmRhdGFDb3VudDtpZihjLmdldExlbmd0aEluQml0cygpPjgqaCl0aHJvdyBuZXcgRXJyb3IoXCJjb2RlIGxlbmd0aCBvdmVyZmxvdy4gKFwiK2MuZ2V0TGVuZ3RoSW5CaXRzKCkrXCI+XCIrOCpoK1wiKVwiKTtmb3IoYy5nZXRMZW5ndGhJbkJpdHMoKSs0PD04KmgmJmMucHV0KDAsNCk7Yy5nZXRMZW5ndGhJbkJpdHMoKSU4IT0wOyljLnB1dEJpdCghMSk7Zm9yKDs7KXtpZihjLmdldExlbmd0aEluQml0cygpPj04KmgpYnJlYWs7aWYoYy5wdXQobyw4KSxjLmdldExlbmd0aEluQml0cygpPj04KmgpYnJlYWs7Yy5wdXQodSw4KX1yZXR1cm4gUChjLG4pfTtyZXR1cm4gQS5hZGREYXRhPWZ1bmN0aW9uKHQscil7cj1yfHxcIkJ5dGVcIjt2YXIgZT1udWxsO3N3aXRjaChyKXtjYXNlXCJOdW1lcmljXCI6ZT1jKHQpO2JyZWFrO2Nhc2VcIkFscGhhbnVtZXJpY1wiOmU9cyh0KTticmVhaztjYXNlXCJCeXRlXCI6ZT1sKHQpO2JyZWFrO2Nhc2VcIkthbmppXCI6ZT1oKHQpO2JyZWFrO2RlZmF1bHQ6dGhyb3dcIm1vZGU6XCIrcn1iLnB1c2goZSksbT1udWxsfSxBLmlzRGFyaz1mdW5jdGlvbih0LHIpe2lmKHQ8MHx8ZDw9dHx8cjwwfHxkPD1yKXRocm93IG5ldyBFcnJvcih0K1wiLFwiK3IpO3JldHVybiBwW3RdW3JdfSxBLmdldE1vZHVsZUNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIGR9LEEubWFrZT1mdW5jdGlvbigpe3goITEsTSgpKX0sQS5jcmVhdGVUYWJsZVRhZz1mdW5jdGlvbih0LHIpe3Q9dHx8MixyPVwidW5kZWZpbmVkXCI9PXR5cGVvZiByPzQqdDpyO3ZhciBlPVwiXCI7ZSs9Jzx0YWJsZSBzdHlsZT1cIicsZSs9XCIgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTtcIixlKz1cIiBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1wiLGUrPVwiIHBhZGRpbmc6IDBweDsgbWFyZ2luOiBcIityK1wicHg7XCIsZSs9J1wiPicsZSs9XCI8dGJvZHk+XCI7Zm9yKHZhciBuPTA7bjxBLmdldE1vZHVsZUNvdW50KCk7bis9MSl7ZSs9XCI8dHI+XCI7Zm9yKHZhciBvPTA7bzxBLmdldE1vZHVsZUNvdW50KCk7bys9MSllKz0nPHRkIHN0eWxlPVwiJyxlKz1cIiBib3JkZXItd2lkdGg6IDBweDsgYm9yZGVyLXN0eWxlOiBub25lO1wiLGUrPVwiIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XCIsZSs9XCIgcGFkZGluZzogMHB4OyBtYXJnaW46IDBweDtcIixlKz1cIiB3aWR0aDogXCIrdCtcInB4O1wiLGUrPVwiIGhlaWdodDogXCIrdCtcInB4O1wiLGUrPVwiIGJhY2tncm91bmQtY29sb3I6IFwiLGUrPUEuaXNEYXJrKG4sbyk/XCIjMDAwMDAwXCI6XCIjZmZmZmZmXCIsZSs9XCI7XCIsZSs9J1wiLz4nO2UrPVwiPC90cj5cIn1yZXR1cm4gZSs9XCI8L3Rib2R5PlwiLGUrPVwiPC90YWJsZT5cIn0sQS5jcmVhdGVTdmdUYWc9ZnVuY3Rpb24odCxyKXt0PXR8fDIscj1cInVuZGVmaW5lZFwiPT10eXBlb2Ygcj80KnQ6cjt2YXIgZSxuLG8saSx1LGY9QS5nZXRNb2R1bGVDb3VudCgpKnQrMipyLGE9XCJcIjtmb3IodT1cImxcIit0K1wiLDAgMCxcIit0K1wiIC1cIit0K1wiLDAgMCwtXCIrdCtcInogXCIsYSs9XCI8c3ZnXCIsYSs9JyB3aWR0aD1cIicrZisncHhcIicsYSs9JyBoZWlnaHQ9XCInK2YrJ3B4XCInLGErPScgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyxhKz1cIj5cIixhKz0nPHBhdGggZD1cIicsbz0wO288QS5nZXRNb2R1bGVDb3VudCgpO28rPTEpZm9yKGk9byp0K3IsZT0wO2U8QS5nZXRNb2R1bGVDb3VudCgpO2UrPTEpQS5pc0RhcmsobyxlKSYmKG49ZSp0K3IsYSs9XCJNXCIrbitcIixcIitpK3UpO3JldHVybiBhKz0nXCIgc3Ryb2tlPVwidHJhbnNwYXJlbnRcIiBmaWxsPVwiYmxhY2tcIi8+JyxhKz1cIjwvc3ZnPlwifSxBLmNyZWF0ZUltZ1RhZz1mdW5jdGlvbih0LHIpe3Q9dHx8MixyPVwidW5kZWZpbmVkXCI9PXR5cGVvZiByPzQqdDpyO3ZhciBlPUEuZ2V0TW9kdWxlQ291bnQoKSp0KzIqcixuPXIsbz1lLXI7cmV0dXJuIHkoZSxlLGZ1bmN0aW9uKHIsZSl7aWYobjw9ciYmcjxvJiZuPD1lJiZlPG8pe3ZhciBpPU1hdGguZmxvb3IoKHItbikvdCksdT1NYXRoLmZsb29yKChlLW4pL3QpO3JldHVybiBBLmlzRGFyayh1LGkpPzA6MX1yZXR1cm4gMX0pfSxBLmNyZWF0ZUltZ09iamVjdD1mdW5jdGlvbih0LHIpe3Q9dHx8MixyPVwidW5kZWZpbmVkXCI9PXR5cGVvZiByPzQqdDpyO3ZhciBlPUEuZ2V0TW9kdWxlQ291bnQoKSp0KzIqcixuPXIsbz1lLXI7cmV0dXJuIHcoZSxlLGZ1bmN0aW9uKHIsZSl7aWYobjw9ciYmcjxvJiZuPD1lJiZlPG8pe3ZhciBpPU1hdGguZmxvb3IoKHItbikvdCksdT1NYXRoLmZsb29yKChlLW4pL3QpO3JldHVybiBBLmlzRGFyayh1LGkpPzA6MX1yZXR1cm4gMX0pfSxBfTtyLnN0cmluZ1RvQnl0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciByPW5ldyBBcnJheSxlPTA7ZTx0Lmxlbmd0aDtlKz0xKXt2YXIgbj10LmNoYXJDb2RlQXQoZSk7ci5wdXNoKDI1NSZuKX1yZXR1cm4gcn0sci5jcmVhdGVTdHJpbmdUb0J5dGVzPWZ1bmN0aW9uKHQscil7dmFyIGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9cCh0KSxuPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5yZWFkKCk7aWYodD09LTEpdGhyb3cgbmV3IEVycm9yO3JldHVybiB0fSxvPTAsaT17fTs7KXt2YXIgdT1lLnJlYWQoKTtpZih1PT0tMSlicmVhazt2YXIgZj1uKCksYT1uKCksYz1uKCkscz1TdHJpbmcuZnJvbUNoYXJDb2RlKHU8PDh8ZiksbD1hPDw4fGM7aVtzXT1sLG8rPTF9aWYobyE9cil0aHJvdyBuZXcgRXJyb3IobytcIiAhPSBcIityKTtyZXR1cm4gaX0oKSxuPVwiP1wiLmNoYXJDb2RlQXQoMCk7cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1uZXcgQXJyYXksbz0wO288dC5sZW5ndGg7bys9MSl7dmFyIGk9dC5jaGFyQ29kZUF0KG8pO2lmKGk8MTI4KXIucHVzaChpKTtlbHNle3ZhciB1PWVbdC5jaGFyQXQobyldO1wibnVtYmVyXCI9PXR5cGVvZiB1PygyNTUmdSk9PXU/ci5wdXNoKHUpOihyLnB1c2godT4+PjgpLHIucHVzaCgyNTUmdSkpOnIucHVzaChuKX19cmV0dXJuIHJ9fTt2YXIgZT17TU9ERV9OVU1CRVI6MSxNT0RFX0FMUEhBX05VTToyLE1PREVfOEJJVF9CWVRFOjQsTU9ERV9LQU5KSTo4fSxuPXtMOjEsTTowLFE6MyxIOjJ9LG89e1BBVFRFUk4wMDA6MCxQQVRURVJOMDAxOjEsUEFUVEVSTjAxMDoyLFBBVFRFUk4wMTE6MyxQQVRURVJOMTAwOjQsUEFUVEVSTjEwMTo1LFBBVFRFUk4xMTA6NixQQVRURVJOMTExOjd9LGk9ZnVuY3Rpb24oKXt2YXIgcj1bW10sWzYsMThdLFs2LDIyXSxbNiwyNl0sWzYsMzBdLFs2LDM0XSxbNiwyMiwzOF0sWzYsMjQsNDJdLFs2LDI2LDQ2XSxbNiwyOCw1MF0sWzYsMzAsNTRdLFs2LDMyLDU4XSxbNiwzNCw2Ml0sWzYsMjYsNDYsNjZdLFs2LDI2LDQ4LDcwXSxbNiwyNiw1MCw3NF0sWzYsMzAsNTQsNzhdLFs2LDMwLDU2LDgyXSxbNiwzMCw1OCw4Nl0sWzYsMzQsNjIsOTBdLFs2LDI4LDUwLDcyLDk0XSxbNiwyNiw1MCw3NCw5OF0sWzYsMzAsNTQsNzgsMTAyXSxbNiwyOCw1NCw4MCwxMDZdLFs2LDMyLDU4LDg0LDExMF0sWzYsMzAsNTgsODYsMTE0XSxbNiwzNCw2Miw5MCwxMThdLFs2LDI2LDUwLDc0LDk4LDEyMl0sWzYsMzAsNTQsNzgsMTAyLDEyNl0sWzYsMjYsNTIsNzgsMTA0LDEzMF0sWzYsMzAsNTYsODIsMTA4LDEzNF0sWzYsMzQsNjAsODYsMTEyLDEzOF0sWzYsMzAsNTgsODYsMTE0LDE0Ml0sWzYsMzQsNjIsOTAsMTE4LDE0Nl0sWzYsMzAsNTQsNzgsMTAyLDEyNiwxNTBdLFs2LDI0LDUwLDc2LDEwMiwxMjgsMTU0XSxbNiwyOCw1NCw4MCwxMDYsMTMyLDE1OF0sWzYsMzIsNTgsODQsMTEwLDEzNiwxNjJdLFs2LDI2LDU0LDgyLDExMCwxMzgsMTY2XSxbNiwzMCw1OCw4NiwxMTQsMTQyLDE3MF1dLG49MTMzNSxpPTc5NzMsZj0yMTUyMixhPXt9LGM9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTA7MCE9dDspcis9MSx0Pj4+PTE7cmV0dXJuIHJ9O3JldHVybiBhLmdldEJDSFR5cGVJbmZvPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10PDwxMDtjKHIpLWMobik+PTA7KXJePW48PGMociktYyhuKTtyZXR1cm4odDw8MTB8cileZn0sYS5nZXRCQ0hUeXBlTnVtYmVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10PDwxMjtjKHIpLWMoaSk+PTA7KXJePWk8PGMociktYyhpKTtyZXR1cm4gdDw8MTJ8cn0sYS5nZXRQYXR0ZXJuUG9zaXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHJbdC0xXX0sYS5nZXRNYXNrRnVuY3Rpb249ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2Ugby5QQVRURVJOMDAwOnJldHVybiBmdW5jdGlvbih0LHIpe3JldHVybih0K3IpJTI9PTB9O2Nhc2Ugby5QQVRURVJOMDAxOnJldHVybiBmdW5jdGlvbih0LHIpe3JldHVybiB0JTI9PTB9O2Nhc2Ugby5QQVRURVJOMDEwOnJldHVybiBmdW5jdGlvbih0LHIpe3JldHVybiByJTM9PTB9O2Nhc2Ugby5QQVRURVJOMDExOnJldHVybiBmdW5jdGlvbih0LHIpe3JldHVybih0K3IpJTM9PTB9O2Nhc2Ugby5QQVRURVJOMTAwOnJldHVybiBmdW5jdGlvbih0LHIpe3JldHVybihNYXRoLmZsb29yKHQvMikrTWF0aC5mbG9vcihyLzMpKSUyPT0wfTtjYXNlIG8uUEFUVEVSTjEwMTpyZXR1cm4gZnVuY3Rpb24odCxyKXtyZXR1cm4gdCpyJTIrdCpyJTM9PTB9O2Nhc2Ugby5QQVRURVJOMTEwOnJldHVybiBmdW5jdGlvbih0LHIpe3JldHVybih0KnIlMit0KnIlMyklMj09MH07Y2FzZSBvLlBBVFRFUk4xMTE6cmV0dXJuIGZ1bmN0aW9uKHQscil7cmV0dXJuKHQqciUzKyh0K3IpJTIpJTI9PTB9O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiYmFkIG1hc2tQYXR0ZXJuOlwiK3QpfX0sYS5nZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT10KFsxXSwwKSxuPTA7bjxyO24rPTEpZT1lLm11bHRpcGx5KHQoWzEsdS5nZXhwKG4pXSwwKSk7cmV0dXJuIGV9LGEuZ2V0TGVuZ3RoSW5CaXRzPWZ1bmN0aW9uKHQscil7aWYoMTw9ciYmcjwxMClzd2l0Y2godCl7Y2FzZSBlLk1PREVfTlVNQkVSOnJldHVybiAxMDtjYXNlIGUuTU9ERV9BTFBIQV9OVU06cmV0dXJuIDk7Y2FzZSBlLk1PREVfOEJJVF9CWVRFOnJldHVybiA4O2Nhc2UgZS5NT0RFX0tBTkpJOnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwibW9kZTpcIit0KX1lbHNlIGlmKHI8Mjcpc3dpdGNoKHQpe2Nhc2UgZS5NT0RFX05VTUJFUjpyZXR1cm4gMTI7Y2FzZSBlLk1PREVfQUxQSEFfTlVNOnJldHVybiAxMTtjYXNlIGUuTU9ERV84QklUX0JZVEU6cmV0dXJuIDE2O2Nhc2UgZS5NT0RFX0tBTkpJOnJldHVybiAxMDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIm1vZGU6XCIrdCl9ZWxzZXtpZighKHI8NDEpKXRocm93IG5ldyBFcnJvcihcInR5cGU6XCIrcik7c3dpdGNoKHQpe2Nhc2UgZS5NT0RFX05VTUJFUjpyZXR1cm4gMTQ7Y2FzZSBlLk1PREVfQUxQSEFfTlVNOnJldHVybiAxMztjYXNlIGUuTU9ERV84QklUX0JZVEU6cmV0dXJuIDE2O2Nhc2UgZS5NT0RFX0tBTkpJOnJldHVybiAxMjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIm1vZGU6XCIrdCl9fX0sYS5nZXRMb3N0UG9pbnQ9ZnVuY3Rpb24odCl7Zm9yKHZhciByPXQuZ2V0TW9kdWxlQ291bnQoKSxlPTAsbj0wO248cjtuKz0xKWZvcih2YXIgbz0wO288cjtvKz0xKXtmb3IodmFyIGk9MCx1PXQuaXNEYXJrKG4sbyksZj0tMTtmPD0xO2YrPTEpaWYoIShuK2Y8MHx8cjw9bitmKSlmb3IodmFyIGE9LTE7YTw9MTthKz0xKW8rYTwwfHxyPD1vK2F8fDA9PWYmJjA9PWF8fHU9PXQuaXNEYXJrKG4rZixvK2EpJiYoaSs9MSk7aT41JiYoZSs9MytpLTUpfWZvcih2YXIgbj0wO248ci0xO24rPTEpZm9yKHZhciBvPTA7bzxyLTE7bys9MSl7dmFyIGM9MDt0LmlzRGFyayhuLG8pJiYoYys9MSksdC5pc0RhcmsobisxLG8pJiYoYys9MSksdC5pc0RhcmsobixvKzEpJiYoYys9MSksdC5pc0RhcmsobisxLG8rMSkmJihjKz0xKSwwIT1jJiY0IT1jfHwoZSs9Myl9Zm9yKHZhciBuPTA7bjxyO24rPTEpZm9yKHZhciBvPTA7bzxyLTY7bys9MSl0LmlzRGFyayhuLG8pJiYhdC5pc0RhcmsobixvKzEpJiZ0LmlzRGFyayhuLG8rMikmJnQuaXNEYXJrKG4sbyszKSYmdC5pc0RhcmsobixvKzQpJiYhdC5pc0RhcmsobixvKzUpJiZ0LmlzRGFyayhuLG8rNikmJihlKz00MCk7Zm9yKHZhciBvPTA7bzxyO28rPTEpZm9yKHZhciBuPTA7bjxyLTY7bis9MSl0LmlzRGFyayhuLG8pJiYhdC5pc0RhcmsobisxLG8pJiZ0LmlzRGFyayhuKzIsbykmJnQuaXNEYXJrKG4rMyxvKSYmdC5pc0Rhcmsobis0LG8pJiYhdC5pc0Rhcmsobis1LG8pJiZ0LmlzRGFyayhuKzYsbykmJihlKz00MCk7Zm9yKHZhciBzPTAsbz0wO288cjtvKz0xKWZvcih2YXIgbj0wO248cjtuKz0xKXQuaXNEYXJrKG4sbykmJihzKz0xKTt2YXIgbD1NYXRoLmFicygxMDAqcy9yL3ItNTApLzU7cmV0dXJuIGUrPTEwKmx9LGF9KCksdT1mdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkoMjU2KSxyPW5ldyBBcnJheSgyNTYpLGU9MDtlPDg7ZSs9MSl0W2VdPTE8PGU7Zm9yKHZhciBlPTg7ZTwyNTY7ZSs9MSl0W2VdPXRbZS00XV50W2UtNV1edFtlLTZdXnRbZS04XTtmb3IodmFyIGU9MDtlPDI1NTtlKz0xKXJbdFtlXV09ZTt2YXIgbj17fTtyZXR1cm4gbi5nbG9nPWZ1bmN0aW9uKHQpe2lmKHQ8MSl0aHJvdyBuZXcgRXJyb3IoXCJnbG9nKFwiK3QrXCIpXCIpO3JldHVybiByW3RdfSxuLmdleHA9ZnVuY3Rpb24ocil7Zm9yKDtyPDA7KXIrPTI1NTtmb3IoO3I+PTI1Njspci09MjU1O3JldHVybiB0W3JdfSxufSgpLGY9ZnVuY3Rpb24oKXt2YXIgdD1bWzEsMjYsMTldLFsxLDI2LDE2XSxbMSwyNiwxM10sWzEsMjYsOV0sWzEsNDQsMzRdLFsxLDQ0LDI4XSxbMSw0NCwyMl0sWzEsNDQsMTZdLFsxLDcwLDU1XSxbMSw3MCw0NF0sWzIsMzUsMTddLFsyLDM1LDEzXSxbMSwxMDAsODBdLFsyLDUwLDMyXSxbMiw1MCwyNF0sWzQsMjUsOV0sWzEsMTM0LDEwOF0sWzIsNjcsNDNdLFsyLDMzLDE1LDIsMzQsMTZdLFsyLDMzLDExLDIsMzQsMTJdLFsyLDg2LDY4XSxbNCw0MywyN10sWzQsNDMsMTldLFs0LDQzLDE1XSxbMiw5OCw3OF0sWzQsNDksMzFdLFsyLDMyLDE0LDQsMzMsMTVdLFs0LDM5LDEzLDEsNDAsMTRdLFsyLDEyMSw5N10sWzIsNjAsMzgsMiw2MSwzOV0sWzQsNDAsMTgsMiw0MSwxOV0sWzQsNDAsMTQsMiw0MSwxNV0sWzIsMTQ2LDExNl0sWzMsNTgsMzYsMiw1OSwzN10sWzQsMzYsMTYsNCwzNywxN10sWzQsMzYsMTIsNCwzNywxM10sWzIsODYsNjgsMiw4Nyw2OV0sWzQsNjksNDMsMSw3MCw0NF0sWzYsNDMsMTksMiw0NCwyMF0sWzYsNDMsMTUsMiw0NCwxNl0sWzQsMTAxLDgxXSxbMSw4MCw1MCw0LDgxLDUxXSxbNCw1MCwyMiw0LDUxLDIzXSxbMywzNiwxMiw4LDM3LDEzXSxbMiwxMTYsOTIsMiwxMTcsOTNdLFs2LDU4LDM2LDIsNTksMzddLFs0LDQ2LDIwLDYsNDcsMjFdLFs3LDQyLDE0LDQsNDMsMTVdLFs0LDEzMywxMDddLFs4LDU5LDM3LDEsNjAsMzhdLFs4LDQ0LDIwLDQsNDUsMjFdLFsxMiwzMywxMSw0LDM0LDEyXSxbMywxNDUsMTE1LDEsMTQ2LDExNl0sWzQsNjQsNDAsNSw2NSw0MV0sWzExLDM2LDE2LDUsMzcsMTddLFsxMSwzNiwxMiw1LDM3LDEzXSxbNSwxMDksODcsMSwxMTAsODhdLFs1LDY1LDQxLDUsNjYsNDJdLFs1LDU0LDI0LDcsNTUsMjVdLFsxMSwzNiwxMiw3LDM3LDEzXSxbNSwxMjIsOTgsMSwxMjMsOTldLFs3LDczLDQ1LDMsNzQsNDZdLFsxNSw0MywxOSwyLDQ0LDIwXSxbMyw0NSwxNSwxMyw0NiwxNl0sWzEsMTM1LDEwNyw1LDEzNiwxMDhdLFsxMCw3NCw0NiwxLDc1LDQ3XSxbMSw1MCwyMiwxNSw1MSwyM10sWzIsNDIsMTQsMTcsNDMsMTVdLFs1LDE1MCwxMjAsMSwxNTEsMTIxXSxbOSw2OSw0Myw0LDcwLDQ0XSxbMTcsNTAsMjIsMSw1MSwyM10sWzIsNDIsMTQsMTksNDMsMTVdLFszLDE0MSwxMTMsNCwxNDIsMTE0XSxbMyw3MCw0NCwxMSw3MSw0NV0sWzE3LDQ3LDIxLDQsNDgsMjJdLFs5LDM5LDEzLDE2LDQwLDE0XSxbMywxMzUsMTA3LDUsMTM2LDEwOF0sWzMsNjcsNDEsMTMsNjgsNDJdLFsxNSw1NCwyNCw1LDU1LDI1XSxbMTUsNDMsMTUsMTAsNDQsMTZdLFs0LDE0NCwxMTYsNCwxNDUsMTE3XSxbMTcsNjgsNDJdLFsxNyw1MCwyMiw2LDUxLDIzXSxbMTksNDYsMTYsNiw0NywxN10sWzIsMTM5LDExMSw3LDE0MCwxMTJdLFsxNyw3NCw0Nl0sWzcsNTQsMjQsMTYsNTUsMjVdLFszNCwzNywxM10sWzQsMTUxLDEyMSw1LDE1MiwxMjJdLFs0LDc1LDQ3LDE0LDc2LDQ4XSxbMTEsNTQsMjQsMTQsNTUsMjVdLFsxNiw0NSwxNSwxNCw0NiwxNl0sWzYsMTQ3LDExNyw0LDE0OCwxMThdLFs2LDczLDQ1LDE0LDc0LDQ2XSxbMTEsNTQsMjQsMTYsNTUsMjVdLFszMCw0NiwxNiwyLDQ3LDE3XSxbOCwxMzIsMTA2LDQsMTMzLDEwN10sWzgsNzUsNDcsMTMsNzYsNDhdLFs3LDU0LDI0LDIyLDU1LDI1XSxbMjIsNDUsMTUsMTMsNDYsMTZdLFsxMCwxNDIsMTE0LDIsMTQzLDExNV0sWzE5LDc0LDQ2LDQsNzUsNDddLFsyOCw1MCwyMiw2LDUxLDIzXSxbMzMsNDYsMTYsNCw0NywxN10sWzgsMTUyLDEyMiw0LDE1MywxMjNdLFsyMiw3Myw0NSwzLDc0LDQ2XSxbOCw1MywyMywyNiw1NCwyNF0sWzEyLDQ1LDE1LDI4LDQ2LDE2XSxbMywxNDcsMTE3LDEwLDE0OCwxMThdLFszLDczLDQ1LDIzLDc0LDQ2XSxbNCw1NCwyNCwzMSw1NSwyNV0sWzExLDQ1LDE1LDMxLDQ2LDE2XSxbNywxNDYsMTE2LDcsMTQ3LDExN10sWzIxLDczLDQ1LDcsNzQsNDZdLFsxLDUzLDIzLDM3LDU0LDI0XSxbMTksNDUsMTUsMjYsNDYsMTZdLFs1LDE0NSwxMTUsMTAsMTQ2LDExNl0sWzE5LDc1LDQ3LDEwLDc2LDQ4XSxbMTUsNTQsMjQsMjUsNTUsMjVdLFsyMyw0NSwxNSwyNSw0NiwxNl0sWzEzLDE0NSwxMTUsMywxNDYsMTE2XSxbMiw3NCw0NiwyOSw3NSw0N10sWzQyLDU0LDI0LDEsNTUsMjVdLFsyMyw0NSwxNSwyOCw0NiwxNl0sWzE3LDE0NSwxMTVdLFsxMCw3NCw0NiwyMyw3NSw0N10sWzEwLDU0LDI0LDM1LDU1LDI1XSxbMTksNDUsMTUsMzUsNDYsMTZdLFsxNywxNDUsMTE1LDEsMTQ2LDExNl0sWzE0LDc0LDQ2LDIxLDc1LDQ3XSxbMjksNTQsMjQsMTksNTUsMjVdLFsxMSw0NSwxNSw0Niw0NiwxNl0sWzEzLDE0NSwxMTUsNiwxNDYsMTE2XSxbMTQsNzQsNDYsMjMsNzUsNDddLFs0NCw1NCwyNCw3LDU1LDI1XSxbNTksNDYsMTYsMSw0NywxN10sWzEyLDE1MSwxMjEsNywxNTIsMTIyXSxbMTIsNzUsNDcsMjYsNzYsNDhdLFszOSw1NCwyNCwxNCw1NSwyNV0sWzIyLDQ1LDE1LDQxLDQ2LDE2XSxbNiwxNTEsMTIxLDE0LDE1MiwxMjJdLFs2LDc1LDQ3LDM0LDc2LDQ4XSxbNDYsNTQsMjQsMTAsNTUsMjVdLFsyLDQ1LDE1LDY0LDQ2LDE2XSxbMTcsMTUyLDEyMiw0LDE1MywxMjNdLFsyOSw3NCw0NiwxNCw3NSw0N10sWzQ5LDU0LDI0LDEwLDU1LDI1XSxbMjQsNDUsMTUsNDYsNDYsMTZdLFs0LDE1MiwxMjIsMTgsMTUzLDEyM10sWzEzLDc0LDQ2LDMyLDc1LDQ3XSxbNDgsNTQsMjQsMTQsNTUsMjVdLFs0Miw0NSwxNSwzMiw0NiwxNl0sWzIwLDE0NywxMTcsNCwxNDgsMTE4XSxbNDAsNzUsNDcsNyw3Niw0OF0sWzQzLDU0LDI0LDIyLDU1LDI1XSxbMTAsNDUsMTUsNjcsNDYsMTZdLFsxOSwxNDgsMTE4LDYsMTQ5LDExOV0sWzE4LDc1LDQ3LDMxLDc2LDQ4XSxbMzQsNTQsMjQsMzQsNTUsMjVdLFsyMCw0NSwxNSw2MSw0NiwxNl1dLHI9ZnVuY3Rpb24odCxyKXt2YXIgZT17fTtyZXR1cm4gZS50b3RhbENvdW50PXQsZS5kYXRhQ291bnQ9cixlfSxlPXt9LG89ZnVuY3Rpb24ocixlKXtzd2l0Y2goZSl7Y2FzZSBuLkw6cmV0dXJuIHRbNCooci0xKSswXTtjYXNlIG4uTTpyZXR1cm4gdFs0KihyLTEpKzFdO2Nhc2Ugbi5ROnJldHVybiB0WzQqKHItMSkrMl07Y2FzZSBuLkg6cmV0dXJuIHRbNCooci0xKSszXTtkZWZhdWx0OnJldHVybn19O3JldHVybiBlLmdldFJTQmxvY2tzPWZ1bmN0aW9uKHQsZSl7dmFyIG49byh0LGUpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcImJhZCBycyBibG9jayBAIHR5cGVOdW1iZXI6XCIrdCtcIi9lcnJvckNvcnJlY3Rpb25MZXZlbDpcIitlKTtmb3IodmFyIGk9bi5sZW5ndGgvMyx1PW5ldyBBcnJheSxmPTA7ZjxpO2YrPTEpZm9yKHZhciBhPW5bMypmKzBdLGM9blszKmYrMV0scz1uWzMqZisyXSxsPTA7bDxhO2wrPTEpdS5wdXNoKHIoYyxzKSk7cmV0dXJuIHV9LGV9KCksYT1mdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSxyPTAsZT17fTtyZXR1cm4gZS5nZXRCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sZS5nZXRBdD1mdW5jdGlvbihyKXt2YXIgZT1NYXRoLmZsb29yKHIvOCk7cmV0dXJuIDE9PSh0W2VdPj4+Ny1yJTgmMSl9LGUucHV0PWZ1bmN0aW9uKHQscil7Zm9yKHZhciBuPTA7bjxyO24rPTEpZS5wdXRCaXQoMT09KHQ+Pj5yLW4tMSYxKSl9LGUuZ2V0TGVuZ3RoSW5CaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHJ9LGUucHV0Qml0PWZ1bmN0aW9uKGUpe3ZhciBuPU1hdGguZmxvb3Ioci84KTt0Lmxlbmd0aDw9biYmdC5wdXNoKDApLGUmJih0W25dfD0xMjg+Pj5yJTgpLHIrPTF9LGV9LGM9ZnVuY3Rpb24odCl7dmFyIHI9ZS5NT0RFX05VTUJFUixuPXQsbz17fTtvLmdldE1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gcn0sby5nZXRMZW5ndGg9ZnVuY3Rpb24odCl7cmV0dXJuIG4ubGVuZ3RofSxvLndyaXRlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1uLGU9MDtlKzI8ci5sZW5ndGg7KXQucHV0KGkoci5zdWJzdHJpbmcoZSxlKzMpKSwxMCksZSs9MztlPHIubGVuZ3RoJiYoci5sZW5ndGgtZT09MT90LnB1dChpKHIuc3Vic3RyaW5nKGUsZSsxKSksNCk6ci5sZW5ndGgtZT09MiYmdC5wdXQoaShyLnN1YnN0cmluZyhlLGUrMikpLDcpKX07dmFyIGk9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTAsZT0wO2U8dC5sZW5ndGg7ZSs9MSlyPTEwKnIrdSh0LmNoYXJBdChlKSk7cmV0dXJuIHJ9LHU9ZnVuY3Rpb24odCl7aWYoXCIwXCI8PXQmJnQ8PVwiOVwiKXJldHVybiB0LmNoYXJDb2RlQXQoMCktXCIwXCIuY2hhckNvZGVBdCgwKTt0aHJvd1wiaWxsZWdhbCBjaGFyIDpcIit0fTtyZXR1cm4gb30scz1mdW5jdGlvbih0KXt2YXIgcj1lLk1PREVfQUxQSEFfTlVNLG49dCxvPXt9O28uZ2V0TW9kZT1mdW5jdGlvbigpe3JldHVybiByfSxvLmdldExlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gbi5sZW5ndGh9LG8ud3JpdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciByPW4sZT0wO2UrMTxyLmxlbmd0aDspdC5wdXQoNDUqaShyLmNoYXJBdChlKSkraShyLmNoYXJBdChlKzEpKSwxMSksZSs9MjtlPHIubGVuZ3RoJiZ0LnB1dChpKHIuY2hhckF0KGUpKSw2KX07dmFyIGk9ZnVuY3Rpb24odCl7aWYoXCIwXCI8PXQmJnQ8PVwiOVwiKXJldHVybiB0LmNoYXJDb2RlQXQoMCktXCIwXCIuY2hhckNvZGVBdCgwKTtpZihcIkFcIjw9dCYmdDw9XCJaXCIpcmV0dXJuIHQuY2hhckNvZGVBdCgwKS1cIkFcIi5jaGFyQ29kZUF0KDApKzEwO3N3aXRjaCh0KXtjYXNlXCIgXCI6cmV0dXJuIDM2O2Nhc2VcIiRcIjpyZXR1cm4gMzc7Y2FzZVwiJVwiOnJldHVybiAzODtjYXNlXCIqXCI6cmV0dXJuIDM5O2Nhc2VcIitcIjpyZXR1cm4gNDA7Y2FzZVwiLVwiOnJldHVybiA0MTtjYXNlXCIuXCI6cmV0dXJuIDQyO2Nhc2VcIi9cIjpyZXR1cm4gNDM7Y2FzZVwiOlwiOnJldHVybiA0NDtkZWZhdWx0OnRocm93XCJpbGxlZ2FsIGNoYXIgOlwiK3R9fTtyZXR1cm4gb30sbD1mdW5jdGlvbih0KXt2YXIgbj1lLk1PREVfOEJJVF9CWVRFLG89ci5zdHJpbmdUb0J5dGVzKHQpLGk9e307cmV0dXJuIGkuZ2V0TW9kZT1mdW5jdGlvbigpe3JldHVybiBufSxpLmdldExlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gby5sZW5ndGh9LGkud3JpdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTA7cjxvLmxlbmd0aDtyKz0xKXQucHV0KG9bcl0sOCl9LGl9LGg9ZnVuY3Rpb24odCl7dmFyIG49ZS5NT0RFX0tBTkpJLG89ci5zdHJpbmdUb0J5dGVzKHQpOyFmdW5jdGlvbih0LGUpe3ZhciBuPXIuc3RyaW5nVG9CeXRlcyh0KTtpZigyIT1uLmxlbmd0aHx8KG5bMF08PDh8blsxXSkhPWUpdGhyb3dcInNqaXMgbm90IHN1cHBvcnRlZC5cIn0oXCLlj4tcIiwzODcyNik7dmFyIGk9e307cmV0dXJuIGkuZ2V0TW9kZT1mdW5jdGlvbigpe3JldHVybiBufSxpLmdldExlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm5+fihvLmxlbmd0aC8yKX0saS53cml0ZT1mdW5jdGlvbih0KXtmb3IodmFyIHI9byxlPTA7ZSsxPHIubGVuZ3RoOyl7dmFyIG49KDI1NSZyW2VdKTw8OHwyNTUmcltlKzFdO2lmKDMzMDg4PD1uJiZuPD00MDk1NiluLT0zMzA4ODtlbHNle2lmKCEoNTc0MDg8PW4mJm48PTYwMzUxKSl0aHJvd1wiaWxsZWdhbCBjaGFyIGF0IFwiKyhlKzEpK1wiL1wiK247bi09NDk0NzJ9bj0xOTIqKG4+Pj44JjI1NSkrKDI1NSZuKSx0LnB1dChuLDEzKSxlKz0yfWlmKGU8ci5sZW5ndGgpdGhyb3dcImlsbGVnYWwgY2hhciBhdCBcIisoZSsxKX0saX0sZz1mdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSxyPXt9O3JldHVybiByLndyaXRlQnl0ZT1mdW5jdGlvbihyKXt0LnB1c2goMjU1JnIpfSxyLndyaXRlU2hvcnQ9ZnVuY3Rpb24odCl7ci53cml0ZUJ5dGUodCksci53cml0ZUJ5dGUodD4+PjgpfSxyLndyaXRlQnl0ZXM9ZnVuY3Rpb24odCxlLG4pe2U9ZXx8MCxuPW58fHQubGVuZ3RoO2Zvcih2YXIgbz0wO288bjtvKz0xKXIud3JpdGVCeXRlKHRbbytlXSl9LHIud3JpdGVTdHJpbmc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKz0xKXIud3JpdGVCeXRlKHQuY2hhckNvZGVBdChlKSl9LHIudG9CeXRlQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sci50b1N0cmluZz1mdW5jdGlvbigpe3ZhciByPVwiXCI7cis9XCJbXCI7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKz0xKWU+MCYmKHIrPVwiLFwiKSxyKz10W2VdO3JldHVybiByKz1cIl1cIn0scn0sdj1mdW5jdGlvbigpe3ZhciB0PTAscj0wLGU9MCxuPVwiXCIsbz17fSxpPWZ1bmN0aW9uKHQpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUodSg2MyZ0KSl9LHU9ZnVuY3Rpb24odCl7aWYodDwwKTtlbHNle2lmKHQ8MjYpcmV0dXJuIDY1K3Q7aWYodDw1MilyZXR1cm4gOTcrKHQtMjYpO2lmKHQ8NjIpcmV0dXJuIDQ4Kyh0LTUyKTtpZig2Mj09dClyZXR1cm4gNDM7aWYoNjM9PXQpcmV0dXJuIDQ3fXRocm93IG5ldyBFcnJvcihcIm46XCIrdCl9O3JldHVybiBvLndyaXRlQnl0ZT1mdW5jdGlvbihuKXtmb3IodD10PDw4fDI1NSZuLHIrPTgsZSs9MTtyPj02OylpKHQ+Pj5yLTYpLHItPTZ9LG8uZmx1c2g9ZnVuY3Rpb24oKXtpZihyPjAmJihpKHQ8PDYtciksdD0wLHI9MCksZSUzIT0wKWZvcih2YXIgbz0zLWUlMyx1PTA7dTxvO3UrPTEpbis9XCI9XCJ9LG8udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbn0sb30scD1mdW5jdGlvbih0KXt2YXIgcj10LGU9MCxuPTAsbz0wLGk9e307aS5yZWFkPWZ1bmN0aW9uKCl7Zm9yKDtvPDg7KXtpZihlPj1yLmxlbmd0aCl7aWYoMD09bylyZXR1cm4tMTt0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGVuZCBvZiBmaWxlLi9cIitvKX12YXIgdD1yLmNoYXJBdChlKTtpZihlKz0xLFwiPVwiPT10KXJldHVybiBvPTAsLTE7dC5tYXRjaCgvXlxccyQvKXx8KG49bjw8Nnx1KHQuY2hhckNvZGVBdCgwKSksbys9Nil9dmFyIGk9bj4+Pm8tOCYyNTU7cmV0dXJuIG8tPTgsaX07dmFyIHU9ZnVuY3Rpb24odCl7aWYoNjU8PXQmJnQ8PTkwKXJldHVybiB0LTY1O2lmKDk3PD10JiZ0PD0xMjIpcmV0dXJuIHQtOTcrMjY7aWYoNDg8PXQmJnQ8PTU3KXJldHVybiB0LTQ4KzUyO2lmKDQzPT10KXJldHVybiA2MjtpZig0Nz09dClyZXR1cm4gNjM7dGhyb3cgbmV3IEVycm9yKFwiYzpcIit0KX07cmV0dXJuIGl9LGQ9ZnVuY3Rpb24odCxyKXt2YXIgZT10LG49cixvPW5ldyBBcnJheSh0KnIpLGk9e307aS5zZXRQaXhlbD1mdW5jdGlvbih0LHIsbil7b1tyKmUrdF09bn0saS53cml0ZT1mdW5jdGlvbih0KXt0LndyaXRlU3RyaW5nKFwiR0lGODdhXCIpLHQud3JpdGVTaG9ydChlKSx0LndyaXRlU2hvcnQobiksdC53cml0ZUJ5dGUoMTI4KSx0LndyaXRlQnl0ZSgwKSx0LndyaXRlQnl0ZSgwKSx0LndyaXRlQnl0ZSgwKSx0LndyaXRlQnl0ZSgwKSx0LndyaXRlQnl0ZSgwKSx0LndyaXRlQnl0ZSgyNTUpLHQud3JpdGVCeXRlKDI1NSksdC53cml0ZUJ5dGUoMjU1KSx0LndyaXRlU3RyaW5nKFwiLFwiKSx0LndyaXRlU2hvcnQoMCksdC53cml0ZVNob3J0KDApLHQud3JpdGVTaG9ydChlKSx0LndyaXRlU2hvcnQobiksdC53cml0ZUJ5dGUoMCk7dmFyIHI9MixvPWYocik7dC53cml0ZUJ5dGUocik7Zm9yKHZhciBpPTA7by5sZW5ndGgtaT4yNTU7KXQud3JpdGVCeXRlKDI1NSksdC53cml0ZUJ5dGVzKG8saSwyNTUpLGkrPTI1NTt0LndyaXRlQnl0ZShvLmxlbmd0aC1pKSx0LndyaXRlQnl0ZXMobyxpLG8ubGVuZ3RoLWkpLHQud3JpdGVCeXRlKDApLHQud3JpdGVTdHJpbmcoXCI7XCIpfTt2YXIgdT1mdW5jdGlvbih0KXt2YXIgcj10LGU9MCxuPTAsbz17fTtyZXR1cm4gby53cml0ZT1mdW5jdGlvbih0LG8pe2lmKHQ+Pj5vIT0wKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvdmVyXCIpO2Zvcig7ZStvPj04OylyLndyaXRlQnl0ZSgyNTUmKHQ8PGV8bikpLG8tPTgtZSx0Pj4+PTgtZSxuPTAsZT0wO258PXQ8PGUsZSs9b30sby5mbHVzaD1mdW5jdGlvbigpe2U+MCYmci53cml0ZUJ5dGUobil9LG99LGY9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTE8PHQsZT0oMTw8dCkrMSxuPXQrMSxpPWEoKSxmPTA7ZjxyO2YrPTEpaS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShmKSk7aS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShyKSksaS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShlKSk7dmFyIGM9ZygpLHM9dShjKTtzLndyaXRlKHIsbik7dmFyIGw9MCxoPVN0cmluZy5mcm9tQ2hhckNvZGUob1tsXSk7Zm9yKGwrPTE7bDxvLmxlbmd0aDspe3ZhciB2PVN0cmluZy5mcm9tQ2hhckNvZGUob1tsXSk7bCs9MSxpLmNvbnRhaW5zKGgrdik/aCs9djoocy53cml0ZShpLmluZGV4T2YoaCksbiksaS5zaXplKCk8NDA5NSYmKGkuc2l6ZSgpPT0xPDxuJiYobis9MSksaS5hZGQoaCt2KSksaD12KX1yZXR1cm4gcy53cml0ZShpLmluZGV4T2YoaCksbikscy53cml0ZShlLG4pLHMuZmx1c2goKSxjLnRvQnl0ZUFycmF5KCl9LGE9ZnVuY3Rpb24oKXt2YXIgdD17fSxyPTAsZT17fTtyZXR1cm4gZS5hZGQ9ZnVuY3Rpb24obil7aWYoZS5jb250YWlucyhuKSl0aHJvdyBuZXcgRXJyb3IoXCJkdXAga2V5OlwiK24pO3Rbbl09cixyKz0xfSxlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gcn0sZS5pbmRleE9mPWZ1bmN0aW9uKHIpe3JldHVybiB0W3JdfSxlLmNvbnRhaW5zPWZ1bmN0aW9uKHIpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB0W3JdfSxlfTtyZXR1cm4gaX0seT1mdW5jdGlvbih0LHIsZSxuKXtmb3IodmFyIG89ZCh0LHIpLGk9MDtpPHI7aSs9MSlmb3IodmFyIHU9MDt1PHQ7dSs9MSlvLnNldFBpeGVsKHUsaSxlKHUsaSkpO3ZhciBmPWcoKTtvLndyaXRlKGYpO2Zvcih2YXIgYT12KCksYz1mLnRvQnl0ZUFycmF5KCkscz0wO3M8Yy5sZW5ndGg7cys9MSlhLndyaXRlQnl0ZShjW3NdKTthLmZsdXNoKCk7dmFyIGw9XCJcIjtyZXR1cm4gbCs9XCI8aW1nXCIsbCs9JyBzcmM9XCInLGwrPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFwiLGwrPWEsbCs9J1wiJyxsKz0nIHdpZHRoPVwiJyxsKz10LGwrPSdcIicsbCs9JyBoZWlnaHQ9XCInLGwrPXIsbCs9J1wiJyxuJiYobCs9JyBhbHQ9XCInLGwrPW4sbCs9J1wiJyksbCs9XCIvPlwifSx3PWZ1bmN0aW9uKHQscixlKXtmb3IodmFyIG49ZCh0LHIpLG89MDtvPHI7bys9MSlmb3IodmFyIGk9MDtpPHQ7aSs9MSluLnNldFBpeGVsKGksbyxlKGksbykpO3ZhciB1PWcoKTtuLndyaXRlKHUpO2Zvcih2YXIgZj12KCksYT11LnRvQnl0ZUFycmF5KCksYz0wO2M8YS5sZW5ndGg7Yys9MSlmLndyaXRlQnl0ZShhW2NdKTtmLmZsdXNoKCk7dmFyIHM9bmV3IEltYWdlO3JldHVybiBzLnNyYz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxcIitmLHMud2lkdGg9dCxzLmhlaWdodD1yLHN9O3JldHVybntRUkNvZGU6cixRUlV0aWw6aX19KCkpOyFmdW5jdGlvbihlKXtpPVtdLG89ZSx1PVwiZnVuY3Rpb25cIj09dHlwZW9mIG8/by5hcHBseShyLGkpOm8sISh2b2lkIDAhPT11JiYodC5leHBvcnRzPXUpKX0oZnVuY3Rpb24oKXtyZXR1cm57UVJDb2RlOmEuUVJDb2RlLFFSVXRpbDphLlFSVXRpbH19KX0sZnVuY3Rpb24odCxyLGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXIuX19lc01vZHVsZT0hMDt2YXIgbz1lKDIzKSxpPW4obyksdT1lKDU5KSxmPW4odSksYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBmLmRlZmF1bHQmJlwic3ltYm9sXCI9PXR5cGVvZiBpLmRlZmF1bHQ/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZi5kZWZhdWx0JiZ0LmNvbnN0cnVjdG9yPT09Zi5kZWZhdWx0JiZ0IT09Zi5kZWZhdWx0LnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fTtyLmRlZmF1bHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgZi5kZWZhdWx0JiZcInN5bWJvbFwiPT09YShpLmRlZmF1bHQpP2Z1bmN0aW9uKHQpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiB0P1widW5kZWZpbmVkXCI6YSh0KX06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGYuZGVmYXVsdCYmdC5jb25zdHJ1Y3Rvcj09PWYuZGVmYXVsdCYmdCE9PWYuZGVmYXVsdC5wcm90b3R5cGU/XCJzeW1ib2xcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgdD9cInVuZGVmaW5lZFwiOmEodCl9fSxmdW5jdGlvbih0LHIsZSl7dC5leHBvcnRzPXtkZWZhdWx0OmUoMjQpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LHIsZSl7ZSgyNSksZSg1NCksdC5leHBvcnRzPWUoNTgpLmYoXCJpdGVyYXRvclwiKX0sZnVuY3Rpb24odCxyLGUpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoMjYpKCEwKTtlKDI5KShTdHJpbmcsXCJTdHJpbmdcIixmdW5jdGlvbih0KXt0aGlzLl90PVN0cmluZyh0KSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIHQscj10aGlzLl90LGU9dGhpcy5faTtyZXR1cm4gZT49ci5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD1uKHIsZSksdGhpcy5faSs9dC5sZW5ndGgse3ZhbHVlOnQsZG9uZTohMX0pfSl9LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDI3KSxvPWUoMjgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24ocixlKXt2YXIgaSx1LGY9U3RyaW5nKG8ocikpLGE9bihlKSxjPWYubGVuZ3RoO3JldHVybiBhPDB8fGE+PWM/dD9cIlwiOnZvaWQgMDooaT1mLmNoYXJDb2RlQXQoYSksaTw1NTI5Nnx8aT41NjMxOXx8YSsxPT09Y3x8KHU9Zi5jaGFyQ29kZUF0KGErMSkpPDU2MzIwfHx1PjU3MzQzP3Q/Zi5jaGFyQXQoYSk6aTp0P2Yuc2xpY2UoYSxhKzIpOihpLTU1Mjk2PDwxMCkrKHUtNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbih0LHIpe3ZhciBlPU1hdGguY2VpbCxuPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpc05hTih0PSt0KT8wOih0PjA/bjplKSh0KX19LGZ1bmN0aW9uKHQscil7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09dCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbih0LHIsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZSgzMCksbz1lKDYpLGk9ZSgzMSksdT1lKDExKSxmPWUoMzIpLGE9ZSgzMyksYz1lKDM0KSxzPWUoNTApLGw9ZSg1MiksaD1lKDUxKShcIml0ZXJhdG9yXCIpLGc9IShbXS5rZXlzJiZcIm5leHRcImluW10ua2V5cygpKSx2PVwiQEBpdGVyYXRvclwiLHA9XCJrZXlzXCIsZD1cInZhbHVlc1wiLHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307dC5leHBvcnRzPWZ1bmN0aW9uKHQscixlLHcsbSxiLEEpe2MoZSxyLHcpO3ZhciB4LEUsTSxfPWZ1bmN0aW9uKHQpe2lmKCFnJiZ0IGluIFMpcmV0dXJuIFNbdF07c3dpdGNoKHQpe2Nhc2UgcDpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUodGhpcyx0KX07Y2FzZSBkOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgZSh0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUodGhpcyx0KX19LE89citcIiBJdGVyYXRvclwiLFQ9bT09ZCxCPSExLFM9dC5wcm90b3R5cGUsUD1TW2hdfHxTW3ZdfHxtJiZTW21dLEM9UHx8XyhtKSxrPW0/VD9fKFwiZW50cmllc1wiKTpDOnZvaWQgMCxEPVwiQXJyYXlcIj09cj9TLmVudHJpZXN8fFA6UDtpZihEJiYoTT1sKEQuY2FsbChuZXcgdCkpLE0hPT1PYmplY3QucHJvdG90eXBlJiYocyhNLE8sITApLG58fGYoTSxoKXx8dShNLGgseSkpKSxUJiZQJiZQLm5hbWUhPT1kJiYoQj0hMCxDPWZ1bmN0aW9uKCl7cmV0dXJuIFAuY2FsbCh0aGlzKX0pLG4mJiFBfHwhZyYmIUImJlNbaF18fHUoUyxoLEMpLGFbcl09QyxhW09dPXksbSlpZih4PXt2YWx1ZXM6VD9DOl8oZCksa2V5czpiP0M6XyhwKSxlbnRyaWVzOmt9LEEpZm9yKEUgaW4geClFIGluIFN8fGkoUyxFLHhbRV0pO2Vsc2UgbyhvLlArby5GKihnfHxCKSxyLHgpO3JldHVybiB4fX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ITB9LGZ1bmN0aW9uKHQscixlKXt0LmV4cG9ydHM9ZSgxMSl9LGZ1bmN0aW9uKHQscil7dmFyIGU9e30uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJuIGUuY2FsbCh0LHIpfX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9e319LGZ1bmN0aW9uKHQscixlKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKDM1KSxvPWUoMjApLGk9ZSg1MCksdT17fTtlKDExKSh1LGUoNTEpKFwiaXRlcmF0b3JcIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHQuZXhwb3J0cz1mdW5jdGlvbih0LHIsZSl7dC5wcm90b3R5cGU9bih1LHtuZXh0Om8oMSxlKX0pLGkodCxyK1wiIEl0ZXJhdG9yXCIpfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMTMpLG89ZSgzNiksaT1lKDQ4KSx1PWUoNDUpKFwiSUVfUFJPVE9cIiksZj1mdW5jdGlvbigpe30sYT1cInByb3RvdHlwZVwiLGM9ZnVuY3Rpb24oKXt2YXIgdCxyPWUoMTgpKFwiaWZyYW1lXCIpLG49aS5sZW5ndGgsbz1cIjxcIix1PVwiPlwiO2ZvcihyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsZSg0OSkuYXBwZW5kQ2hpbGQociksci5zcmM9XCJqYXZhc2NyaXB0OlwiLHQ9ci5jb250ZW50V2luZG93LmRvY3VtZW50LHQub3BlbigpLHQud3JpdGUobytcInNjcmlwdFwiK3UrXCJkb2N1bWVudC5GPU9iamVjdFwiK28rXCIvc2NyaXB0XCIrdSksdC5jbG9zZSgpLGM9dC5GO24tLTspZGVsZXRlIGNbYV1baVtuXV07cmV0dXJuIGMoKX07dC5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHQscil7dmFyIGU7cmV0dXJuIG51bGwhPT10PyhmW2FdPW4odCksZT1uZXcgZixmW2FdPW51bGwsZVt1XT10KTplPWMoKSx2b2lkIDA9PT1yP2U6byhlLHIpfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMTIpLG89ZSgxMyksaT1lKDM3KTt0LmV4cG9ydHM9ZSgxNik/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odCxyKXtvKHQpO2Zvcih2YXIgZSx1PWkociksZj11Lmxlbmd0aCxhPTA7Zj5hOyluLmYodCxlPXVbYSsrXSxyW2VdKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDM4KSxvPWUoNDgpO3QuZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7cmV0dXJuIG4odCxvKX19LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDMyKSxvPWUoMzkpLGk9ZSg0MikoITEpLHU9ZSg0NSkoXCJJRV9QUk9UT1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxyKXt2YXIgZSxmPW8odCksYT0wLGM9W107Zm9yKGUgaW4gZillIT11JiZuKGYsZSkmJmMucHVzaChlKTtmb3IoO3IubGVuZ3RoPmE7KW4oZixlPXJbYSsrXSkmJih+aShjLGUpfHxjLnB1c2goZSkpO3JldHVybiBjfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoNDApLG89ZSgyOCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKG8odCkpfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoNDEpO3QuZXhwb3J0cz1PYmplY3QoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbih0KXtyZXR1cm5cIlN0cmluZ1wiPT1uKHQpP3Quc3BsaXQoXCJcIik6T2JqZWN0KHQpfX0sZnVuY3Rpb24odCxyKXt2YXIgZT17fS50b1N0cmluZzt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGUuY2FsbCh0KS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDM5KSxvPWUoNDMpLGk9ZSg0NCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihyLGUsdSl7dmFyIGYsYT1uKHIpLGM9byhhLmxlbmd0aCkscz1pKHUsYyk7aWYodCYmZSE9ZSl7Zm9yKDtjPnM7KWlmKGY9YVtzKytdLGYhPWYpcmV0dXJuITB9ZWxzZSBmb3IoO2M+cztzKyspaWYoKHR8fHMgaW4gYSkmJmFbc109PT1lKXJldHVybiB0fHxzfHwwO3JldHVybiF0JiYtMX19fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSgyNyksbz1NYXRoLm1pbjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD9vKG4odCksOTAwNzE5OTI1NDc0MDk5MSk6MH19LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDI3KSxvPU1hdGgubWF4LGk9TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJuIHQ9bih0KSx0PDA/byh0K3IsMCk6aSh0LHIpfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoNDYpKFwia2V5c1wiKSxvPWUoNDcpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gblt0XXx8KG5bdF09byh0KSl9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSg3KSxvPVwiX19jb3JlLWpzX3NoYXJlZF9fXCIsaT1uW29dfHwobltvXT17fSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpW3RdfHwoaVt0XT17fSl9fSxmdW5jdGlvbih0LHIpe3ZhciBlPTAsbj1NYXRoLnJhbmRvbSgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIi5jb25jYXQodm9pZCAwPT09dD9cIlwiOnQsXCIpX1wiLCgrK2UrbikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKHQscil7dC5leHBvcnRzPVwiY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mXCIuc3BsaXQoXCIsXCIpfSxmdW5jdGlvbih0LHIsZSl7dC5leHBvcnRzPWUoNykuZG9jdW1lbnQmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMTIpLmYsbz1lKDMyKSxpPWUoNTEpKFwidG9TdHJpbmdUYWdcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQscixlKXt0JiYhbyh0PWU/dDp0LnByb3RvdHlwZSxpKSYmbih0LGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpyfSl9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSg0NikoXCJ3a3NcIiksbz1lKDQ3KSxpPWUoNykuU3ltYm9sLHU9XCJmdW5jdGlvblwiPT10eXBlb2YgaSxmPXQuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gblt0XXx8KG5bdF09dSYmaVt0XXx8KHU/aTpvKShcIlN5bWJvbC5cIit0KSl9O2Yuc3RvcmU9bn0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMzIpLG89ZSg1MyksaT1lKDQ1KShcIklFX1BST1RPXCIpLHU9T2JqZWN0LnByb3RvdHlwZTt0LmV4cG9ydHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0KXtyZXR1cm4gdD1vKHQpLG4odCxpKT90W2ldOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuY29uc3RydWN0b3ImJnQgaW5zdGFuY2VvZiB0LmNvbnN0cnVjdG9yP3QuY29uc3RydWN0b3IucHJvdG90eXBlOnQgaW5zdGFuY2VvZiBPYmplY3Q/dTpudWxsfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMjgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KG4odCkpfX0sZnVuY3Rpb24odCxyLGUpe2UoNTUpO2Zvcih2YXIgbj1lKDcpLG89ZSgxMSksaT1lKDMzKSx1PWUoNTEpKFwidG9TdHJpbmdUYWdcIiksZj1bXCJOb2RlTGlzdFwiLFwiRE9NVG9rZW5MaXN0XCIsXCJNZWRpYUxpc3RcIixcIlN0eWxlU2hlZXRMaXN0XCIsXCJDU1NSdWxlTGlzdFwiXSxhPTA7YTw1O2ErKyl7dmFyIGM9ZlthXSxzPW5bY10sbD1zJiZzLnByb3RvdHlwZTtsJiYhbFt1XSYmbyhsLHUsYyksaVtjXT1pLkFycmF5fX0sZnVuY3Rpb24odCxyLGUpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoNTYpLG89ZSg1NyksaT1lKDMzKSx1PWUoMzkpO3QuZXhwb3J0cz1lKDI5KShBcnJheSxcIkFycmF5XCIsZnVuY3Rpb24odCxyKXt0aGlzLl90PXUodCksdGhpcy5faT0wLHRoaXMuX2s9cn0sZnVuY3Rpb24oKXt2YXIgdD10aGlzLl90LHI9dGhpcy5fayxlPXRoaXMuX2krKztyZXR1cm4hdHx8ZT49dC5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLG8oMSkpOlwia2V5c1wiPT1yP28oMCxlKTpcInZhbHVlc1wiPT1yP28oMCx0W2VdKTpvKDAsW2UsdFtlXV0pfSxcInZhbHVlc1wiKSxpLkFyZ3VtZW50cz1pLkFycmF5LG4oXCJrZXlzXCIpLG4oXCJ2YWx1ZXNcIiksbihcImVudHJpZXNcIil9LGZ1bmN0aW9uKHQscil7dC5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57dmFsdWU6cixkb25lOiEhdH19fSxmdW5jdGlvbih0LHIsZSl7ci5mPWUoNTEpfSxmdW5jdGlvbih0LHIsZSl7dC5leHBvcnRzPXtkZWZhdWx0OmUoNjApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LHIsZSl7ZSg2MSksZSg3MiksZSg3MyksZSg3NCksdC5leHBvcnRzPWUoOCkuU3ltYm9sfSxmdW5jdGlvbih0LHIsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZSg3KSxvPWUoMzIpLGk9ZSgxNiksdT1lKDYpLGY9ZSgzMSksYT1lKDYyKS5LRVksYz1lKDE3KSxzPWUoNDYpLGw9ZSg1MCksaD1lKDQ3KSxnPWUoNTEpLHY9ZSg1OCkscD1lKDYzKSxkPWUoNjQpLHk9ZSg2NSksdz1lKDY4KSxtPWUoMTMpLGI9ZSgzOSksQT1lKDE5KSx4PWUoMjApLEU9ZSgzNSksTT1lKDY5KSxfPWUoNzEpLE89ZSgxMiksVD1lKDM3KSxCPV8uZixTPU8uZixQPU0uZixDPW4uU3ltYm9sLGs9bi5KU09OLEQ9ayYmay5zdHJpbmdpZnksTj1cInByb3RvdHlwZVwiLEk9ZyhcIl9oaWRkZW5cIiksTD1nKFwidG9QcmltaXRpdmVcIiksaj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxSPXMoXCJzeW1ib2wtcmVnaXN0cnlcIiksRj1zKFwic3ltYm9sc1wiKSxVPXMoXCJvcC1zeW1ib2xzXCIpLFE9T2JqZWN0W05dLEg9XCJmdW5jdGlvblwiPT10eXBlb2YgQyxKPW4uUU9iamVjdCxLPSFKfHwhSltOXXx8IUpbTl0uZmluZENoaWxkLFk9aSYmYyhmdW5jdGlvbigpe1xucmV0dXJuIDchPUUoUyh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFModGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KT9mdW5jdGlvbih0LHIsZSl7dmFyIG49QihRLHIpO24mJmRlbGV0ZSBRW3JdLFModCxyLGUpLG4mJnQhPT1RJiZTKFEscixuKX06Uyx6PWZ1bmN0aW9uKHQpe3ZhciByPUZbdF09RShDW05dKTtyZXR1cm4gci5faz10LHJ9LFc9SCYmXCJzeW1ib2xcIj09dHlwZW9mIEMuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuXCJzeW1ib2xcIj09dHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgQ30scT1mdW5jdGlvbih0LHIsZSl7cmV0dXJuIHQ9PT1RJiZxKFUscixlKSxtKHQpLHI9QShyLCEwKSxtKGUpLG8oRixyKT8oZS5lbnVtZXJhYmxlPyhvKHQsSSkmJnRbSV1bcl0mJih0W0ldW3JdPSExKSxlPUUoZSx7ZW51bWVyYWJsZTp4KDAsITEpfSkpOihvKHQsSSl8fFModCxJLHgoMSx7fSkpLHRbSV1bcl09ITApLFkodCxyLGUpKTpTKHQscixlKX0sRz1mdW5jdGlvbih0LHIpe20odCk7Zm9yKHZhciBlLG49eShyPWIocikpLG89MCxpPW4ubGVuZ3RoO2k+bzspcSh0LGU9bltvKytdLHJbZV0pO3JldHVybiB0fSwkPWZ1bmN0aW9uKHQscil7cmV0dXJuIHZvaWQgMD09PXI/RSh0KTpHKEUodCkscil9LFo9ZnVuY3Rpb24odCl7dmFyIHI9ai5jYWxsKHRoaXMsdD1BKHQsITApKTtyZXR1cm4hKHRoaXM9PT1RJiZvKEYsdCkmJiFvKFUsdCkpJiYoIShyfHwhbyh0aGlzLHQpfHwhbyhGLHQpfHxvKHRoaXMsSSkmJnRoaXNbSV1bdF0pfHxyKX0sVj1mdW5jdGlvbih0LHIpe2lmKHQ9Yih0KSxyPUEociwhMCksdCE9PVF8fCFvKEYscil8fG8oVSxyKSl7dmFyIGU9Qih0LHIpO3JldHVybiFlfHwhbyhGLHIpfHxvKHQsSSkmJnRbSV1bcl18fChlLmVudW1lcmFibGU9ITApLGV9fSxYPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcixlPVAoYih0KSksbj1bXSxpPTA7ZS5sZW5ndGg+aTspbyhGLHI9ZVtpKytdKXx8cj09SXx8cj09YXx8bi5wdXNoKHIpO3JldHVybiBufSx0dD1mdW5jdGlvbih0KXtmb3IodmFyIHIsZT10PT09USxuPVAoZT9VOmIodCkpLGk9W10sdT0wO24ubGVuZ3RoPnU7KSFvKEYscj1uW3UrK10pfHxlJiYhbyhRLHIpfHxpLnB1c2goRltyXSk7cmV0dXJuIGl9O0h8fChDPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEMpdGhyb3cgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIVwiKTt2YXIgdD1oKGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSxyPWZ1bmN0aW9uKGUpe3RoaXM9PT1RJiZyLmNhbGwoVSxlKSxvKHRoaXMsSSkmJm8odGhpc1tJXSx0KSYmKHRoaXNbSV1bdF09ITEpLFkodGhpcyx0LHgoMSxlKSl9O3JldHVybiBpJiZLJiZZKFEsdCx7Y29uZmlndXJhYmxlOiEwLHNldDpyfSkseih0KX0sZihDW05dLFwidG9TdHJpbmdcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLl9rfSksXy5mPVYsTy5mPXEsZSg3MCkuZj1NLmY9WCxlKDY3KS5mPVosZSg2NikuZj10dCxpJiYhZSgzMCkmJmYoUSxcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsWiwhMCksdi5mPWZ1bmN0aW9uKHQpe3JldHVybiB6KGcodCkpfSksdSh1LkcrdS5XK3UuRiohSCx7U3ltYm9sOkN9KTtmb3IodmFyIHJ0PVwiaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXNcIi5zcGxpdChcIixcIiksZXQ9MDtydC5sZW5ndGg+ZXQ7KWcocnRbZXQrK10pO2Zvcih2YXIgcnQ9VChnLnN0b3JlKSxldD0wO3J0Lmxlbmd0aD5ldDspcChydFtldCsrXSk7dSh1LlMrdS5GKiFILFwiU3ltYm9sXCIse2ZvcjpmdW5jdGlvbih0KXtyZXR1cm4gbyhSLHQrPVwiXCIpP1JbdF06Ult0XT1DKHQpfSxrZXlGb3I6ZnVuY3Rpb24odCl7aWYoVyh0KSlyZXR1cm4gZChSLHQpO3Rocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIHN5bWJvbCFcIil9LHVzZVNldHRlcjpmdW5jdGlvbigpe0s9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe0s9ITF9fSksdSh1LlMrdS5GKiFILFwiT2JqZWN0XCIse2NyZWF0ZTokLGRlZmluZVByb3BlcnR5OnEsZGVmaW5lUHJvcGVydGllczpHLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpWLGdldE93blByb3BlcnR5TmFtZXM6WCxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6dHR9KSxrJiZ1KHUuUyt1LkYqKCFIfHxjKGZ1bmN0aW9uKCl7dmFyIHQ9QygpO3JldHVyblwiW251bGxdXCIhPUQoW3RdKXx8XCJ7fVwiIT1EKHthOnR9KXx8XCJ7fVwiIT1EKE9iamVjdCh0KSl9KSksXCJKU09OXCIse3N0cmluZ2lmeTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10JiYhVyh0KSl7Zm9yKHZhciByLGUsbj1bdF0sbz0xO2FyZ3VtZW50cy5sZW5ndGg+bzspbi5wdXNoKGFyZ3VtZW50c1tvKytdKTtyZXR1cm4gcj1uWzFdLFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJihlPXIpLCFlJiZ3KHIpfHwocj1mdW5jdGlvbih0LHIpe2lmKGUmJihyPWUuY2FsbCh0aGlzLHQscikpLCFXKHIpKXJldHVybiByfSksblsxXT1yLEQuYXBwbHkoayxuKX19fSksQ1tOXVtMXXx8ZSgxMSkoQ1tOXSxMLENbTl0udmFsdWVPZiksbChDLFwiU3ltYm9sXCIpLGwoTWF0aCxcIk1hdGhcIiwhMCksbChuLkpTT04sXCJKU09OXCIsITApfSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSg0NykoXCJtZXRhXCIpLG89ZSgxNCksaT1lKDMyKSx1PWUoMTIpLmYsZj0wLGE9T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sYz0hZSgxNykoZnVuY3Rpb24oKXtyZXR1cm4gYShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pLHM9ZnVuY3Rpb24odCl7dSh0LG4se3ZhbHVlOntpOlwiT1wiKyArK2Ysdzp7fX19KX0sbD1mdW5jdGlvbih0LHIpe2lmKCFvKHQpKXJldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0P3Q6KFwic3RyaW5nXCI9PXR5cGVvZiB0P1wiU1wiOlwiUFwiKSt0O2lmKCFpKHQsbikpe2lmKCFhKHQpKXJldHVyblwiRlwiO2lmKCFyKXJldHVyblwiRVwiO3ModCl9cmV0dXJuIHRbbl0uaX0saD1mdW5jdGlvbih0LHIpe2lmKCFpKHQsbikpe2lmKCFhKHQpKXJldHVybiEwO2lmKCFyKXJldHVybiExO3ModCl9cmV0dXJuIHRbbl0ud30sZz1mdW5jdGlvbih0KXtyZXR1cm4gYyYmdi5ORUVEJiZhKHQpJiYhaSh0LG4pJiZzKHQpLHR9LHY9dC5leHBvcnRzPXtLRVk6bixORUVEOiExLGZhc3RLZXk6bCxnZXRXZWFrOmgsb25GcmVlemU6Z319LGZ1bmN0aW9uKHQscixlKXt2YXIgbj1lKDcpLG89ZSg4KSxpPWUoMzApLHU9ZSg1OCksZj1lKDEyKS5mO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgcj1vLlN5bWJvbHx8KG8uU3ltYm9sPWk/e306bi5TeW1ib2x8fHt9KTtcIl9cIj09dC5jaGFyQXQoMCl8fHQgaW4gcnx8ZihyLHQse3ZhbHVlOnUuZih0KX0pfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMzcpLG89ZSgzOSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQscil7Zm9yKHZhciBlLGk9byh0KSx1PW4oaSksZj11Lmxlbmd0aCxhPTA7Zj5hOylpZihpW2U9dVthKytdXT09PXIpcmV0dXJuIGV9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSgzNyksbz1lKDY2KSxpPWUoNjcpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgcj1uKHQpLGU9by5mO2lmKGUpZm9yKHZhciB1LGY9ZSh0KSxhPWkuZixjPTA7Zi5sZW5ndGg+YzspYS5jYWxsKHQsdT1mW2MrK10pJiZyLnB1c2godSk7cmV0dXJuIHJ9fSxmdW5jdGlvbih0LHIpe3IuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbih0LHIpe3IuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoNDEpO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIkFycmF5XCI9PW4odCl9fSxmdW5jdGlvbih0LHIsZSl7dmFyIG49ZSgzOSksbz1lKDcwKS5mLGk9e30udG9TdHJpbmcsdT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sZj1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIG8odCl9Y2F0Y2godCl7cmV0dXJuIHUuc2xpY2UoKX19O3QuZXhwb3J0cy5mPWZ1bmN0aW9uKHQpe3JldHVybiB1JiZcIltvYmplY3QgV2luZG93XVwiPT1pLmNhbGwodCk/Zih0KTpvKG4odCkpfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoMzgpLG89ZSg0OCkuY29uY2F0KFwibGVuZ3RoXCIsXCJwcm90b3R5cGVcIik7ci5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih0KXtyZXR1cm4gbih0LG8pfX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUoNjcpLG89ZSgyMCksaT1lKDM5KSx1PWUoMTkpLGY9ZSgzMiksYT1lKDE1KSxjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ci5mPWUoMTYpP2M6ZnVuY3Rpb24odCxyKXtpZih0PWkodCkscj11KHIsITApLGEpdHJ5e3JldHVybiBjKHQscil9Y2F0Y2godCl7fWlmKGYodCxyKSlyZXR1cm4gbyghbi5mLmNhbGwodCxyKSx0W3JdKX19LGZ1bmN0aW9uKHQscil7fSxmdW5jdGlvbih0LHIsZSl7ZSg2MykoXCJhc3luY0l0ZXJhdG9yXCIpfSxmdW5jdGlvbih0LHIsZSl7ZSg2MykoXCJvYnNlcnZhYmxlXCIpfSxmdW5jdGlvbih0LHIsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89ZSgxKSxpPW4obyksdT1lKDIpLGY9bih1KSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpeygwLGkuZGVmYXVsdCkodGhpcyx0KX1yZXR1cm4oMCxmLmRlZmF1bHQpKHQsbnVsbCxbe2tleTpcImNyZWF0ZUNhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gZS53aWR0aD10LGUuaGVpZ2h0PXQsZS5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHIsMCwwLHQsdCksZX19LHtrZXk6XCJ0aHJlc2hvbGRcIix2YWx1ZTpmdW5jdGlvbih0LHIsZSxuKXtyZXR1cm4uMjEyNip0Ky43MTUyKnIrLjA3MjIqZT49bj8yNTU6MH19XSksdH0oKTtyLmRlZmF1bHQ9YX1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dmQyVmljR0ZqYXk5MWJtbDJaWEp6WVd4TmIyUjFiR1ZFWldacGJtbDBhVzl1SWl3aWQyVmljR0ZqYXpvdkx5OXhZWEowTG0xcGJpNXFjeUlzSW5kbFluQmhZMnM2THk4dmQyVmljR0ZqYXk5aWIyOTBjM1J5WVhBZ05tWTRNamhrTjJFMllqTXdaV05rT0dRelpEa2lMQ0ozWldKd1lXTnJPaTh2THk0dmMzSmpMM0ZoY25RdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWlZV0psYkMxeWRXNTBhVzFsTDJobGJIQmxjbk12WTJ4aGMzTkRZV3hzUTJobFkyc3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlpWVdKbGJDMXlkVzUwYVcxbEwyaGxiSEJsY25NdlkzSmxZWFJsUTJ4aGMzTXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlpWVdKbGJDMXlkVzUwYVcxbEwyTnZjbVV0YW5NdmIySnFaV04wTDJSbFptbHVaUzF3Y205d1pYSjBlUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzltYmk5dlltcGxZM1F2WkdWbWFXNWxMWEJ5YjNCbGNuUjVMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZaWE0yTG05aWFtVmpkQzVrWldacGJtVXRjSEp2Y0dWeWRIa3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZaWGh3YjNKMExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyZHNiMkpoYkM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5amIzSmxMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMk4wZUM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5aExXWjFibU4wYVc5dUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyaHBaR1V1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV1J3TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJGdUxXOWlhbVZqZEM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5cGN5MXZZbXBsWTNRdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmFXVTRMV1J2YlMxa1pXWnBibVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmWkdWelkzSnBjSFJ2Y25NdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZlptRnBiSE11YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmWkc5dExXTnlaV0YwWlM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5MGJ5MXdjbWx0YVhScGRtVXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZjSEp2Y0dWeWRIa3RaR1Z6WXk1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5emNtTXZjWEpqYjJSbExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZbUZpWld3dGNuVnVkR2x0WlM5b1pXeHdaWEp6TDNSNWNHVnZaaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJKaFltVnNMWEoxYm5ScGJXVXZZMjl5WlMxcWN5OXplVzFpYjJ3dmFYUmxjbUYwYjNJdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdlptNHZjM2x0WW05c0wybDBaWEpoZEc5eUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlpYTTJMbk4wY21sdVp5NXBkR1Z5WVhSdmNpNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXpkSEpwYm1jdFlYUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkRzh0YVc1MFpXZGxjaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlrWldacGJtVmtMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMmwwWlhJdFpHVm1hVzVsTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJ4cFluSmhjbmt1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmY21Wa1pXWnBibVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYUdGekxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgybDBaWEpoZEc5eWN5NXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXBkR1Z5TFdOeVpXRjBaUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTl2WW1wbFkzUXRZM0psWVhSbExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyOWlhbVZqZEMxa2NITXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXdGxlWE11YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV3RsZVhNdGFXNTBaWEp1WVd3dWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmRHOHRhVzlpYW1WamRDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXBiMkpxWldOMExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyTnZaaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTloY25KaGVTMXBibU5zZFdSbGN5NXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOTBieTFzWlc1bmRHZ3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkRzh0YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZjMmhoY21Wa0xXdGxlUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTl6YUdGeVpXUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkV2xrTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJWdWRXMHRZblZuTFd0bGVYTXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZhSFJ0YkM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5elpYUXRkRzh0YzNSeWFXNW5MWFJoWnk1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5M2EzTXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXZHdieTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTkwYnkxdlltcGxZM1F1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTkzWldJdVpHOXRMbWwwWlhKaFlteGxMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZaWE0yTG1GeWNtRjVMbWwwWlhKaGRHOXlMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMkZrWkMxMGJ5MTFibk5qYjNCaFlteGxjeTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlwZEdWeUxYTjBaWEF1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmZDJ0ekxXVjRkQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJKaFltVnNMWEoxYm5ScGJXVXZZMjl5WlMxcWN5OXplVzFpYjJ3dWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdlptNHZjM2x0WW05c0wybHVaR1Y0TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WlhNMkxuTjViV0p2YkM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dFpYUmhMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM2RyY3kxa1pXWnBibVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYTJWNWIyWXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZaVzUxYlMxclpYbHpMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMjlpYW1WamRDMW5iM0J6TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDI5aWFtVmpkQzF3YVdVdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmFYTXRZWEp5WVhrdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmIySnFaV04wTFdkdmNHNHRaWGgwTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDI5aWFtVmpkQzFuYjNCdUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyOWlhbVZqZEMxbmIzQmtMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZaWE0zTG5ONWJXSnZiQzVoYzNsdVl5MXBkR1Z5WVhSdmNpNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwyVnpOeTV6ZVcxaWIyd3ViMkp6WlhKMllXSnNaUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl6Y21NdmRYUnBiQzVxY3lKZExDSnVZVzFsY3lJNld5SnliMjkwSWl3aVptRmpkRzl5ZVNJc0ltVjRjRzl5ZEhNaUxDSnRiMlIxYkdVaUxDSmtaV1pwYm1VaUxDSmhiV1FpTENKMGFHbHpJaXdpYlc5a2RXeGxjeUlzSWw5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4aUxDSnRiMlIxYkdWSlpDSXNJbWx1YzNSaGJHeGxaRTF2WkhWc1pYTWlMQ0pwWkNJc0lteHZZV1JsWkNJc0ltTmhiR3dpTENKdElpd2lZeUlzSW5BaUxDSmZhVzUwWlhKdmNGSmxjWFZwY21WRVpXWmhkV3gwSWl3aWIySnFJaXdpWDE5bGMwMXZaSFZzWlNJc0ltUmxabUYxYkhRaUxDSlBZbXBsWTNRaUxDSmtaV1pwYm1WUWNtOXdaWEowZVNJc0luWmhiSFZsSWl3aVgyTnNZWE56UTJGc2JFTm9aV05yTWlJc0lsOWpiR0Z6YzBOaGJHeERhR1ZqYXpNaUxDSmZZM0psWVhSbFEyeGhjM015SWl3aVgyTnlaV0YwWlVOc1lYTnpNeUlzSWw5eGNtTnZaR1VpTENKZmRYUnBiQ0lzSWw5MWRHbHNNaUlzSWxGQmNuUWlMQ0p2Y0hScGIyNXpJaXdpVkhsd1pVVnljbTl5SWl3aWFXMWhaMlZRWVhSb0lpd2labWxzZEdWeUlpd2lSRVZHUVZWTVZGTWlMQ0pyWlhraUxDSmxiQ0lzSW1sdFlXZGxVMmw2WlNJc0luQmhaR1JwYm1jaUxDSnNaWFpsYkNJc0luRnlJaXdpVVZKRGIyUmxJaXdpWVdSa1JHRjBZU0lzSW0xaGEyVWlMQ0p4Y2tsdFlXZGxJaXdpWTNKbFlYUmxTVzFuVDJKcVpXTjBJaXdpYzJWc1ppSXNJbTl1Ykc5aFpDSXNJbU52ZG1WeVNXMWhaMlVpTENKSmJXRm5aU0lzSW5OeVl5SXNJbkpsYzNWc2RFTmhiblpoY3lJc0ltTnlaV0YwWlVOaGJuWmhjeUlzSW5GeVEyRnVkbUZ6SWl3aWQybGtkR2dpTENKb1pXbG5hSFFpTENKamIzWmxja05oYm5aaGN5SXNJbVJ2WTNWdFpXNTBJaXdpWTNKbFlYUmxSV3hsYldWdWRDSXNJbWRsZEVOdmJuUmxlSFFpTENKa2NtRjNTVzFoWjJVaUxDSmpiM1psY2tsdFlXZGxSR0YwWVNJc0ltZGxkRWx0WVdkbFJHRjBZU0lzSW1OdmRtVnlTVzFoWjJWQ2FXNWhjbmtpTENKa1lYUmhJaXdpY21WemRXeDBTVzFoWjJWRVlYUmhJaXdpY21WemRXeDBTVzFoWjJWQ2FXNWhjbmtpTENKcElpd2liR1Z1WjNSb0lpd2llQ0lzSWsxaGRHZ2lMQ0ptYkc5dmNpSXNJbmtpTENKbVlXTjBiM0lpTENKMGFISmxjMmh2YkdRaUxDSndkWFJKYldGblpVUmhkR0VpTENKd1lYUjBaWEp1VUc5emRHbHZiaUlzSWxGU1ZYUnBiQ0lzSW1kbGRGQmhkSFJsY201UWIzTnBkR2x2YmlJc0ltb2lMQ0p5WldOMFdDSXNJbkpsWTNSWklpd2ljbVZqZEZkcFpIUm9JaXdpY21WamRFaGxhV2RvZENJc0luSmxZM1JFWVhSaElpd2lhVzV1WlhKSVZFMU1JaXdpWVhCd1pXNWtRMmhwYkdRaUxDSm5aWFFpTENKM2FXNWtiM2NpTENKcGJuTjBZVzVqWlNJc0lrTnZibk4wY25WamRHOXlJaXdpWDJSbFptbHVaVkJ5YjNCbGNuUjVJaXdpWDJSbFptbHVaVkJ5YjNCbGNuUjVNaUlzSW1SbFptbHVaVkJ5YjNCbGNuUnBaWE1pTENKMFlYSm5aWFFpTENKd2NtOXdjeUlzSW1SbGMyTnlhWEIwYjNJaUxDSmxiblZ0WlhKaFlteGxJaXdpWTI5dVptbG5kWEpoWW14bElpd2lkM0pwZEdGaWJHVWlMQ0p3Y205MGIxQnliM0J6SWl3aWMzUmhkR2xqVUhKdmNITWlMQ0p3Y205MGIzUjVjR1VpTENJa1QySnFaV04wSWl3aWFYUWlMQ0prWlhOaklpd2lKR1Y0Y0c5eWRDSXNJbE1pTENKR0lpd2laaUlzSW1kc2IySmhiQ0lzSW1OdmNtVWlMQ0pqZEhnaUxDSm9hV1JsSWl3aVVGSlBWRTlVV1ZCRklpd2lkSGx3WlNJc0ltNWhiV1VpTENKemIzVnlZMlVpTENKdmQyNGlMQ0p2ZFhRaUxDSkpVMTlHVDFKRFJVUWlMQ0pKVTE5SFRFOUNRVXdpTENKSElpd2lTVk5mVTFSQlZFbERJaXdpU1ZOZlVGSlBWRThpTENKUUlpd2lTVk5mUWtsT1JDSXNJa0lpTENKSlUxOVhVa0ZRSWl3aVZ5SXNJbVY0Y0ZCeWIzUnZJaXdpZFc1a1pXWnBibVZrSWl3aVF5SXNJbUVpTENKaUlpd2lZWEpuZFcxbGJuUnpJaXdpWVhCd2JIa2lMQ0pHZFc1amRHbHZiaUlzSW5acGNuUjFZV3dpTENKU0lpd2lWU0lzSWw5Zlp5SXNJblpsY25OcGIyNGlMQ0pmWDJVaUxDSmhSblZ1WTNScGIyNGlMQ0ptYmlJc0luUm9ZWFFpTENKa1VDSXNJbU55WldGMFpVUmxjMk1pTENKdlltcGxZM1FpTENKaGJrOWlhbVZqZENJc0lrbEZPRjlFVDAxZlJFVkdTVTVGSWl3aWRHOVFjbWx0YVhScGRtVWlMQ0pQSWl3aVFYUjBjbWxpZFhSbGN5SXNJbVVpTENKcGMwOWlhbVZqZENJc0ltVjRaV01pTENKcGN5SXNJblpoYkNJc0luUnZVM1J5YVc1bklpd2lkbUZzZFdWUFppSXNJbUpwZEcxaGNDSXNJbDlmVjBWQ1VFRkRTMTlCVFVSZlJFVkdTVTVGWDBaQlExUlBVbGxmWHlJc0lsOWZWMFZDVUVGRFMxOUJUVVJmUkVWR1NVNUZYMEZTVWtGWlgxOGlMQ0pmWDFkRlFsQkJRMHRmUVUxRVgwUkZSa2xPUlY5U1JWTlZURlJmWHlJc0lsOTBlWEJsYjJZeUlpd2ljWEpqYjJSbElpd2ljWEpRYjJ4NWJtOXRhV0ZzSWl3aWJuVnRJaXdpYzJocFpuUWlMQ0pGY25KdmNpSXNJbDl1ZFcwaUxDSnZabVp6WlhRaUxDSkJjbkpoZVNJc0lsOTBhR2x6SWl3aVoyVjBRWFFpTENKcGJtUmxlQ0lzSW1kbGRFeGxibWQwYUNJc0ltMTFiSFJwY0d4NUlpd2lVVkpOWVhSb0lpd2laMlY0Y0NJc0ltZHNiMmNpTENKdGIyUWlMQ0p5WVhScGJ5SXNJblI1Y0dWT2RXMWlaWElpTENKbGNuSnZja052Y25KbFkzUnBiMjVNWlhabGJDSXNJbEJCUkRBaUxDSlFRVVF4SWl3aVgzUjVjR1ZPZFcxaVpYSWlMQ0pmWlhKeWIzSkRiM0p5WldOMGFXOXVUR1YyWld3aUxDSlJVa1Z5Y205eVEyOXljbVZqZEdsdmJreGxkbVZzSWl3aVgyMXZaSFZzWlhNaUxDSmZiVzlrZFd4bFEyOTFiblFpTENKZlpHRjBZVU5oWTJobElpd2lYMlJoZEdGTWFYTjBJaXdpYldGclpVbHRjR3dpTENKMFpYTjBJaXdpYldGemExQmhkSFJsY200aUxDSnRiMlIxYkdWRGIzVnVkQ0lzSW5KdmR5SXNJbU52YkNJc0luTmxkSFZ3VUc5emFYUnBiMjVRY205aVpWQmhkSFJsY200aUxDSnpaWFIxY0ZCdmMybDBhVzl1UVdScWRYTjBVR0YwZEdWeWJpSXNJbk5sZEhWd1ZHbHRhVzVuVUdGMGRHVnliaUlzSW5ObGRIVndWSGx3WlVsdVptOGlMQ0p6WlhSMWNGUjVjR1ZPZFcxaVpYSWlMQ0pqY21WaGRHVkVZWFJoSWl3aWJXRndSR0YwWVNJc0luSWlMQ0puWlhSQ1pYTjBUV0Z6YTFCaGRIUmxjbTRpTENKdGFXNU1iM04wVUc5cGJuUWlMQ0p3WVhSMFpYSnVJaXdpYkc5emRGQnZhVzUwSWl3aVoyVjBURzl6ZEZCdmFXNTBJaXdpY0c5eklpd2lZbWwwY3lJc0ltZGxkRUpEU0ZSNWNHVk9kVzFpWlhJaUxDSm5aWFJDUTBoVWVYQmxTVzVtYnlJc0ltbHVZeUlzSW1KcGRFbHVaR1Y0SWl3aVlubDBaVWx1WkdWNElpd2liV0Z6YTBaMWJtTWlMQ0puWlhSTllYTnJSblZ1WTNScGIyNGlMQ0prWVhKcklpd2liV0Z6YXlJc0ltTnlaV0YwWlVKNWRHVnpJaXdpWW5WbVptVnlJaXdpY25OQ2JHOWphM01pTENKdFlYaEVZME52ZFc1MElpd2liV0Y0UldORGIzVnVkQ0lzSW1SalpHRjBZU0lzSW1WalpHRjBZU0lzSW1SalEyOTFiblFpTENKa1lYUmhRMjkxYm5RaUxDSmxZME52ZFc1MElpd2lkRzkwWVd4RGIzVnVkQ0lzSW0xaGVDSXNJbWRsZEVKMVptWmxjaUlzSW5KelVHOXNlU0lzSW1kbGRFVnljbTl5UTI5eWNtVmpkRkJ2YkhsdWIyMXBZV3dpTENKeVlYZFFiMng1SWl3aWJXOWtVRzlzZVNJc0ltMXZaRWx1WkdWNElpd2lkRzkwWVd4RGIyUmxRMjkxYm5RaUxDSmtZWFJoVEdsemRDSXNJbEZTVWxOQ2JHOWpheUlzSW1kbGRGSlRRbXh2WTJ0eklpd2ljWEpDYVhSQ2RXWm1aWElpTENKd2RYUWlMQ0puWlhSTmIyUmxJaXdpWjJWMFRHVnVaM1JvU1c1Q2FYUnpJaXdpZDNKcGRHVWlMQ0owYjNSaGJFUmhkR0ZEYjNWdWRDSXNJbkIxZEVKcGRDSXNJbTF2WkdVaUxDSnVaWGRFWVhSaElpd2ljWEpPZFcxaVpYSWlMQ0p4Y2tGc2NHaGhUblZ0SWl3aWNYSTRRbWwwUW5sMFpTSXNJbkZ5UzJGdWFta2lMQ0p3ZFhOb0lpd2lhWE5FWVhKcklpd2laMlYwVFc5a2RXeGxRMjkxYm5RaUxDSmpjbVZoZEdWVVlXSnNaVlJoWnlJc0ltTmxiR3hUYVhwbElpd2liV0Z5WjJsdUlpd2ljWEpJZEcxc0lpd2lZM0psWVhSbFUzWm5WR0ZuSWl3aWJXTWlMQ0p0Y2lJc0luSmxZM1FpTENKemFYcGxJaXdpY1hKVGRtY2lMQ0pqY21WaGRHVkpiV2RVWVdjaUxDSnRhVzRpTENKemRISnBibWRVYjBKNWRHVnpJaXdpY3lJc0ltSjVkR1Z6SWl3aVkyaGhja052WkdWQmRDSXNJbU55WldGMFpWTjBjbWx1WjFSdlFubDBaWE1pTENKMWJtbGpiMlJsUkdGMFlTSXNJbTUxYlVOb1lYSnpJaXdpZFc1cFkyOWtaVTFoY0NJc0ltSnBiaUlzSW1KaGMyVTJORVJsWTI5a1pVbHVjSFYwVTNSeVpXRnRJaXdpY21WaFpDSXNJbU52ZFc1MElpd2lZakFpTENKaU1TSXNJbUl5SWl3aVlqTWlMQ0pySWl3aVUzUnlhVzVuSWl3aVpuSnZiVU5vWVhKRGIyUmxJaXdpZGlJc0luVnVhMjV2ZDI1RGFHRnlJaXdpWTJoaGNrRjBJaXdpVVZKTmIyUmxJaXdpVFU5RVJWOU9WVTFDUlZJaUxDSk5UMFJGWDBGTVVFaEJYMDVWVFNJc0lrMVBSRVZmT0VKSlZGOUNXVlJGSWl3aVRVOUVSVjlMUVU1S1NTSXNJa3dpTENKTklpd2lVU0lzSWtnaUxDSlJVazFoYzJ0UVlYUjBaWEp1SWl3aVVFRlVWRVZTVGpBd01DSXNJbEJCVkZSRlVrNHdNREVpTENKUVFWUlVSVkpPTURFd0lpd2lVRUZVVkVWU1RqQXhNU0lzSWxCQlZGUkZVazR4TURBaUxDSlFRVlJVUlZKT01UQXhJaXdpVUVGVVZFVlNUakV4TUNJc0lsQkJWRlJGVWs0eE1URWlMQ0pRUVZSVVJWSk9YMUJQVTBsVVNVOU9YMVJCUWt4Rklpd2lSekUxSWl3aVJ6RTRJaXdpUnpFMVgwMUJVMHNpTENKblpYUkNRMGhFYVdkcGRDSXNJbVJwWjJsMElpd2laQ0lzSW1WeWNtOXlRMjl5Y21WamRFeGxibWQwYUNJc0luTmhiV1ZEYjNWdWRDSXNJbVJoY210RGIzVnVkQ0lzSW1GaWN5SXNJa1ZZVUY5VVFVSk1SU0lzSWt4UFIxOVVRVUpNUlNJc0ltNGlMQ0pTVTE5Q1RFOURTMTlVUVVKTVJTSXNJbkZ5VWxOQ2JHOWpheUlzSW1kbGRGSnpRbXh2WTJ0VVlXSnNaU0lzSW5KelFteHZZMnNpTENKc2FYTjBJaXdpWDJKMVptWmxjaUlzSWw5c1pXNW5kR2dpTENKaWRXWkpibVJsZUNJc0ltSnBkQ0lzSWw5dGIyUmxJaXdpWDJSaGRHRWlMQ0p6ZEhKVWIwNTFiU0lzSW5OMVluTjBjbWx1WnlJc0ltTm9ZWFJVYjA1MWJTSXNJbWRsZEVOdlpHVWlMQ0pmWW5sMFpYTWlMQ0pqYjJSbElpd2lZbmwwWlVGeWNtRjVUM1YwY0hWMFUzUnlaV0Z0SWl3aWQzSnBkR1ZDZVhSbElpd2lkM0pwZEdWVGFHOXlkQ0lzSW5keWFYUmxRbmwwWlhNaUxDSnZabVlpTENKc1pXNGlMQ0ozY21sMFpWTjBjbWx1WnlJc0luUnZRbmwwWlVGeWNtRjVJaXdpWW1GelpUWTBSVzVqYjJSbFQzVjBjSFYwVTNSeVpXRnRJaXdpWDJKMVpteGxiaUlzSWw5aVlYTmxOalFpTENKM2NtbDBaVVZ1WTI5a1pXUWlMQ0psYm1OdlpHVWlMQ0ptYkhWemFDSXNJbkJoWkd4bGJpSXNJbk4wY2lJc0lsOXpkSElpTENKZmNHOXpJaXdpYldGMFkyZ2lMQ0prWldOdlpHVWlMQ0puYVdaSmJXRm5aU0lzSWw5M2FXUjBhQ0lzSWw5b1pXbG5hSFFpTENKelpYUlFhWGhsYkNJc0luQnBlR1ZzSWl3aWJIcDNUV2x1UTI5a1pWTnBlbVVpTENKeVlYTjBaWElpTENKblpYUk1XbGRTWVhOMFpYSWlMQ0ppYVhSUGRYUndkWFJUZEhKbFlXMGlMQ0pmYjNWMElpd2lYMkpwZEV4bGJtZDBhQ0lzSWw5aWFYUkNkV1ptWlhJaUxDSmpiR1ZoY2tOdlpHVWlMQ0psYm1SRGIyUmxJaXdpWW1sMFRHVnVaM1JvSWl3aWRHRmliR1VpTENKc2VuZFVZV0pzWlNJc0ltRmtaQ0lzSW1KNWRHVlBkWFFpTENKaWFYUlBkWFFpTENKa1lYUmhTVzVrWlhnaUxDSmpiMjUwWVdsdWN5SXNJbWx1WkdWNFQyWWlMQ0pmYldGd0lpd2lYM05wZW1VaUxDSm5aWFJRYVhobGJDSXNJbUZzZENJc0ltZHBaaUlzSW1KaGMyVTJOQ0lzSW1sdFp5SXNJbDlwZEdWeVlYUnZjaUlzSWw5cGRHVnlZWFJ2Y2pJaUxDSmZjM2x0WW05c0lpd2lYM041YldKdmJESWlMQ0pmZEhsd1pXOW1JaXdpWTI5dWMzUnlkV04wYjNJaUxDSWtZWFFpTENKcGRHVnlZWFJsWkNJc0lsOTBJaXdpWDJraUxDSndiMmx1ZENJc0ltUnZibVVpTENKMGIwbHVkR1ZuWlhJaUxDSmtaV1pwYm1Wa0lpd2lWRTlmVTFSU1NVNUhJaXdpYkNJc0luTnNhV05sSWl3aVkyVnBiQ0lzSW1selRtRk9JaXdpVEVsQ1VrRlNXU0lzSW5KbFpHVm1hVzVsSWl3aWFHRnpJaXdpU1hSbGNtRjBiM0p6SWl3aUpHbDBaWEpEY21WaGRHVWlMQ0p6WlhSVWIxTjBjbWx1WjFSaFp5SXNJbWRsZEZCeWIzUnZkSGx3WlU5bUlpd2lTVlJGVWtGVVQxSWlMQ0pDVlVkSFdTSXNJbXRsZVhNaUxDSkdSbDlKVkVWU1FWUlBVaUlzSWt0RldWTWlMQ0pXUVV4VlJWTWlMQ0p5WlhSMWNtNVVhR2x6SWl3aVFtRnpaU0lzSWs1QlRVVWlMQ0p1WlhoMElpd2lSRVZHUVZWTVZDSXNJa2xUWDFORlZDSXNJa1pQVWtORlJDSXNJbTFsZEdodlpITWlMQ0pKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU0lzSW1kbGRFMWxkR2h2WkNJc0ltdHBibVFpTENKd2NtOTBieUlzSWxSQlJ5SXNJa1JGUmw5V1FVeFZSVk1pTENKV1FVeFZSVk5mUWxWSElpd2lKRzVoZEdsMlpTSXNJaVJrWldaaGRXeDBJaXdpSkdWdWRISnBaWE1pTENJa1lXNTVUbUYwYVhabElpd2laVzUwY21sbGN5SXNJblpoYkhWbGN5SXNJbWhoYzA5M2JsQnliM0JsY25SNUlpd2lZM0psWVhSbElpd2laRkJ6SWl3aVpXNTFiVUoxWjB0bGVYTWlMQ0pKUlY5UVVrOVVUeUlzSWtWdGNIUjVJaXdpWTNKbFlYUmxSR2xqZENJc0ltbG1jbUZ0WlVSdlkzVnRaVzUwSWl3aWFXWnlZVzFsSWl3aWJIUWlMQ0puZENJc0luTjBlV3hsSWl3aVpHbHpjR3hoZVNJc0ltTnZiblJsYm5SWGFXNWtiM2NpTENKdmNHVnVJaXdpWTJ4dmMyVWlMQ0pRY205d1pYSjBhV1Z6SWl3aWNtVnpkV3gwSWl3aVoyVjBTMlY1Y3lJc0lpUnJaWGx6SWl3aWRHOUpUMkpxWldOMElpd2lZWEp5WVhsSmJtUmxlRTltSWl3aWJtRnRaWE1pTENKSlQySnFaV04wSWl3aVkyOW1JaXdpY0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVaUxDSnpjR3hwZENJc0luUnZUR1Z1WjNSb0lpd2lkRzlKYm1SbGVDSXNJa2xUWDBsT1EweFZSRVZUSWl3aUpIUm9hWE1pTENKbWNtOXRTVzVrWlhnaUxDSnphR0Z5WldRaUxDSjFhV1FpTENKVFNFRlNSVVFpTENKemRHOXlaU0lzSW5CNElpd2ljbUZ1Wkc5dElpd2lZMjl1WTJGMElpd2laRzlqZFcxbGJuUkZiR1Z0Wlc1MElpd2laR1ZtSWl3aWRHRm5JaXdpYzNSaGRDSXNJbE41YldKdmJDSXNJbFZUUlY5VFdVMUNUMHdpTENJa1pYaHdiM0owY3lJc0luUnZUMkpxWldOMElpd2lUMkpxWldOMFVISnZkRzhpTENKVVQxOVRWRkpKVGtkZlZFRkhJaXdpWTI5c2JHVmpkR2x2Ym5NaUxDSkRiMnhzWldOMGFXOXVJaXdpWVdSa1ZHOVZibk5qYjNCaFlteGxjeUlzSW5OMFpYQWlMQ0pmYXlJc0lrRnlaM1Z0Wlc1MGN5SXNJa1JGVTBOU1NWQlVUMUpUSWl3aVRVVlVRU0lzSWt0RldTSXNJaVJtWVdsc2N5SXNJbmRyY3lJc0luZHJjMFY0ZENJc0luZHJjMFJsWm1sdVpTSXNJbXRsZVU5bUlpd2laVzUxYlV0bGVYTWlMQ0pwYzBGeWNtRjVJaXdpWDJOeVpXRjBaU0lzSW1kUFVFNUZlSFFpTENJa1IwOVFSQ0lzSWlSRVVDSXNJbWRQVUVRaUxDSm5UMUJPSWl3aUpGTjViV0p2YkNJc0lpUktVMDlPSWl3aVNsTlBUaUlzSWw5emRISnBibWRwWm5raUxDSnpkSEpwYm1kcFpua2lMQ0pJU1VSRVJVNGlMQ0pVVDE5UVVrbE5TVlJKVmtVaUxDSnBjMFZ1ZFcwaUxDSlRlVzFpYjJ4U1pXZHBjM1J5ZVNJc0lrRnNiRk41YldKdmJITWlMQ0pQVUZONWJXSnZiSE1pTENKVlUwVmZUa0ZVU1ZaRklpd2lVVTlpYW1WamRDSXNJbk5sZEhSbGNpSXNJbVpwYm1SRGFHbHNaQ0lzSW5ObGRGTjViV0p2YkVSbGMyTWlMQ0pFSWl3aWNISnZkRzlFWlhOaklpd2lkM0poY0NJc0luTjViU0lzSW1selUzbHRZbTlzSWl3aWFYUmxjbUYwYjNJaUxDSWtaR1ZtYVc1bFVISnZjR1Z5ZEhraUxDSWtaR1ZtYVc1bFVISnZjR1Z5ZEdsbGN5SXNJaVJqY21WaGRHVWlMQ0lrY0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVaUxDSkZJaXdpSkdkbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaUlzSWlSblpYUlBkMjVRY205d1pYSjBlVTVoYldWeklpd2lKR2RsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3lJc0lrbFRYMDlRSWl3aUpITmxkQ0lzSW5ObGRDSXNJbk41YldKdmJITWlMQ0ptYjNJaUxDSnJaWGxHYjNJaUxDSjFjMlZUWlhSMFpYSWlMQ0oxYzJWVGFXMXdiR1VpTENKblpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0lpTENKblpYUlBkMjVRY205d1pYSjBlVTVoYldWeklpd2laMlYwVDNkdVVISnZjR1Z5ZEhsVGVXMWliMnh6SWl3aWNtVndiR0ZqWlhJaUxDSWtjbVZ3YkdGalpYSWlMQ0poY21keklpd2ljMlYwUkdWell5SXNJbWx6UlhoMFpXNXphV0pzWlNJc0lrWlNSVVZhUlNJc0luQnlaWFpsYm5SRmVIUmxibk5wYjI1eklpd2ljMlYwVFdWMFlTSXNJbmNpTENKbVlYTjBTMlY1SWl3aVoyVjBWMlZoYXlJc0ltOXVSbkpsWlhwbElpd2liV1YwWVNJc0lrNUZSVVFpTENKblQxQlRJaXdpY0VsRklpd2laMlYwVTNsdFltOXNjeUlzSW1GeVp5SXNJbmRwYm1SdmQwNWhiV1Z6SWl3aVoyVjBWMmx1Wkc5M1RtRnRaWE1pTENKb2FXUmtaVzVMWlhseklpd2lWWFJwYkNJc0ltbHRZV2RsSWl3aVkyRnVkbUZ6SWl3aVp5SmRMQ0p0WVhCd2FXNW5jeUk2SWtOQlFVRXNVMEZCUVVFc1JVRkJRVU1zUjBGRFFTeG5Ra0ZCUVVNc1ZVRkJRU3huUWtGQlFVTXNVVUZEUVVFc1QwRkJRVVFzVVVGQlFVUXNTVUZEUVN4clFrRkJRVWNzWjBKQlFVRkRMRWxCUTBGRUxGVkJRVUZJTEVkQlEwRXNaMEpCUVVGRExGTkJRMEZCTEZGQlFVRXNTMEZCUVVRc1NVRkZRVVFzUlVGQlFTeExRVUZCUXl4TFFVTkRTeXhMUVVGQkxGZEJRMFFzVFVOQlowSXNWVUZCVlVNc1IwTk9NVUlzVVVGQlFVTXNSMEZCUVVNc1IwRkhRU3hIUVVGQlF5eEZRVUZCUkN4SFFVTkJMRTFCUVVGRExFZEJRVUZFTEVkQlFVRlFMRTlCUjBFc1NVRkJRVU1zUjBGQlFVOHNSVUZCUVVRc1NVRkRRVkFzVjBGRFFWTXNSMEZCUVVZc1JVRkRRVWNzVVVGQlFTeEZRVlZCTEU5QlRrRk1MRWRCUVVGRkxFZEJRVUZKTEV0QlFVRldMRVZCUVVGRUxGRkJRVUZETEVsQlFVRkVMRkZCUVVGTkxFZEJSMEZNTEVWQlFVRlRMRkZCUVVFc1JVRkhRVlFzUlVGQlFVUXNVVUYyUWtFc1IwRkJRVkVzUzBGeFEwRXNUMEZVUVVZc1IwRkJRVTBzUlVGQlFWQXNSVUZIUVVNc1JVRkJRVThzUlVGQlFVd3NSVUZIUVVZc1JVRkJRVkVzUlVGQlFTeFhRVWRCVWl4RlFVRkJMRXRFWjBKTkxGTkJRVk5NTEVWQlFWRkVMRVZCUVZOTkxFZEJSUzlDTEZsQmIwSkJMRk5CUVZOVExFZEJRWFZDUXl4SFFVRlBMRTFCUVU5QkxFbEJRVTlCTEVWQlFVbERMRmRCUVdGRUxFZEJRVkZGTEZGQlFWTkdMRWRCYkVKMlJrY3NUMEZCVDBNc1pVRkJaWEJDTEVWQlFWTXNZMEZETTBKeFFpeFBRVUZQTEVkQlIxZ3NTVUZCU1VNc1IwRkJiVUpvUWl4RlFVRnZRaXhIUVVWMlEybENMRVZCUVcxQ1VpeEZRVUYxUWs4c1IwRkZNVU5GTEVWQlFXZENiRUlzUlVGQmIwSXNSMEZGY0VOdFFpeEZRVUZuUWxZc1JVRkJkVUpUTEVkRmNFVTFRMFVzUlVGQlFYQkNMRVZCUVVFc1NVRkRRWEZDTEVWQlFVRnlRaXhGUVVGQkxFbEdlVVZMYzBJc1JVRkJVMklzUlVGQmRVSlpMRWRGZGtVdlFrVXNSVVl5UlUwc1YwVXhSVllzVVVGQlFVRXNSMEZCV1VNc1IwRkRWaXhKUVVSdFFpeEZRVUZCVUN4RlFVRkJUQ3hUUVVGQlpDeExRVUZCZVVJc1IwRkRTU3h0UWtGQldrTXNSMEZEVUN4TFFVRk5MRWxCUVVsRExGZEJRVlVzTWtKQlEycENMRWxCUVRaQ0xHMUNRVUZzUWtRc1IwRkJVVlFzVFVGRGRFSXNTMEZCVFN4SlFVRkpWU3hYUVVGVkxHZERRVU5xUWl4SlFVRnBReXh0UWtGQmRFSkVMRWRCUVZGRkxGVkJRM1JDTEV0QlFVMHNTVUZCU1VRc1YwRkJWU3h2UTBGSmVFSXpRaXhOUVVGTE5rSXNUMEZCYjBNc2JVSkJRVzVDU0N4SFFVRlJSeXhQUVVFd1Frb3NSVUZCUzBzc1UwRkJVMFFzVDBGQlUwZ3NSVUZCVVVjc1QwRkRka1kzUWl4TFFVRkxhVUlzVFVGQlVWTXNSVUZCVVZRc1RVRkRja0pxUWl4TFFVRkxORUlzVlVGQldVWXNSVUZCVVVVc1ZVWnpUSGhDTEU5QmRrZEJMRVZCUVVsUUxFVkJRV05RTEZOQlFWTlhMRWxCUTNaQ1RTeEpRVUZMTEU5QlEweGtMRTFCUVU4c1UwVjBSVlJsTEVkQlEwZ3NSMEZCU1VNc1IwRkJXU3hKUVVOYVF5eEZRVUZWTEVkQlExWkRMRVZCUVZFc1IwRkZVa01zUjBGQlN5eEZRVUZCWkN4RlFVRkJaU3hSUVVGUFJpeEZRVUZQTEVsQlEzWkNReXhIUVVGSFJTeFJRVUZSZEVNc1MwRkJTMmxDTEU5QlEyaENiVUlzUlVGQlIwY3NUVUZEU0N4SlFVRkpReXhIUVVGVlNpeEZRVUZIU3l4blFrRkJaMElzUjBGRk4wSkRMRVZCUVU4eFF5eEpRVU5ZZDBNc1IwRkJVVWNzVDBGQlV5eFhRVU5pTEVkQlFVbERMRWRCUVdFc1IwRkJTVU1zVFVGRGNrSkVMRWRCUVZkRkxFbEJRVTFLTEVWQlFVdGtMRk5CUlhSQ0xFbEJRVWx0UWl4SFFVRmxka0lzUlVGQlFWWXNVVUZCUzJ0RExHRkJRV0ZtTEVWQlFWZFBMRWRCUXpWRFV5eEZRVUZYZWtJc1JVRkJRVllzVVVGQlMydERMR0ZCUVdGbUxFVkJRVmRQTEVWQlJUVkRTU3hIUVVGWFJDeFBRVUZUTEZkQlExcERMRVZCUVZkTkxFMUJRVkZPTEVWQlFWZFBMRkZCUXpsQ1VDeEZRVUZYVHl4UlFVRlZiRUlzUlVGQmMwSXNSVUZCVmtNc1NVRkJaMElzUlVGQlRWVXNSVUZCVjA4c1QwRkJVMUFzUlVGQlYwMHNUMEZEZEVaT0xFVkJRVmROTEUxQlFWRnFRaXhGUVVGelFpeEZRVUZXUXl4SlFVVXZRbFVzUlVGQlYwMHNUMEZCVTJwQ0xFVkJRWE5DTEVWQlFWWkRMRWxCUVdkQ0xFVkJRVTFWTEVWQlFWZE5MRTFCUVZGT0xFVkJRVmRQTEZGQlEzQkdVQ3hGUVVGWFR5eFBRVUZUYkVJc1JVRkJjMElzUlVGQlZrTXNSVUZIY0VNc1NVRkJTV3RDTEVkQlFXTkRMRk5CUVZORExHTkJRV01zVTBGRGVrTkdMRWRCUVZsR0xFMUJRVkZxUWl4RlFVTndRbTFDTEVWQlFWbEVMRTlCUVZOc1FpeEZRVU55UW0xQ0xFVkJRVmxITEZkQlFWY3NUVUZCVFVNc1ZVRkJWVm9zUlVGQldWWXNSVUZCVTBFc1JVRkJVMFFzUlVGQmMwSXNSVUZCVmtNc1JVRkJZVVFzUlVGQmMwSXNSVUZCVmtNc1JVRlBNVWNzUzBGQlN5eEhRVXhFZFVJc1IwRkJhVUpNTEVWQlFWbEhMRmRCUVZjc1RVRkJUVWNzWVVGQllTeEZRVUZITEVWQlFVZDZRaXhGUVVGWFFTeEhRVU0xUlRCQ0xFVkJRVzFDUml4RlFVRmxSeXhMUVVOc1EwTXNSVUZCYTBKa0xFVkJRV0ZSTEZkQlFWY3NUVUZCVFVjc1lVRkJZU3hGUVVGSExFVkJRVWQ2UWl4RlFVRlhRU3hIUVVNNVJUWkNMRVZCUVc5Q1JDeEZRVUZuUWtRc1MwRkZMMEpITEVWQlFVa3NSVUZCUjBFc1JVRkJTVW9zUlVGQmFVSkxMRTlCUVZGRUxFZEJRVXNzUlVGQlJ5eERRVU5xUkN4SFFVRkpSU3hIUVVGSlF5eExRVUZMUXl4TlFVRk5TaXhGUVVGSkxFZEJRVXM1UWl4RlFVTjRRbTFETEVWQlFVbEdMRXRCUVV0RExFMUJRVTFFTEV0QlFVdERMRTFCUVUxS0xFVkJRVWtzUjBGQlN6bENMRVZCUlhaRExFbEJRVWxuUXl4RlFVRkpMMElzUjBGQlYydERMRVZCUVVsc1F5eEhRVUZYSzBJc1IwRkJTMmhETEVWQlFWVkRMRWRCUVZkclF5eEhRVUZMYmtNc1JVRkJWVU1zUlVGRGRrVTBRaXhGUVVGclFrTXNSVUZCUlN4SFFVRkxMRTFCUnpkQ0xFdEJRVWxGTEVWQlFVVXNSMEZCU3l4SFFVRkxSeXhGUVVGRkxFZEJRVXNzVFVGSGJrSklMRVZCUVVrc1MwRkJUMGNzUlVGQlNTeEpRVUZOUVN4SFFVRkxia01zUlVGQlZTeExRVWR3UTJkRExFZEJRVXRvUXl4RlFVRlZMRWxCUVUxdFF5eEZRVUZKTEVsQlFUZENMRU5CU1VFc1IwRkJiVUlzWVVGQlpqRkNMRVZCUVV0aUxFOUJRWFZDTEVOQlF6VkNMRWRCUVVsM1F5eEhRVUZUTjBNc1JVRkJRVllzVVVGQlMzZEVMRlZCUVZWWUxFVkJRV2xDU1N4SFFVRkpTaXhGUVVGcFFra3NSVUZCUlN4SFFVRkpTaXhGUVVGcFFra3NSVUZCUlN4SFFVRkpMRWxCUXk5R1JDeEhRVUZyUWtNc1IwRkJTMDBzUlVGRGRrSlFMRVZCUVd0Q1F5eEZRVUZGTEVkQlFVdE5MRVZCUTNwQ1VDeEZRVUZyUWtNc1JVRkJSU3hIUVVGTFRTeE5RVU5JTEZOQlFXWXpRaXhGUVVGTFlpeFRRVU5hYVVNc1JVRkJhMEpETEVkQlFVdEtMRVZCUVdsQ1NTeEhRVU40UTBRc1JVRkJhMEpETEVWQlFVVXNSMEZCUzBvc1JVRkJhVUpKTEVWQlFVVXNSMEZETlVORUxFVkJRV3RDUXl4RlFVRkZMRWRCUVV0S0xFVkJRV2xDU1N4RlFVRkZMRWRCUldoRVJDeEhRVUZyUWtNc1JVRkJSU3hIUVVGTFNpeEZRVUZwUWtrc1JVRkJSU3hKUVVkb1JHaENMRVZCUVdGUkxGZEJRVmNzVFVGQlRXZENMR0ZCUVdGV0xFVkJRV2xDTEVWQlFVY3NSVUZITDBRc1MwRkJTeXhIUVVSRVZ5eEhRVUZwUW14RUxFVkJRVUZ0UkN4UFFVRlBReXh0UWtGQmJVSjJReXhIUVVOMFF6UkNMRVZCUVVrc1JVRkJSMEVzUlVGQlNWTXNSVUZCWlZJc1QwRkJVVVFzUjBGQlN5eEZRVU0xUXl4SlFVRkxMRWRCUVVsWkxFZEJRVWtzUlVGQlIwRXNSVUZCU1Vnc1JVRkJaVklzVDBGQlVWY3NSMEZCU3l4RlFVRkhMRU5CUXk5RExFZEJRVWxXTEVkQlFVbFBMRVZCUVdWVUxFZEJRMjVDU3l4RlFVRkpTU3hGUVVGbFJ5eEZRVU4yUWl4TlFVRlpMRWRCUVV4V0xFZEJRV1VzU1VGQlRFY3NSMEZCYTBJc1IwRkJURUVzUjBGQlpTeEpRVUZNU0N4SFFVRnJRaXhIUVVGTVFTeEhRVUZsTEVkQlFVeEhMRWRCUVZVc1EwRkRja1VzUjBGQlNWRXNSMEZCVVN4SFFVRkxXQ3hGUVVGRkxFZEJRVXNzUjBGRGNFSlpMRVZCUVZFc1IwRkJTMVFzUlVGQlJTeEhRVUZMTEVkQlEzQkNWU3hGUVVGaExFZEJRVXRpTEVWQlFVVXNSMEZCU3l4SFFVRk5WeXhGUVVNdlFrY3NSVUZCWXl4SFFVRkxXQ3hGUVVGRkxFZEJRVXNzUjBGQlRWTXNSVUZGYUVOSExFVkJRVmN2UWl4RlFVRlRUU3hYUVVGWExFMUJRVTFITEdGQlFXRnJRaXhGUVVGUFF5eEZRVUZQUXl4RlFVRlhReXhGUVVNdlJXaERMRWRCUVdGUkxGZEJRVmNzVFVGQlRXZENMR0ZCUVdGVExFVkJRVlZLTEVWQlFVOURMRWxCVDNoRk4wTXNSVUZCUjJsRUxGVkJRVmtzUjBGRFptcEVMRVZCUVVkclJDeFpRVUZaYmtNc1ZVWjVSV3hDYUVJc1NVRkJTeXhYUVVOTWIwUXNTVUZCU3l4WFJUTkxWaXhQUVVWRmJFVXNUVUZCVHl4SFFVTlFXU3hQUVVGUkxHbENSaXRMUmtvc1NVVXpSVm95UkN4UlFVRlBNMFFzUzBGQlQwRXNSVVlyUldJM1FpeEZRVUZSYTBJc1VVVTVSVTF6UlN4UFFVRlBNMFFzVFVaclJtaENMRk5CUVZNMVFpeEZRVUZSUkN4SFJ6bE5ka0lzV1VGRlFVRXNSMEZCUVdsQ0xGbEJRVUVzUlVGRlFXcENMRVZCUVVGclFpeFJRVUZCTEZOQlFVRjFSU3hGUVVGQlF5eEhRVU5CTEV0QlFVRkVMRmxCUVVGRExFbEJRMEVzVTBGQlFUTkVMRmRCUVVFc2RVTkljMDVOTEZOQlFWTTVRaXhGUVVGUlJDeEZRVUZUVFN4SFNUVk9hRU1zV1VGUlFTeFRRVUZCVXl4SFFVRkJReXhIUVVGelF5eE5RVUZCUVN4TlFVRkJReXhYUVVGQlJDeEhRVUYxUTBVc1VVRkJRVVlzUjBGT04wVm9RaXhGUVVGQmFVSXNXVUZCUVN4RFFVVkJMRWxCUVVFd1JTeEhRVUZCY2tZc1JVRkJRU3hIUVVWQmMwWXNSVUZCUVRkRkxFVkJRVUUwUlN4RlFVbEJNMFlzUjBGQlFXdENMRkZCUVVFc1YwRkRRU3hSUVVGQk1rVXNSMEZCUVVNc1JVRkJRVU1zUjBGRFFTeFBRVUZCTlVJc1IwRkJRU3hGUVVGdFFrRXNSVUZCUVRSQ0xFVkJRVUV6UWl4UFFVRnJRa1FzU1VGQlFTeERRVU55UXl4SFFVRkJOa0lzUjBGQlFVUXNSVUZCUVRWQ0xFVkJRMEUyUWl4SFFVRkJReXhYUVVGQlJDeEZRVUZCUXl4aFFVRkJMRVZCUTBGRUxFVkJRVUZGTEdOQlFVRXNSVUZEUVN4VFFVRkJSaXhQUVVGQlJ5eFZRVUZCTEVsQlEwRXNSVUZCUVZBc1JVRkJRVEZGTEZOQlFVRTBSU3hGUVVGQlJTeEZRVUZCTjBRc1NVRkJRVFpFTEVsQlNVRXNaMEpCUVVGT0xFVkJRVUZWTEVWQlFVRkRMRWRCUjBFc1RVRkdRVVFzU1VGQlFWQXNSVUZCUVVnc1JVRkJRVmtzVlVGQlFVWXNSMEZEUVVNc1IwRkJRVklzUlVGQlFVZ3NSVUZCUVZjc1IwRkRRVmdzVDBwdlQwMHNVMEZCVTNwR0xFVkJRVkZFTEVWQlFWTk5MRWRMTlZCb1Ewd3NSVUZCUVVRc1UwRkJhMEpyUWl4UlFVRkJXaXhGUVVGQkxFZEJRVUZYTEZsQlFVRXNTVXhyVVZvc1UwRkJVMmhDTEVWQlFWRkVMRVZCUVZOTkxFZE5iRkZvUTBFc1JVRkJRU3hGUVVOQkxFbEJRVUZwUnl4SFFVRkJha2NzUlVGQlFTeEhRVUZCWVN4TlFVTkJiRUlzUjBGQlFVUXNVVUZCUVN4VFFVRkJkMGNzUlVGQlFYSkZMRVZCUVVGelJTeEhRVU5CTEUxQlFVRkdMRWRCUVVGdVJpeGxRVUZCYjBZc1JVRkJRWEpGTEVWQlFVRnpSU3hMVG5sUlRTeFRRVUZUZUVjc1JVRkJVVVFzUlVGQlUwMHNSMDgxVVdoRExFZEJRVUZ2Unl4SFFVRkJjRWNzUlVGQlFTeEZRVVZCYjBjc1MwRkJRVU1zUlVGQlFVUXNSVUZCUVVVc1IwRkJRWFJITEVWQlFVRXNZMEZCZFVWakxHVkJRVUZrTEVWQlFVRXNTVUZCUVhWSExFdFFhMUpxUlN4VFFVRlROVWNzUlVGQlVVUXNSVUZCVTAwc1IxRndVbWhETEVkQlFVRjNSeXhIUVVGQmVFY3NSVUZCUVN4SFFVTkJlVWNzUlVGQlFYcEhMRVZCUVVFc1IwRkRRVEJITEVWQlFVRXhSeXhGUVVGQkxFZEJRMEV5Unl4RlFVRkJNMGNzUlVGQlFTeEpRVU5CTkVjc1JVRkJRU3haUVVWQlVpeEZRVUZCTEZOQlFVRlRMRVZCUVVGRExFVkJRVUZETEVkQlEwRXNSMEZUUVd4R0xFZEJRVUZ0Uml4RlFVRkJReXhGUVZSQlF5eEZRVUZCVEN4RlFVRkJWQ3hGUVVGQlJTeEZRVU5CWVN4RlFVRkJUaXhGUVVGQlZDeEZRVUZCWjBJc1JVRkRRVU1zUlVGQlFWSXNSVUZCUVZRc1JVRkJRVU1zUlVGRFFXbENMRVZCUVVGVUxFVkJRVUZVTEVWQlFVRnRRaXhGUVVOQlF5eEZRVUZCV0N4RlFVRkJWQ3hGUVVGQmNVSXNSVUZEUVVNc1JVRkJRV0lzUlVGQlFWUXNSVUZCUVhWQ0xFVkJRMEZxU1N4RlFVRkJlVWdzUlVGQlFWWXNTVUZCUVVzc1MwRkJRVXdzUlVGQlFVc3NUMEZEUVdNc1JVRkJRV3hKTEVWQlFVRnJTQ3hIUVVOQmNFSXNSVUZCUVRKQ0xFVkJRVUZZTEVWQlFVRmhMRVZCUVVGaUxFVkJRVUZOTEVsQlFVRk9MRVZCUVVGTkxGRkJRWEZHUml4RlFVVnlSazhzUzBGQlFVb3NSVUZCUVVRc1JVRkRRU3hMUVVGQmFrWXNTVUZCUVd0R0xFZEJSVUZETEVkQlFVRkZMRWRCUVVFeFFpeEhRVUZCY1VNc1UwRkJRWEpETEVWQlFVRXpSQ3hIUVVOQmJVWXNSMEZCUVc1R0xFbEJRVUZ1UXl4TFFVVkJkVWdzUlVGQlFVUXNSVUZCUVhoQ0xFVkJRVUV6UkN4SFFVRkJhMFlzUlVGQlFXeEdMRWRCUlVGdVF5eEZRVUZCYlVNc1IwRkJRWE5HTEVkQlFVRXNhMEpCUVVFelFpeEhRVUZCTTBRc1IwRkJRV3RHTEVWQlFVRnNSaXhIUVVWQk1rWXNSMEZCUVZJc1JVRkJRVTRzUlVGQlFVOHNSVUZCUVZRc1IwRkZRV3RDTEVkQlFVRnNReXhGUVVGQk0wUXNTVUZCUVc5R0xFVkJRVUVzVTBGQlFXRXNSMEZEUVN4SFFVRkJlRUlzUjBGQlFTeFRRVUZCZVVJc1JVRkJRVU1zUlVGQlFYcElMRWRCUTBFc1IwRkJRVlFzWlVGQlFXZEpMRWRCUVVFc1EwRkRRU3hQUVVGQlJ5eFZRVUZCYmtVc1VVRkRRU3hwUWtGQlFXZEZMRVZCUTBFc2EwSkJRVUZCTEVkQlFVRkRMRVZCUTBFc2EwSkJRVUZFTEVkQlFVRkRMRVZCUVVGRExFZEJRMWNzVlVGQlFVWXNSMEZCUVVNc1JVRkJRVU1zUlVGQlFYcElMRWRCUTBZc1RVRkJRWFZJTEVkQlFVRkpMRTFCUVVGd1NTeExRVUZCYlVrc1YwRkhWQ3hQUVVSQk0wSXNSMEZCUVUwc1IwRkJRV3RDTEVWQlFVRnNRaXhIUVVOQlRpeEhRVVZMVnl4SFFVRkJTeXhIUVVGQkxHdENRVUZCVEN4SFFVRkJVQ3hGUVVGQmVVSXNVMEZCUVRsSUxFdEJRVUUwUnl4TFFVVk1TeXhMUVVOQk5VZ3NSVUZCUVRCSkxGVkJRVUV4U1N4RlFVRkJNRWtzWVVGQkswTjJSeXhIUVVGQmIwWXNSVUZGTDBOS0xFVkJRVUZVTEVWQlFVRnBReXhIUVVGQlZDeE5RVUZCTDBZc1NVRkJRVGhGTEVWQlFVRnBRaXhGUVVGQkwwWXNSVUZCUVc5R0xFdEJTMEZpTEVkQlFVRkZMRVZCUVVFc1JVRkRRVVlzUlVGQlFXZENMRVZCUVVFc1JVRkRRV2hDTEVWQlFVRkRMRVZCUVVFc1JVRkRRVVFzUlVGQlFXMUNMRVZCUVVFc1JVRkRRVzVDTEVWQlFVRnhRaXhGUVVGQkxFZEJRMEZ5UWl4RlFVRkJkVUlzUlVGQlFTeEhRVU5CZGtJc1JVRkJRV3RETEVWQlFVRXNSMEZEUVd4RExFVkJRVUZwUXl4RlFVRkJMRWxCUTBFeFNTeEZRVUZCUkN4UlFVRkJNRWNzUjFJd1VrMHNVMEZCVTNwSExFVkJRVkZFTEVkVGNsWjJRaXhIUVVGQk9FY3NSMEZCUVRkSExFVkJRVUZFTEZGQlFVRXNiVUpCUVVGM1JpeG5Ra0ZCUVd4Q0xGZEJRMEZyUWl4UFFVRkJMRzFDUVVGQk1VTXNXVUZCUVhkQ0xGZEJRVUY0UWl4TFFVRkJNa1lzVTBGQlFTeG5Ra0ZEUVN4cFFrRkJRVWtzVjBGQlFTOUNMRWxVTkZaTkxGTkJRVk0zUnl4RlFVRlJSQ3hIVlM5V2RrSXNSMEZCUVN0SExFZEJRVUU1Unl4RlFVRkJSQ3hUUVVFMlFqaEpMRkZCUVVFc1VVRkROMElzYVVKQlFVRkRMRmRCUVVGb1F5eEpWbkZYVFN4VFFVRlRPVWNzUlVGQlVVUXNSVUZCVTAwc1IxZHlWMmhETEVkQlFVRXdTU3hIUVVGQk1Va3NSVUZCUVN4SFFVTkJUQ3hIUVVGQlJDeFJRVUZCTEZOQlFVRnBTaXhGUVVGQlF5eEZRVUZCT1VVc1IwRkZRU3hIUVVSQk5FVXNSVUZCUVVNc1IwRkRRV1FzVTBGQlFXVXNSVUZCUVN4TlFVRkJSQ3hGUVVOQkxGRkJRVUUzUlN4SFFVTkJMSFZDUVVGQmFVVXNSMEZEUVN4TlFVRkJXU3hIUVVGQmRFa3NTMEZCUVhWSkxFVkJRVUZpTEVkQlJVRXNkMEpCUVVGQkxFVkJRVUZETEVkQlEwRXNUVUZCUVZjc1IwRkJRWFJKTEV0QlFVRjFTU3hGUVVGQllpeEZRVUZCUXl4SFFVVkJMSGRDUVVGQlJDeEZRVUZCUXl4RlFVRkJla2dzUjBGRFFTeE5RVUZCYjBrc1IwRkJRWFJKTEV0QlFVRjFTU3hGUVVGQllpeEZRVUZCUXl4RlFVRkJla2dzU1VGSFFTeHJRa0ZEUVN4TlFVRkJiMGtzUjBGQlFWUXNUVUZCUVZVc1JVRkJRVmdzWTFnNFYwMHNVMEZCVTNSSkxFVkJRVkZFTEVkWkwxaDJRa01zUlVGQlFVUXNVVUZCUVN4VFFVRkJkMGNzUjBGRFFTeHhRa0ZCUVVFc1IwRkJRU3hMUVVGQmVrVXNWMEZCUVhsRkxFVkJRVUVzYzBKQlEwRXNUMEZCUVVFc1MxcHpXVTBzVTBGQlUzWkhMRVZCUVZGRUxFVkJRVk5OTEVkaGVGbG9ReXhIUVVGQk5ra3NSMEZCUVRkSkxFVkJRVUVzU1VGRFFUaEpMRVZCUVVFNVNTeEZRVUZCTEVkQlEwRk1MRWRCUVVGRUxGRkJRVUZOTEVWQlFVRXNZVUZCUVN0SkxFVkJRVUZzU0N4RlFVRkJaQ3hIUVVOQkxFMUJRVUU0U0N4SFFVRkJkRU1zUlVGQlFYZERMRVZCUVVGc1NDeEZRVUZCYVVnc1JVRkJRU3hGUVVGQkwwZ3NTMEZEUXl4VFFVRkJaMGtzUlVGQlFXeElMRVZCUVVGa0xFZEJSVVFzVFVGRVFXZEpMRWRCUVVGc1NDeEhRVUZCWkN4RlFVTkJaMGtzU1dJcldVMHNVMEZCVTNCS0xFVkJRVkZFTEVWQlFWTk5MRWRqY2xwb1F5eEhRVUZCWjBvc1IwRkJRV2hLTEVWQlFVRXNTVUZEUVdsS0xFVkJRVUZxU2l4RlFVRkJMRWxCUTBGclNpeEZRVUZCYkVvc1JVRkJRU3hKUVVOQk5ra3NSVUZCUVdoSkxFOUJRVUZETEdOQlJVRndRaXhIUVVGQk5rY3NSVUZCUVhaSExFVkJRVUVzU1VGQlFXRXNUMEZCUVVNc1pVRkJRU3hUUVVGQmNVa3NSVUZCUVRWQ0xFVkJRVUUyUWl4SFFVbEJMRWRCU0VGS0xFVkJRVUZITEVkQlEwRTFRaXhGUVVGQk1rSXNSVUZCUVROQ0xFZEJRVUVzUjBGRFFYbENMRVZCUVVGSkxFZEJRMEZJTEVWQlFVRXNTVUZEUVN4TlFVRkJTaXhIUVVGQlRTeEZRVUZCTlVJc1JVRkJRVFpDTEVkQlEwY3NUVUZCUVVNc1NVRkRTQ3hWUVVGQlJDeEpRVUZCTEU5QlFVRkJMRWRCUVVFc1MwRkJRVE5JTEZkQlFVRXNNa0pCUlVFc1QwRkVRU3hUUVVGQk1rZ3NTMEZCUVVRc1JVRkJRVFZDTEVkQlFVRTJRaXhGUVVGQmNra3NUMEZEUVc5SkxFbGtORnBOTEZOQlFWTjRTaXhGUVVGUlJDeEZRVUZUVFN4SFpURmhhRU1zUjBGQlFYTktMRWRCUVVGMFNpeEZRVUZCTEVkQlEwRk1MRWRCUVVGRUxGRkJRVUVzVTBGQlFYZEhMRWRCUTBFc1NVRkJRVzlFTEVWQlFVRndSQ3hIUVVGQkxFdEJRVUY2UlN4WFFVRkJlVVVzUlVGQlFTeHhRa0ZEUVN4UFFVRkJRU3hMWm1saVRTeFRRVUZUZGtjc1JVRkJVVVFzUjJkQ2NHSjJRa01zUlVGQlFVUXNVVUZCUVN4VFFVRkJkMGNzUjBGRFFTeHpRa0ZCUVVFc1IwRkJRU3hQUVVGQlFTeEZRVUZCTEd0Q1FVRkJRU3hMYUVJeVlrMHNVMEZCVTNaSExFVkJRVkZFTEVWQlFWTk5MRWRwUWpWaWFFTk1MRVZCUVVGRUxGTkJRVUZOTEVWQlFVRXNUVUZCUVVFc1JVRkJRU3hsUVVOQkxFMUJRVzFITEVsQlFXNUhZU3hQUVVGQlF5eGxRVUZCWkN4RlFVRkJMR2RDUVVGelJXbEdMRWxCUVVFc1YwRkJaMElzV1VGQllUaERMRXRxUW0xak4wWXNVMEZCVTNCSkxFVkJRVkZFTEVWQlFWTk5MRWRyUW01amFFTk1MRVZCUVVGRUxGTkJRVUZOTEVWQlFVRXNaVUZEUVN4TlFVRnpSU3hKUVVGMFJXRXNUMEZCUVVNc2EwSkJRV2xETEV0QlFWRnRSU3hKUVVGQkxGZEJRV2RDTEZsQlFXRTRReXhMYkVJeVkyaEZMRk5CUVZOd1NTeEZRVUZSUkN4SGJVSTNZM1pDUXl4RlFVRkJSQ3hSUVVGQkxGTkJRVUUyU2l4SFFVTkJMRWxCUTBFc1VVRkJRVUVzU1VGRFJ5eE5RVUZCUml4SFFVTklMRmx1UW5Ga1RTeFRRVUZUTVVvc1JVRkJVVVFzUlVGQlUwMHNSMjlDZW1Sb1F5eEhRVUZCYzBvc1IwRkJRWFJLTEVWQlFVRXNTVUZEUVcxRUxFVkJRVUZ1UkN4RlFVRkJMRWRCUVVGdFJDeFRRVVZCY1Vjc1JVRkJRVVlzUlVGQlFXNUhMRWxCUVVGdFJ5eEZRVUZCYmtjc1JVRkJRVU1zWTBGRFFYcEVMRWRCUVVGRUxGRkJRVUVzVTBGQlFYZEhMRWRCUTBFc1RVRkJRWE5FTEVkQlFVRnlSeXhGUVVGQlF5eGpRVUZCT0VNc1VYQkNaMlZOTEZOQlFWTjJSeXhGUVVGUlJDeEZRVUZUVFN4SGNVSndaV2hETEVkQlFVRnpTaXhIUVVGQmRFb3NSVUZCUVN4SFFVZEJUQ3hIUVVGQlJDeFJRVUZCTEZOQlFVRjNSeXhGUVVGQlJ5eEhRVU5CTEVsQlFVRnBSQ3hGUVVGQmNFUXNSMEZCUVN4TlFVRkJRU3hGUVVOQkxFbEJRVUY1UXl4SFFVRkJZeXhEUVVOQkxFbEJRVUZ3UkN4SFFVRkJMRzFDUVVGQmMwTXNSVUZCUVhwRExFVkJRVUYzUkN4WlFVRkJTaXhGUVVGQlJ5eEZRVUZCWkN4RlFVRkJkRWtzUzBGQlFUWkdMRWxCUVVFc1RVRkJRWFZFTEVWQlEwRXNkVUpCUVVGa0xFVkJRVUY2UXl4RlFVRkJlVVFzVjBGQlFVd3NSVUZCUVVjc1JVRkJRV1FzUlVGQlFYUkpMRXRCUVVFMlJpeEpRVUZCTEUxQlFVRjFSQ3hGUVVOQkxFdEJRVUZ3UkN4SFFVRkJMRzFDUVVGQmMwTXNSVUZCUVhwRExFVkJRVUYzUkN4WlFVRkJTaXhGUVVGQlJ5eEZRVUZCWkN4RlFVRkJkRWtzUzBGQlFUWkdMRWxCUVVFc1RVRkJRWFZFTEVWQlEwRXNUVUZCUVdoSkxGZEJRVUVzTmtOeVFqUmxUU3hUUVVGVE9VSXNSVUZCVVVRc1IzTkNkR1oyUWtNc1JVRkJRVVFzVVVGQlFTeFRRVUZCYTBzc1JVRkJRVGRKTEVkQlEwRXNUMEZEUVRSRkxHRkJRVUVzUlVGQlFXbEZMRWRCUTBGb1JTeGxRVUZCTEVWQlFVRm5SU3hIUVVOQkwwUXNWMEZCUVN4RlFVRkJLMFFzUjBGRFFUZEpMRmQwUWpobVRTeFRRVUZUY0VJc1JVRkJVVVFzUlVGQlUwMHNSMEZSTDBJc1VVRkJVMU1zUjBGQmRVSkRMRWRCUVU4c1RVRkJUMEVzU1VGQlQwRXNSVUZCU1VNc1YwRkJZVVFzUjBGQlVVVXNVVUZCVTBZc1IwRk9ka1lzUjBGQlNXMUtMRWRCUVdkRFF5eEZRVUU0UWtNc1JVRkZPVVJETEVWQlFWZG9TeXhGUVVGdlFpeEpkVUowWm1oRGFVc3NSM1pDZDJaWmVFb3NSVUZCZFVKMVNpeEhkVUo0WmpGQ0xGZEJNamhDV0N4UlFVRlRSU3hIUVVGaFF5eEZRVUZMUXl4SFFVVjZRaXhIUVVGNVFpeHRRa0ZCWkVRc1IwRkJTWEpITEU5QlEySXNTMEZCVFN4SlFVRkpkVWNzVDBGQlRVWXNSVUZCU1hKSExFOUJRVk1zU1VGQlRYTkhMRVZCUjNKRExFbEJRVWxGTEVkQlFVOHNWMEZGVkN4SlFVUkJMRWRCUVVsRExFZEJRVk1zUlVGRFRrRXNSVUZCVTBvc1JVRkJTWEpITEZGQlFYbENMRWRCUVdaeFJ5eEZRVUZKU1N4SlFVTm9RMEVzUjBGQlZTeERRVWRhTEV0QlFVc3NSMEZFUkVRc1IwRkJUeXhIUVVGSlJTeFBRVUZOVEN4RlFVRkpja2NzVDBGQlUzbEhMRVZCUVZOSUxFZEJRMnhEZGtjc1JVRkJTU3hGUVVGSFFTeEZRVUZKYzBjc1JVRkJTWEpITEU5QlFWTjVSeXhGUVVGUk1VY3NSMEZCU3l4RlFVTTFRM2xITEVWQlFVdDZSeXhIUVVGTGMwY3NSVUZCU1hSSExFVkJRVWt3Unl4RlFVVndRaXhQUVVGUFJDeE5RVWRNUnl4SlFUUkRTaXhQUVRGRFFVRXNSMEZCVFVNc1RVRkJVU3hUUVVGVFF5eEhRVU55UWl4TlFVRlBUQ3hIUVVGTFN5eEpRVWRrUml4RlFVRk5SeXhWUVVGWkxGZEJRMmhDTEUxQlFVOU9MRWRCUVV0NFJ5eFJRVWRrTWtjc1JVRkJUVWtzVTBGQlZ5eFRRVUZUZUVJc1IwRkplRUlzU1VGQlN5eEhRVVpFWXl4SFFVRk5MRWRCUVVsTExFOUJRVTFETEVWQlFVMUhMRmxCUVdOMlFpeEZRVUZGZFVJc1dVRkJZeXhIUVVVdlF5OUhMRVZCUVVrc1JVRkJSMEVzUlVGQlNUUkhMRVZCUVUxSExGbEJRV0V2Unl4SFFVRkxMRVZCUXpGRExFbEJRVXNzUjBGQlNWa3NSMEZCU1N4RlFVRkhRU3hGUVVGSk5FVXNSVUZCUlhWQ0xGbEJRV0Z1Unl4SFFVRkxMRVZCUTNSRE1FWXNSVUZCU1hSSExFVkJRVWxaTEVsQlFVMXhSeXhGUVVGUFF5eExRVUZMUkN4RlFVRlBSU3hMUVVGTFVDeEZRVUZOUXl4TlFVRk5OMGNzU1VGQlQybElMRVZCUVU5RkxFdEJRVXN6UWl4RlFVRkZjVUlzVFVGQlRXcEhMRWxCU1dwR0xFOUJRVTk1Uml4SFFVRmhReXhGUVVGTExFbEJSek5DVFN4RlFVRk5VU3hKUVVGTkxGTkJRVk0xUWl4SFFVVnVRaXhIUVVGSmIwSXNSVUZCVFVjc1dVRkJZM1pDTEVWQlFVVjFRaXhaUVVGakxFVkJRM1JETEUxQlFVOUlMRVZCVFZRc1MwRkJTeXhIUVVoRVV5eEhRVUZSU2l4RlFVRlBSU3hMUVVGTFVDeEZRVUZOUXl4TlFVRk5MRWxCUVU5SkxFVkJRVTlGTEV0QlFVc3pRaXhGUVVGRmNVSXNUVUZCVFN4SlFVVXpSRkFzUlVGQlRTeEhRVUZKU3l4UFFVRk5ReXhGUVVGTlJ5eGhRVU5xUWk5SExFVkJRVWtzUlVGQlIwRXNSVUZCU1RSSExFVkJRVTFITEZsQlFXRXZSeXhIUVVGTExFVkJRekZEYzBjc1JVRkJTWFJITEVkQlFVczBSeXhGUVVGTlF5eE5RVUZOTjBjc1JVRkhka0lzUzBGQlN5eEhRVUZKUVN4SFFVRkpMRVZCUVVkQkxFVkJRVWwzUml4RlFVRkZkVUlzV1VGQllTOUhMRWRCUVVzc1JVRkRkRU56Unl4RlFVRkpkRWNzU1VGQlRXbElMRVZCUVU5RExFdEJRVXRFTEVWQlFVOUZMRXRCUVVzelFpeEZRVUZGY1VJc1RVRkJUVGRITEVsQlFVOXhTQ3hGUVVsdVJDeFBRVUZQYUVJc1IwRkJZVU1zUlVGQlN5eEhRVUZIWXl4SlFVRkpOVUlzU1VGSE0wSnZRaXhGUVRrdlFsUXNSMEZCU1ZJc1IwRkJVeXhUUVVGVGEwSXNSVUZCV1VNc1IwRkZhRU1zUjBGQlNVTXNSMEZCVHl4SlFVTlFReXhGUVVGUExFZEJSVkJETEVWQlFXTktMRVZCUTJSTExFVkJRWGRDUXl4RlFVRjFRa3dzUjBGREwwTk5MRVZCUVZjc1MwRkRXRU1zUlVGQlpTeEZRVU5tUXl4RlFVRmhMRXRCUTJKRExFVkJRVmtzUjBGQlNYSkNMRTlCUldoQ1F5eExRVVZCY1VJc1JVRkJWeXhUUVVGVFF5eEZRVUZOUXl4SFFVVTFRa3dzUlVGQk5rSXNSVUZCWkVvc1JVRkJhMElzUjBGRGFrTkhMRVZCUVZjc1UwRkJVMDhzUjBGRmJFSXNTVUZCU3l4SFFVUkViRTBzUjBGQlZTeEhRVUZKZVVzc1QwRkJUWGxDTEVkQlEyWkRMRVZCUVUwc1JVRkJSMEVzUlVGQlRVUXNSVUZCWVVNc1IwRkJUeXhGUVVGSExFTkJRemREYmswc1JVRkJVVzFOTEVkQlFVOHNSMEZCU1RGQ0xFOUJRVTE1UWl4RlFVTjZRaXhMUVVGTExFZEJRVWxGTEVkQlFVMHNSVUZCUjBFc1JVRkJUVVlzUlVGQllVVXNSMEZCVHl4RlFVTXhRM0JOTEVWQlFWRnRUU3hIUVVGTFF5eEhRVUZQTEV0QlIzaENMRTFCUVU5d1RTeEpRVU5RTkV3c1IwRkZSbE1zUlVGQk1FSXNSVUZCUnl4SFFVTTNRa0VzUlVGQk1FSlVMRVZCUVdVc1JVRkJSeXhIUVVNMVExTXNSVUZCTUVJc1JVRkJSMVFzUlVGQlpTeEhRVU0xUTFVc1NVRkRRVU1zU1VGRFFVTXNSVUZCWTFJc1JVRkJUVU1zUjBGRmFFSlVMRWRCUVdVc1IwRkRha0pwUWl4RlFVRm5RbFFzUjBGSFFTeE5RVUZrU0N4SlFVTkdRU3hGUVVGaFlTeEZRVUZYYkVJc1JVRkJZVU1zUlVGQmRVSkxMRWxCUnpsRVlTeEZRVUZSWkN4RlFVRlpTU3hKUVVkc1Fra3NSVUZCTkVJc1UwRkJVMFlzUlVGQlMwTXNSMEZGTlVNc1NVRkJTeXhIUVVGSlVTeEpRVUZKTEVWQlFVbEJMRWRCUVVzc1JVRkJSMEVzUjBGQlN5eEZRVVUxUWl4TFFVRkpWQ3hGUVVGTlV5eEpRVUZMTEVkQlFVMW9RaXhIUVVGblFrOHNSVUZCVFZNc1IwRkZNME1zU1VGQlN5eEhRVUZKY0Uwc1NVRkJTU3hGUVVGSlFTeEhRVUZMTEVWQlFVZEJMRWRCUVVzc1JVRkZlRUkwVEN4RlFVRk5OVXdzU1VGQlN5eEhRVUZOYjB3c1IwRkJaMEpSTEVWQlFVMDFUQ3hKUVVWeVF5eEhRVUZMYjAwc1IwRkJTMEVzUjBGQlN5eEpRVUZYTEVkQlFVeHdUU3hIUVVGbExFZEJRVXhCTEVsQlF6ZENMRWRCUVV0QkxFZEJRVXRCTEVkQlFVc3NTVUZCVnl4SFFVRk1iMDBzUjBGQlpTeEhRVUZNUVN4SlFVTXZRaXhIUVVGTFFTeEhRVUZMUVN4SFFVRkxMRWRCUVVzc1IwRkJTM0JOTEVkQlFVdEJMRWRCUVVzc1JVRkRla050VEN4RlFVRlRVU3hGUVVGTlV5eEhRVUZIVWl4RlFVRk5OVXdzU1VGQlN5eEZRVVUzUW0xTUxFVkJRVk5STEVWQlFVMVRMRWRCUVVkU0xFVkJRVTAxVEN4SlFVRkxMRWxCVFdwRGNVMHNSVUZCY1VJc1YwRkxka0lzU1VGQlN5eEhRVWhFUXl4SFFVRmxMRVZCUTJaRExFVkJRVlVzUlVGRlRHcEtMRVZCUVVrc1JVRkJSMEVzUlVGQlNTeEZRVUZIUVN4SFFVRkxMRVZCUVVjc1EwRkZOMEpwU1N4SFFVRlRMRVZCUVUxcVNTeEZRVVZtTEVsQlFVbHJTaXhIUVVGWmVFa3NSVUZCVDNsSkxHRkJRV0YyUXl4SlFVVXpRaXhIUVVGTU5VY3NSMEZCVldkS0xFVkJRV1ZGTEV0QlF6TkNSaXhGUVVGbFJTeEZRVU5tUkN4RlFVRlZha29zUjBGSlpDeE5RVUZQYVVvc1NVRkhURklzUlVGQmNVSXNWMEZGZGtJc1NVRkJTeXhIUVVGSlN5eEhRVUZKTEVWQlFVZEJMRVZCUVVsb1FpeEZRVUZsTEVWQlFVZG5RaXhIUVVGTExFVkJRMjVDTEUxQlFXeENha0lzUlVGQlUybENMRWRCUVVjc1MwRkhhRUpxUWl4RlFVRlRhVUlzUjBGQlJ5eEhRVUZOUVN4RlFVRkpMRWRCUVVzc1JVRkhOMElzUzBGQlN5eEhRVUZKY0Uwc1IwRkJTU3hGUVVGSFFTeEZRVUZKYjB3c1JVRkJaU3hGUVVGSGNFd3NSMEZCU3l4RlFVTnVRaXhOUVVGc1FtMU1MRVZCUVZNc1IwRkJSMjVNTEV0QlIyaENiVXdzUlVGQlV5eEhRVUZIYmt3c1IwRkJUVUVzUlVGQlNTeEhRVUZMTEVsQlNUTkNPRXdzUlVGQk5rSXNWMEZKTDBJc1NVRkJTeXhIUVVaRVdTeEhRVUZOTVVrc1JVRkJUME1zYlVKQlFXMUNLMGNzUjBGRk0wSXhTQ3hGUVVGSkxFVkJRVWRCTEVWQlFVbHZTaXhGUVVGSmJrb3NUMEZCVVVRc1IwRkJTeXhGUVVWdVF5eEpRVUZMTEVkQlFVbFpMRWRCUVVrc1JVRkJSMEVzUlVGQlNYZEpMRVZCUVVsdVNpeFBRVUZSVnl4SFFVRkxMRVZCUVVjc1EwRkZkRU1zUjBGQlNYbElMRWRCUVUxbExFVkJRVWx3U2l4SFFVTldjMGtzUlVGQlRXTXNSVUZCU1hoSkxFVkJSV1FzU1VGQk1FSXNUVUZCZEVKcFNDeEZRVUZUVVN4SFFVRkxReXhIUVVsc1FpeEpRVUZMTEVkQlFVbFJMRWxCUVVrc1JVRkJTVUVzUjBGQlN5eEZRVUZIUVN4SFFVRkxMRVZCUlRWQ0xFbEJRVXNzUjBGQlNYQk5MRWxCUVVrc1JVRkJTVUVzUjBGQlN5eEZRVUZIUVN4SFFVRkxMRVZCUlhoQ2IwMHNTVUZCU3l4SFFVRlhMRWRCUVV4QkxFZEJRVlZ3VFN4SlFVRkxMRWRCUVZjc1IwRkJURUVzUjBGRGRrSXNSMEZCVEc5TkxFZEJRV1VzUjBGQlRIQk5MRVZCUTJoQ2JVd3NSVUZCVTFFc1JVRkJUVk1zUjBGQlIxSXNSVUZCVFRWTUxFbEJRVXNzUlVGRk4wSnRUQ3hGUVVGVFVTeEZRVUZOVXl4SFFVRkhVaXhGUVVGTk5Vd3NTVUZCU3l4SlFWRnlRMmxOTEVWQlFXdENMRk5CUVZOVUxFZEJTVGRDTEVsQlFVc3NSMEZHUkcxQ0xFZEJRVTh6U1N4RlFVRlBORWtzYVVKQlFXbENOVUlzUjBGRk1VSXhTQ3hGUVVGSkxFVkJRVWRCTEVWQlFVa3NSMEZCU1VFc1IwRkJTeXhGUVVGSExFTkJRemxDTEVkQlFVbHZTQ3hKUVVGUll5eEhRVUU0UWl4SlFVRnVRbTFDTEVkQlFWRnlTaXhGUVVGTExFVkJRM0JETmtnc1IwRkJVekZJTEV0QlFVdERMRTFCUVUxS0xFVkJRVWtzU1VGQlNVRXNSVUZCU1N4RlFVRkpPRWdzUlVGQlpTeEZRVUZKTEVkQlFVdFdMRVZCUnpsRUxFbEJRVXNzUjBGQlNYQklMRWRCUVVrc1JVRkJSMEVzUlVGQlNTeEhRVUZKUVN4SFFVRkxMRVZCUVVjc1EwRkRPVUlzUjBGQlNXOUlMRWxCUVZGakxFZEJRVGhDTEVsQlFXNUNiVUlzUjBGQlVYSktMRVZCUVVzc1JVRkRjRU0yU0N4SFFVRlROMGdzUlVGQlNTeEZRVUZKT0Vnc1JVRkJaU3hGUVVGSkxFZEJRVWN6U0N4TFFVRkxReXhOUVVGTlNpeEZRVUZKTEVsQlFVMXZTQ3hKUVVrMVJITkNMRVZCUVdkQ0xGTkJRVk5TTEVWQlFVMURMRWRCVFdwRExFbEJRVXNzUjBGS1JIUkpMRWRCUVZFNFNDeEhRVUY1UWl4RlFVRkxVU3hGUVVOMFEydENMRVZCUVU4elNTeEZRVUZQTmtrc1pVRkJaVEZLTEVkQlIzaENSeXhGUVVGSkxFVkJRVWRCTEVWQlFVa3NSMEZCU1VFc1IwRkJTeXhGUVVGSExFTkJSVGxDTEVkQlFVbHZTQ3hKUVVGUll5eEhRVUU0UWl4SlFVRnVRbTFDTEVkQlFWRnlTaXhGUVVGTExFVkJSV2hEUVN4SFFVRkpMRVZCUTA0MlNDeEZRVUZUTjBnc1IwRkJSeXhIUVVGTGIwZ3NSVUZEVW5CSUxFVkJRVWtzUlVGRFlqWklMRVZCUVZNM1NDeEZRVUZKTEVkQlFVY3NSMEZCUzI5SUxFVkJSWEpDVXl4RlFVRlRReXhGUVVGbExFZEJRVXM1U0N4SFFVRkhMRWRCUVV0dlNDeEZRVXQ2UXl4SlFVRkxMRWRCUVVsd1NDeEhRVUZKTEVWQlFVZEJMRVZCUVVrc1IwRkJTVUVzUjBGQlN5eEZRVUZITEVOQlJUbENMRWRCUVVsdlNDeEpRVUZSWXl4SFFVRTRRaXhKUVVGdVFtMUNMRWRCUVZGeVNpeEZRVUZMTEVWQlJXaERRU3hIUVVGSkxFVkJRMDQyU0N4RlFVRlRMRWRCUVVkRExFVkJRV1U1U0N4RlFVRkpMRWRCUVV0dlNDeEZRVU16UW5CSUxFVkJRVWtzUlVGRFlqWklMRVZCUVZNc1IwRkJSeXhIUVVGTE4wZ3NSVUZCU1N4RlFVRkpMRWRCUVV0dlNDeEZRVVU1UWxNc1JVRkJVeXhIUVVGSExFZEJRVXMzU0N4RlFVRkpMRWRCUVV0dlNDeEZRVXM1UWxNc1JVRkJVME1zUlVGQlpTeEhRVUZITEVsQlFVOUpMRWRCUjJoRFZ5eEZRVUZWTEZOQlFWTm9TaXhGUVVGTmMwa3NSMEZSTTBJc1NVRkJTeXhIUVU1RWNVSXNTVUZCVFN4RlFVTk9ia0lzUlVGQlRWQXNSVUZCWlN4RlFVTnlRakpDTEVWQlFWY3NSVUZEV0VNc1JVRkJXU3hGUVVOYVF5eEZRVUZYYWtvc1JVRkJUMnRLTEdkQ1FVRm5RbnBDTEVkQlJUZENSeXhGUVVGTlVpeEZRVUZsTEVWQlFVZFJMRVZCUVUwc1JVRkJSMEVzUjBGQlR5eEZRVWt2UXl4SlFVWlhMRWRCUVZCQkxFbEJRVlZCTEVkQlFVOHNTMEZGVWl4RFFVVllMRWxCUVVzc1IwRkJTVFZNTEVkQlFVa3NSVUZCUjBFc1JVRkJTU3hGUVVGSFFTeEhRVUZMTEVWQlJURkNMRWRCUVRoQ0xFMUJRVEZDYlV3c1JVRkJVMUVzUjBGQlMwTXNSVUZCVFRWTUxFZEJRVmtzUTBGRmJFTXNSMEZCU1cxT0xFbEJRVThzUTBGRlVFZ3NSMEZCV1RkS0xFVkJRVXRKTEZOQlEyNUNORW9zUlVGQmEwUXNTVUZCZEVOb1N5eEZRVUZMTmtvc1MwRkJaVVFzUlVGQldTeEhRVWM1UXl4SlFVRkpTeXhIUVVGUFNDeEZRVUZUZEVJc1JVRkJTME1zUlVGQlRUVk1MRVZCUlROQ2IwNHNTMEZEUmtRc1IwRkJVVUVzUjBGSFZtaERMRVZCUVZOUkxFZEJRVXRETEVWQlFVMDFUQ3hIUVVGTGJVNHNSVUZEZWtKS0xFZEJRVmtzUlVGRlVrRXNTVUZCV1N4SlFVTmtReXhIUVVGaExFVkJRMkpFTEVWQlFWY3NSMEZQYWtJc1IwRkdRWEJDTEVkQlFVOXRRaXhGUVVWSWJrSXNSVUZCVFN4SFFVRkxVQ3hIUVVGblFrOHNSVUZCU3l4RFFVTnNRMEVzUjBGQlQyMUNMRVZCUTFCQkxFZEJRVTlCTEVOQlExQXNWVUZOU2s4c1JVRkJZeXhUUVVGVFF5eEZRVUZSUXl4SFFWVnFReXhKUVVGTExFZEJVa1IyUkN4SFFVRlRMRVZCUlZSM1JDeEZRVUZoTEVWQlEySkRMRVZCUVdFc1JVRkZZa01zUlVGQlV5eEhRVUZKZWtRc1QwRkJUWE5FTEVWQlFWTm9TeXhSUVVNMVFtOUxMRVZCUVZNc1IwRkJTVEZFTEU5QlFVMXpSQ3hGUVVGVGFFc3NVVUZGZGtJMlNTeEZRVUZKTEVWQlFVZEJMRVZCUVVsdFFpeEZRVUZUYUVzc1QwRkJVVFpKTEVkQlFVc3NSVUZCUnl4RFFVVXpReXhIUVVGSmQwSXNSMEZCVlV3c1JVRkJVMjVDTEVkQlFVZDVRaXhWUVVOMFFrTXNSVUZCVlZBc1JVRkJVMjVDTEVkQlFVY3lRaXhYUVVGaFNDeERRVVYyUTBvc1IwRkJZUzlLTEV0QlFVdDFTeXhKUVVGSlVpeEZRVUZaU1N4SFFVTnNRMGdzUlVGQllXaExMRXRCUVV0MVN5eEpRVUZKVUN4RlFVRlpTeXhIUVVWc1Ewb3NSVUZCVDNSQ0xFZEJRVXNzUjBGQlNXNURMRTlCUVUweVJDeEZRVVYwUWl4TFFVRkxMRWRCUVVsMFN5eEhRVUZKTEVWQlFVZEJMRVZCUVVsdlN5eEZRVUZQZEVJc1IwRkJSemRKTEU5QlFWRkVMRWRCUVVzc1JVRkRla052U3l4RlFVRlBkRUlzUjBGQlJ6bEpMRWRCUVVzc1NVRkJUMmRMTEVWQlFVOVhMRmxCUVZrelN5eEZRVUZKTUVjc1JVRkZMME5CTEVsQlFWVTBSQ3hEUVVWV0xFbEJRVWxOTEVkQlFWTnNTeXhGUVVGUGJVc3NNRUpCUVRCQ1RDeEhRVU14UTAwc1JVRkJWWHBGTEVWQlFXRXJSQ3hGUVVGUGRFSXNSMEZCU1RoQ0xFVkJRVTgzUkN4WlFVRmpMRWRCUlhaRVowVXNSVUZCVlVRc1JVRkJVVEZFTEVsQlFVbDNSQ3hGUVVNeFFsQXNSMEZCVDNaQ0xFZEJRVXNzUjBGQlNXNURMRTlCUVUxcFJTeEZRVUZQTjBRc1dVRkJZeXhGUVVNelF5eExRVUZMTEVkQlFVa3ZSeXhIUVVGSkxFVkJRVWRCTEVWQlFVbHhTeXhGUVVGUGRrSXNSMEZCUnpkSkxFOUJRVkZFTEVkQlFVc3NSVUZCUnl4RFFVTTFReXhIUVVGSlowd3NSMEZCVjJoTUxFVkJRVWtyU3l4RlFVRlJhRVVzV1VGQlkzTkVMRVZCUVU5MlFpeEhRVUZITjBrc1RVRkRia1J2U3l4SFFVRlBka0lzUjBGQlJ6bEpMRWRCUVUxblRDeEhRVUZaTEVWQlFVbEVMRVZCUVZGc1JTeE5RVUZOYlVVc1IwRkJXU3hIUVVzNVJDeEpRVUZMTEVkQlJFUkRMRWRCUVdsQ0xFVkJRMXBxVEN4RlFVRkpMRVZCUVVkQkxFVkJRVWxwU3l4RlFVRlRhRXNzVDBGQlVVUXNSMEZCU3l4RlFVTjRRMmxNTEVkQlFXdENhRUlzUlVGQlUycExMRWRCUVVkNVN5eFZRVTFvUXl4TFFVRkxMRWRCU0VRMVN5eEhRVUZQTEVkQlFVazRSeXhQUVVGTmMwVXNSMEZEYWtKdVJTeEZRVUZSTEVWQlJVZzVSeXhGUVVGSkxFVkJRVWRCTEVWQlFVbHJTeXhGUVVGWmJFc3NSMEZCU3l4RlFVTnVReXhKUVVGTExFZEJRVWs0U1N4SFFVRkpMRVZCUVVkQkxFVkJRVWx0UWl4RlFVRlRhRXNzVDBGQlVUWkpMRWRCUVVzc1JVRkRjRU01U1N4RlFVRkpiMHNzUlVGQlQzUkNMRWRCUVVjM1NTeFRRVU5vUWtvc1JVRkJTMmxJTEVkQlFWTnpSQ3hGUVVGUGRFSXNSMEZCUnpsSkxFZEJRM2hDT0Vjc1IwRkJVeXhGUVV0bUxFdEJRVXNzUjBGQlNUbEhMRWRCUVVrc1JVRkJSMEVzUlVGQlNXMUxMRVZCUVZsdVN5eEhRVUZMTEVWQlEyNURMRWxCUVVzc1IwRkJTVGhKTEVkQlFVa3NSVUZCUjBFc1JVRkJTVzFDTEVWQlFWTm9TeXhQUVVGUk5ra3NSMEZCU3l4RlFVTndRemxKTEVWQlFVbHhTeXhGUVVGUGRrSXNSMEZCUnpkSkxGTkJRMmhDU2l4RlFVRkxhVWdzUjBGQlUzVkVMRVZCUVU5MlFpeEhRVUZIT1Vrc1IwRkRlRUk0Unl4SFFVRlRMRVZCUzJZc1QwRkJUMnBJTEVsQlIwd3JTU3hGUVVGaExGTkJRVk4wUWl4RlFVRlpReXhGUVVGelFqSkVMRWRCVFRGRUxFbEJRVXNzUjBGS1JHcENMRWRCUVZkclFpeEZRVUZWUXl4WlFVRlpPVVFzUlVGQldVTXNSMEZGTjBONVF5eEZRVUZUY1VJc1NVRkZTbkpNTEVWQlFVa3NSVUZCUjBFc1JVRkJTV3RNTEVWQlFWTnFUQ3hQUVVGUlJDeEhRVUZMTEVWQlFVY3NRMEZETTBNc1IwRkJTVWdzUjBGQlQzRk1MRVZCUVZOc1RDeEZRVU53UW1kTExFZEJRVTl6UWl4SlFVRkpla3dzUlVGQlN6Qk1MRlZCUVZjc1IwRkRNMEoyUWl4RlFVRlBjMElzU1VGQlNYcE1MRVZCUVV0clNDeFpRVUZoY2tjc1JVRkJUemhMTEdkQ1FVRm5Rak5NTEVWQlFVc3dUQ3hWUVVGWGFrVXNTVUZEY0VWNlNDeEZRVUZMTkV3c1RVRkJUWHBDTEVkQlMySXNTVUZCU3l4SFFVUkVNRUlzUjBGQmFVSXNSVUZEV2pGTUxFVkJRVWtzUlVGQlIwRXNSVUZCU1dsTExFVkJRVk5vU3l4UFFVRlJSQ3hIUVVGTExFVkJRM2hETUV3c1IwRkJhMEo2UWl4RlFVRlRha3NzUjBGQlIzVkxMRk5CUjJoRExFbEJRVWxRTEVWQlFVOTNRaXhyUWtGQmNVTXNSVUZCYWtKRkxFVkJRemRDTEV0QlFVMHNTVUZCU1d4R0xFOUJRVTBzTUVKQlExcDNSQ3hGUVVGUGQwSXNhMEpCUTFBc1NVRkRhVUlzUlVGQmFrSkZMRVZCUTBFc1NVRlRUaXhMUVV4Sk1VSXNSVUZCVDNkQ0xHdENRVUZ2UWl4SFFVRnpRaXhGUVVGcVFrVXNSMEZEYkVNeFFpeEZRVUZQYzBJc1NVRkJTU3hGUVVGSExFZEJTVlIwUWl4RlFVRlBkMElzYTBKQlFXOUNMRWRCUVVzc1IwRkRja040UWl4RlFVRlBNa0lzVVVGQlR5eEZRVWxvUWl4UlFVRmhMRU5CUlZnc1IwRkJTVE5DTEVWQlFVOTNRaXh0UWtGQmMwTXNSVUZCYWtKRkxFVkJRemxDTEV0QlNVWXNTVUZHUVRGQ0xFVkJRVTl6UWl4SlFVRkpPVVFzUlVGQlRTeEhRVVZpZDBNc1JVRkJUM2RDTEcxQ1FVRnpReXhGUVVGcVFrVXNSVUZET1VJc1MwRkZSakZDTEVkQlFVOXpRaXhKUVVGSk4wUXNSVUZCVFN4SFFVZHVRaXhOUVVGUGMwTXNSMEZCV1VNc1JVRkJVVU1zUjBFNFNqZENMRTlCTTBwQmNrUXNSMEZCVFhKSkxGRkJRVlVzVTBGQlUzTkNMRVZCUVUwclRDeEhRVVUzUWtFc1JVRkJUMEVzUjBGQlVTeE5RVVZtTEVsQlFVbERMRWRCUVZVc1NVRkZaQ3hSUVVGUFJDeEhRVU5RTEVsQlFVc3NWVUZEU0VNc1JVRkJWVU1zUlVGQlUycE5MRVZCUTI1Q0xFMUJRMFlzUzBGQlN5eGxRVU5JWjAwc1JVRkJWVVVzUlVGQlYyeE5MRVZCUTNKQ0xFMUJRMFlzUzBGQlN5eFBRVU5JWjAwc1JVRkJWVWNzUlVGQlYyNU5MRVZCUTNKQ0xFMUJRMFlzUzBGQlN5eFJRVU5JWjAwc1JVRkJWVWtzUlVGQlVYQk5MRVZCUTJ4Q0xFMUJRMFlzVTBGRFJTeExRVUZOTEZGQlFWVXJUQ3hGUVVkc1FqVkVMRVZCUVZWclJTeExRVUZMVEN4SFFVTm1PVVFzUlVGQllTeE5RVWRtYmtJc1JVRkJUWFZHTEU5QlFWTXNVMEZCVXpsRUxFVkJRVXRETEVkQlF6TkNMRWRCUVVsRUxFVkJRVTBzUjBGQlMxQXNSMEZCWjBKUExFZEJRVTlETEVWQlFVMHNSMEZCUzFJc1IwRkJaMEpSTEVWQlF5OUVMRXRCUVUwc1NVRkJTVGxDTEU5QlFVMDJRaXhGUVVGTkxFbEJRVTFETEVWQlJUbENMRTlCUVU5VUxFZEJRVk5STEVkQlFVdERMRWxCUjNaQ01VSXNSVUZCVFhkR0xHVkJRV2xDTEZkQlEzSkNMRTFCUVU5MFJTeEpRVWRVYkVJc1JVRkJUWEJKTEV0QlFVOHNWMEZEV0hsS0xFZEJRVk1zUlVGQlQyTXNUVUZIYkVKdVF5eEZRVUZOZVVZc1pVRkJhVUlzVTBGQlUwTXNSVUZCVlVNc1IwRkZlRU5FTEVWQlFWZEJMRWRCUVZrc1JVRkRka0pETEVWQlFUSkNMRzFDUVVGV1FTeEhRVUZ0UXl4RlFVRllSQ3hGUVVGbFF5eERRVVY0UkN4SlFVRkpReXhIUVVGVExFVkJSV0pCTEVsQlFWVXNhVUpCUTFaQkxFZEJRVlVzTUVOQlExWkJMRWRCUVZVc09FSkJRMVpCTEVkQlFWVXNNRUpCUVRSQ1JDeEZRVUZUTEUxQlF5OURReXhIUVVGVkxFdEJRMVpCTEVkQlFWVXNVMEZGVml4TFFVRkxMRWRCUVVreFJDeEhRVUZKTEVWQlFVZEJMRVZCUVVsc1F5eEZRVUZOZDBZc2FVSkJRV3RDZEVRc1IwRkJTeXhGUVVGSExFTkJSV3hFTUVRc1IwRkJWU3hOUVVWV0xFdEJRVXNzUjBGQlNUbFFMRWRCUVVrc1JVRkJSMEVzUlVGQlNXdExMRVZCUVUxM1JpeHBRa0ZCYTBJeFVDeEhRVUZMTEVWQlF5OURPRkFzUjBGQlZTeGpRVU5XUVN4SFFVRlZMREJEUVVOV1FTeEhRVUZWTERoQ1FVTldRU3hIUVVGVkxEaENRVU5XUVN4SFFVRlZMRmRCUVdGR0xFVkJRVmNzVFVGRGJFTkZMRWRCUVZVc1dVRkJZMFlzUlVGQlZ5eE5RVU51UTBVc1IwRkJWU3h6UWtGRFZrRXNSMEZCVlRWR0xFVkJRVTExUml4UFFVRlBja1FzUlVGQlIzQk5MRWRCUVVrc1ZVRkJXU3hWUVVNeFF6aFFMRWRCUVZVc1NVRkRWa0VzUjBGQlZTeExRVWRhUVN4SlFVRlZMRkZCVFZvc1RVRklRVUVzU1VGQlZTeFhRVU5XUVN4SFFVRlZMRmxCUzFvMVJpeEZRVUZOTmtZc1lVRkJaU3hUUVVGVFNDeEZRVUZWUXl4SFFVVjBRMFFzUlVGQlYwRXNSMEZCV1N4RlFVTjJRa01zUlVGQk1rSXNiVUpCUVZaQkxFZEJRVzFETEVWQlFWaEVMRVZCUVdWRExFTkJRM2hFTEVsQlEwazNVQ3hIUVVGSFoxRXNSVUZCU1RWRUxFVkJRVWMyUkN4RlFVRmpReXhGUVVSNFFrTXNSVUZCVDJwSExFVkJRVTEzUml4cFFrRkJiVUpGTEVWQlFXOUNMRVZCUVZSRExFVkJRemRDVHl4RlFVRk5MRVZCV1hoQ0xFdEJWa0ZHTEVWQlFVOHNTVUZCVFU0c1JVRkJWeXhSUVVGVlFTeEZRVU5vUXl4TFFVRlBRU3hGUVVGWExGTkJRVmRCTEVWQlFWY3NTMEZGTVVOUkxFZEJRVk1zVDBGRFZFRXNSMEZCVXl4WFFVRmhSQ3hGUVVGUExFMUJRemRDUXl4SFFVRlRMRmxCUVdORUxFVkJRVThzVFVGRE9VSkRMRWRCUVZNc2MwTkJRMVJCTEVkQlFWTXNTVUZEVkVFc1IwRkJVeXhaUVVWS2FFVXNSVUZCU1N4RlFVRkhRU3hGUVVGSmJFTXNSVUZCVFhkR0xHbENRVUZyUW5SRUxFZEJRVXNzUlVGRk0wTXNTVUZFUVRaRUxFVkJRVXMzUkN4RlFVRkpkMFFzUlVGQlYwTXNSVUZEWmpkUUxFVkJRVWtzUlVGQlIwRXNSVUZCU1d0TExFVkJRVTEzUml4cFFrRkJhMEl4VUN4SFFVRkxMRVZCUTNaRGEwc3NSVUZCVFhWR0xFOUJRVTl5UkN4RlFVRkhjRTBzUzBGRGJFSm5VU3hGUVVGTGFGRXNSVUZCUlRSUUxFVkJRVk5ETEVWQlEyaENUeXhIUVVGVExFbEJRVTFLTEVWQlFVc3NTVUZCVFVNc1JVRkJTME1zUlVGUmNrTXNUMEZJUVVVc1NVRkJVeXgzUTBGRFZFRXNSMEZCVXl4VlFVdFliRWNzUlVGQlRXMUhMR0ZCUVdVc1UwRkJVMVFzUlVGQlZVTXNSMEZGZEVORUxFVkJRVmRCTEVkQlFWa3NSVUZEZGtKRExFVkJRVEpDTEcxQ1FVRldRU3hIUVVGdFF5eEZRVUZZUkN4RlFVRmxReXhEUVVWNFJDeEpRVUZKVFN4SFFVRlBha2NzUlVGQlRYZEdMR2xDUVVGdFFrVXNSVUZCYjBJc1JVRkJWRU1zUlVGRE0wTlRMRVZCUVUxVUxFVkJRMDQzUWl4RlFVRk5iVU1zUlVGQlQwNHNRMEZGYWtJc1QwRkJUMUVzUjBGQllVWXNSVUZCVFVFc1JVRkJUU3hUUVVGVE0wMHNSVUZCUjBjc1IwRkRNVU1zUjBGQlNUSk5MRWRCUVU4NVRTeEhRVUZMUVN4RlFVRkpkMHNzUjBGQlQzTkRMRWRCUVU4elRTeEhRVUZMUVN4RlFVRkpjVXNzUlVGQlN5eERRVU01UXl4SFFVRkphRThzUjBGQlNYbEVMRXRCUVV0RExFOUJRVkZHTEVWQlFVazRUU3hIUVVGUFZpeEhRVU0xUW5oRUxFVkJRVWt6U1N4TFFVRkxReXhQUVVGUlF5eEZRVUZKTWswc1IwRkJUMVlzUlVGRGFFTXNUMEZCVHpGR0xFZEJRVTExUml4UFFVRlBja1FzUlVGQlIzQk5MRWRCUVVrc1JVRkJTU3hGUVVVdlFpeE5RVUZQTEUxQlMySnJTeXhGUVVGTmJFa3NaMEpCUVd0Q0xGTkJRVk0wVGl4RlFVRlZReXhIUVVWNlEwUXNSVUZCVjBFc1IwRkJXU3hGUVVOMlFrTXNSVUZCTWtJc2JVSkJRVlpCTEVkQlFXMURMRVZCUVZoRUxFVkJRV1ZETEVOQlJYaEVMRWxCUVVsTkxFZEJRVTlxUnl4RlFVRk5kMFlzYVVKQlFXMUNSU3hGUVVGdlFpeEZRVUZVUXl4RlFVTXpRMU1zUlVGQlRWUXNSVUZEVGpkQ0xFVkJRVTF0UXl4RlFVRlBUaXhEUVVWcVFpeFBRVUZQTjA0c1IwRkJaMEp0VHl4RlFVRk5RU3hGUVVGTkxGTkJRVk16VFN4RlFVRkhSeXhIUVVNM1F5eEhRVUZKTWswc1IwRkJUemxOTEVkQlFVdEJMRVZCUVVsM1N5eEhRVUZQYzBNc1IwRkJUek5OTEVkQlFVdEJMRVZCUVVseFN5eEZRVUZMTEVOQlF6bERMRWRCUVVsb1R5eEhRVUZKZVVRc1MwRkJTME1zVDBGQlVVWXNSVUZCU1RoTkxFZEJRVTlXTEVkQlF6VkNlRVFzUlVGQlNUTkpMRXRCUVV0RExFOUJRVkZETEVWQlFVa3lUU3hIUVVGUFZpeEZRVU5vUXl4UFFVRlBNVVlzUjBGQlRYVkdMRTlCUVU5eVJDeEZRVUZIY0Uwc1IwRkJTU3hGUVVGSkxFVkJSUzlDTEUxQlFVOHNUVUZMVG10TExFVkJUMVJTTEVkQlFVODJSeXhqUVVGblFpeFRRVUZUUXl4SFFVVTVRaXhKUVVGTExFZEJSRVJETEVkQlFWRXNSMEZCU1hoSExFOUJRMUF6Unl4RlFVRkpMRVZCUVVkQkxFVkJRVWxyVGl4RlFVRkZhazRzVDBGQlVVUXNSMEZCU3l4RlFVRkhMRU5CUTNCRExFZEJRVWwwUkN4SFFVRkpkMUVzUlVGQlJVVXNWMEZCVjNCT0xFVkJRM0pDYlU0c1IwRkJUV3BDTEV0QlFWTXNTVUZCU25oUUxFZEJSV0lzVFVGQlQzbFJMRWxCV1ZRdlJ5eEZRVUZQYVVnc2IwSkJRWE5DTEZOQlFWTkRMRVZCUVdGRExFZEJTV3BFTEVkQlFVbERMRWRCUVdFc1YwRlhaaXhKUVZSQkxFZEJRVWxETEVkQlFVMURMRVZCUVhkQ1NpeEhRVU01UWtzc1JVRkJUeXhYUVVOVUxFZEJRVWw0U2l4SFFVRkpjMG9zUlVGQlNVVXNUVUZEV2l4SlFVRkplRW9zU1VGQlN5eEZRVUZKTEV0QlFVMHNTVUZCU1hGRExFMUJRM1pDTEU5QlFVOXlReXhKUVVkTWVVb3NSVUZCVVN4RlFVTlNTaXhQUVVOVExFTkJRMWdzUjBGQlNVc3NSMEZCUzBvc1JVRkJTVVVzVFVGRFlpeEpRVUZKUlN4SlFVRk5MRVZCUVVrc1MwRkRaQ3hKUVVGSlF5eEhRVUZMU0N4SlFVTk1TU3hGUVVGTFNpeEpRVU5NU3l4RlFVRkxUQ3hKUVVOTVRTeEZRVUZKUXl4UFFVRlBReXhoUVVGbFRpeEhRVUZOTEVWQlFVdERMRWRCUTNKRFRTeEZRVUZMVEN4SFFVRk5MRVZCUVV0RExFTkJRM0JDVWl4SFFVRlhVeXhIUVVGTFJ5eEZRVU5vUWxJc1IwRkJVeXhGUVVWWUxFZEJRVWxCTEVkQlFWTk1MRVZCUTFnc1MwRkJUU3hKUVVGSkwwY3NUMEZCVFc5SUxFVkJRVkVzVDBGQlUwd3NSVUZIYmtNc1QwRkJUME1zVFVGSFRHRXNSVUZCWXl4SlFVRkpha0lzVjBGQlZ5eEZRVVZxUXl4UFFVRlBMRlZCUVZOR0xFZEJSV1FzU1VGQlN5eEhRVVJFUXl4SFFVRlJMRWRCUVVsNFJ5eFBRVU5RTTBjc1JVRkJTU3hGUVVGSFFTeEZRVUZKYTA0c1JVRkJSV3BPTEU5QlFWRkVMRWRCUVVzc1JVRkJSeXhEUVVOd1F5eEhRVUZKZEVRc1IwRkJTWGRSTEVWQlFVVkZMRmRCUVZkd1RpeEZRVU55UWl4SlFVRkpkRVFzUlVGQlNTeEpRVU5PZVZFc1JVRkJUV3BDTEV0QlFVdDRVQ3hQUVVOT0xFTkJRMHdzUjBGQlNYbElMRWRCUVVseFNpeEZRVUZYVGl4RlFVRkZiMElzVDBGQlQzUlBMRWRCUTFvc2FVSkJRVXh0UlN4SlFVTkRMRWxCUVVwQkxFbEJRV0ZCTEVWQlJXcENaMG9zUlVGQlRXcENMRXRCUVVzdlNDeEpRVWRZWjBvc1JVRkJUV3BDTEV0QlFVc3ZTQ3hKUVVGTkxFZEJRMnBDWjBvc1JVRkJUV3BDTEV0QlFWTXNTVUZCU2k5SUxFbEJSMkpuU2l4RlFVRk5ha0lzUzBGQlMyMURMRWxCU1dwQ0xFMUJRVTlzUWl4SlFWRllMRWxCUVVsdlFpeEpRVU5HUXl4WlFVRnBRaXhGUVVOcVFrTXNaVUZCYVVJc1JVRkRha0pETEdWQlFXbENMRVZCUTJwQ1F5eFhRVUZwUWl4SFFVOW1MMGNzUjBGRFJtZElMRVZCUVVrc1JVRkRTa01zUlVGQlNTeEZRVU5LUXl4RlFVRkpMRVZCUTBwRExFVkJRVWtzUjBGUFJrTXNSMEZEUmtNc1YwRkJZU3hGUVVOaVF5eFhRVUZoTEVWQlEySkRMRmRCUVdFc1JVRkRZa01zVjBGQllTeEZRVU5pUXl4WFFVRmhMRVZCUTJKRExGZEJRV0VzUlVGRFlrTXNWMEZCWVN4RlFVTmlReXhYUVVGaExFZEJUMWc1VHl4RlFVRlRMRmRCUlZnc1IwRkJTU3RQTEZGQlJVUXNSVUZCUnl4TFFVTklMRVZCUVVjc1MwRkRTQ3hGUVVGSExFdEJRMGdzUlVGQlJ5eExRVU5JTEVWQlFVY3NTMEZEU0N4RlFVRkhMRWRCUVVrc1MwRkRVQ3hGUVVGSExFZEJRVWtzUzBGRFVDeEZRVUZITEVkQlFVa3NTMEZEVUN4RlFVRkhMRWRCUVVrc1MwRkRVQ3hGUVVGSExFZEJRVWtzUzBGRFVDeEZRVUZITEVkQlFVa3NTMEZEVUN4RlFVRkhMRWRCUVVrc1MwRkRVQ3hGUVVGSExFZEJRVWtzUjBGQlNTeExRVU5ZTEVWQlFVY3NSMEZCU1N4SFFVRkpMRXRCUTFnc1JVRkJSeXhIUVVGSkxFZEJRVWtzUzBGRFdDeEZRVUZITEVkQlFVa3NSMEZCU1N4TFFVTllMRVZCUVVjc1IwRkJTU3hIUVVGSkxFdEJRMWdzUlVGQlJ5eEhRVUZKTEVkQlFVa3NTMEZEV0N4RlFVRkhMRWRCUVVrc1IwRkJTU3hMUVVOWUxFVkJRVWNzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZEWml4RlFVRkhMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJRMllzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4TlFVTm1MRVZCUVVjc1IwRkJTU3hIUVVGSkxFZEJRVWtzVFVGRFppeEZRVUZITEVkQlFVa3NSMEZCU1N4SFFVRkpMRTFCUTJZc1JVRkJSeXhIUVVGSkxFZEJRVWtzUjBGQlNTeE5RVU5tTEVWQlFVY3NSMEZCU1N4SFFVRkpMRWRCUVVrc1RVRkRaaXhGUVVGSExFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NUVUZEYmtJc1JVRkJSeXhIUVVGSkxFZEJRVWtzUjBGQlNTeEpRVUZMTEUxQlEzQkNMRVZCUVVjc1IwRkJTU3hIUVVGSkxFZEJRVWtzU1VGQlN5eE5RVU53UWl4RlFVRkhMRWRCUVVrc1IwRkJTU3hIUVVGSkxFbEJRVXNzVFVGRGNFSXNSVUZCUnl4SFFVRkpMRWRCUVVrc1IwRkJTU3hKUVVGTExFMUJRM0JDTEVWQlFVY3NSMEZCU1N4SFFVRkpMRWRCUVVrc1NVRkJTeXhOUVVOd1FpeEZRVUZITEVkQlFVa3NSMEZCU1N4SFFVRkpMRWxCUVVzc1RVRkRjRUlzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SlFVRkxMRWxCUVVzc1RVRkRla0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SlFVRkxMRWxCUVVzc1RVRkRla0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SlFVRkxMRWxCUVVzc1RVRkRla0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SlFVRkxMRWxCUVVzc1RVRkRla0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SlFVRkxMRWxCUVVzc1RVRkRla0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SlFVRkxMRWxCUVVzc1RVRkZlRUpETEVWQlFVOHNTMEZEVUVNc1JVRkJUeXhMUVVOUVF5eEZRVUZaTEUxQlJWcG9TaXhMUVVWQmFVb3NSVUZCWXl4VFFVRlRhRkVzUjBGRmVrSXNTVUZFUVN4SFFVRkphVkVzUjBGQlVTeEZRVU5ITEVkQlFWSnFVU3hIUVVOTWFWRXNSMEZCVXl4RlFVTlVhbEVzUzBGQlZTeERRVVZhTEU5QlFVOXBVU3hIUVdkT1ZDeFBRVGROUVd4S0xFZEJRVTB5UXl4bFFVRnBRaXhUUVVGVE1Vb3NSMEZGT1VJc1NVRkVRU3hIUVVGSmExRXNSMEZCU1d4UkxFZEJRVkVzUjBGRFZHZFJMRVZCUVZsRkxFZEJRVXRHTEVWQlFWbElMRWxCUVZFc1IwRkRNVU5MTEVkQlFVMU1MRWRCUVZGSExFVkJRVmxGTEVkQlFVdEdMRVZCUVZsSUxFVkJSVGRETEZGQlFWVTNVQ3hIUVVGUkxFZEJRVTFyVVN4SFFVRkxTQ3hIUVVjdlFtaEtMRVZCUVUwd1F5eHBRa0ZCYlVJc1UwRkJVM3BLTEVkQlJXaERMRWxCUkVFc1IwRkJTV3RSTEVkQlFVbHNVU3hIUVVGUkxFZEJRMVJuVVN4RlFVRlpSU3hIUVVGTFJpeEZRVUZaUml4SlFVRlJMRWRCUXpGRFNTeEhRVUZOU2l4SFFVRlJSU3hGUVVGWlJTeEhRVUZMUml4RlFVRlpSaXhGUVVVM1F5eFBRVUZST1ZBc1NVRkJVU3hIUVVGTmExRXNSMEZIZUVKdVNpeEZRVUZOYWtjc2JVSkJRWEZDTEZOQlFWTXlSeXhIUVVOc1F5eE5RVUZQYlVrc1IwRkJkVUp1U1N4RlFVRmhMRWxCUnpkRFZpeEZRVUZOWjBRc1owSkJRV3RDTEZOQlFWTjZRaXhIUVVVdlFpeFBRVUZSUVN4SFFVVlNMRWxCUVVzMlJ5eEhRVUZqUXl4WFFVTnFRaXhOUVVGUExGVkJRVk5xVUN4RlFVRkhXU3hIUVVGTExFOUJRVkZhTEVWQlFVbFpMRWRCUVVzc1IwRkJTeXhGUVVOb1JDeExRVUZMYjA4c1IwRkJZMFVzVjBGRGFrSXNUVUZCVHl4VlFVRlRiRkFzUlVGQlIxa3NSMEZCU3l4TlFVRlBXaXhIUVVGSkxFZEJRVXNzUlVGRE1VTXNTMEZCUzJkUUxFZEJRV05ITEZkQlEycENMRTFCUVU4c1ZVRkJVMjVRTEVWQlFVZFpMRWRCUVVzc1RVRkJUMEVzUjBGQlNTeEhRVUZMTEVWQlF6RkRMRXRCUVV0dlR5eEhRVUZqU1N4WFFVTnFRaXhOUVVGUExGVkJRVk53VUN4RlFVRkhXU3hIUVVGTExFOUJRVkZhTEVWQlFVbFpMRWRCUVVzc1IwRkJTeXhGUVVOb1JDeExRVUZMYjA4c1IwRkJZMHNzVjBGRGFrSXNUVUZCVHl4VlFVRlRjbEFzUlVGQlIxa3NSMEZCU3l4UFFVRlJWQ3hMUVVGTFF5eE5RVUZOU2l4RlFVRkpMRWRCUVV0SExFdEJRVXRETEUxQlFVMVJMRVZCUVVrc1NVRkJUeXhIUVVGTExFVkJRMnBHTEV0QlFVdHZUeXhIUVVGalRTeFhRVU5xUWl4TlFVRlBMRlZCUVZOMFVDeEZRVUZIV1N4SFFVRkxMRTFCUVZGYUxFZEJRVWxaTEVWQlFVc3NSVUZCUzFvc1JVRkJTVmtzUlVGQlN5eEhRVUZMTEVWQlF6bEVMRXRCUVV0dlR5eEhRVUZqVHl4WFFVTnFRaXhOUVVGUExGVkJRVk4yVUN4RlFVRkhXU3hIUVVGTExFOUJRVlZhTEVWQlFVbFpMRVZCUVVzc1JVRkJTMW9zUlVGQlNWa3NSVUZCU3l4SFFVRkxMRWRCUVVzc1JVRkRja1VzUzBGQlMyOVBMRWRCUVdOUkxGZEJRMnBDTEUxQlFVOHNWVUZCVTNoUUxFVkJRVWRaTEVkQlFVc3NUMEZCVlZvc1JVRkJTVmtzUlVGQlN5eEhRVUZMV2l4RlFVRkpXU3hIUVVGTExFZEJRVXNzUjBGQlN5eEZRVVZ5UlN4VFFVTkZMRXRCUVUwc1NVRkJTVFJHTEU5QlFVMHNiVUpCUVhGQ01rSXNTMEZKZWtOMlFpeEZRVUZOYVVVc01FSkJRVFJDTEZOQlFWTnRSaXhIUVVWNlF5eEpRVUZMTEVkQlJFUTVUQ3hIUVVGSmJVTXNSMEZCWXl4SFFVRkpMRWRCUTJwQ2NrY3NSVUZCU1N4RlFVRkhRU3hGUVVGSloxRXNSVUZCYjBKb1VTeEhRVUZMTEVWQlF6TkRhMFVzUlVGQlNVRXNSVUZCUlRoRExGTkJRVk5ZTEVkQlFXTXNSVUZCUjFrc1JVRkJUME1zUzBGQlMyeElMRWxCUVVzc1IwRkZia1FzVDBGQlQydEZMRWxCUjFRd1F5eEZRVUZOTkVVc1owSkJRV3RDTEZOQlFWTkpMRVZCUVUwMVNTeEhRVVZ5UXl4SFFVRkpMRWRCUVV0QkxFZEJRVkZCTEVWQlFVOHNSMEZKZEVJc1QwRkJUelJKTEVkQlExQXNTVUZCU3pKRExFZEJRVTlETEZsQlFXbENMRTFCUVU4c1IwRkRjRU1zUzBGQlMwUXNSMEZCVDBVc1pVRkJhVUlzVFVGQlR5eEZRVU53UXl4TFFVRkxSaXhIUVVGUFJ5eGxRVUZwUWl4TlFVRlBMRVZCUTNCRExFdEJRVXRJTEVkQlFVOUpMRmRCUVdsQ0xFMUJRVThzUlVGRGNFTXNVMEZEUlN4TFFVRk5MRWxCUVVsdVNTeFBRVUZOTEZGQlFWVnZSaXhQUVVkMlFpeEpRVUZKTlVrc1JVRkJUeXhIUVVsb1FpeFBRVUZQTkVrc1IwRkRVQ3hKUVVGTE1rTXNSMEZCVDBNc1dVRkJhVUlzVFVGQlR5eEhRVU53UXl4TFFVRkxSQ3hIUVVGUFJTeGxRVUZwUWl4TlFVRlBMRWRCUTNCRExFdEJRVXRHTEVkQlFVOUhMR1ZCUVdsQ0xFMUJRVThzUjBGRGNFTXNTMEZCUzBnc1IwRkJUMGtzVjBGQmFVSXNUVUZCVHl4SFFVTndReXhUUVVORkxFdEJRVTBzU1VGQlNXNUpMRTlCUVUwc1VVRkJWVzlHTEU5QlIzWkNMRTFCUVVrMVNTeEZRVUZQTEVsQlkyaENMRXRCUVUwc1NVRkJTWGRFTEU5QlFVMHNVVUZCVlhoRUxFVkJWakZDTEZGQlFVODBTU3hIUVVOUUxFbEJRVXN5UXl4SFFVRlBReXhaUVVGcFFpeE5RVUZQTEVkQlEzQkRMRXRCUVV0RUxFZEJRVTlGTEdWQlFXbENMRTFCUVU4c1IwRkRjRU1zUzBGQlMwWXNSMEZCVDBjc1pVRkJhVUlzVFVGQlR5eEhRVU53UXl4TFFVRkxTQ3hIUVVGUFNTeFhRVUZwUWl4TlFVRlBMRWRCUTNCRExGTkJRMFVzUzBGQlRTeEpRVUZKYmtrc1QwRkJUU3hSUVVGVmIwWXNUVUZSYUVOb1JpeEZRVUZOZFVNc1lVRkJaU3hUUVVGVEwwTXNSMEZSTlVJc1NVRkJTeXhIUVU1RVowTXNSMEZCWTJoRExFVkJRVTluUnl4cFFrRkZja0pzUkN4RlFVRlpMRVZCU1ZCaUxFVkJRVTBzUlVGQlIwRXNSVUZCVFVRc1JVRkJZVU1zUjBGQlR5eEZRVU14UXl4SlFVRkxMRWRCUVVsRExFZEJRVTBzUlVGQlIwRXNSVUZCVFVZc1JVRkJZVVVzUjBGQlR5eEZRVUZITEVOQlN6ZERMRWxCUVVzc1IwRklSREpJTEVkQlFWa3NSVUZEV25CSExFVkJRVTk2UkN4RlFVRlBLMFlzVDBGQlR6bEVMRVZCUVV0RExFZEJSWEpDVVN4SFFVRkpMRVZCUVVsQkxFZEJRVXNzUlVGQlIwRXNSMEZCU3l4RlFVVTFRaXhMUVVGSlZDeEZRVUZOVXl4RlFVRkpMRWRCUVV0V0xFZEJRV1ZETEVWQlFVMVRMRWRCU1hoRExFbEJRVXNzUjBGQlNYQk5MRWxCUVVrc1JVRkJTVUVzUjBGQlN5eEZRVUZIUVN4SFFVRkxMRVZCUlhoQ05Fd3NSVUZCVFRWTUxFVkJRVWtzUjBGQlN6Qk1MRWRCUVdWRkxFVkJRVTAxVEN4SFFVa3ZRaXhIUVVGTWIwMHNSMEZCWlN4SFFVRk1jRTBzUjBGSlZtMU9MRWRCUVZGNlJDeEZRVUZQSzBZc1QwRkJUemxFTEVWQlFVMVRMRVZCUVVkU0xFVkJRVTAxVEN4TFFVTjJRM1ZVTEVkQlFXRXNSVUZMWmtFc1IwRkJXU3hKUVVOa0wwY3NSMEZCWXl4RlFVRkpLMGNzUlVGQldTeEhRVTl3UXl4SlFVRkxMRWRCUVVrMVNDeEhRVUZOTEVWQlFVZEJMRVZCUVUxRUxFVkJRV01zUlVGQlIwTXNSMEZCVHl4RlFVTTVReXhKUVVGTExFZEJRVWxETEVkQlFVMHNSVUZCUjBFc1JVRkJUVVlzUlVGQll5eEZRVUZIUlN4SFFVRlBMRVZCUVVjc1EwRkRha1FzUjBGQlNYTkdMRWRCUVZFc1EwRkRVbmhJTEVkQlFVOHJSaXhQUVVGUE9VUXNSVUZCUzBNc1MwRkJUM05HTEVkQlFWTXNSMEZEYmtONFNDeEZRVUZQSzBZc1QwRkJUemxFTEVWQlFVMHNSVUZCUjBNc1MwRkJUM05HTEVkQlFWTXNSMEZEZGtONFNDeEZRVUZQSzBZc1QwRkJUemxFTEVWQlFVdERMRVZCUVUwc1MwRkJTM05HTEVkQlFWTXNSMEZEZGtONFNDeEZRVUZQSzBZc1QwRkJUemxFTEVWQlFVMHNSVUZCUjBNc1JVRkJUU3hMUVVGTGMwWXNSMEZCVXl4SFFVTnNReXhIUVVGVVFTeEhRVUYxUWl4SFFVRlVRU3hKUVVOb1FqRkZMRWRCUVdFc1IwRlBia0lzU1VGQlN5eEhRVUZKWWl4SFFVRk5MRVZCUVVkQkxFVkJRVTFFTEVWQlFXRkRMRWRCUVU4c1JVRkRNVU1zU1VGQlN5eEhRVUZKUXl4SFFVRk5MRVZCUVVkQkxFVkJRVTFHTEVWQlFXTXNSVUZCUjBVc1IwRkJUeXhGUVVNeFEyeERMRVZCUVU4clJpeFBRVUZQT1VRc1JVRkJTME1zUzBGRFpteERMRVZCUVU4clJpeFBRVUZQT1VRc1JVRkJTME1zUlVGQlRTeEpRVU42UW14RExFVkJRVThyUml4UFFVRlBPVVFzUlVGQlMwTXNSVUZCVFN4SlFVTjZRbXhETEVWQlFVOHJSaXhQUVVGUE9VUXNSVUZCUzBNc1JVRkJUU3hKUVVONlFteERMRVZCUVU4clJpeFBRVUZQT1VRc1JVRkJTME1zUlVGQlRTeExRVU42UW14RExFVkJRVThyUml4UFFVRlBPVVFzUlVGQlMwTXNSVUZCVFN4SlFVTjZRbXhETEVWQlFVOHJSaXhQUVVGUE9VUXNSVUZCUzBNc1JVRkJUU3hMUVVNdlFsa3NSMEZCWVN4SFFVdHVRaXhMUVVGTExFZEJRVWxhTEVkQlFVMHNSVUZCUjBFc1JVRkJUVVlzUlVGQllVVXNSMEZCVHl4RlFVTXhReXhKUVVGTExFZEJRVWxFTEVkQlFVMHNSVUZCUjBFc1JVRkJUVVFzUlVGQll5eEZRVUZIUXl4SFFVRlBMRVZCUXpGRGFrTXNSVUZCVHl0R0xFOUJRVTg1UkN4RlFVRkxReXhMUVVObWJFTXNSVUZCVHl0R0xFOUJRVTg1UkN4RlFVRk5MRVZCUVVkRExFbEJRM1pDYkVNc1JVRkJUeXRHTEU5QlFVODVSQ3hGUVVGTkxFVkJRVWRETEVsQlEzWkNiRU1zUlVGQlR5dEdMRTlCUVU4NVJDeEZRVUZOTEVWQlFVZERMRWxCUTNaQ2JFTXNSVUZCVHl0R0xFOUJRVTg1UkN4RlFVRk5MRVZCUVVkRExFdEJRM1pDYkVNc1JVRkJUeXRHTEU5QlFVODVSQ3hGUVVGTkxFVkJRVWRETEVsQlEzWkNiRU1zUlVGQlR5dEdMRTlCUVU4NVJDeEZRVUZOTEVWQlFVZERMRXRCUXpkQ1dTeEhRVUZoTEVkQlUyNUNMRXRCUVVzc1IwRkdSR2RJTEVkQlFWa3NSVUZGVURWSUxFVkJRVTBzUlVGQlIwRXNSVUZCVFVZc1JVRkJZVVVzUjBGQlR5eEZRVU14UXl4SlFVRkxMRWRCUVVsRUxFZEJRVTBzUlVGQlIwRXNSVUZCVFVRc1JVRkJZVU1zUjBGQlR5eEZRVU4wUTJwRExFVkJRVThyUml4UFFVRlBPVVFzUlVGQlMwTXNTMEZEY2tJMFNDeEhRVUZoTEVWQlMyNUNMRWxCUVVrM1NTeEhRVUZSYkVnc1MwRkJTMmRSTEVsQlFVa3NTVUZCVFVRc1JVRkJXVGxJTEVWQlFXTkJMRVZCUVdNc1NVRkJUU3hEUVVkNlJTeFBRVVpCWXl4SlFVRnhRaXhIUVVGU04wSXNSMEZMVWxRc1MwRlBURXNzUlVGQlV5eFhRVTFZTEVsQlFVc3NSMEZLUkcxS0xFZEJRVmtzUjBGQlNYcEtMRTlCUVUwc1MwRkRkRUl3U2l4RlFVRlpMRWRCUVVreFNpeFBRVUZOTEV0QlIycENNMGNzUlVGQlNTeEZRVUZIUVN4RlFVRkpMRVZCUVVkQkxFZEJRVXNzUlVGRE1VSnZVU3hGUVVGVmNGRXNSMEZCU3l4SFFVRkxRU3hEUVVWMFFpeExRVUZMTEVkQlFVbEJMRWRCUVVrc1JVRkJSMEVzUlVGQlNTeEpRVUZMUVN4SFFVRkxMRVZCUXpWQ2IxRXNSVUZCVlhCUkxFZEJRVXR2VVN4RlFVRlZjRkVzUlVGQlNTeEhRVU42UW05UkxFVkJRVlZ3VVN4RlFVRkpMRWRCUTJSdlVTeEZRVUZWY0ZFc1JVRkJTU3hIUVVOa2IxRXNSVUZCVlhCUkxFVkJRVWtzUlVGRmNFSXNTMEZCU3l4SFFVRkpRU3hIUVVGSkxFVkJRVWRCTEVWQlFVa3NTVUZCUzBFc1IwRkJTeXhGUVVNMVFuRlJMRVZCUVZWRUxFVkJRVlZ3VVN4SlFVRlBRU3hEUVVjM1FpeEpRVUZKTkVjc1MwRjNRa29zVDBGMFFrRkJMRWRCUVUxUExFdEJRVThzVTBGQlUyMUtMRWRCUlhCQ0xFZEJRVWxCTEVWQlFVa3NSVUZEVGl4TFFVRk5MRWxCUVVrNVNpeFBRVUZOTEZGQlFWVTRTaXhGUVVGSkxFbEJSMmhETEU5QlFVOUVMRWRCUVZWRExFbEJSMjVDTVVvc1JVRkJUVTBzUzBGQlR5eFRRVUZUYjBvc1IwRkZjRUlzUzBGQlQwRXNSVUZCU1N4SFFVTlVRU3hIUVVGTExFZEJSMUFzVFVGQlQwRXNSMEZCU3l4TFFVTldRU3hIUVVGTExFZEJSMUFzVDBGQlQwWXNSMEZCVlVVc1NVRkhXakZLTEV0Qk5FVk1kVVVzUlVGQldTeFhRVVZrTEVkQlFVbHZSaXhMUVZGRUxFVkJRVWNzUjBGQlNTeExRVU5RTEVWQlFVY3NSMEZCU1N4TFFVTlFMRVZCUVVjc1IwRkJTU3hMUVVOUUxFVkJRVWNzUjBGQlNTeEpRVWRRTEVWQlFVY3NSMEZCU1N4TFFVTlFMRVZCUVVjc1IwRkJTU3hMUVVOUUxFVkJRVWNzUjBGQlNTeExRVU5RTEVWQlFVY3NSMEZCU1N4TFFVZFFMRVZCUVVjc1IwRkJTU3hMUVVOUUxFVkJRVWNzUjBGQlNTeExRVU5RTEVWQlFVY3NSMEZCU1N4TFFVTlFMRVZCUVVjc1IwRkJTU3hMUVVkUUxFVkJRVWNzU1VGQlN5eExRVU5TTEVWQlFVY3NSMEZCU1N4TFFVTlFMRVZCUVVjc1IwRkJTU3hMUVVOUUxFVkJRVWNzUjBGQlNTeEpRVWRRTEVWQlFVY3NTVUZCU3l4TlFVTlNMRVZCUVVjc1IwRkJTU3hMUVVOUUxFVkJRVWNzUjBGQlNTeEhRVUZKTEVWQlFVY3NSMEZCU1N4TFFVTnNRaXhGUVVGSExFZEJRVWtzUjBGQlNTeEZRVUZITEVkQlFVa3NTMEZIYkVJc1JVRkJSeXhIUVVGSkxFdEJRMUFzUlVGQlJ5eEhRVUZKTEV0QlExQXNSVUZCUnl4SFFVRkpMRXRCUTFBc1JVRkJSeXhIUVVGSkxFdEJSMUFzUlVGQlJ5eEhRVUZKTEV0QlExQXNSVUZCUnl4SFFVRkpMRXRCUTFBc1JVRkJSeXhIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlEyeENMRVZCUVVjc1IwRkJTU3hIUVVGSkxFVkJRVWNzUjBGQlNTeExRVWRzUWl4RlFVRkhMRWxCUVVzc1MwRkRVaXhGUVVGSExFZEJRVWtzUjBGQlNTeEZRVUZITEVkQlFVa3NTMEZEYkVJc1JVRkJSeXhIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlEyeENMRVZCUVVjc1IwRkJTU3hIUVVGSkxFVkJRVWNzUjBGQlNTeExRVWRzUWl4RlFVRkhMRWxCUVVzc1RVRkRVaXhGUVVGSExFZEJRVWtzUjBGQlNTeEZRVUZITEVkQlFVa3NTMEZEYkVJc1JVRkJSeXhIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlEyeENMRVZCUVVjc1IwRkJTU3hIUVVGSkxFVkJRVWNzUjBGQlNTeExRVWRzUWl4RlFVRkhMRWRCUVVrc1IwRkJTU3hGUVVGSExFZEJRVWtzUzBGRGJFSXNSVUZCUnl4SFFVRkpMRWRCUVVrc1JVRkJSeXhIUVVGSkxFdEJRMnhDTEVWQlFVY3NSMEZCU1N4SFFVRkpMRVZCUVVjc1IwRkJTU3hMUVVOc1FpeEZRVUZITEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkhiRUlzUlVGQlJ5eEpRVUZMTEV0QlExSXNSVUZCUnl4SFFVRkpMRWRCUVVrc1JVRkJSeXhIUVVGSkxFdEJRMnhDTEVWQlFVY3NSMEZCU1N4SFFVRkpMRVZCUVVjc1IwRkJTU3hMUVVOc1FpeEZRVUZITEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkhiRUlzUlVGQlJ5eEpRVUZMTEVkQlFVa3NSVUZCUnl4SlFVRkxMRXRCUTNCQ0xFVkJRVWNzUjBGQlNTeEhRVUZKTEVWQlFVY3NSMEZCU1N4TFFVTnNRaXhGUVVGSExFZEJRVWtzUjBGQlNTeEZRVUZITEVkQlFVa3NTMEZEYkVJc1JVRkJSeXhIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlIyeENMRVZCUVVjc1NVRkJTeXhOUVVOU0xFVkJRVWNzUjBGQlNTeEhRVUZKTEVWQlFVY3NSMEZCU1N4TFFVTnNRaXhGUVVGSExFZEJRVWtzUjBGQlNTeEZRVUZITEVkQlFVa3NTMEZEYkVJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlIyNUNMRVZCUVVjc1NVRkJTeXhKUVVGTExFVkJRVWNzU1VGQlN5eE5RVU55UWl4RlFVRkhMRWRCUVVrc1IwRkJTU3hGUVVGSExFZEJRVWtzUzBGRGJFSXNSMEZCU1N4SFFVRkpMRWRCUVVrc1JVRkJSeXhIUVVGSkxFdEJRMjVDTEVkQlFVa3NSMEZCU1N4SFFVRkpMRVZCUVVjc1IwRkJTU3hMUVVkdVFpeEZRVUZITEVsQlFVc3NSMEZCU1N4RlFVRkhMRWxCUVVzc1MwRkRjRUlzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSVUZCUnl4SFFVRkpMRXRCUTJ4Q0xFVkJRVWNzUjBGQlNTeEhRVUZKTEVWQlFVY3NSMEZCU1N4TFFVTnNRaXhIUVVGSkxFZEJRVWtzUjBGQlNTeEZRVUZITEVkQlFVa3NTMEZIYmtJc1JVRkJSeXhKUVVGTExFZEJRVWtzUlVGQlJ5eEpRVUZMTEV0QlEzQkNMRVZCUVVjc1IwRkJTU3hIUVVGSkxFVkJRVWNzUjBGQlNTeExRVU5zUWl4SFFVRkpMRWRCUVVrc1IwRkJTU3hGUVVGSExFZEJRVWtzUzBGRGJrSXNSVUZCUnl4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJSMjVDTEVWQlFVY3NTVUZCU3l4SlFVRkxMRVZCUVVjc1NVRkJTeXhOUVVOeVFpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkRia0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUTI1Q0xFVkJRVWNzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVZHVRaXhGUVVGSExFbEJRVXNzU1VGQlN5eEZRVUZITEVsQlFVc3NUVUZEY2tJc1JVRkJSeXhIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlEyeENMRWRCUVVrc1IwRkJTU3hIUVVGSkxFVkJRVWNzUjBGQlNTeExRVU51UWl4RlFVRkhMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUzBGSGJrSXNSVUZCUnl4SlFVRkxMRWxCUVVzc1JVRkJSeXhKUVVGTExFMUJRM0pDTEVWQlFVY3NSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hMUVVOdVFpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkRia0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUjI1Q0xFVkJRVWNzU1VGQlN5eEpRVUZMTEVWQlFVY3NTVUZCU3l4TlFVTnlRaXhGUVVGSExFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZEYmtJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlEyNUNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVWR3UWl4RlFVRkhMRWxCUVVzc1NVRkJTeXhGUVVGSExFbEJRVXNzVFVGRGNrSXNSMEZCU1N4SFFVRkpMRXRCUTFJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUlVGQlJ5eEhRVUZKTEV0QlEyNUNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFVkJRVWNzUjBGQlNTeExRVWR1UWl4RlFVRkhMRWxCUVVzc1NVRkJTeXhGUVVGSExFbEJRVXNzVFVGRGNrSXNSMEZCU1N4SFFVRkpMRXRCUTFJc1JVRkJSeXhIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlEyNUNMRWRCUVVrc1IwRkJTU3hMUVVkU0xFVkJRVWNzU1VGQlN5eEpRVUZMTEVWQlFVY3NTVUZCU3l4TlFVTnlRaXhGUVVGSExFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZEYmtJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlEzQkNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVWR3UWl4RlFVRkhMRWxCUVVzc1NVRkJTeXhGUVVGSExFbEJRVXNzVFVGRGNrSXNSVUZCUnl4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJRMjVDTEVkQlFVa3NSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hMUVVOd1FpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkhia0lzUlVGQlJ5eEpRVUZMTEVsQlFVc3NSVUZCUnl4SlFVRkxMRTFCUTNKQ0xFVkJRVWNzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVTnVRaXhGUVVGSExFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZEYmtJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlIzQkNMRWRCUVVrc1NVRkJTeXhKUVVGTExFVkJRVWNzU1VGQlN5eE5RVU4wUWl4SFFVRkpMRWRCUVVrc1IwRkJTU3hGUVVGSExFZEJRVWtzUzBGRGJrSXNSMEZCU1N4SFFVRkpMRWRCUVVrc1JVRkJSeXhIUVVGSkxFdEJRMjVDTEVkQlFVa3NSMEZCU1N4SFFVRkpMRVZCUVVjc1IwRkJTU3hMUVVkdVFpeEZRVUZITEVsQlFVc3NTVUZCU3l4RlFVRkhMRWxCUVVzc1RVRkRja0lzUjBGQlNTeEhRVUZKTEVkQlFVa3NSVUZCUnl4SFFVRkpMRXRCUTI1Q0xFVkJRVWNzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVTnVRaXhIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZIY0VJc1JVRkJSeXhKUVVGTExFbEJRVXNzUjBGQlNTeEpRVUZMTEUxQlEzUkNMRVZCUVVjc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVU51UWl4RlFVRkhMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUzBGRGJrSXNSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJSM0JDTEVWQlFVY3NTVUZCU3l4SlFVRkxMRVZCUVVjc1NVRkJTeXhOUVVOeVFpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkRia0lzUlVGQlJ5eEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUTI1Q0xFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVZHdRaXhGUVVGSExFbEJRVXNzU1VGQlN5eEhRVUZKTEVsQlFVc3NUVUZEZEVJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlEzQkNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVU53UWl4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUzBGSGNFSXNSMEZCU1N4SlFVRkxMRWxCUVVzc1JVRkJSeXhKUVVGTExFMUJRM1JDTEVWQlFVY3NSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hMUVVOdVFpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkRia0lzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUjNCQ0xFZEJRVWtzU1VGQlN5eE5RVU5VTEVkQlFVa3NSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hMUVVOd1FpeEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRWRCUVVrc1MwRkRjRUlzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUjNCQ0xFZEJRVWtzU1VGQlN5eEpRVUZMTEVWQlFVY3NTVUZCU3l4TlFVTjBRaXhIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZEY0VJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlEzQkNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVWR3UWl4SFFVRkpMRWxCUVVzc1NVRkJTeXhGUVVGSExFbEJRVXNzVFVGRGRFSXNSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJRM0JDTEVkQlFVa3NSMEZCU1N4SFFVRkpMRVZCUVVjc1IwRkJTU3hMUVVOdVFpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkhia0lzUjBGQlNTeEpRVUZMTEVsQlFVc3NSVUZCUnl4SlFVRkxMRTFCUTNSQ0xFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVTndRaXhIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZEY0VJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlIzQkNMRVZCUVVjc1NVRkJTeXhKUVVGTExFZEJRVWtzU1VGQlN5eE5RVU4wUWl4RlFVRkhMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUzBGRGJrSXNSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJRM0JDTEVWQlFVY3NSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hMUVVkdVFpeEhRVUZKTEVsQlFVc3NTVUZCU3l4RlFVRkhMRWxCUVVzc1RVRkRkRUlzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUTNCQ0xFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVTndRaXhIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NTMEZIY0VJc1JVRkJSeXhKUVVGTExFbEJRVXNzUjBGQlNTeEpRVUZMTEUxQlEzUkNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVU53UWl4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUzBGRGNFSXNSMEZCU1N4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFdEJSM0JDTEVkQlFVa3NTVUZCU3l4SlFVRkxMRVZCUVVjc1NVRkJTeXhOUVVOMFFpeEhRVUZKTEVkQlFVa3NSMEZCU1N4RlFVRkhMRWRCUVVrc1MwRkRia0lzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4SFFVRkpMRXRCUTNCQ0xFZEJRVWtzUjBGQlNTeEhRVUZKTEVkQlFVa3NSMEZCU1N4TFFVZHdRaXhIUVVGSkxFbEJRVXNzU1VGQlN5eEZRVUZITEVsQlFVc3NUVUZEZEVJc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeEhRVUZKTEV0QlEzQkNMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUjBGQlNTeExRVU53UWl4SFFVRkpMRWRCUVVrc1IwRkJTU3hIUVVGSkxFZEJRVWtzUzBGSGJrSkRMRVZCUVZrc1UwRkJVeTlHTEVWQlFWbEdMRWRCUTI1RExFZEJRVWt6UkN4TFFVZEtMRTlCUmtGQkxFZEJRVTAyUkN4WFFVRmhRU3hGUVVOdVFqZEVMRVZCUVUweVJDeFZRVUZaUVN4RlFVTllNMFFzUjBGSFRFRXNTMEZGUVRaS0xFVkJRV3RDTEZOQlFWTnVTaXhGUVVGWlF5eEhRVVY2UXl4UFFVRlBRU3hIUVVOUUxFbEJRVXRMTEVkQlFYVkNaMGdzUlVGRE1VSXNUVUZCVHpKQ0xFZEJRV3RETEVkQlFXeENha29zUlVGQllTeEhRVUZUTEVWQlF5OURMRXRCUVV0TkxFZEJRWFZDYVVnc1JVRkRNVUlzVFVGQlR6QkNMRWRCUVd0RExFZEJRV3hDYWtvc1JVRkJZU3hIUVVGVExFVkJReTlETEV0QlFVdE5MRWRCUVhWQ2EwZ3NSVUZETVVJc1RVRkJUM2xDTEVkQlFXdERMRWRCUVd4Q2Frb3NSVUZCWVN4SFFVRlRMRVZCUXk5RExFdEJRVXROTEVkQlFYVkNiVWdzUlVGRE1VSXNUVUZCVDNkQ0xFZEJRV3RETEVkQlFXeENha29zUlVGQllTeEhRVUZUTEVWQlF5OURMRk5CUTBVc1VVRXJRa29zVDBFelFrRldMRWRCUVUxM1JTeFpRVUZqTEZOQlFWTTVSQ3hGUVVGWlF5eEhRVVYyUXl4SFFVRkpiVW9zUjBGQlZVUXNSVUZCWjBKdVNpeEZRVUZaUXl4RlFVVXhReXhKUVVGelFpeHRRa0ZCV0cxS0xFZEJRMVFzUzBGQlRTeEpRVUZKYkVzc1QwRkJUU3cyUWtGQkswSmpMRVZCUXpORExIbENRVUV5UWtNc1JVRlBha01zUzBGQlN5eEhRVXBFZEVnc1IwRkJVM2xSTEVWQlFWRjZVU3hQUVVGVExFVkJSVEZDTUZFc1JVRkJUeXhIUVVGSmFFc3NUMEZGVGpOSExFVkJRVWtzUlVGQlIwRXNSVUZCU1VNc1JVRkJVVVFzUjBGQlN5eEZRVTB2UWl4SlFVRkxMRWRCU2tRMFRpeEhRVUZST0VNc1JVRkJXU3hGUVVGS01WRXNSVUZCVVN4SFFVTjRRbmxMTEVWQlFXRnBSeXhGUVVGWkxFVkJRVW94VVN4RlFVRlJMRWRCUXpkQ2RVc3NSVUZCV1cxSExFVkJRVmtzUlVGQlNqRlJMRVZCUVZFc1IwRkZka0paTEVWQlFVa3NSVUZCUjBFc1JVRkJTV2RPTEVWQlFVOW9UaXhIUVVGTExFVkJRemxDSzFBc1JVRkJTM3BGTEV0QlFVdHpSU3hGUVVGVkwwWXNSVUZCV1VZc1IwRkpjRU1zVDBGQlQyOUhMRWxCUjBZdlNpeExRVTlNZVVVc1JVRkJZeXhYUVVWb1FpeEhRVUZKZFVZc1IwRkJWU3hIUVVGSmFrc3NUMEZEWkd0TExFVkJRVlVzUlVGRlZtcExMRWxCYlVOS0xFOUJha05CUVN4SFFVRk5LMFFzVlVGQldTeFhRVU5vUWl4TlFVRlBhVWNzU1VGSFZHaExMRVZCUVUxRExFMUJRVkVzVTBGQlUwTXNSMEZEY2tJc1IwRkJTV2RMTEVkQlFWY3pVU3hMUVVGTFF5eE5RVUZOTUVjc1JVRkJVU3hGUVVOc1F5eFBRVUV3UkN4TFFVRm9SRGhLTEVWQlFWRkZMRXRCUVdVc1JVRkJTV2hMTEVWQlFWRXNSVUZCVHl4SlFVZDBSRVlzUlVGQlRUQkZMRWxCUVUwc1UwRkJVMmhHTEVWQlFVdHlSeXhIUVVONFFpeEpRVUZMTEVkQlFVbEVMRWRCUVVrc1JVRkJSMEVzUlVGQlNVTXNSVUZCVVVRc1IwRkJTeXhGUVVNdlFqUkhMRVZCUVUwclJTeFBRVUU0UXl4SlFVRnVRM0pHTEVsQlFWTnlSeXhGUVVGVFJDeEZRVUZKTEVWQlFVOHNTMEZKYkVRMFJ5eEZRVUZOTkVVc1owSkJRV3RDTEZkQlEzUkNMRTFCUVU5eFJpeEpRVWRVYWtzc1JVRkJUU3RGTEU5QlFWTXNVMEZCVTI5R0xFZEJSWFJDTEVkQlFVbEVMRWRCUVZjelVTeExRVUZMUXl4TlFVRk5lVkVzUlVGQlZTeEZRVU5vUTBRc1IwRkJVVE5STEZGQlFWVTJVU3hIUVVOd1FrWXNSVUZCVVRGRkxFdEJRVXNzUjBGSFdEWkZMRWxCUTBaSUxFVkJRVkZGTEVsQlFXTXNUVUZCVlVRc1JVRkJWU3hIUVVjMVEwRXNSMEZCVnl4SFFVZE9ha3NzUjBGUFRHdEdMRVZCUVZjc1UwRkJVMnBOTEVkQlJYUkNMRWRCUVVsdFVpeEhRVUZSZWtNc1JVRkJUME1zV1VGRFpubERMRVZCUVZGd1VpeEZRVVZTSzBjc1NVRkZTa0VzUjBGQlRUSkZMRkZCUVZVc1YwRkRaQ3hOUVVGUGVVWXNTVUZIVkhCTExFVkJRVTFITEZWQlFWa3NVMEZCVTJsRUxFZEJRM3BDTEUxQlFVOXBTQ3hIUVVGTmFGSXNVVUZIWmpKSExFVkJRVTAyUlN4TlFVRlJMRk5CUVZONlFpeEhRVTF5UWl4SlFVcEJMRWRCUVVsdVN5eEhRVUZQYjFJc1JVRkZVR3BTTEVWQlFVa3NSVUZGUkVFc1JVRkJTU3hGUVVGSlNDeEZRVUZMU1N4UlFVTnNRaXRLTEVWQlFVOXpRaXhKUVVGSk5FWXNSVUZCVTNKU0xFVkJRVXR6VWl4VlFVRlZibElzUlVGQlIwRXNSVUZCU1N4SlFVRk5MRWxCUTJoRVFTeEhRVUZMTEVOQlIwaEJMRWRCUVVsSUxFVkJRVXRKTEZOQlExQktMRVZCUVV0SkxFOUJRVk5FTEVkQlFVc3NSVUZEY2tKblN5eEZRVUZQYzBJc1NVRkJTVFJHTEVWQlFWTnlVaXhGUVVGTGMxSXNWVUZCVlc1U0xFVkJRVWRCTEVWQlFVa3NTVUZCVFN4SFFVTjJRMGdzUlVGQlMwa3NUMEZCVTBRc1IwRkJTeXhIUVVNMVFtZExMRVZCUVU5elFpeEpRVUZKTkVZc1JVRkJVM0pTTEVWQlFVdHpVaXhWUVVGVmJsSXNSVUZCUjBFc1JVRkJTU3hKUVVGTkxFbEJTM1JFTEVsQlFVbHJVaXhIUVVGWExGTkJRVk5vUlN4SFFVVjBRaXhKUVVGTExFZEJSRVExUnl4SFFVRk5MRVZCUTBSMFJ5eEZRVUZKTEVWQlFVZEJMRVZCUVVsclRpeEZRVUZGYWs0c1QwRkJVVVFzUjBGQlN5eEZRVU5xUTNOSExFVkJRVmtzUjBGQlRrRXNSVUZCVnpoTExFVkJRVlZzUlN4RlFVRkZiMElzVDBGQlQzUlBMRWRCUlhSRExFOUJRVTl6Unl4SlFVZE1PRXNzUlVGQldTeFRRVUZUTVZVc1IwRkRka0lzUjBGQlNTeExRVUZQUVN4SFFVRkxRU3hIUVVGTExFbEJRMjVDTEUxQlFVOUJMRWRCUVVVd1VTeFhRVUZYTEVkQlFVc3NTVUZCU1VFc1YwRkJWeXhGUVVVeFF5eE5RVUZOTEdsQ1FVRnRRakZSTEVWQlJ6TkNMRTlCUVU5clN5eEpRVTlNYlVZc1JVRkJZU3hUUVVGVGJFMHNSMEZGZUVJc1IwRkJTVzFTTEVkQlFWRjZReXhGUVVGUFJTeGxRVU5tZDBNc1JVRkJVWEJTTEVWQlJWSXJSeXhKUVVWS1FTeEhRVUZOTWtVc1VVRkJWU3hYUVVOa0xFMUJRVTk1Uml4SlFVZFVjRXNzUlVGQlRVY3NWVUZCV1N4VFFVRlRhVVFzUjBGRGVrSXNUVUZCVDJsSUxFZEJRVTFvVWl4UlFVZG1Na2NzUlVGQlRUWkZMRTFCUVZFc1UwRkJVM3BDTEVkQlRYSkNMRWxCU2tFc1IwRkJTV3RFTEVkQlFVa3JSQ3hGUVVWS2FsSXNSVUZCU1N4RlFVVkVRU3hGUVVGSkxFVkJRVWxyVGl4RlFVRkZhazRzVVVGRFppdEtMRVZCUVU5elFpeEpRVU50UWl4SFFVRjRRaXRHTEVWQlFWRnVSU3hGUVVGRmIwSXNUMEZCVDNSUExFbEJRMnBDY1ZJc1JVRkJVVzVGTEVWQlFVVnZRaXhQUVVGUGRFOHNSVUZCU1N4SlFVRk5MRWxCUXpkQ1FTeEhRVUZMTEVOQlIwaEJMRWRCUVVsclRpeEZRVUZGYWs0c1VVRkRVaXRLTEVWQlFVOXpRaXhKUVVGSkswWXNSVUZCVVc1RkxFVkJRVVZ2UWl4UFFVRlBkRThzU1VGQlRTeEhRVWwwUXl4SlFVRkpjVklzUjBGQlZTeFRRVUZUTTFVc1IwRkZja0lzUjBGQlNTeExRVUZQUVN4SFFVRkxRU3hIUVVGTExFbEJRMjVDTEUxQlFVOUJMRWRCUVVVd1VTeFhRVUZYTEVkQlFVc3NTVUZCU1VFc1YwRkJWeXhGUVVOdVF5eEpRVUZKTEV0QlFVOHhVU3hIUVVGTFFTeEhRVUZMTEVsQlF6RkNMRTFCUVU5QkxFZEJRVVV3VVN4WFFVRlhMRWRCUVVzc1NVRkJTVUVzVjBGQlZ5eEhRVUZMTEVWQlJUZERMRkZCUVZFeFVTeEhRVU5TTEVsQlFVc3NTVUZCVFN4TlFVRlBMRWRCUTJ4Q0xFdEJRVXNzU1VGQlRTeE5RVUZQTEVkQlEyeENMRXRCUVVzc1NVRkJUU3hOUVVGUExFZEJRMnhDTEV0QlFVc3NTVUZCVFN4TlFVRlBMRWRCUTJ4Q0xFdEJRVXNzU1VGQlRTeE5RVUZQTEVkQlEyeENMRXRCUVVzc1NVRkJUU3hOUVVGUExFZEJRMnhDTEV0QlFVc3NTVUZCVFN4TlFVRlBMRWRCUTJ4Q0xFdEJRVXNzU1VGQlRTeE5RVUZQTEVkQlEyeENMRXRCUVVzc1NVRkJUU3hOUVVGUExFZEJRMnhDTEZOQlEwVXNTMEZCVFN4cFFrRkJiVUpCTEVkQlN5OUNMRTlCUVU5clN5eEpRVTlNYjBZc1JVRkJZU3hUUVVGVGJrMHNSMEZGZUVJc1IwRkJTVzFTTEVkQlFWRjZReXhGUVVGUFJ5eGxRVVZtTkVNc1JVRkJVMnhNTEVWQlFVODJSeXhqUVVGamNFNHNSMEZGT1VJclJ5eEpRV2RDU2l4UFFXUkJRU3hIUVVGTk1rVXNVVUZCVlN4WFFVTmtMRTFCUVU5NVJpeEpRVWRVY0Vzc1JVRkJUVWNzVlVGQldTeFRRVUZUYVVRc1IwRkRla0lzVFVGQlQzTklMRWRCUVU5eVVpeFJRVWRvUWpKSExFVkJRVTAyUlN4TlFVRlJMRk5CUVZONlFpeEhRVU55UWl4SlFVRkxMRWRCUVVsb1N5eEhRVUZKTEVWQlFVZEJMRVZCUVVselVpeEZRVUZQY2xJc1QwRkJVVVFzUjBGQlN5eEZRVU4wUTJkTExFVkJRVTl6UWl4SlFVRkpaMGNzUlVGQlQzUlNMRWRCUVVrc1NVRkpia0kwUnl4SFFVOU1jVVlzUlVGQlZTeFRRVUZUY0Uwc1IwRkZja0lzUjBGQlNXMVNMRWRCUVZGNlF5eEZRVUZQU1N4WFFVVm1Na01zUlVGQlUyeE1MRVZCUVU4MlJ5eGpRVUZqY0U0c1NVRkZha01zVTBGQlUyNUVMRVZCUVVjMlZTeEhRVVZZTEVkQlFVbHlTaXhIUVVGUE9VSXNSVUZCVHpaSExHTkJRV04yVVN4RlFVTm9ReXhKUVVGdFFpeEhRVUZtZDB3c1JVRkJTMnBKTEZOQlFXdENhVWtzUlVGQlN5eEpRVUZOTEVWQlFVdEJMRVZCUVVzc1MwRkJUM0ZLTEVWQlEzSkVMRXRCUVUwc2RVSkJSVklzU1VGQlZTeE5RVVZhTEVsQlFVa3pTeXhMUVhkRFNpeFBRWFJEUVVFc1IwRkJUVEpGTEZGQlFWVXNWMEZEWkN4TlFVRlBlVVlzU1VGSFZIQkxMRVZCUVUxSExGVkJRVmtzVTBGQlUybEVMRWRCUTNwQ0xGTkJRVlZ6U0N4RlFVRlBjbElzVDBGQlV5eEpRVWMxUWpKSExFVkJRVTAyUlN4TlFVRlJMRk5CUVZONlFpeEhRVTF5UWl4SlFVcEJMRWRCUVVsdVN5eEhRVUZQZVZJc1JVRkZVSFJTTEVWQlFVa3NSVUZGUkVFc1JVRkJTU3hGUVVGSlNDeEZRVUZMU1N4UlFVRlJMRU5CUlRGQ0xFZEJRVWwyUkN4SlFVRlBMRWxCUVU5dFJDeEZRVUZMUnl4TFFVRlBMRVZCUVUwc1NVRkJUMGdzUlVGQlMwY3NSVUZCU1N4RlFVVndSQ3hKUVVGSkxFOUJRVlYwUkN4SFFVRkxRU3hIUVVGTExFMUJRM1JDUVN4SFFVRkxMRlZCUTBFc1RVRkJTU3hQUVVGVlFTeEhRVUZMUVN4SFFVRkxMRTlCUnpkQ0xFdEJRVTBzYjBKQlFYTkNjMFFzUlVGQlNTeEhRVUZMTEVsQlFVMTBSQ3hEUVVZelEwRXNTVUZCU3l4TlFVdFFRU3hGUVVFd1FpeExRVUZ1UWtFc1NVRkJUU3hGUVVGTExFMUJRVzlDTEVsQlFVcEJMRWRCUld4RGMwNHNSVUZCVDNOQ0xFbEJRVWsxVHl4RlFVRkhMRWxCUldSelJDeEhRVUZMTEVWQlIxQXNSMEZCU1VFc1JVRkJTVWdzUlVGQlMwa3NUMEZEV0N4TFFVRk5MRzlDUVVGelFrUXNSVUZCU1N4SlFVazNRalJITEVkQlYwdzBTeXhGUVVGM1FpeFhRVVV4UWl4SFFVRkpSaXhIUVVGVExFZEJRVWt6U3l4UFFVVmlReXhKUVRCRFNpeFBRWGhEUVVFc1IwRkJUVFpMTEZWQlFWa3NVMEZCVTNST0xFZEJRM3BDYlU0c1JVRkJUM0JHTEV0QlFWTXNTVUZCU2k5SUxFbEJSMlI1UXl4RlFVRk5PRXNzVjBGQllTeFRRVUZUTVZJc1IwRkRNVUkwUnl4RlFVRk5Oa3NzVlVGQlZYcFNMRWRCUTJoQ05FY3NSVUZCVFRaTExGVkJRVlY2VWl4SlFVRk5MRWxCUjNoQ05FY3NSVUZCVFN0TExGZEJRV0VzVTBGQlUzaE9MRVZCUVVkNVRpeEZRVUZMUXl4SFFVTnNRMFFzUlVGQlRVRXNSMEZCVHl4RlFVTmlReXhGUVVGTlFTeEhRVUZQTVU0c1JVRkJSV3hGTEUxQlEyWXNTMEZCU3l4SFFVRkpSQ3hIUVVGSkxFVkJRVWRCTEVWQlFVazJVaXhGUVVGTE4xSXNSMEZCU3l4RlFVTTFRalJITEVWQlFVMDJTeXhWUVVGVmRFNHNSVUZCUlc1RkxFVkJRVWswVWl4TFFVa3hRbWhNTEVWQlFVMXJUQ3haUVVGakxGTkJRVk0xUlN4SFFVTXpRaXhKUVVGTExFZEJRVWxzVGl4SFFVRkpMRVZCUVVkQkxFVkJRVWxyVGl4RlFVRkZhazRzVDBGQlVVUXNSMEZCU3l4RlFVTnFRelJITEVWQlFVMDJTeXhWUVVGVmRrVXNSVUZCUlVVc1YwRkJWM0JPTEV0QlNXcERORWNzUlVGQlRXMU1MRmxCUVdNc1YwRkRiRUlzVFVGQlQxUXNTVUZIVkRGTExFVkJRVTFtTEZOQlFWY3NWMEZEWml4SFFVRkpjVWdzUjBGQlNTeEZRVU5TUVN4SlFVRkxMRWRCUTB3c1MwRkJTeXhIUVVGSmJFNHNSMEZCU1N4RlFVRkhRU3hGUVVGSmMxSXNSVUZCVDNKU0xFOUJRVkZFTEVkQlFVc3NSVUZEYkVOQkxFVkJRVWtzU1VGRFRtdE9MRWRCUVVzc1MwRkZVRUVzUjBGQlMyOUZMRVZCUVU5MFVpeEZRVWRrTEU5QlJFRnJUaXhKUVVGTExFdEJTVUYwUnl4SFFVOU1iMHdzUlVGQk1rSXNWMEZGTjBJc1IwRkJTWEJDTEVkQlFWVXNSVUZEVm5GQ0xFVkJRVlVzUlVGRFZuQkNMRVZCUVZVc1JVRkRWbkZDTEVWQlFWVXNSMEZGVm5STUxFdEJSVUYxVEN4RlFVRmxMRk5CUVZOb1R5eEhRVU14UWl0T0xFZEJRVmRvUlN4UFFVRlBReXhoUVVGaGFVVXNSVUZCVnl4SFFVRkthazhzUzBGSGNFTnBUeXhGUVVGVExGTkJRVk01UWl4SFFVTndRaXhIUVVGSlFTeEZRVUZKTEU5QlJVUXNTVUZCU1VFc1JVRkJTU3hIUVVOaUxFMUJRVThzU1VGQlQwRXNRMEZEVkN4SlFVRkpRU3hGUVVGSkxFZEJRMklzVFVGQlR5eExRVUZSUVN4RlFVRkpMRWRCUTJRc1NVRkJTVUVzUlVGQlNTeEhRVU5pTEUxQlFVOHNTMEZCVVVFc1JVRkJTU3hIUVVOa0xFbEJRVk1zU1VGQlRFRXNSVUZEVkN4TlFVRlBMRWRCUTBZc1NVRkJVeXhKUVVGTVFTeEZRVU5VTEUxQlFVOHNTVUZGVkN4TFFVRk5MRWxCUVVrNVNpeFBRVUZOTEV0QlFVODRTaXhIUVc5RGVrSXNUMEZxUTBFeFNpeEhRVUZOTmtzc1ZVRkJXU3hUUVVGVGJrSXNSMEZOZWtJc1NVRktRVTBzUlVGQlYwRXNSMEZCVnl4RlFVRlZMRWxCUVVwT0xFVkJRelZDTWtJc1IwRkJWeXhGUVVOWWNFSXNSMEZCVnl4RlFVVktiMElzUjBGQlZ5eEhRVU5vUWtVc1JVRkJZWFpDTEVsQlFXRnhRaXhGUVVGVkxFZEJRM0JEUVN4SFFVRlhMRWRCU1daeVRDeEZRVUZOZVV3c1RVRkJVU3hYUVZGYUxFZEJUa2xLTEVWQlFWVXNTVUZEV2tVc1JVRkJZWFpDTEVkQlFWa3NSVUZCU1hGQ0xFZEJRemRDY2tJc1JVRkJWU3hGUVVOV2NVSXNSVUZCVlN4SFFVZFNjRUlzUlVGQlZTeEhRVUZMTEVWQlIycENMRWxCUVVzc1IwRkVSSGxDTEVkQlFWTXNSVUZCU1hwQ0xFVkJRVlVzUlVGRGJFSTNVU3hGUVVGSkxFVkJRVWRCTEVWQlFVbHpVeXhGUVVGUmRGTXNSMEZCU3l4RlFVTXZRbXRUTEVkQlFWY3NTMEZMYWtKMFRDeEZRVUZOWml4VFFVRlhMRmRCUTJZc1RVRkJUM0ZOTEVsQlIwWjBUQ3hIUVU5TU9FY3NSVUZCTUVJc1UwRkJVelpGTEVkQlJYSkRMRWRCUVVsRExFZEJRVTlFTEVWQlExQkZMRVZCUVU4c1JVRkRVRGRDTEVWQlFWVXNSVUZEVm5GQ0xFVkJRVlVzUlVGRlZuSk1MRWxCUlVwQkxFZEJRVTByUnl4TFFVRlBMRmRCUlZnc1MwRkJUM05GTEVWQlFWVXNSMEZCUnl4RFFVVnNRaXhIUVVGSlVTeEhRVUZSUkN4RlFVRkxkbE1zVDBGQlVTeERRVU4yUWl4SFFVRmxMRWRCUVZoblV5eEZRVU5HTEU5QlFVOHNRMEZGVkN4TlFVRk5MRWxCUVVsNlRDeFBRVUZOTERKQ1FVRTJRbmxNTEVkQlJ5OURMRWRCUVVsMlZpeEhRVUZKT0ZZc1JVRkJTMnhGTEU5QlFVOXRSU3hGUVVkd1FpeEpRVVpCUVN4SFFVRlJMRVZCUlVNc1MwRkJUQzlXTEVWQlJVWXNUVUZFUVhWV0xFZEJRVlVzUjBGRFNDeERRVU5GZGxZc1IwRkJSV2RYTEUxQlFVMHNWVUZMYmtJNVFpeEZRVUZYUVN4SFFVRlhMRVZCUVVzclFpeEZRVUZQYWxjc1JVRkJSVEJSTEZkQlFWY3NTVUZETDBNMlJTeEhRVUZYTEVkQlIySXNSMEZCU1ROQ0xFZEJRVXROTEVsQlFXRnhRaXhGUVVGVkxFVkJRVThzUjBGRmRrTXNUMEZFUVVFc1NVRkJWeXhGUVVOS00wSXNSVUZIVkN4SlFVRkpjVU1zUjBGQlV5eFRRVUZUYWxjc1IwRkRjRUlzUjBGQlNTeEpRVUZSUVN4SFFVRkxRU3hIUVVGTExFZEJRM0JDTEUxQlFVOUJMRWRCUVVrc1JVRkRUaXhKUVVGSkxFbEJRVkZCTEVkQlFVdEJMRWRCUVVzc1NVRkRNMElzVFVGQlQwRXNSMEZCU1N4SFFVRlBMRVZCUTJJc1NVRkJTU3hKUVVGUlFTeEhRVUZMUVN4SFFVRkxMRWRCUXpOQ0xFMUJRVTlCTEVkQlFVa3NSMEZCVHl4RlFVTmlMRWxCUVZNc1NVRkJURUVzUlVGRFZDeE5RVUZQTEVkQlEwWXNTVUZCVXl4SlFVRk1RU3hGUVVOVUxFMUJRVThzUjBGRlVDeE5RVUZOTEVsQlFVazRTaXhQUVVGTkxFdEJRVTg1U2l4SFFVa3pRaXhQUVVGUGEwc3NTVUZQVEdkTkxFVkJRVmNzVTBGQlUzcFVMRVZCUVU5RExFZEJSVGRDTEVkQlFVbDVWQ3hIUVVGVE1WUXNSVUZEVkRKVUxFVkJRVlV4VkN4RlFVTldObElzUlVGQlVTeEhRVUZKZEVzc1QwRkJUWGhJTEVWQlFWRkRMRWRCUlRGQ2QwZ3NTVUZGU2tFc1IwRkJUVzFOTEZOQlFWY3NVMEZCVXpkVExFVkJRVWRITEVWQlFVY3lVeXhIUVVNNVFpOUNMRVZCUVUwMVVTeEZRVUZKZDFNc1JVRkJVek5UTEVkQlFVczRVeXhIUVVjeFFuQk5MRVZCUVUwMlJTeE5RVUZSTEZOQlFWTnlTU3hIUVV0eVFrRXNSVUZCU1RCUExGbEJRVmtzVlVGTGFFSXhUeXhGUVVGSmMwOHNWMEZCVjIxQ0xFZEJRMlo2VUN4RlFVRkpjMDhzVjBGQlYyOUNMRWRCUldZeFVDeEZRVUZKY1U4c1ZVRkJWU3hMUVVOa2NrOHNSVUZCU1hGUExGVkJRVlVzUjBGRFpISlBMRVZCUVVseFR5eFZRVUZWTEVkQlRXUnlUeXhGUVVGSmNVOHNWVUZCVlN4SFFVTmtjazhzUlVGQlNYRlBMRlZCUVZVc1IwRkRaSEpQTEVWQlFVbHhUeXhWUVVGVkxFZEJSMlJ5VHl4RlFVRkpjVThzVlVGQlZTeExRVU5rY2s4c1JVRkJTWEZQTEZWQlFWVXNTMEZEWkhKUExFVkJRVWx4VHl4VlFVRlZMRXRCUzJSeVR5eEZRVUZKTUU4c1dVRkJXU3hMUVVOb1FqRlBMRVZCUVVselR5eFhRVUZYTEVkQlEyWjBUeXhGUVVGSmMwOHNWMEZCVnl4SFFVTm1kRThzUlVGQlNYTlBMRmRCUVZkdFFpeEhRVU5tZWxBc1JVRkJTWE5QTEZkQlFWZHZRaXhIUVVObU1WQXNSVUZCU1hGUExGVkJRVlVzUlVGUlpDeEpRVUZKZDBJc1IwRkJhVUlzUlVGRGFrSkRMRVZCUVZORExFVkJRV0ZHTEVWQlJURkNOMUFzUjBGQlNYRlBMRlZCUVZWM1FpeEZRVWxrTEV0QlJrRXNSMEZCU1haTkxFZEJRVk1zUlVGRlRuZE5MRVZCUVU5cVZDeFBRVUZUZVVjc1JVRkJVeXhMUVVNNVFuUkVMRVZCUVVseFR5eFZRVUZWTEV0QlEyUnlUeXhGUVVGSmRVOHNWMEZCVjNWQ0xFVkJRVkY0VFN4RlFVRlJMRXRCUXk5Q1FTeEhRVUZWTEVkQlIxcDBSQ3hIUVVGSmNVOHNWVUZCVlhsQ0xFVkJRVTlxVkN4UFFVRlRlVWNzUjBGRE9VSjBSQ3hGUVVGSmRVOHNWMEZCVjNWQ0xFVkJRVkY0VFN4RlFVRlJkMDBzUlVGQlQycFVMRTlCUVZONVJ5eEhRVU12UTNSRUxFVkJRVWx4VHl4VlFVRlZMRWRCU1dSeVR5eEZRVUZKTUU4c1dVRkJXU3hMUVVkc1FpeEpRVUZKYzBJc1IwRkJhMElzVTBGQlUyaFJMRWRCUlRkQ0xFZEJRVWxwVVN4SFFVRlBhbEVzUlVGRFVHdFJMRVZCUVdFc1JVRkRZa01zUlVGQllTeEZRVVZpTTAwc1NVRXdRa29zVDBGNFFrRkJMRWRCUVUwMlJTeE5RVUZSTEZOQlFWTTFUQ3hGUVVGTlNTeEhRVVV6UWl4SFFVRk5TaXhKUVVGVFNTeEhRVUZYTEVWQlEzaENMRXRCUVUwc1NVRkJTWFZITEU5QlFVMHNZMEZIYkVJc1RVRkJUemhOTEVWQlFXRnlWQ3hIUVVGVkxFZEJRelZDYjFRc1JVRkJTelZDTEZWQlFWVXNTMEZCVlRWU0xFZEJRVkY1VkN4RlFVRmpReXhKUVVNdlEzUlVMRWRCUVZjc1JVRkJTWEZVTEVWQlEyWjZWQ3hMUVVGWExFVkJRVWw1VkN4RlFVTm1ReXhGUVVGaExFVkJRMkpFTEVWQlFXRXNRMEZIWmtNc1NVRkJZekZVTEVkQlFWRjVWQ3hGUVVOMFFrRXNSMEZCTUVKeVZDeEhRVWMxUWpKSExFVkJRVTE1VEN4TlFVRlJMRmRCUTFKcFFpeEZRVUZoTEVkQlEyWkVMRVZCUVVzMVFpeFZRVUZWT0VJc1NVRkpXak5OTEVkQlIweDFUU3hGUVVGbExGTkJRVk5HTEVkQlV6RkNMRWxCUVVzc1IwRlFSRThzUjBGQldTeEhRVUZMVUN4RlFVTnFRbEVzUjBGQlZ5eEhRVUZMVWl4SFFVRnJRaXhGUVVOc1ExTXNSVUZCV1ZRc1JVRkJhVUlzUlVGSE4wSlZMRVZCUVZGRExFbEJSVWcxVkN4RlFVRkpMRVZCUVVkQkxFVkJRVWwzVkN4RlFVRlhlRlFzUjBGQlN5eEZRVU5zUXpKVUxFVkJRVTFGTEVsQlFVa3pSaXhQUVVGUFF5eGhRVUZoYms4c1IwRkZhRU15VkN4SFFVRk5SU3hKUVVGSk0wWXNUMEZCVDBNc1lVRkJZWEZHTEVsQlF6bENSeXhGUVVGTlJTeEpRVUZKTTBZc1QwRkJUME1zWVVGQllYTkdMRWRCUlRsQ0xFbEJRVWxMTEVkQlFWVjBReXhKUVVOV2RVTXNSVUZCVTFnc1JVRkJaMEpWTEVWQlJ6ZENReXhIUVVGUGRFa3NUVUZCVFN0SUxFVkJRVmRGTEVWQlJYaENMRWxCUVVsTkxFZEJRVmtzUlVGRldqbEhMRVZCUVVsblFpeFBRVUZQUXl4aFFVRmhPRU1zUlVGQlRTdERMRWRCUjJ4RExFdEJSa0ZCTEVkQlFXRXNSVUZGVGtFc1JVRkJXUzlETEVWQlFVMW9VaXhSUVVGUkxFTkJSUzlDTEVkQlFVbDJSQ3hIUVVGSmQxSXNUMEZCVDBNc1lVRkJZVGhETEVWQlFVMHJReXhIUVVOc1EwRXNTVUZCWVN4RlFVVlVUQ3hGUVVGTlRTeFRRVUZUTDBjc1JVRkJTWGhSTEVkQlJYSkNkMUVzUjBGQlVYaFJMRWRCU1ZKeFdDeEZRVUZQZEVrc1RVRkJUV3RKTEVWQlFVMVBMRkZCUVZGb1NDeEhRVUZKZDBjc1IwRkZNMEpETEVWQlFVMDVSeXhQUVVGVExFOUJSV0k0Unl4RlFVRk5PVWNzVVVGQlZ5eEhRVUZMTmtjc1NVRkRlRUpCTEVkQlFXRXNSMEZIWmtNc1JVRkJUVVVzU1VGQlNUTkhMRVZCUVVsNFVTeEpRVWRvUW5kUkxFVkJRVWw0VVN4SFFWZFNMRTFCVUVGeFdDeEhRVUZQZEVrc1RVRkJUV3RKTEVWQlFVMVBMRkZCUVZGb1NDeEhRVUZKZDBjc1IwRkhMMEpMTEVWQlFVOTBTU3hOUVVGTlowa3NSVUZCVTBNc1IwRkZkRUpMTEVWQlFVOHhRaXhSUVVWQmVVSXNSVUZCVVM5Q0xHVkJSMkkyUWl4RlFVRlhMRmRCUldJc1IwRkJTVThzVFVGRFFVTXNSVUZCVVN4RlFVVlNlRTRzU1VGelFrb3NUMEZ3UWtGQkxFZEJRVTFwVGl4SlFVRk5MRk5CUVZNM1ZpeEhRVU51UWl4SFFVRkpORWtzUlVGQlRYRk9MRk5CUVZOcVZ5eEhRVU5xUWl4TFFVRk5MRWxCUVVsM1NTeFBRVUZOTEZkQlFXRjRTU3hGUVVVdlFtMVhMRWRCUVV0dVZ5eEhRVUZQYjFjc1JVRkRXa0VzUjBGQlV5eEhRVWRZZUU0c1JVRkJUV2xITEV0QlFVOHNWMEZEV0N4TlFVRlBkVWdzU1VGSFZIaE9MRVZCUVUxelRpeFJRVUZWTEZOQlFWTnNWeXhIUVVOMlFpeE5RVUZQYlZjc1IwRkJTMjVYTEVsQlIyUTBTU3hGUVVGTmNVNHNVMEZCVnl4VFFVRlRhbGNzUjBGRGVFSXNUVUZCTWtJc2JVSkJRV0p0Vnl4SFFVRkxibGNzU1VGSFpEUkpMRVZCUjFRc1QwRkJUMEVzU1VGSFRHMUhMRVZCUVdVc1UwRkJVelZPTEVWQlFVOURMRVZCUVZGcFZpeEZRVUZWUXl4SFFVZHVSQ3hKUVVGTExFZEJSRVJETEVkQlFVMHpRaXhGUVVGVGVsUXNSVUZCVDBNc1IwRkRha0pwUWl4RlFVRkpMRVZCUVVkQkxFVkJRVWxxUWl4RlFVRlJhVUlzUjBGQlN5eEZRVU12UWl4SlFVRkxMRWRCUVVsSUxFZEJRVWtzUlVGQlIwRXNSVUZCU1dZc1JVRkJUMlVzUjBGQlN5eEZRVU01UW5GVkxFVkJRVWw0UWl4VFFVRlROMU1zUlVGQlIwY3NSVUZCUjJkVkxFVkJRVk51VlN4RlFVRkhSeXhIUVVsdVF5eEpRVUZKT0VRc1IwRkJTWEZPTEVkQlExSXJReXhIUVVGSk9Va3NUVUZCVFhSSUxFVkJTVllzUzBGQlN5eEhRVVpFY1ZFc1IwRkJVM2hETEVsQlExUTNSU3hGUVVGUmFFb3NSVUZCUlRST0xHTkJRMHd2VWl4RlFVRkpMRVZCUVVkQkxFVkJRVWx0VGl4RlFVRk5iRTRzVDBGQlVVUXNSMEZCU3l4RlFVTnlRM2RWTEVWQlFVOHZReXhWUVVGVmRFVXNSVUZCVFc1T0xFZEJSWHBDZDFVc1IwRkJUMjVETEU5QlJWQXNTVUZCU1c5RExFZEJRVTBzUlVGdFFsWXNUMEZzUWtGQkxFbEJRVThzVDBGRFVFRXNSMEZCVHl4VFFVTlFRU3hIUVVGUExIbENRVU5RUVN4SFFVRlBSQ3hGUVVOUVF5eEhRVUZQTEVsQlExQkJMRWRCUVU4c1YwRkRVRUVzUjBGQlQzUldMRVZCUTFCelZpeEhRVUZQTEVsQlExQkJMRWRCUVU4c1dVRkRVRUVzUjBGQlQzSldMRVZCUTFCeFZpeEhRVUZQTEVsQlEwaElMRWxCUTBaSExFZEJRVThzVTBGRFVFRXNSMEZCVDBnc1JVRkRVRWNzUjBGQlR5eExRVVZVUVN4SFFVRlBMRTFCUzB3dlZpeEZRVUZyUWl4VFFVRlRVeXhGUVVGUFF5eEZRVUZSYVZZc1IwRkhOVU1zU1VGQlN5eEhRVVJFUlN4SFFVRk5NMElzUlVGQlUzcFVMRVZCUVU5RExFZEJRMnBDYVVJc1JVRkJTU3hGUVVGSFFTeEZRVUZKYWtJc1JVRkJVV2xDTEVkQlFVc3NSVUZETDBJc1NVRkJTeXhIUVVGSlNDeEhRVUZKTEVWQlFVZEJMRVZCUVVsbUxFVkJRVTlsTEVkQlFVc3NSVUZET1VKeFZTeEZRVUZKZUVJc1UwRkJVemRUTEVWQlFVZEhMRVZCUVVkblZTeEZRVUZUYmxVc1JVRkJSMGNzUjBGSmJrTXNTVUZCU1RoRUxFZEJRVWx4VGl4SFFVTlNLME1zUjBGQlNUbEpMRTFCUVUxMFNDeEZRVWxXTEV0QlFVc3NSMEZHUkhGUkxFZEJRVk40UXl4SlFVTlVOMFVzUlVGQlVXaEtMRVZCUVVVMFRpeGpRVU5NTDFJc1JVRkJTU3hGUVVGSFFTeEZRVUZKYlU0c1JVRkJUV3hPTEU5QlFWRkVMRWRCUVVzc1JVRkRja04zVlN4RlFVRlBMME1zVlVGQlZYUkZMRVZCUVUxdVRpeEhRVVY2UW5kVkxFZEJRVTl1UXl4UFFVVlFMRWxCUVVsdlF5eEhRVUZOTEVkQlFVa3pWaXhOUVV0a0xFOUJTa0V5Vml4SFFVRkpNVllzU1VGQlRTeDVRa0ZCTWtKNVZpeEZRVU55UTBNc1JVRkJTWFJXTEUxQlFWRkJMRVZCUTFwelZpeEZRVUZKY2xZc1QwRkJVMEVzUlVGRlRuRldMRVZCVFZRc1VVRkRSVzVYTEU5QlFWRTRTQ3hGUVVOU01VWXNUMEZCVVVFc1VVRkpXQ3hUUVVGVk9VVXNSMEZGVEhGTExFdEJRVUZFTEVWQlFVRXNSVUZCUVVVc1JVRkJRU3hyUWtGQlFVWXNTMEZCUVROQ0xFMUJRVUY0U1N4RlFVRkJiMHNzUjBGQlFVUXNTVUZCUVdoRExGTkJRVUZyUXl4SlFVRkJjRXNzUlVGQlFVUXNVVUZCUVhGTExFdEJTVW9zVjBGRFJTeFBRVU5GTlVnc1QwRkJVVGhJTEVWQlFVODVTQ3hQUVVObWIwTXNUMEZCVVRCR0xFVkJRVTh4Uml4WGRrSjNSbVlzVTBGQlV6VkZMRVZCUVZGRUxFVkJRVk5OTEVkM1FuSndSV2hETEZsQlkwRXNVMEZCUVZNc1IwRkJRVU1zUjBGQmMwTXNUVUZCUVVFc1RVRkJRVU1zVjBGQlFVUXNSMEZCZFVORkxGRkJRVUZHTEVkQldqZEZhRUlzUlVGQlFXbENMRmxCUVVFc1EwRkZRU3hKUVVGQk5GZ3NSMEZCUVhaWkxFVkJRVUVzU1VGRlFYZFpMRVZCUVVFdldDeEZRVUZCT0Znc1IwRkZRVVVzUlVGQlFYcFpMRVZCUVVFc1NVRkZRVEJaTEVWQlFVRnFXU3hGUVVGQloxa3NSMEZGUVVVc1JVRkJRU3hyUWtGQlFVUXNSMEZCUVRsWUxGTkJRVUVzWjBKQlFVRTBXQ3hIUVVGQk5WZ3NVVUZCUVN4VFFVRkJSaXhIUVVGcFNDeGhRVUZCUVN4SlFVRnhRaXhUUVVGQlFTeEhRVUZ0UWl4TlFVRkJRU3hKUVVGQkxHdENRVUZCWjFrc1IwRkJRVGxZTEZOQlFVRkdMRVZCUVVGcldTeGpRVUZCUml4RlFVRkJPVmdzVTBGQlFVWXNTVUZCUVdkWkxFVkJRVUU1V0N4UlFVRkJiMFlzVlVGQlFTeGxRVUZCZEVZc1IwRkpla3BvUWl4SFFVRkJhMElzVVVGQlFTeHJRa0ZCUVRoWUxFZEJRVUU1V0N4VFFVRkJMRmRCUVVFcldDeEZRVUZCU0N4RlFVRkJOVmdzVTBGQlFTeFRRVUZCUml4SFFVTkJMSGxDUVVGQlFTeEhRVUZCTEZsQlFVRnBXU3hGUVVGQmFsa3NTVUZEUXl4VFFVRkJRU3hIUVVORUxFMUJRVUZCTEVsQlFVRXNhMEpCUVVGbldTeEhRVUZCT1Znc1UwRkJRVVlzUlVGQlFXdFpMR05CUVVGR0xFVkJRVUU1V0N4VFFVRkJSaXhKUVVGQloxa3NSVUZCUVRsWUxGRkJRVUZ2Uml4VlFVRkJMRFJDUVVGQmRFWXNSMEZCUVN4WlFVRkJhVmtzUlVGQlFXcFpMRXQ0UWpSd1JVMHNVMEZCVTJZc1JVRkJVVVFzUlVGQlUwMHNSM2xDTDNGRmFFTk1MRVZCUVVGRUxGTkJRV3RDYTBJc1VVRkJRVm9zUlVGQlFTeEpRVUZCVnl4WlFVRkJMRWw2UW5GeVJWb3NVMEZCVTJoQ0xFVkJRVkZFTEVWQlFWTk5MRWN3UW5KeVJXaERRU3hGUVVGQkxFbEJRMEZCTEVWQlFVRXNTVUZEUVV3c1JVRkJRVVFzVVVGQlFVMHNSVUZCUVN4SlFVRkJkVWNzUlVGQlFTeGhNVUl5Y2tWTkxGTkJRVk0xUnl4RlFVRlJSQ3hGUVVGVFRTeEhNa0kzY2tWb1F5eFpRVU5CTEVsQlFVRTJXU3hIUVVGQk4xa3NSVUZCUVN4UFFVZEJRU3hIUVVGQkxFbEJRVUVyVWl4UFFVRkJMR3RDUVVGQkswY3NSMEZEUVdoYUxFdEJRVUZwV2l4SFFVRkJhRWdzVDBGQlFTdEhMRWRCUTBGb1dpeExRVUZCYTFvc1IwRkJRU3hIUVVWRExGZEJRMFFzUjBGRlFVTXNSMEZHUVRsUUxFVkJRVUZ5U2l4TFFVRkJhVm9zUjBGRFFYQlBMRVZCUVVFM1N5eExRVUZCYTFvc1JVRkZRU3hQUVVGQmNrOHNTVUZCUVhoQ0xFVkJRVUZ5Uml4UlFVRXJRaTlETEUxQlFVRTRSeXhQUVVGQmNWSXNUVUZCUVN4SlFVTXZRa1FzUlVGQlFVb3NSVUZCUVRGUUxFVkJRVUYzUWl4SFFVTkJOMHNzUzBGQlFXdGFMRWxCUVVGRExFVkJRVUZ1Vml4UlFVTlZMME1zVFVGQlFXdFpMRVZCUVVGRExFMUJRVUVzVHpOQ2IzTkZTaXhUUVVGVGRsb3NSVUZCVVVRc1JVRkJVMDBzUnpSQ2JuUkZhRU1zUjBGQlFXMWFMRWRCUVVGdVdpeEZRVUZCTEVsQlEwRnZXaXhGUVVGQmNGb3NSVUZCUVN4SFFVZEJUQ3hIUVVGQlJDeFJRVUZCTEZOQlFVRXlXaXhIUVVOQkxHZENRVUZCZWxFc1JVRkJRWEZGTEVkQlEwRXNSMEZIUVd4R0xFZEJRVUZETEVWQlNFRXJTU3hGUVVGQlowSXNUMEZCUVhGSUxFVkJRVUY0VVN4SlFVTkJMMFVzUlVGQlFYTldMRVZCUVVGc1RTeEhRVU5CY1Uwc1JVRkJRWFpKTEVWQlFVRnFUaXhOUVVWQkxFOUJRVUZFTEVkQlFVRXNSMEZCUVVFc1IwRkJRWGxXTEVWQlFVRkVMRVZCUVVFc1IwRkJRWGhTTEZGQlEwRkZMRVZCUVVGblNpeEZRVUZCUlN4WFFVRkJjRTRzUjBGRFFXdEZMRVZCUVVFc1QwRkJRVUVzUlVGQlFTeFBRVUZCYkVVc1JVRkJRU3hKUVVGQmVWWXNTVUZCUVhSU0xFVkJRVUVyU1N4RlFVRkJSU3hYUVVGQmNFNHNSVUZCUVN4WFFVRkJiVVVzUlVGQlFTeE5RVU5CY1ZJc1JVRkJRWFJKTEVWQlFVRnZRaXhQUVVGQmRFOHNSMEZCUVd0RkxFVkJRMEZ6VWl4RlFVRkJkRWtzUlVGQlFYZEpMRTFCUVVFeFZpeEpRVUZCTEVsQlFVRnJSU3hGUVVGQkxGbEJRVUZETEVWQlFVRXNhVUkxUWpKMFJVMHNVMEZCVTNKSkxFVkJRVkZFTEVjMlFuaDFSWFpDTEVkQlFVRTRXaXhIUVVGQmVGWXNTMEZCUVhkV0xFdEJRMEYyVml4RlFVRkJSQ3hMUVVGQlF5eExRVU5CZEVVc1IwRkJRVVFzVVVGQlFTeFRRVUZCZDBjc1IwRkRRU3hOUVVGQmRWUXNUMEZCUVhaVUxFMUJRVUVzUjBGQlFVRXNSVUZCUVN4RlFVRkJha01zUlVGQlFYVldMRWRCUVVGMFZDeExOMEpuZGtWTkxGTkJRVk4yUnl4RlFVRlJSQ3hIT0VKdWRrVjJRa01zUlVGQlFVUXNVVUZCUVN4VFFVRkJkMGNzUjBGRFFTeEhRVUZCTWtJc1VVRkJRVE5DTEVWQlFVRXNTMEZCUVhwRkxGZEJRVUVzZVVKQlFVRjVSU3hGUVVOQkxFOUJRVUZCTEVzNVFqSjJSVTBzVTBGQlUzWkhMRVZCUVZGRUxFVkJRVk5OTEVjclFqbDJSV2hETEZsQlEwRXNTVUZCUVRCYUxFZEJRVUV4V2l4RlFVRkJMRWxCUTBGdlJ5eEZRVUZCY0Vjc1JVRkJRU3hIUVVOQk1sb3NSVUZCUVROYUxFVkJRVUVzU1VGRFFUSkhMRVZCUVVFelJ5eEZRVUZCTEVsQlEwRTBXaXhGUVVGQk5Wb3NSVUZCUVN4SlFVTkJObG9zUlVGQlFUZGFMRVZCUVVFc1NVRkRRVGhhTEVWQlFVRTVXaXhGUVVGQkxFbEJRMEVyV2l4RlFVRkJMMW9zUlVGQlFTeEpRVU5CWjJFc1JVRkJRV2hoTEVWQlFVRXNTVUZEUVdsaExFVkJRVUZxWVN4RlFVRkJMR2RDUVVOQmEyRXNUMEZCUVVNc1RVRkJRU3hYUVVGQlFTeFJRVU5CUXl4RlFVRkJMR0ZCUTBGRExFVkJRVUVzVDBGRFFVTXNSVUZCUVN4VFFVVkJReXhGUVVGQkxGZEJRVFJDTEUxQlFVRjZZU3hOUVVVMVFrZ3NSMEZCUVVRc1VVRkJRU3hUUVVGQk9HRXNSVUZCUVVNc1JVRkJRWEpXTEVWQlFVRnpWaXhGUVVGQlF5eEZRVUZCUXl4RlFVRkJReXhIUVVOQlppeEZRVUZCTVZVc1JVRkJRWEZXTEVWQlFVRkRMRVZCUTBFc1NVRmxRVWtzUjBGQlFXcGFMRVZCUVVGcldpeEZRV1pCUXl4RlFVRkJMRk5CUVVGRExFZEJRMEVzU1VGQlFXWXNSMEZCUVdVc1NVRkJRVU1zUjBGQlFTeE5RVUZCUVN4SFFVRkJSQ3hGUVVOQkxGRkJRVUZCTEVkQlEwRXNTVUZCUVZvc1IwRkJRU3hyUWtGQmQwTXNWVUZCUVdwV0xFZEJRVUYwUml4TFFVRkJiV0lzUjBGRGVFTXNTMEZCUVZnc1IwRkJRU3hyUWtGQk5FTXNWVUZCUVd4V0xFZEJRVUYwUml4TFFVRkJiV0lzU1VGRGRrTXNhMEpCUVRKQ0xGVkJRVUUzVml4SFFVRkJkRVlzUzBGQlFXMWlMRXRCUldoRFJTeEZRVUZCVml4RlFVRkJMRmxCUTBGWExFVkJRVUZVTEVkQlFVRk1MRVZCUTBGbExFZEJRVUVzUlVGRFFVZ3NSVUZCUVZZc1JVRkJRWGhWTEZWQlEwRnpWaXhGUVVGQlNpeEZRVUZCYWtJc1NVRkJRV2xDTEVWQlFVRmtMRWxCUVVGUExFZEJRVUZQTEVWQlFVRlFMRWRCUTBGWkxFVkJRVUZFTEVkQlFVRk9MRVZCUVVGTUxFZEJRMEZoTEVWQlFVRmlMRVZCUVVGVExFVkJRVUZLTEVWQlFVRXNWMEZCUVU4c1JVRkJRVEZVTEU5QlEwRTBWQ3hGUVVGQkxGTkJRVUZvUWl4RlFVRkJVeXhGUVVGQlVTeFRRVUZCU2l4SFFYZENRU3hKUVhKQ1FVY3NTVUZEUVZZc1JVRkJRV1lzUlVGQlFYbENMRVZCUVVGd1lpeExRVUZCTEVkQlFVRnRZU3hMUVVOQlR5eEpRVUZCYkdFc1QwRkJRVzFHTEZsQlJVRXJWQ3hGUVVGQlowSXNSVUZCUVVrc1IwRkJRU3hIUVVWQmVrSXNSMEZCUVVVc1JVRkJRVzFDTEVWQlFVRmtMRWxCUVVGMFZDeEZRVUZCYjFVc1JVRkJRV1FzUlVGQlFVMHNTMEZKUVdFc1IwRkJRVVVzUzBGQlFYaFZMRTlCUVVGM1ZDeEpRVU5CWlN4SFFVRkJMRVZCUTBGRkxFVkJRVUVzVjBGQmFVTXNUVUZCUVVRc1IwRkJRV3BpTEV0QlFVRlFMRkZCUjJwRE5Gb3NTVUZCUVcxQ0xFbEJRVUZZTEVsQlFVRnRRaXhIUVVGQlNDeEZRVUZCYWtJc1NVRkRRWFJVTEVWQlFVRjFWU3hGUVVGQmFrSXNSVUZCUVhOQ0xFZEJSMEV4UWl4RlFVRkJXU3hIUVVGQll5eEZRVU5CTVVJc1JVRkJRWE5DTEVkQlFVRmFMRVZCUTBGSkxFVkJUVUVzUjBGTVFVY3NSMEZEUVdFc1QwRkJRVkFzUlVGQlFVY3NSVUZCUVZBc1JVRkJRVllzUjBGRFFVZ3NTMEZCUVZNc1JVRkJRVmNzUlVGQlFWQXNSVUZCUVZnc1IwRkRRWEZDTEZGQlFVRkdMRWRCUlVGWUxFVkJRVUVzU1VGQlFXaGFMRWxCUVVGcFdpeEhRVU5CYWxvc1NVRkJRWEZhTEVsQlFVRjJRaXhGUVVGQmRVSXNSVUZCUVhKYUxFVkJRVUZwV2l4RlFVRkJhbG9zVVVGRFMzVkZMRXRCUVVGdFFpeEZRVUZCYmtJc1JVRkJRVVVzUjBGQlFUUlVMRWRCUVVGdFFpeEhRVUZCV2l4RlFVRkJTeXhGUVVWTUxFOUJRVUZCTEVzdlFuRjNSVTBzVTBGQlUyNWlMRVZCUVZGRUxFZG5RM293UlhaQ1F5eEZRVUZCUkN4VFFVRkJMRWRvUXlzd1JVMHNVMEZCVTBNc1JVRkJVVVFzUlVGQlUwMHNSMmxETHpCRmFFTk1MRVZCUVVGRUxGRkJRVUZOTEVWQlFVRXNTMnBEY1RGRlRTeFRRVUZUVEN4RlFVRlJSQ3hIYTBOeU1VVjJRaXhIUVVGQmEyTXNUVUZCZFVKQkxHTkJRM1pDYW1Nc1IwRkJRVVFzVVVGQlFTeFRRVUZCZDBjc1JVRkJRWEpGTEVkQlEwRXNUVUZCUVN0YUxFZEJRVUYyWWl4TFFVRkJOa1lzUlVGQlFYSkZMRXRzUXpReFJVMHNVMEZCVTJ4RExFVkJRVkZFTEVkdFF6a3hSWFpDUXl4RlFVRkJSQ3haYmtOdk1rVk5MRk5CUVZORExFVkJRVkZFTEVWQlFWTk5MRWR2UTNBeVJXaERMRmxCUTBFc1NVRkJRVFppTEVkQlFVRTNZaXhGUVVGQkxFbEJRMEV3Uml4RlFVRkJNVVlzUlVGQlFTeEpRVU5CSzFvc1JVRkJRUzlhTEVWQlFVRXNTVUZEUVN0aExFbEJSMEV2WVN4SFFVRkJMRWxCUVVFcllTeEZRVUZCTDJFc1JVRkJRU3d5UWtGQlowWXNUVUZCUVVZc1VVRkZhRVpJTEVWQlFVRkVMRkZCUVVFc1UwRkJRVEJHTEVWQlFVRnhWaXhGUVVGQlF5eEhRVU5CZEZZc1JVRkJRVmtzVlVGQlFUWldMRVZCUVVGa0xFZEJRWEZFVEN4TFFVRkJhRllzUlVGQlFTeEZRVUZCWjFZc1MwRkRja1JZTEVWQlFVRXpWU3hGUVVGQmNWWXNSVUZCUVN4bGNFTXlNa1ZOTEZOQlFWTTVZU3hGUVVGUlJDeEZRVUZUVFN4SGNVTnlNMFZvUXl4SFFVRkJaMG9zUjBGQlFXaEtMRVZCUVVFc1NVRkRRVGhpTEVWQlFVRTVZaXhGUVVGQkxFbEJRMEVyWWl4RlFVRkJMMklzUlVGQlFTeEpRVU5CWjJNc1JVRkJRV2hqTEVWQlFVRXNaMEpCUTBGcFl5eEZRVUZCTEdGQlEwRnlWaXhGUVVGQkxGbEJSMEZ6Vml4RlFVRkJMRmRCUlVFc1IwRkpRVU1zUjBGS1FVTXNSVUZCUVhCakxFVkJRVUVzWTBGRFFUWkVMRVZCUVVGcldTeEZRVUZCYWxrc1QwRkRRWFZaTEVWQlFVRXNTVUZEUVVNc1JVRkJRU3hIUVZsQkxFdEJWa0ZHTEVWQlFVRkhMRTFCUVVGRExGRkJRVUVzVDBGRFFYaGpMRVZCUVVFc1NVRkJRV2RHTEZsQlFVRnZXQ3hIUVVOQlFTeEZRVUZCZUZvc1NVRkJRU3hqUVVkQmRWb3NSVUZCUVVNc1JVRkJRVXNzWTBGQlFYUmFMRk5CUTBGbldpeEZRVUZCVHl4UFFVTkJVQ3hGUVVGQk4wMHNUVUZCUVN0TkxFVkJRVUVzVTBGQlFVTXNSVUZCUVN4dlFrRkJRVVFzUlVGQlFTeFZRVUZCUXl4SFFVTkJTQ3hGUVVGQlVTeFJRVU5CVkN4RlFVRkJReXhGUVVGQk4xWXNSVUZEUVhwRExGZEJRVUZ4V1N4SFFVRkJkRllzUjBGQlFXMVdMRVZCUVVGc1dTeEhRVU5CTEU5QlFVRnhXU3hMUVVkQmRtTXNSMEZCUVVRc1VVRkJRVzFDTEU5QlFVRm5ZaXhSUVVGQkxGTkJRVUV4VXl4RlFVRkJlVlFzUjBGRFFTeEhRVUZCUXl4RlFWRkJMRTlCVUVFc1VVRkJRVEZVTEVkQlEwRTRVeXhGUVVGQmNsWXNSMEZCUVc5RExFVkJRVUZITEVkQlEwRXdWQ3hGUVVGQkxFZEJRVUZhTEVkQlEwRkJMRVZCUVVGeVZpeEhRVUZCTEV0QlJVRnBWeXhGUVVGQllpeEhRVUZCTjFNc1IwRkRSekJVTEVWQlFVRllMRWxCUTBoeVZTeFRRVUZCSzFVc1JVRkJRVU1zUlVGQlFXWXNSVUZCUVdVc1JVRkJRVVFzUzNKRE9ETkZUU3hUUVVGVGFtUXNSVUZCVVVRc1JVRkJVMDBzUjNORGNqWkZhRU1zUjBGQlFUWkpMRWRCUVVFM1NTeEZRVUZCTEVsQlEwRm5TaXhGUVVGQmFFb3NSVUZCUVN4SlFVTkJPR01zUlVGQlFUbGpMRVZCUVVFc1IwRkZRVXdzUjBGQlFVUXNVVUZCUVUwc1JVRkJRU3hKUVVGQllTeFBRVUZCTUVVc2FVSkJRVUVzVTBGQlFUUkVMRVZCUVVGNVZDeEhRVU5CTlZRc1JVRkJRVWNzUlVGTFFTeExRVXBCTEVkQlIwRTFRaXhIUVVoQk5GTXNSVUZCUVRKRExFVkJRVUZHTEVkQlEwRTVXU3hGUVVGQmNWY3NSVUZCUVhKWExFOUJRMEZFTEVWQlFVRXNSVUZGUVVNc1JVRkJRVVFzUjBGQlFXZEdMRVZCUVVGMFF5eEZRVUZCTkVNc1JVRkJRVFZDTEVWQlFVRTBVeXhGUVVGQmRGY3NTMEZCUVN0WkxFVkJRVUZ5Vml4SFFVTkJMRTlCUVVFMFFpeExkRU0wTmtWTkxGTkJRVk40U2l4RlFVRlJSQ3hGUVVGVFRTeEhkVU4wTjBWb1F5eEhRVUZCSzJNc1IwRkJRUzlqTEVWQlFVRXNTVUZEUVN0aUxFVkJRVUV2WWl4RlFVRkJMRWRCUlVGTUxFZEJRVUZFTEZGQlFVRnRRaXhQUVVGQmMxb3NUVUZCUVN4VFFVRkJhRklzUjBGRFFTeE5RVUZCTkZRc1IwRkJRVFZVTEVWQlFVRTBVeXhMZGtNNE4wVk5MRk5CUVZOd1l5eEZRVUZSUkN4RlFVRlRUU3hIZDBOdU9FVm9ReXhIUVVGQk5Gb3NSMEZCUVRWYUxFVkJRVUVzU1VGRFFXZGtMRVZCUVVGb1pDeEZRVUZCTEVsQlEwRnBaQ3hGUVVGQmFtUXNSVUZCUVN4UlFVTkJaMk1zUlVGQlFXaGpMRVZCUVVFc1pVRkZRVXdzUjBGQlFVUXNVVUZCUVN4VFFVRkJjVW9zUlVGQlFXMVZMRWRCUTBFc1IwRkhRWEppTEVkQlNFRnpTQ3hGUVVGQk5sUXNSVUZCUVdwVkxFZEJRMEZzUml4RlFVRkJMRVZCUTBGbldpeEpRVVZCTEV0QlFVRm9ZaXhKUVVGQmMwZ3NSMEZCUVhSSUxFZEJRVUZ0WVN4SFFVRkJjRU1zUlVGQlFYcFJMRVZCUVVGMFNDeEpRVUZCWjJJc1JVRkJRVGxOTEV0QlFVRnNUeXhGUVVWQkxFMUJRVUZ4WWl4RlFVRkJjRm9zVDBGQlFVUXNSMEZCUVN0V0xFVkJRVUY2VVN4RlFVRkJkRWdzUlVGQlFYRmlMRVZCUVVGeVdpeFRRVU5CYjFvc1JVRkJRVW9zUlVGQlFXaGlMRWxCUVVGbllpeEZRVUZCT1Uwc1MwRkJRV3hQTEVkQlJVRXNUMEZCUVdkaUxFdDRRekE0UlUwc1UwRkJVMnhrTEVWQlFWRkVMRVZCUVZOTkxFZDVRM2c1UldoRExFZEJRVUZ0WkN4SFFVRkJibVFzUlVGQlFTeEpRVU5CYjFvc1JVRkJRWEJhTEVWQlFVRXNSMEZEUVV3c1IwRkJRVVFzVVVGQlFTeFRRVUZCZDBjc1IwRkRRU3hOUVVGQmFWZ3NSMEZCUVM5RUxFVkJRVUZzVkN4TmVrTm5LMFZOTEZOQlFWTjJSeXhGUVVGUlJDeEZRVUZUVFN4SE1FTnVLMFZvUXl4SFFVRkJiMlFzUjBGQlFYQmtMRVZCUVVFc1IwRkRRVXdzUjBGQlFVUXNVVUZCUVcxQ0xFOUJRVUVzUzBGQlFYZGpMSEZDUVVGQkxFZEJRVUY0WXl4UFFVRkJMRk5CUVVGeFJpeEhRVU5CTEdkQ1FVRkJhMWdzUlVGQlFXeFlMRXRCUVVGdldDeE5RVUZCTEVsQlFVRjZZeXhQUVVGQmNVWXNTekZETWl0RlRTeFRRVUZUZGtjc1JVRkJVVVFzUnpKRE9TdEZka0lzUjBGQlFXZExMRTFCUVdsQ1FTeFJRVVZxUWk5S0xFZEJRVUZFTEZGQlFVRXNVMEZCUVhkSExFZEJRMEVzVFVGQlFYZEVMRWRCUVVGeVNpeExRVUZCTmtZc1IwRkJRWEZVTEUxQlFVRXNVVE5EY1M5RlRTeFRRVUZUTlZvc1JVRkJVVVFzUlVGQlUwMHNSelJEZEM5RmFFTXNSMEZCUVdka0xFZEJRVUZvWkN4RlFVRkJMRWxCUTBGMVpDeEZRVUZCZG1Rc1JVRkJRU3hKUVVOQmQyUXNSVUZCUVhoa0xFVkJRVUVzUjBGRFFVd3NSMEZCUVVRc1VVRkJRU3hUUVVGQksyUXNSMEZEUVN4blFrRkJRVU1zUlVGQlFUVmlMRVZCUVVFMllpeEhRVU5CTEVkQlIwRTFZeXhIUVVoQmIwa3NSVUZCUVRaVUxFVkJRVUZWTEVkQlEwRTFXaXhGUVVGQmVWb3NSVUZCUVhCVkxFVkJRVUZ5Uml4UlFVTkJOa2NzUlVGQlFUWlRMRVZCUVVGSExFVkJRVUUzV2l4RlFVZEJMRWxCUVVFeVdpeEhRVUZCTTJJc1RVRkJRU3hMUVVGQlowTXNSVUZCUVRaSExFZEJSVUVzUjBGRVFUVktMRVZCUVVGdlNTeEZRVUZCZDBJc1MwRkRRVFZLTEV0QlFVRXNZVUZGU3l4TlFVRlhLME1zUlVGQlFUWkhMRVZCUVdWQkxFbEJRVUVzU1VGQlFUaFRMRWRCUVVFNVV5eEpRVUZCZUVJc1MwRkRMMEpCTEVWQlFVRjNRaXhMUVVGQk4wa3NSVUZCUVN4TlFVRkJNbUlzU1VGQlFUbFRMRWRCUVVFc1EwRkRTeXhSUVVGQk9GTXNTVUZCUVN4TE5VTm5aMFpETEZOQlFWTTVaQ3hGUVVGUlJDeEZRVUZUVFN4SE5rTnFhRVpvUXl4SFFVRkJiVm9zUjBGQlFXNWFMRVZCUVVFc1NVRkRRVFpSTEVWQlFVRTNUU3hMUVVGQk5rMHNSMEZEUVd4U0xFZEJRVUZFTEZGQlFVRXNVMEZCUVhkSExFZEJRMEVzVFVGQlFVRXNSMEZCUVN4RlFVRkJNa3NzUlVGQlFYTkpMRVZCUVVGcVZDeEhRVUZCTEhOQ04wTjVhRVpOTEZOQlFWTjJSeXhGUVVGUlJDeEZRVUZUVFN4SE9FTTNhRVpvUXl4SFFVRkJiVm9zUjBGQlFXNWFMRVZCUVVFc1NVRkRRWFZQTEVWQlFVRjJTeXhMUVVGQmRVc3NTVUZEUVhORExFVkJRVUUzVFN4TFFVRkJOazBzUjBGRFFXeFNMRWRCUVVGRUxGRkJRVUVzVTBGQlFXbE1MRVZCUVVFM1J5eEhRVVZCTEUxQlJFRTJSeXhIUVVGQmQwOHNSVUZCUVhoUExFZEJRMEZCTEVWQlFVRXNSVUZCUVRSRUxFVkJRVUUxUkN4RlFVRkJOMGNzUlVGQlFTeEhRVUZCSzAwc1JVRkJRV3hITEVWQlFVRTNSeXhMT1VOdmFVWk5MRk5CUVZOdVJTeEZRVUZSUkN4RlFVRlRUU3hISzBONmFVWm9ReXhIUVVGQk5HUXNSMEZCUVRWa0xFVkJRVUVzV1VGRFFUWmtMRVZCUVVFM1pDeEZRVUZCTEVkQlEwRk1MRWRCUVVGRUxGRkJRVUVzVTBGQlFXMURMRWRCUTBFc1RVRkJRU3RpTEVkQlFVRXZZaXhMUVVGQksySXNSVUZCUVM5aUxFZEJRVUZuWXl4RlFVRkJhR01zVFM5RFoycEdUU3hUUVVGVGJFTXNSVUZCVVVRc1JVRkJVMDBzUjJkRWJtcEdhRU1zUjBGQlFYZEhMRWRCUVVGNFJ5eEZRVUZCTEVkQlEwRTRaQ3hGUVVGQkxIRkNRVU5CUXl4RlFVRkJkbGdzUlVGQlFYTllMRXRCUVVGMFdDeEZRVUZCYzFnc1RVRkRRVzVsTEVkQlFVRkVMRkZCUVVFc1UwRkJRVzFETEVkQlEwRXNUVUZCUVd0akxFZEJRVUZzWXl4TFFVRkJhMk1zUlVGQlFXeGpMRk5vUkRCcVJrMHNVMEZCVTJ4RExFVkJRVkZFTEVkcFJEbHFSblpDTEVkQlFVRlRMRWRCUVVFc1JVRkRRVFprTEVWQlFVRm9ZU3hMUVVGQmFXRXNVVUZEUVhSbExFZEJRVUZFTEZGQlFVRXNVMEZCUVcxRExFZEJRMEVzWjBKQlFVRnhZeXhQUVVGQmNsY3NVMEZCUVdoSExFVkJRVUVzUjBGQlFVRXNSVUZCUVN4UlFVRkJNVUlzUlVGQlFUWmtMRWRCUVVGMFZTeFRRVUZCTEU5cVJIRnJSazBzVTBGQlV5OUtMRVZCUVZGRUxFZHJSSFpyUm5aQ1F5eEZRVUZCUkN4UlFVRkJMR2RIUVVWQk5HUXNUVUZCUVN4TmJFUTRhMFpOTEZOQlFWTXpaQ3hGUVVGUlJDeEZRVUZUVFN4SGJVUnFiRVpvUTB3c1JVRkJRVVFzVVVGQlFVMHNSVUZCUVN4SFFVRkJiVVFzYlVKQlFVRm5ZaXhwUW01RWRXeEdUU3hUUVVGVGVHVXNSVUZCVVVRc1JVRkJVMDBzUjI5RWRteEdhRU1zUjBGQlFXOWxMRWRCUVVGd1pTeEZRVUZCTEVsQlFVRjFSeXhGUVVOQmNWUXNSVUZCUVRWYUxFVkJRVUVzU1VGRFFXMWlMRVZCUVVGdVlpeEZRVUZCTEd0Q1FVVkJUQ3hIUVVGQlJDeFJRVUZCTEZOQlFVRjNSeXhGUVVGQmJWa3NSVUZCUVVNc1IwRkRRWEJaTEVsQlFVRXdWQ3hGUVVGQk1WUXNSVUZCUVc5WkxFVkJRVUZ3V1N4SlFVRkJSaXhWUVVGQmJWWXNTVUZCUVdsRUxFVkJRVUZzV1N4RlFVRkJhVllzUjBGQmEwVjJWaXhqUVVGQkxFVkJRVUUzUlN4TlFVRkJjMlFzVFhCRU9HeEdOVVFzVTBGQlV6RmxMRVZCUVZGRUxFVkJRVk5OTEVkeFJHNXRSbWhETEVkQlFVRXJaQ3hIUVVGQkwyUXNSVUZCUVN4WFFVTkJObVFzUlVGQlFUZGtMRVZCUVVFc1NVRkRRWFZsTEVWQlFVRjJaU3hGUVVGQkxFZEJRVUYxWlN4UFFVTkJReXhGUVVGQkxHdENRVUZCUkN4SFFVVkJSU3hGUVVGQk9XVXNSVUZCUVVRc1VVRkJRU3hUUVVGQmIwZ3NSMEZEUVN4TlFVRkJhVmdzUjBGQlFXcFlMRXRCUVVGcFdDeEZRVUZCYWxnc1IwRkRRVEJZTEVkQlFVRkVMRVZCUVVGNldDeExRVUZCTUZnc1JVRkJRVVFzUlVGQlFWWXNSMEZCUVN4VlFVRkJMMWNzU1VGSFFUSllMRWRCUVVGV0xGTnlSSGx0Umswc1UwRkJVM0JsTEVWQlFWRkVMRVZCUVZOTkxFZHpSR3h1Um1oRExFZEJRVUUwV2l4SFFVRkJOVm9zUlVGQlFTeEpRVU5CTUdVc1JVRkJRVEZsTEVWQlFVRXNTVUZEUVdkakxFVkJRVUZvWXl4RlFVRkJMR2RDUVVOQk1tVXNSVUZCUVRsa0xFOUJRVUZ0Uml4VFFVVkJja2NzUjBGQlFVUXNVVUZCUVcxQ0xFOUJRVUZ0V2l4blFrRkJRU3hUUVVGQk4xRXNSMEZGUVN4TlFVUkJRU3hIUVVGQmRWWXNSVUZCUVhaV0xFZEJRMEY1VVN4RlFVRkJlbEVzUlVGQlFUWlRMRWRCUVVFM1V5eEZRVUZCTmxNc1IwRkRRU3hyUWtGQlFUZFRMRWRCUVVGNVVDeGhRVUZCZWxBc1pVRkJRWGxRTEZsQlEwRjZVQ3hGUVVGQmVWQXNXVUZCUVRWVExGVkJRMGR0UkN4WlFVRkJkRWtzVVVGQlFUaGtMRVZCUVVFc1QzUkVNRzVHUnl4VFFVRlRhR1lzUlVGQlVVUXNSVUZCVTAwc1IzVkVjRzlHYUVNc1IwRkJRVzlhTEVkQlFVRndXaXhGUVVGQkxFZEJRMEZNTEVkQlFVRkVMRkZCUVVFc1UwRkJRWGRITEVkQlEwRXNUVUZCUVhKR0xGRkJRVUYxV1N4RlFVRkJiRlFzVFhaRU5HOUdUU3hUUVVGVGRrY3NSVUZCVVVRc1JVRkJVMDBzUjNkRUwyOUdhRU5CTEVWQlFVRXNSMEZOUVN4UlFVeEJkMGNzUjBGQlFYaEhMRVZCUVVFc1IwRkRRVEpITEVWQlFVRXpSeXhGUVVGQkxFbEJRMEUyV2l4RlFVRkJOMW9zUlVGQlFTeEpRVU5CTkdVc1JVRkJRVFZsTEVWQlFVRXNiVUpCUlVFMlpTeEhRVUZCTEhORlFVRkJhR0lzUlVGQlFTeEZRVUYzUjBFc1JVRkJRU3hGUVVGUFFTeEpRVUZCTEVOQlF5OUhMRWRCUVVFMFZ5eEhRVUZCYjBVc1JVRkJRV2hpTEVkQlEwRnBZaXhGUVVGQmRGa3NSVUZCUVdsVkxFZEJRMEZUTEVWQlFVRTBSQ3hMUVVGQk9Wa3NVMEZEUVd0V0xFOUJRVUV3UkN4SlFVRkJhbGtzUlVGQlFYVlZMRVZCUVVFd1JDeEZRVUZCYmtVc1IwRkRRVm9zUlVGQlFWa3NSMEZCUVZvc1JVRkJRWEpRTEZGNFJITndSazBzVTBGQlV6ZExMRVZCUVZGRUxFVkJRVk5OTEVkNVJHcHhSbWhETEZsQlEwRXNTVUZCUVN0bExFZEJRVUV2WlN4RlFVRkJMRWxCUTBGblppeEZRVUZCYUdZc1JVRkJRU3hKUVVOQk5sb3NSVUZCUVRkYUxFVkJRVUVzU1VGRFFXZGtMRVZCUVVGb1pDeEZRVUZCTEVkQlRVRk1MRWRCUVVGRUxGRkJRVUZOTEVWQlFVRXNTVUZCUVhkTExFMUJRVUVzYVVKQlFVRnpUeXhGUVVGQmJVTXNSMEZEUVc1aUxFdEJRVUZwV2l4SFFVRkJhVVVzUlVGQlFXeEZMRWRCUTBGb1dpeExRVUZCYTFvc1IwRkJRU3hGUVVOQmJGb3NTMEZCUVcxbUxFZEJRVUZvUlN4SFFVVkRMRmRCUTBRc1IwRkJRVGxTTEVkQlFVRnlTaXhMUVVGQmFWb3NSMEZEUVd0RExFVkJRVUZ1WWl4TFFVRkJiV1lzUjBGRFFYUlZMRVZCUVVFM1N5eExRVUZCYTFvc1NVRkRRU3hSUVVGQk4xQXNSMEZCUVhkQ0xFZEJRVUY0UWl4RlFVRkJja1lzVVVGRFFXaEZMRXRCUVVGcFdpeEhRVUZCYkZJc1QwRkRRVzFZTEVWQlFVRXNTVUZGUVN4UlFVRkJMMFFzUlVGQlFTdEVMRVZCUVVFc1JVRkJRWEpWTEVkQlEwRXNWVUZCUVhOUkxFVkJRVUVyUkN4RlFVRkJMRVZCUVVFM1ZpeEZRVUZCZDBJc1NVRkRRWEZWTEVWQlFVRXNSMEZCUVhKVkxFVkJRVUY0UWl4RlFVRkJkMElzVFVGRFF5eFZRVWRFYTFBc1JVRkJRWEZHTEZWQlFVRnlSaXhGUVVGQmNsQXNUVUZGUVhWVkxFVkJRVUVzVVVGRFFVRXNSVUZCUVN4VlFVTkJRU3hGUVVGQkxGbDZSSFZ4Umswc1UwRkJVM0JtTEVWQlFWRkVMRWN3UkhoelJuWkNReXhGUVVGQlJDeFJRVUZCTEdNeFJEaHpSazBzVTBGQlUwTXNSVUZCVVVRc1J6SkVPWE5HZGtKRExFVkJRVUZFTEZGQlFVRXNVMEZCUVhkYUxFVkJRVUZ1V1N4SFFVTkJMRTlCUVZWQkxGRkJRVUZ0V1N4Wk0wUnhkRVpLTEZOQlFWTjJXaXhGUVVGUlJDeEZRVUZUVFN4SE5FUjBkRVpvUTA0c1JVRkJRVFpITEVWQlFVRjJSeXhGUVVGQkxFczFSRFIwUmswc1UwRkJVMHdzUlVGQlVVUXNSVUZCVTAwc1J6WkVOWFJHYUVOTUxFVkJRVUZFTEZOQlFXdENhMElzVVVGQlFWb3NSVUZCUVN4SlFVRkJWeXhaUVVGQkxFazNSR3QxUmxvc1UwRkJVMmhDTEVWQlFWRkVMRVZCUVZOTkxFYzRSR3gxUm1oRFFTeEZRVUZCTEVsQlEwRkJMRVZCUVVFc1NVRkRRVUVzUlVGQlFTeEpRVU5CUVN4RlFVRkJMRWxCUTBGTUxFVkJRVUZFTEZGQlFVRk5MRVZCUVVFc1IwRkJRWFZsTEZFNVJIZDFSazBzVTBGQlV6VmxMRVZCUVZGRUxFVkJRVk5OTEVjclJEVjFSbWhETEZsQlJVRXNTVUZCUVhkSExFZEJRVUY0Unl4RlFVRkJMRWRCUTBFMFdpeEZRVUZCTlZvc1JVRkJRU3hKUVVOQmJXWXNSVUZCUVc1bUxFVkJRVUVzU1VGRFFXOUhMRVZCUVVGd1J5eEZRVUZCTEVkQlEwRXlXaXhGUVVGQk0xb3NSVUZCUVN4SlFVTkJiMllzUlVGQlFYQm1MRVZCUVVFc1NVRkJRWEZtTEVsQlEwRkRMRVZCUVVGMFppeEZRVUZCTEVsQlEwRTBaQ3hGUVVGQk5XUXNSVUZCUVN4SlFVTkJLMW9zUlVGQlFTOWFMRVZCUVVFc1NVRkRRVFprTEVWQlFVRTNaQ3hGUVVGQkxFbEJRMEYxWml4RlFVRkJkbVlzUlVGQlFTeEpRVU5CZDJZc1JVRkJRWGhtTEVWQlFVRXNTVUZEUVhsbUxFVkJRVUY2Wml4RlFVRkJMRWxCUTBFd1ppeEZRVUZCTVdZc1JVRkJRU3hKUVVOQk1tWXNSVUZCUVRObUxFVkJRVUVzU1VGRFFUUm1MRVZCUVVFMVppeEZRVUZCTEVsQlEwRm5TaXhGUVVGQmFFb3NSVUZCUVN4SlFVTkJaMlFzUlVGQlFXaGtMRVZCUVVFc1NVRkRRV3RLTEVWQlFVRnNTaXhGUVVGQkxFbEJRMEU0U1N4RlFVRkJPVWtzUlVGQlFTeEpRVU5CTm1Zc1JVRkJRVGRtTEVWQlFVRXNTVUZEUVRobUxFVkJRVUU1Wml4RlFVRkJMRWxCUTBFclppeEZRVUZCTDJZc1JVRkJRU3hKUVVOQloyZENMRVZCUVVGb1owSXNSVUZCUVN4SlFVTkJLMk1zUlVGQlFTOWpMRVZCUVVFc1NVRkRRV2xuUWl4RlFVRkJSaXhGUVVGQmVGb3NSVUZEUVhORExFVkJRVUZ0V0N4RlFVRkJlbG9zUlVGRFFUSmFMRVZCUVVGS0xFVkJRVUYyV2l4RlFVTkJORm9zUlVGQlFUTmFMRVZCUVVFcldDeFBRVU5CTmtJc1JVRkJRVFZhTEVWQlFVRTJXaXhMUVVOQlF5eEZRVUZCUml4TFFVRkJSeXhWUVVOQk0xb3NSVUZCUVN4WlFVTkJORm9zUlVGQlFXcENMRVZCUVVFc1YwRkRRV3RDTEVWQlFVRnNRaXhGUVVGQkxHVkJRMEZ0UWl4TFFVRjFRbkpFTEhGQ1FVTjJRbk5FTEVWQlFVRXZReXhGUVVGQkxHMUNRVU5CWjBRc1JVRkJRV2hFTEVWQlFVRXNWMEZEUVdsRUxFVkJRVUZxUkN4RlFVRkJMR05CUTBGbExFVkJRVUU1WkN4UFFVRkJLMFlzUjBGRFFXdGhMRVZCUVVFc2EwSkJRVUZZTEVkQlEwRlpMRVZCUVVGMllTeEZRVUZCZFdFc1VVRkZRVU1zUjBGQlFVUXNUVUZCUVc1aExFdEJRVUZ0WVN4RlFVRkJibUVzUjBGQlFYRmhMRlZCUjBGRExFVkJRVUV2UWl4SFFVRkJSeXhGUVVGQk8wRkJRMEVzVFVGRlJ5eEpRVVpJVHl4RlFVRkJhRmdzUzBGQmMwSXNTMEZEZEVJMVJDeEpRVUZCTEZkQlFXOUNMRTFCUVVFMFJDeEhRVUZCTDBrc1MwRkJRU3hMUVVGMVFtbENMRTFCUVVFc1NVRkJVMmRJTEUxQlEycEVRU3hKUVVOR0xGTkJRVUUzUWl4RlFVRkJja1VzUlVGQlFYTm1MRWRCUTBRc1IwRkJRVU1zUjBGQlFXNUNMRVZCUVVGMFFpeEZRVUZCT1dNc1JVRkRRWFZtTEZWQlFVRjZReXhIUVVGQk9XTXNSMEZEUVdkSUxFVkJRVUV6UXl4RlFVRkJja1VzUlVGQlFYTm1MRWRCUTBGRExFZEJRVUZzWWl4SlFVRkJlVmtzUjBGQlFUbFdMRVZCUVVFNFZpeEZRVUZCT1dNc1JVRkJRWFZtTEVsQlEwTjJXU3hGUVVWRWQxa3NSVUZCUVN4VFFVRkJhRVFzUjBGRFFTeEhRVUZCYVVRc1IwRkJRVllzUlVGQlFYWkRMRWRCUVVGM1FpeEZRVUZCVFN4RlFVRkJkbG9zUjBGRlFTeFBRVVJCTUdFc1IwRkJRWEpETEVkQlFVRmFMRVZCUTBGcFJDeEhRVWRCUXl4RlFVRkJWQ3hIUVVGQkxHZENRVUZCV0N4SFFVRkJjVUlzVTBGQlFTeFRRVUZCZEdJc1IwRkRRU3h6UWtGQlFVRXNTVUZEUXl4VFFVRkJRU3hIUVVORUxFMUJRVUZCTEdGQlFVRnBZU3hKUVVkQmMwSXNSVUZCUVN4VFFVRkJkbUlzUlVGQlFYSkZMRVZCUVVGelppeEhRVXRCTEUxQlNrRnFZaXhMUVVGQmVWa3NSMEZCUVRoRExFVkJRVUZhTEVWQlFVRm9aaXhGUVVGQmMyWXNSMEZEUVc1WkxFVkJRVUU1UXl4SFFVTkJja1VzUlVGQlFYRklMRVZCUVVGeVNDeEhRVUZCTEVkQlEwRnRTQ3hGUVVGQmJWa3NSMEZEUVhaSUxFVkJRVUZuU0N4RlFVRkJMMlVzU1VGRFFYTm1MRVZCUVVGNFlpeFpRVWxCYVZVc1JVRkJRVEZVTEVWQlFVRnpZU3hKUVVGQmRHRXNSVUZCUVhOaExFZEJRVUV6WlN4TFFVRkJjVVVzUlVGQlFYTmhMRWRCUVVFelpTeEpRVUZCTEVkQlEwRnpaaXhGUVVGQmRFSXNSVUZCUVhOQ0xFZEJRWE5DZUdJc1YwRkJRVzFFTEVWQlFVRXNWVUZLZEVJNFVTeEZRVUZCTVZRc1JVRkJRWE5oTEVsQlFVRXpXQ3hGUVVGQk0wTXNSVUZCUVhOaExFVkJRVUV4V0N4RlFVRkJMRTlCUTBFMVF5eEZRVUZCYzJFc1IwRkJRVE5sTEVsQlFVRXNSMEZKUzNGbUxFVkJRVUZvWWl4RlFVRkJja1VzUlVGQlFYTm1MRWxCUTBaMFdTeEZRVUZCTTBNc1JVRkJRWEpGTEVWQlFVRnpaaXhKUVVWSVR5eEZRVUZCTEZOQlFVRjRZaXhGUVVGQmNVSXNSMEZEUVhsQ0xFVkJRVUU1UXl4RlFVdEJMRXRCU2tFc1IwRkhRWEpGTEVkQlNFRnpXU3hGUVVGQmQwWXNSVUZCUVhCWkxFVkJRVUY1Vml4RlFVRkJlbFlzU1VGRFFURkVMRVZCUVVFc1JVRkRRWGxXTEVWQlFVRmhMRVZCUVVGeVZ5eFBRVVZCZDFZc1JVRkJRWHBXTEVkQlFVRTBaQ3hGUVVGQmRtSXNSVUZCUVhKRkxFVkJRVUZ6V1N4RlFVRkJkRmNzUzBGQlFUQkVMRVZCUVVFeFJpeEhRVU5CTEU5QlFVRnhSU3hKUVVWQmVXSXNSVUZCUVN4VFFVRkJlbUlzUlVGQlFYRkNMRWRCUTBFc1RVRkJRVTBzVlVGQlFVNHNSVUZCUVhOWkxFVkJRVUV6V2l4SFFVRkJkMklzUlVGQlFUZENMRVZCUVVFeldpeEhRVUZCY1VJc1NVRkZRWEZoTEVWQlFVRXNVMEZCUVM5bUxFZEJRMEVzUjBGQlFXZG5RaXhIUVVGQmJrSXNSVUZCUVhKblFpeExRVUZCVUN4TFFVRkJLMElzUlVGQlFYRklMRVZCUVVGeVNDeEhRVUZCTEVkQlEwRXNVMEZCUVM5Q0xFOUJRVUUyWlN4SFFVRkJMMFVzUlVGQlFXZElMRVZCUVVFdlpTeExRVUZCSzFnc1JVRkJRV2xJTEVWQlFVRm9aaXhSUVVOQloyZENMRWxCUVVGcVNTeEZRVUZCT1Zvc1MwRkJRU3RDTEV0QlFVRXJXQ3hGUVVGQlowZ3NSVUZCUVM5bExFbEJRVUVyV0N4RlFVRkJPVm9zUzBGQlFUQm5RaXhKUVVGQk1XZENMRXRCUVVFd1owSXNSMEZCUVRObExFdEJRVUZuWjBJc1NVRkZRVU1zUlVGQlFTeFRRVUZCTldJc1JVRkJRWEpGTEVkQlIwRXNSMEZHUVhGRkxFVkJRVUU0Vnl4RlFVRkJPVmNzUjBGRFFYSkZMRVZCUVVGeFNDeEZRVUZCY2tnc1IwRkJRU3hIUVVOQmNVVXNTVUZCUVhsWkxFbEJRVUV2UlN4RlFVRkJaMGdzUlVGQlFTOWxMRWxCUVVFcldDeEZRVUZCYVVnc1JVRkJRV2htTEVkQlFVRXNRMEZEUVN4SFFVRkJjMllzUjBGQlFXeENMRVZCUVVFdldpeEZRVUZCY2tVc1JVRkZRU3hSUVVSQmMyWXNTVUZCUVhaSUxFVkJRVUZuU0N4RlFVRkJMMlVzU1VGQlFTdFlMRVZCUVVFeFZDeEZRVUZCYzJFc1NVRkJRWFJoTEVWQlFVRnpZU3hIUVVGQk0yVXNTMEZCUVhObUxFVkJRVUY0WWl4WlFVRkJMRWRCUTBGM1lpeEpRVVZCV1N4RlFVRkJMRk5CUVVFM1lpeEhRVXRCTEVsQlNrRXNSMEZIUVhKRkxFZEJTRUZ4WWl4RlFVRkJaMFFzUlVGQlFXeEVMRVZCUVVFNVZ5eEpRVU5CTWxjc1MwRkRRV2hhTEVWQlFVRXNSVUZGUVhGYUxFVkJRVUZ3V2l4UFFVRkJSQ3hIUVVOQksxWXNSVUZCUVdkSUxFVkJRVUV2WlN4RlFVRkJjV0lzUlVGQlFYSmFMRTlCUVVGb1F5eEhRVUZCTW1Vc1IwRkJRVE5sTEVkQlFVRjFaQ3hIUVVGQmRrTXNSVUZCUVRsTkxFdEJRVUZzVHl4RlFVTkhMRTlCUVVGbllpeEpRVVZJYlVZc1IwRkJRU3hUUVVGQk9XSXNSMEZOUVN4SlFVeEJMRWRCU1VGeVJTeEhRVXBCYjJkQ0xFVkJRVUV2WWl4SlFVRkJlVmtzUlVGRFFYcENMRVZCUVVGblJDeEZRVUZCSzBJc1JVRkJRWEJDTEVWQlFVRTNSQ3hGUVVGQk9WY3NTVUZEUVRKWExFdEJRMEZvV2l4RlFVRkJMRVZCUlVGeFdpeEZRVUZCY0Zvc1QwRkJRVVFzU1VGRFFTdFdMRVZCUVVGblNDeEZRVUZCTDJVc1JVRkJRWEZpTEVWQlFVRnlXaXhQUVVGQmIyVXNTVUZCUVhKSkxFVkJRVUVyUlN4RlFVRkJPV01zU1VGQlFXZGlMRVZCUVVFNVRTeExRVUZCTmxFc1JVRkJRUzlsTEVkQlEwY3NUMEZCUVdkaUxFZEJTVWhwUlN4TFFVTkJXQ3hGUVVGQkxGZEJRMEVzUjBGQlFYSm5RaXhsUVVGQmNXZENMRWRCUVVFc1MwRkJRVEZsTEZkQlFVRXNLMEpCUTBFc1NVRkJRVFJqTEVkQlFVRlNMRVZCUVVFMVZpeFZRVUZCYmtVc1QwRkJRU3hGUVVGQmJVVXNWVUZCUVN4SFFVRkJTaXhSUVVOQmNXRXNSVUZCUVN4VFFVRkJibWhDTEVkQlEwRnFRaXhQUVVGQk5tVXNSMEZCUVhWRUxFVkJRVUUzYUVJc1MwRkJRWGRuUWl4RlFVRkJPV1lzUjBGRFFUWlpMRVZCUVVFNVdpeExRVUZCTUdkQ0xFbEJRVUUxUnl4RlFVRkJPVm9zUzBGQlFUQm5RaXhIUVVGQmJrTXNTMEZCUVhabExFdEJRVUV3WjBJc1IwRkJRVzVETEVsQlFVRXNSMEZEUVRaRExFVkJRVUZ3YUVJc1MwRkJRWFZsTEVWQlFVRjJWaXhGUVVGQkxFVkJRVUV2U0N4SlFVZEJMRTlCUkVGdlpTeEpRVUZCTmtJc1IwRkJRVVVzUlVGQlFYWkRMRVZCUVVGT0xFZEJRVGhFZWxrc1kwRkJRU3hGUVVGQmRXTXNTVUZCUVVRc1NVRkRPVVJpTEVWQlFVRm9SQ3hKUVVWQk1VVXNSVUZCUVhkSExFVkJRVUYyV2l4SFFVRkJMSE5DUVVOQkxFMUJRVUU1Unl4TlFVRkJiV1lzUzBGSFFXTXNSVUZCUVhoYUxFVkJRVUYxWWl4RlFVTkJPVUlzUlVGQlFYcGFMRVZCUVVGcllpeEZRVU5CZW1oQ0xFVkJRVUVzU1VGQlFYVkhMRVZCUVVGMVdpeEZRVUZCZGxvc1JVRkJRWGRpTEVWQlEwRXZhRUlzUlVGQlFTeEpRVUZCZFVjc1JVRkJRWEZpTEVWQlEwRTFhRUlzUlVGQlFTeEpRVUZCZFVjc1JVRkJRWGxpTEVkQlJVRTNReXhKUVVGQmJtWXNSVUZCUVN4TFFVTkJNbG9zUlVGQlFXZEdMRVZCUVVFc2RVSkJRVUZwUkN4SFFVRkJMRWRCUjBGd1F5eEZRVUZCYWxvc1JVRkJRU3hUUVVGQlR5eEhRVU5CTEUxQlFVRjFZU3hIUVVGQk9VSXNSVUZCUVhwWkxFMUJTVUZXTEVsQlFVRm5RaXhGUVVGQmFFSXNSVUZCUVhWQ0xFVkJRVUYyUWl4RlFVRkJSU3hIUVVGQmQyRXNSMEZCTUVSMlF5eFBRVUZCTkVJc1IwRkZNVVFzVVVGQlFXbERMRWxCUVVFc2FVaEJSMEU1UlN4TlFVRkJMRXRCUVVGNldpeEhRVUZCTEVWQlFXOUNkV1VzUjBGQlFYUmxMRTlCUVVGRUxFbEJRVzlDTUdJc1JVRkJRVFpETEVkQlFVRjJaU3hOUVVWNFF5eFJRVUZCZFdVc1NVRkJRWEpHTEVWQlFVRjNReXhGUVVGQmVFSXNUMEZCUVd4aExFZEJRVUVzUlVGQk1FTjFaU3hIUVVGQmRHVXNUMEZCUVVRc1NVRkJiMEkwWWl4RlFVRkJNa01zUjBGQlFYWmxMRTFCUlRsRWRVTXNTMEZCUVVNc1JVRkJRVVFzUlVGQlFVVXNSMEZCUVhkaExFVkJRVUVzVlVGRlFYVkNMRWxCUVVFc1UwRkJRWGhuUWl4SFFVTkJMRTFCUVVFcldDeEhRVUZCSzBjc1JVRkJRVGxsTEVkQlFVRXNTVUZEUVRobExFVkJRVUU1WlN4SFFVTkJPR1VzUlVGQlFUbGxMRWRCUVVGelpTeEZRVUZCZEdVc1NVRkhRWGxuUWl4UFFVRkJMRk5CUVVGNlowSXNSMEZEUVN4SFFVRkJNR1lzUlVGQlFURm1MRWRCUVVFc1RVRkJRVFprTEVkQlFVRnBRaXhGUVVGQk9XVXNSVUZEUVN4TlFVRkJTaXhYUVVGQlNTeEZRVUZCTEhOQ1FVVkJNR2RDTEZWQlFVRXNWMEZCZDBKMlFpeEhRVUZCTEVkQlEzaENkMElzVlVGQlFTeFhRVUYzUW5oQ0xFZEJRVUVzUzBGSGVFSTFZU3hKUVVGQlF5eEZRVUZCUkN4RlFVRkJSU3hIUVVGQmQyRXNSVUZCUVN4VlFVVkJha1lzVDBGQlFUaEdMRVZCUlVFM1owSXNaVUZCUVRKblFpeEZRVVZCYkdNc2FVSkJRVUZ0WXl4RlFVVkJaU3g1UWtGQlFWZ3NSVUZGUVZrc2IwSkJRVUZZTEVWQlJVRlpMSE5DUVVGQldDeExRVWxCTlVJc1IwRkJRV2hoTEVsQlFVRkRMRVZCUVVGRUxFVkJRVUZGTEVsQlFVRjNZU3hIUVVGQmVFSXNSVUZCUVN4WFFVTkJMRWRCUVVGcVdpeEhRVUZCT0Zvc1IwRkpRU3hwUWtGQlFVY3NSMEZCUVdwaExFdEJRWGxFTEUxQlFYcEVhV0VzUjBGQmIwUjJXU3hGUVVGQk1VSXNTMEZCWVN4TlFVRkJhV0VzUlVGQlFYcG1MRTlCUVVGM1JpeFBRVU5vUlN4UlFVTkVhMkVzVlVGQlFTeFRRVUZCY21Fc1IwRkRRU3hIUVVGQk1rSXNVMEZCUVROQ0xFbEJRVUZ4WWl4RlFVRkJjbUlzUjBGQlFTeERRVWxCTEVsQlNFRXNSMEZGUVRCakxFZEJRVUZETEVWQlJrRkRMRWRCUVVFMVl5eEhRVU5CY2tNc1JVRkJRU3hGUVVWQmIwVXNWVUZCUVc1RkxFOUJRVUZFTEVkQlFVRnBaaXhGUVVGQkwxTXNTMEZCUVRsSUxGVkJRVUZ3UlN4TFFWRkJMRTlCVUVFclpTeEhRVUZCUlN4RlFVRkJMRWRCUTBFc2EwSkJRVUZHTEV0QlFVRkRMRVZCUVVGRUxFbEJRMEZETEVkQlFVRnFSQ3hGUVVGQlowUXNUMEZCUVN4VFFVRkJMMmRDTEVWQlFVRmtMRWRCUlVFc1IwRkVRVGhvUWl4SlFVRkJPV2hDTEVWQlFVRTRhRUlzUlVGQlFYaHBRaXhMUVVGQlVDeExRVUZCSzBJc1JVRkJRV1FzUzBGRFFYZG5RaXhGUVVGQmVHZENMRWRCUVVFc1RVRkJRVUVzUzBGRlFTdG9RaXhGUVVGQkxFZEJRVUZHTEVWQlEwRjBReXhGUVVGQmNGa3NUVUZCUVd0WkxFVkJRVUV3UXl4UFFVdEJNME1zUlVGQlFYWmFMRWRCUVVFMldpeEpRVUZCZW1kQ0xFVkJRVUVzU1VGQlFXMW5RaXhGUVVGQmRsb3NSMEZCUVRaYUxFVkJRVUZPTEVWQlFVRjJXaXhIUVVGQkswTXNVMEZGUVc5UkxFVkJRVUZ2Unl4RlFVRkJMRlZCUlVGd1J5eEZRVUZCTDFZc1MwRkJRU3hYUVVWQksxWXNSVUZCUVhaVUxFVkJRVUUyV2l4TFFVRkJMRmt2Ukd0MlJrMHNVMEZCVXpGblFpeEZRVUZSUkN4RlFVRlRUU3hIWjBVMU9VWm9ReXhIUVVGQmIyWXNSMEZCUVhCbUxFVkJRVUVzV1VGRFFYTktMRVZCUVVGMFNpeEZRVUZCTEVsQlEwRTBXaXhGUVVGQk5Wb3NSVUZCUVN4SlFVTkJLMmxDTEVWQlFVRXZhVUlzUlVGQlFTeEpRVUZCZFVjc1JVRkRRWEJITEVWQlFVRXNSVUZEUVRacFFpeEZRVUZCYm1sQ0xFOUJRVUZ0YVVJc1kwRkJRU3hYUVVOQkxGVkJSVUZETEVkQlFVRnFha0lzUlVGQlFTeGxRVU5CTEUxQlFVRm5ha0lzUjBGQlFXNXBRaXhQUVVGQmNXbENMSGxDUVVWQlF5eEZRVUZCTEZOQlFVRnFaQ3hIUVVOQk5tTXNSVUZCUVRkakxFVkJRVUZyV2l4SFFVRnhRbkpsTEU5QlEzSkNPRU1zUlVGQlFTeFBRVUZCTVVRc1JVRkRRV2xxUWl4VFFVZEJReXhGUVVGQkxGTkJRVUZ1WkN4RlFVRkJNbFlzUjBGRlFTeEpRVUZCZGxNc1JVRkJRWEJFTEVkQlFVRXNjMEpCUVVGQkxFMUJRVUVzWjBKQlFVRkJMRWRCUVVFc1UwRkJRVUVzUTBGRFFTeExRVUZCTUZRc1JVRkJRVEZVTEVWQlFVRnJXaXhIUVVGQkxFTkJSVUVzU1VGQlFUUkVMRVZCUVVFNVl5eEhRVUZCTEZOQlJVRXNTMEZCUVRKV0xFVkJRVUVzVTBGRlFYTklMRWRCUVVGcVpDeEhRVVZITEUxQlFVRkJMRWRCUVVGcldpeEhRVUZCZG1Jc1IwRkZTSGxtTEVWQlFVRXNVMEZCUVhCa0xFVkJRVUV5Vml4SFFVTkJMRWxCUVVGcVF5eEZRVUZCTVZRc1JVRkJRV3RhTEVkQlFVRXNRMEZGUVN4SlFVRkJORVFzUlVGQlFUbGpMRWRCUVVFc1VVRkZRU3hMUVVGQk1sWXNSVUZCUVN4UlFVVkJjMGdzUjBGQlFXcGtMRWRCUlVjc1RVRkJRVUVzUjBGQlFXdGFMRWRCUVVGblJTeEhRVWRJUnl4RlFVRkJMRk5CUVVGeVpDeEhRVVZCTEUxQlJFRXJZeXhKUVVGQlR5eEZRVUZCUXl4TlFVRkJWQ3hGUVVGQk9XTXNTMEZCUVRCVUxFVkJRVUV4VkN4RlFVRkJhMW9zU1VGQlFTdEVMRVZCUVVGcVpDeEhRVU5CUVN4SFFVVkJjMlFzUlVGQlFUZHFRaXhGUVVGQlJDeFRRVU5CTW1Zc1NVRkJRVVFzUlVGRFFYRkZMRTFCUVVFc1JVRkRRVW9zVlVGRFFVTXNWVUZEUVVNc1lXaEZiU3RHVFN4VFFVRlROV3BDTEVWQlFWRkVMRVZCUVZOTkxFZHBSWFJvUjJoRExFZEJRVUYzUnl4SFFVRkJlRWNzUlVGQlFTeEhRVU5CZVVjc1JVRkJRWHBITEVWQlFVRXNSMEZEUVRCYUxFVkJRVUV4V2l4RlFVRkJMRWxCUTBGM1ppeEZRVUZCZUdZc1JVRkJRU3hKUVVOQll5eEZRVUZCWkN4RlFVRkJMRWxCUVVGMVJ5eERRVU5CTlVjc1IwRkJRVVFzVVVGQlFTeFRRVUZCYjBnc1IwRkRRU3hIUVVGQmNWb3NSMEZCUVRGYUxFVkJRVUU0V0N4VFFVRkJPVmdzUlVGQlFUaFlMRTlCUVVFM1JTeExRVUV3Ukd4VUxFVkJRVUVyV0N4WFFVTXhSQ3hOUVVGQmVsZ3NSVUZCUVhGTUxFOUJRVUVzU1VGQlFYSk1MRWxCUVVGeFdpeEpRVUZCY21Zc1JVRkJRWEZtTEVWQlFVRnlXaXhIUVVGblJpOUdMRTFCUVVGNVpTeEZRVUZCYWxvc1JVRkJRVThzVDJwRk5taEhNVVVzVTBGQlUyNUlMRVZCUVZGRUxFVkJRVk5OTEVkclJYQnBSMmhETEVkQlFVRTRZeXhIUVVGQk9XTXNSVUZCUVN4SlFVTkJaMlFzUlVGQlFXaGtMRVZCUVVFc1IwRkRRVXdzUjBGQlFVUXNVVUZCUVN4VFFVRkJjVW9zUlVGQlFXcElMRWRCVFVFc1NVRk1RU3hIUVVsQlJDeEhRVXBCYzBnc1JVRkJRVFpVTEVWQlFVRnFWU3hIUVVOQmIxSXNSVUZCUVRKRExFVkJRVUV6VkN4SFFVTkJja1lzUlVGQlFYRlhMRVZCUVVGeVZ5eFBRVU5CTmtjc1JVRkJRU3hGUVVWQk4wY3NSVUZCUVRaSExFZEJRVUVzUjBGQlFYaENMRVZCUVVGMFNDeEZRVUZCYzFrc1JVRkJRWGhRTEZGQlFVRTNTU3hGUVVGQkxFMUJRVUZFTEV0c1JUSnBSMDBzVTBGQlUyeERMRVZCUVZGRUxFVkJRVk5OTEVkdFJXeHFSMmhETEVkQlFVRTRZeXhIUVVGQk9XTXNSVUZCUVN4SlFVTkJNR3BDTEVWQlFVRXhha0lzUlVGQlFTeEpRVU5CTW1wQ0xFVkJRVUV6YWtJc1JVRkJRU3hIUVVOQlRDeEhRVUZCUkN4UlFVRkJMRk5CUVVGM1J5eEhRVU5CTEVkQlFVRXlWeXhIUVVGQlF5eEZRVUZCTlZjc1IwRkRRVEJrTEVWQlFVRkdMRVZCUVVGdVpDeERRVU5CTEVsQlFVRnhaQ3hGUVV0QkxFbEJTa0VzUjBGSFFTOW9RaXhIUVVoQmRXZENMRVZCUVVGM1FpeEZRVUZCTVdRc1IwRkRRWGRoTEVWQlFVRnBSQ3hGUVVGQmNHUXNSVUZEUVRGRExFVkJRVUVzUlVGRlFYVmxMRVZCUVVGMFpTeFBRVUZCUkN4SFFVRkJObU1zUlVGQlFYSm5RaXhMUVVGQk5rWXNSVUZCUVhKRkxFVkJRVUYxWjBJc1JVRkJRWFpsTEU5QlFVRm5XaXhGUVVGQk9VMHNTMEZCUVd4UExFVkJRMGNzVDBGQlFXZGlMRXR1UlRCcVIwY3NVMEZCVTJ4a0xFVkJRVkZFTEVkdlJYWnJSM1pDUVN4RlFVRkJOa2NzUlVGQlFURkdMRTlCUVVFNGFFSXNkVUp3UlRaclIwMHNVMEZCVTJocVFpeEZRVUZSUkN4SGNVVTNhMGQyUWtFc1JVRkJRVFpITEV0QlFXTTRWeXh6UW5KRmJXeEhVaXhUUVVGVE1XUXNSVUZCVVVRc1JVRkJVMDBzUjNORmJHeEhhRU1zUjBGQlFXOWtMRWRCUVVGd1pDeEZRVUZCTEVkQlEwRk1MRWRCUVVGRUxGRkJRVUU0U3l4TlFVRkJiMVlzVTBGQlFTeFRRVUZCYVVVc1IwRkRRU3hsUVVGQmVrY3NSVUZCUVhsSExFdDBSVEJzUjAwc1UwRkJVMnhyUWl4RlFVRlJSQ3hGUVVGVFRTeEhkVVUxYkVkb1F5eEhRVUZCWjJRc1IwRkJRV2hrTEVWQlFVRXNTVUZEUVd0blFpeEZRVUZCYkdkQ0xFVkJRVUVzU1VGQlFYVkhMRVZCUTBGdFJDeExRVUZyUWtFc1UwRkZiRUp2WVN4RlFVRkJMR2RDUVVGQk5XVXNhVUpCUVVGeVJTeFBRVUZCTm1oQ0xHOUNRVU5CTjJoQ0xFOUJRVUUyYUVJc2IwSkJRVUY0WkN4WFFVVkJObVVzUlVGQlFTeFRRVUZCTjJRc1IwRkRRU3hKUVVOQkxFMUJRVUZuWVN4SFFVRkJhR0VzUjBGRFJ5eE5RVUZCYlVRc1IwRkRTQ3hOUVVGQmVXRXNSMEZCUVhaTExGTkJTVUUxV2l4SFFVRkJSQ3hSUVVGQk5rY3NSVUZCUVN4VFFVRkJUQ3hIUVVOQkxFMUJRVUUwWkN4SlFVRkJMRzFDUVVGQmNHRXNSVUZCUVhKS0xFdEJRVUUyUml4SFFVRkJObVFzUlVGQlFUZGtMRWRCUVVGbllTeEZRVUZCYkVRc1JVRkJRVGxYTEUxMlJYRnRSMDBzVTBGQlUzWkhMRVZCUVZGRUxFVkJRVk5OTEVkM1JYSnVSMmhETEVkQlFVRXJZeXhIUVVGQkwyTXNSVUZCUVN4SlFVTkJaMnRDTEVWQlFVRm9hMElzUlVGQlFTeEpRVUZCYTJVc1QwRkJRU3h4UWtGRlFYaGxMRWRCUVVFMlJ5eEZRVUZCTVVZc1QwRkJRVFpvUWl4eFFrRkJRU3hUUVVGQmRsb3NSMEZEUVN4TlFVRkJORlFzUjBGQlFUVlVMRVZCUVVFMllTeExlRVUyYmtkTkxGTkJRVk55YTBJc1JVRkJVVVFzUlVGQlUwMHNSM2xGYkc5SGFFTXNSMEZCUVRKcVFpeEhRVUZCTTJwQ0xFVkJRVUVzU1VGRFFUaEpMRVZCUVVFNVNTeEZRVUZCTEVsQlEwRm5aQ3hGUVVGQmFHUXNSVUZCUVN4SlFVTkJhMG9zUlVGQlFXeEtMRVZCUVVFc1NVRkRRVFJhTEVWQlFVRTFXaXhGUVVGQkxFbEJRMEZwU2l4RlFVRkJha29zUlVGQlFTeEpRVU5CYVdkQ0xFVkJRVUZ3Wml4UFFVRkJOR2hDTEhkQ1FVVkJMMmxDTEVkQlFVRTJSeXhGUVVGQmRrY3NSVUZCUVN4SlFVRkJhV2RDTEVWQlFVRXNVMEZCUVRsWExFVkJRVUUxUWl4SFFVZEJMRWRCUmtFMFFpeEZRVUZCTmxRc1JVRkJRVGRVTEVkQlEwRTFRaXhGUVVGQk1rSXNSVUZCUVROQ0xFZEJRVUVzUjBGRFFUQkNMRVZCUVVFc1NVRkRRU3hOUVVGQloxZ3NSMEZCUVRsWExFVkJRVUUxUWl4SFFVTkhMRTFCUVVFNFFpeEpRVU5JTEVkQlFVRjFVU3hGUVVGQmVsRXNSVUZCUVRWQ0xFZEJRVUVzVFVGQlFYVkNMRWxCUVVFMllTeEZRVUZCY0dRc1JVRkJRV3hITEV0QlFVRTRTU3hGUVVGQk5VSXNSMEZCUVRSQ0xFVkJRVUUxUWl4TmVrVjViMGROTEZOQlFWTTFTQ3hGUVVGUlJDeExRVTFxUWl4VFFVRlRReXhGUVVGUlJDeEZRVUZUVFN4SE1FVTNjRWRvUTBFc1JVRkJRU3h6UWpGRmJYRkhUU3hUUVVGVFRDeEZRVUZSUkN4RlFVRlRUU3hITWtWdWNVZG9RMEVzUlVGQlFTeHRRak5GZVhGSFRTeFRRVUZUVEN4RlFVRlJSQ3hGUVVGVFRTeEhRVVV2UWl4WlFXTkJMRk5CUVZOVExFZEJRWFZDUXl4SFFVRlBMRTFCUVU5QkxFbEJRVTlCTEVWQlFVbERMRmRCUVdGRUxFZEJRVkZGTEZGQlFWTkdMRWRCV25aR1J5eFBRVUZQUXl4bFFVRmxjRUlzUlVGQlV5eGpRVU0zUW5GQ0xFOUJRVThzUjBGSFZDeEpRVUZKUXl4SFFVRnRRbWhDTEVWQlFXOUNMRWRCUlhaRGFVSXNSVUZCYlVKU0xFVkJRWFZDVHl4SFFVVXhRMFVzUlVGQlowSnNRaXhGUVVGdlFpeEhRVVZ3UTIxQ0xFVkJRV2RDVml4RlFVRjFRbE1zUnpSRmRuSkhkRU1yYVVJc1JUVkZNbkpIVFN4WFFVTlVMRkZCUVZOQkxFMUJRMUFzUlVGQlNXaHFRaXhGUVVGcFFrd3NVMEZCVTJRc1MwRkJUVzFyUWl4SFFXdENkRU1zVDBGbVFTeEZRVUZKT1dsQ0xFVkJRV05RTEZOQlFWTnhha0lzUlVGQlRTeFBRVU12UW5CcFFpeEpRVUZMTEdWQlEweGtMRTFCUVU4c1V6UkZhbk5IVlRKUUxFVkJRVTEzVkN4SFFVTjRRaXhIUVVGSlF5eEhRVUZUYUdoQ0xGTkJRVk5ETEdOQlFXTXNVMEZKY0VNc1QwRklRU3RuUWl4SFFVRlBibWhDTEUxQlFWRXdUaXhGUVVObWVWUXNSVUZCVDJ4b1FpeFBRVUZUZVU0c1JVRkRhRUo1VkN4RlFVRlBPV2RDTEZkQlFWY3NUVUZCVFVNc1ZVRkJWVFJuUWl4RlFVRlBMRVZCUVVjc1JVRkJSM2hVTEVWQlFVMUJMRWRCUXpsRGVWUXNTelZGYjNOSFRuUnBRaXhKUVVGTExGbEJRMHhrTEUxQlFVOHNVelJGYkhOSFR6Uk1MRVZCUVVkNVdDeEZRVUZIY0dNc1JVRkJSMnBJTEVkQlEzaENMRTFCUVZFc1RVRkJUelJNTEVWQlFVa3NUVUZCVDNsWUxFVkJRVWtzVFVGQlQzQmpMRWRCUVV0cVNDeEZRVUZUTEVsQlFVMHNUVFZGY1hOSGJrUnJha0lzU1VGSFZIWnJRaXhIUVVGUmEwSXNVVFJGY0hOSFRYRnFRaUlzSW1acGJHVWlPaUp4WVhKMExtMXBiaTVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpaG1kVzVqZEdsdmJpQjNaV0p3WVdOclZXNXBkbVZ5YzJGc1RXOWtkV3hsUkdWbWFXNXBkR2x2YmloeWIyOTBMQ0JtWVdOMGIzSjVLU0I3WEc1Y2RHbG1LSFI1Y0dWdlppQmxlSEJ2Y25SeklEMDlQU0FuYjJKcVpXTjBKeUFtSmlCMGVYQmxiMllnYlc5a2RXeGxJRDA5UFNBbmIySnFaV04wSnlsY2JseDBYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1poWTNSdmNua29LVHRjYmx4MFpXeHpaU0JwWmloMGVYQmxiMllnWkdWbWFXNWxJRDA5UFNBblpuVnVZM1JwYjI0bklDWW1JR1JsWm1sdVpTNWhiV1FwWEc1Y2RGeDBaR1ZtYVc1bEtGdGRMQ0JtWVdOMGIzSjVLVHRjYmx4MFpXeHpaU0JwWmloMGVYQmxiMllnWlhod2IzSjBjeUE5UFQwZ0oyOWlhbVZqZENjcFhHNWNkRngwWlhod2IzSjBjMXRjSW5GaGNuUmNJbDBnUFNCbVlXTjBiM0o1S0NrN1hHNWNkR1ZzYzJWY2JseDBYSFJ5YjI5MFcxd2ljV0Z5ZEZ3aVhTQTlJR1poWTNSdmNua29LVHRjYm4wcEtIUm9hWE1zSUdaMWJtTjBhVzl1S0NrZ2UxeHVjbVYwZFhKdUlGeHVYRzVjYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTSUM4dlhHNHZMeUIzWldKd1lXTnJMM1Z1YVhabGNuTmhiRTF2WkhWc1pVUmxabWx1YVhScGIyNGlMQ0lvWm5WdVkzUnBiMjRnZDJWaWNHRmphMVZ1YVhabGNuTmhiRTF2WkhWc1pVUmxabWx1YVhScGIyNG9jbTl2ZEN3Z1ptRmpkRzl5ZVNrZ2UxeHVYSFJwWmloMGVYQmxiMllnWlhod2IzSjBjeUE5UFQwZ0oyOWlhbVZqZENjZ0ppWWdkSGx3Wlc5bUlHMXZaSFZzWlNBOVBUMGdKMjlpYW1WamRDY3BYRzVjZEZ4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbVlXTjBiM0o1S0NrN1hHNWNkR1ZzYzJVZ2FXWW9kSGx3Wlc5bUlHUmxabWx1WlNBOVBUMGdKMloxYm1OMGFXOXVKeUFtSmlCa1pXWnBibVV1WVcxa0tWeHVYSFJjZEdSbFptbHVaU2hiWFN3Z1ptRmpkRzl5ZVNrN1hHNWNkR1ZzYzJVZ2FXWW9kSGx3Wlc5bUlHVjRjRzl5ZEhNZ1BUMDlJQ2R2WW1wbFkzUW5LVnh1WEhSY2RHVjRjRzl5ZEhOYlhDSnhZWEowWENKZElEMGdabUZqZEc5eWVTZ3BPMXh1WEhSbGJITmxYRzVjZEZ4MGNtOXZkRnRjSW5GaGNuUmNJbDBnUFNCbVlXTjBiM0o1S0NrN1hHNTlLU2gwYUdsekxDQm1kVzVqZEdsdmJpZ3BJSHRjYm5KbGRIVnliaUF2S2lvcUtpb3FMeUFvWm5WdVkzUnBiMjRvYlc5a2RXeGxjeWtnZXlBdkx5QjNaV0p3WVdOclFtOXZkSE4wY21Gd1hHNHZLaW9xS2lvcUx5QmNkQzh2SUZSb1pTQnRiMlIxYkdVZ1kyRmphR1ZjYmk4cUtpb3FLaW92SUZ4MGRtRnlJR2x1YzNSaGJHeGxaRTF2WkhWc1pYTWdQU0I3ZlR0Y2JpOHFLaW9xS2lvdlhHNHZLaW9xS2lvcUx5QmNkQzh2SUZSb1pTQnlaWEYxYVhKbElHWjFibU4wYVc5dVhHNHZLaW9xS2lvcUx5QmNkR1oxYm1OMGFXOXVJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvYlc5a2RXeGxTV1FwSUh0Y2JpOHFLaW9xS2lvdlhHNHZLaW9xS2lvcUx5QmNkRngwTHk4Z1EyaGxZMnNnYVdZZ2JXOWtkV3hsSUdseklHbHVJR05oWTJobFhHNHZLaW9xS2lvcUx5QmNkRngwYVdZb2FXNXpkR0ZzYkdWa1RXOWtkV3hsYzF0dGIyUjFiR1ZKWkYwcFhHNHZLaW9xS2lvcUx5QmNkRngwWEhSeVpYUjFjbTRnYVc1emRHRnNiR1ZrVFc5a2RXeGxjMXR0YjJSMWJHVkpaRjB1Wlhod2IzSjBjenRjYmk4cUtpb3FLaW92WEc0dktpb3FLaW9xTHlCY2RGeDBMeThnUTNKbFlYUmxJR0VnYm1WM0lHMXZaSFZzWlNBb1lXNWtJSEIxZENCcGRDQnBiblJ2SUhSb1pTQmpZV05vWlNsY2JpOHFLaW9xS2lvdklGeDBYSFIyWVhJZ2JXOWtkV3hsSUQwZ2FXNXpkR0ZzYkdWa1RXOWtkV3hsYzF0dGIyUjFiR1ZKWkYwZ1BTQjdYRzR2S2lvcUtpb3FMeUJjZEZ4MFhIUmxlSEJ2Y25Sek9pQjdmU3hjYmk4cUtpb3FLaW92SUZ4MFhIUmNkR2xrT2lCdGIyUjFiR1ZKWkN4Y2JpOHFLaW9xS2lvdklGeDBYSFJjZEd4dllXUmxaRG9nWm1Gc2MyVmNiaThxS2lvcUtpb3ZJRngwWEhSOU8xeHVMeW9xS2lvcUtpOWNiaThxS2lvcUtpb3ZJRngwWEhRdkx5QkZlR1ZqZFhSbElIUm9aU0J0YjJSMWJHVWdablZ1WTNScGIyNWNiaThxS2lvcUtpb3ZJRngwWEhSdGIyUjFiR1Z6VzIxdlpIVnNaVWxrWFM1allXeHNLRzF2WkhWc1pTNWxlSEJ2Y25SekxDQnRiMlIxYkdVc0lHMXZaSFZzWlM1bGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktUdGNiaThxS2lvcUtpb3ZYRzR2S2lvcUtpb3FMeUJjZEZ4MEx5OGdSbXhoWnlCMGFHVWdiVzlrZFd4bElHRnpJR3h2WVdSbFpGeHVMeW9xS2lvcUtpOGdYSFJjZEcxdlpIVnNaUzVzYjJGa1pXUWdQU0IwY25WbE8xeHVMeW9xS2lvcUtpOWNiaThxS2lvcUtpb3ZJRngwWEhRdkx5QlNaWFIxY200Z2RHaGxJR1Y0Y0c5eWRITWdiMllnZEdobElHMXZaSFZzWlZ4dUx5b3FLaW9xS2k4Z1hIUmNkSEpsZEhWeWJpQnRiMlIxYkdVdVpYaHdiM0owY3p0Y2JpOHFLaW9xS2lvdklGeDBmVnh1THlvcUtpb3FLaTljYmk4cUtpb3FLaW92WEc0dktpb3FLaW9xTHlCY2RDOHZJR1Y0Y0c5elpTQjBhR1VnYlc5a2RXeGxjeUJ2WW1wbFkzUWdLRjlmZDJWaWNHRmphMTl0YjJSMWJHVnpYMThwWEc0dktpb3FLaW9xTHlCY2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHViU0E5SUcxdlpIVnNaWE03WEc0dktpb3FLaW9xTDF4dUx5b3FLaW9xS2k4Z1hIUXZMeUJsZUhCdmMyVWdkR2hsSUcxdlpIVnNaU0JqWVdOb1pWeHVMeW9xS2lvcUtpOGdYSFJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG1NZ1BTQnBibk4wWVd4c1pXUk5iMlIxYkdWek8xeHVMeW9xS2lvcUtpOWNiaThxS2lvcUtpb3ZJRngwTHk4Z1gxOTNaV0p3WVdOclgzQjFZbXhwWTE5d1lYUm9YMTljYmk4cUtpb3FLaW92SUZ4MFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NXdJRDBnWENJdUxpOWthWE4wTDF3aU8xeHVMeW9xS2lvcUtpOWNiaThxS2lvcUtpb3ZJRngwTHk4Z1RHOWhaQ0JsYm5SeWVTQnRiMlIxYkdVZ1lXNWtJSEpsZEhWeWJpQmxlSEJ2Y25SelhHNHZLaW9xS2lvcUx5QmNkSEpsZEhWeWJpQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLREFwTzF4dUx5b3FLaW9xS2k4Z2ZTbGNiaThxS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW92WEc0dktpb3FLaW9xTHlBb1cxeHVMeW9nTUNBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MEozVnpaU0J6ZEhKcFkzUW5PMXh1WEhSY2JseDBUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0dWNGNHOXlkSE1zSUZ3aVgxOWxjMDF2WkhWc1pWd2lMQ0I3WEc1Y2RDQWdJQ0IyWVd4MVpUb2dkSEoxWlZ4dVhIUjlLVHRjYmx4MFhHNWNkSFpoY2lCZlkyeGhjM05EWVd4c1EyaGxZMnN5SUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3hLVHRjYmx4MFhHNWNkSFpoY2lCZlkyeGhjM05EWVd4c1EyaGxZMnN6SUQwZ1gybHVkR1Z5YjNCU1pYRjFhWEpsUkdWbVlYVnNkQ2hmWTJ4aGMzTkRZV3hzUTJobFkyc3lLVHRjYmx4MFhHNWNkSFpoY2lCZlkzSmxZWFJsUTJ4aGMzTXlJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlneUtUdGNibHgwWEc1Y2RIWmhjaUJmWTNKbFlYUmxRMnhoYzNNeklEMGdYMmx1ZEdWeWIzQlNaWEYxYVhKbFJHVm1ZWFZzZENoZlkzSmxZWFJsUTJ4aGMzTXlLVHRjYmx4MFhHNWNkSFpoY2lCZmNYSmpiMlJsSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3lNU2s3WEc1Y2RGeHVYSFIyWVhJZ1gzVjBhV3dnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktEYzFLVHRjYmx4MFhHNWNkSFpoY2lCZmRYUnBiRElnUFNCZmFXNTBaWEp2Y0ZKbGNYVnBjbVZFWldaaGRXeDBLRjkxZEdsc0tUdGNibHgwWEc1Y2RHWjFibU4wYVc5dUlGOXBiblJsY205d1VtVnhkV2x5WlVSbFptRjFiSFFvYjJKcUtTQjdJSEpsZEhWeWJpQnZZbW9nSmlZZ2IySnFMbDlmWlhOTmIyUjFiR1VnUHlCdlltb2dPaUI3SUdSbFptRjFiSFE2SUc5aWFpQjlPeUI5WEc1Y2RGeHVYSFIyWVhJZ1VVRnlkQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNibHgwSUNBZ0lHWjFibU4wYVc5dUlGRkJjblFvYjNCMGFXOXVjeWtnZTF4dVhIUWdJQ0FnSUNBZ0lDZ3dMQ0JmWTJ4aGMzTkRZV3hzUTJobFkyc3pMbVJsWm1GMWJIUXBLSFJvYVhNc0lGRkJjblFwTzF4dVhIUmNibHgwSUNBZ0lDQWdJQ0JwWmlBb2RIbHdaVzltSUc5d2RHbHZibk1nUFQwOUlDZDFibVJsWm1sdVpXUW5LU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjFGQmNuUWdjbVZ4ZFdseVpXUWdZRzl3ZEdsdmJuTmdMaWNwTzF4dVhIUWdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9kSGx3Wlc5bUlHOXdkR2x2Ym5NdWRtRnNkV1VnUFQwOUlDZDFibVJsWm1sdVpXUW5LU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjFGQmNuUWdjbVZ4ZFdseVpXUWdZSFpoYkhWbFlDQnZjSFJwYjI0dUp5azdYRzVjZENBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllnYjNCMGFXOXVjeTVwYldGblpWQmhkR2dnUFQwOUlDZDFibVJsWm1sdVpXUW5LU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjFGQmNuUWdjbVZ4ZFdseVpXUWdZR2x0WVdkbFVHRjBhR0FnYjNCMGFXOXVMaWNwTzF4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUNBZ2RHaHBjeTVtYVd4MFpYSWdQU0IwZVhCbGIyWWdiM0IwYVc5dWN5NW1hV3gwWlhJZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z1VVRnlkQzVFUlVaQlZVeFVVeTVtYVd4MFpYSWdPaUJ2Y0hScGIyNXpMbVpwYkhSbGNqdGNibHgwSUNBZ0lDQWdJQ0IwYUdsekxuWmhiSFZsSUQwZ2IzQjBhVzl1Y3k1MllXeDFaVHRjYmx4MElDQWdJQ0FnSUNCMGFHbHpMbWx0WVdkbFVHRjBhQ0E5SUc5d2RHbHZibk11YVcxaFoyVlFZWFJvTzF4dVhIUWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDZ3dMQ0JmWTNKbFlYUmxRMnhoYzNNekxtUmxabUYxYkhRcEtGRkJjblFzSUZ0N1hHNWNkQ0FnSUNBZ0lDQWdhMlY1T2lBbmJXRnJaU2NzWEc1Y2RDQWdJQ0FnSUNBZ2RtRnNkV1U2SUdaMWJtTjBhVzl1SUcxaGEyVW9aV3dwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlHbHRZV2RsVTJsNlpTQTlJREU1TlR0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlIQmhaR1JwYm1jZ1BTQXhNanRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUd4bGRtVnNJRDBnTVRBN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQjJZWElnY1hJZ1BTQW9NQ3dnWDNGeVkyOWtaUzVSVWtOdlpHVXBLR3hsZG1Wc0xDQW5TQ2NwTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0J4Y2k1aFpHUkVZWFJoS0hSb2FYTXVkbUZzZFdVcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCeGNpNXRZV3RsS0NrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQnhja2x0WVdkbElEMGdjWEl1WTNKbFlYUmxTVzFuVDJKcVpXTjBLRE1wTzF4dVhIUmNibHgwSUNBZ0lDQWdJQ0FnSUNBZ2RtRnlJSE5sYkdZZ1BTQjBhR2x6TzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0J4Y2tsdFlXZGxMbTl1Ykc5aFpDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUJqYjNabGNrbHRZV2RsSUQwZ2JtVjNJRWx0WVdkbEtDazdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjNabGNrbHRZV2RsTG5OeVl5QTlJSE5sYkdZdWFXMWhaMlZRWVhSb08xeHVYSFJjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQnlaWE4xYkhSRFlXNTJZWE1nUFNCZmRYUnBiREl1WkdWbVlYVnNkQzVqY21WaGRHVkRZVzUyWVhNb2FXMWhaMlZUYVhwbExDQnhja2x0WVdkbEtUdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCeGNrTmhiblpoY3lBOUlGOTFkR2xzTWk1a1pXWmhkV3gwTG1OeVpXRjBaVU5oYm5aaGN5aHBiV0ZuWlZOcGVtVXNJSEZ5U1cxaFoyVXBPMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZkbVZ5U1cxaFoyVXViMjVzYjJGa0lEMGdablZ1WTNScGIyNGdLQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoamIzWmxja2x0WVdkbExuZHBaSFJvSUR3Z1kyOTJaWEpKYldGblpTNW9aV2xuYUhRcElIdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjkyWlhKSmJXRm5aUzVvWldsbmFIUWdQU0FvYVcxaFoyVlRhWHBsSUMwZ2NHRmtaR2x1WnlBcUlESXBJQ29nS0RFdU1DQXFJR052ZG1WeVNXMWhaMlV1YUdWcFoyaDBJQzhnWTI5MlpYSkpiV0ZuWlM1M2FXUjBhQ2s3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmRtVnlTVzFoWjJVdWQybGtkR2dnUFNCcGJXRm5aVk5wZW1VZ0xTQndZV1JrYVc1bklDb2dNanRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiM1psY2tsdFlXZGxMbmRwWkhSb0lEMGdLR2x0WVdkbFUybDZaU0F0SUhCaFpHUnBibWNnS2lBeUtTQXFJQ2d4TGpBZ0tpQmpiM1psY2tsdFlXZGxMbmRwWkhSb0lDOGdZMjkyWlhKSmJXRm5aUzVvWldsbmFIUXBPMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjNabGNrbHRZV2RsTG1obGFXZG9kQ0E5SUdsdFlXZGxVMmw2WlNBdElIQmhaR1JwYm1jZ0tpQXlPMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUdOdmRtVnlRMkZ1ZG1GeklEMGdaRzlqZFcxbGJuUXVZM0psWVhSbFJXeGxiV1Z1ZENnblkyRnVkbUZ6SnlrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5MlpYSkRZVzUyWVhNdWQybGtkR2dnUFNCcGJXRm5aVk5wZW1VN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5MlpYSkRZVzUyWVhNdWFHVnBaMmgwSUQwZ2FXMWhaMlZUYVhwbE8xeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmRtVnlRMkZ1ZG1GekxtZGxkRU52Ym5SbGVIUW9KekprSnlrdVpISmhkMGx0WVdkbEtHTnZkbVZ5U1cxaFoyVXNJSEJoWkdScGJtY3NJSEJoWkdScGJtY3NJR2x0WVdkbFUybDZaU0F0SUhCaFpHUnBibWNnS2lBeUxDQnBiV0ZuWlZOcGVtVWdMU0J3WVdSa2FXNW5JQ29nTWlrN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUJqYjNabGNrbHRZV2RsUkdGMFlTQTlJR052ZG1WeVEyRnVkbUZ6TG1kbGRFTnZiblJsZUhRb0p6SmtKeWt1WjJWMFNXMWhaMlZFWVhSaEtEQXNJREFzSUdsdFlXZGxVMmw2WlN3Z2FXMWhaMlZUYVhwbEtUdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMllYSWdZMjkyWlhKSmJXRm5aVUpwYm1GeWVTQTlJR052ZG1WeVNXMWhaMlZFWVhSaExtUmhkR0U3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbGMzVnNkRWx0WVdkbFJHRjBZU0E5SUhKbGMzVnNkRU5oYm5aaGN5NW5aWFJEYjI1MFpYaDBLQ2N5WkNjcExtZGxkRWx0WVdkbFJHRjBZU2d3TENBd0xDQnBiV0ZuWlZOcGVtVXNJR2x0WVdkbFUybDZaU2s3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbGMzVnNkRWx0WVdkbFFtbHVZWEo1SUQwZ2NtVnpkV3gwU1cxaFoyVkVZWFJoTG1SaGRHRTdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWTI5MlpYSkpiV0ZuWlVKcGJtRnllUzVzWlc1bmRHZzdJR2tnS3owZ05Da2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2VDQTlJRTFoZEdndVpteHZiM0lvYVNBdklEUXBJQ1VnYVcxaFoyVlRhWHBsTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMllYSWdlU0E5SUUxaGRHZ3VabXh2YjNJb1RXRjBhQzVtYkc5dmNpaHBJQzhnTkNrZ0x5QnBiV0ZuWlZOcGVtVXBPMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSGdnUENCd1lXUmthVzVuSUh4OElIa2dQQ0J3WVdSa2FXNW5JSHg4SUhnZ1BqMGdhVzFoWjJWVGFYcGxJQzBnY0dGa1pHbHVaeUI4ZkNCNUlENDlJR2x0WVdkbFUybDZaU0F0SUhCaFpHUnBibWNwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RFbHRZV2RsUW1sdVlYSjVXMmtnS3lBelhTQTlJREE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjUwYVc1MVpUdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2VDQWxJRE1nUFQwZ01TQW1KaUI1SUNVZ015QTlQU0F4S1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9lQ0E4SURNMklDWW1JQ2g1SUR3Z016WWdmSHdnZVNBK1BTQnBiV0ZuWlZOcGVtVWdMU0F6TmlrcElIdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuUnBiblZsTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2g0SUQ0OUlHbHRZV2RsVTJsNlpTQXRJRE0ySUNZbUlIa2dQQ0F6TmlrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHbHVkV1U3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JseDBYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoelpXeG1MbVpwYkhSbGNpQTlQU0FuZEdoeVpYTm9iMnhrSnlrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlHWmhZM1J2Y2lBOUlGOTFkR2xzTWk1a1pXWmhkV3gwTG5Sb2NtVnphRzlzWkNoamIzWmxja2x0WVdkbFFtbHVZWEo1VzJsZExDQmpiM1psY2tsdFlXZGxRbWx1WVhKNVcya2dLeUF4WFN3Z1kyOTJaWEpKYldGblpVSnBibUZ5ZVZ0cElDc2dNbDBzSURFeU55azdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYTjFiSFJKYldGblpVSnBibUZ5ZVZ0cFhTQTlJR1poWTNSdmNqdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGMzVnNkRWx0WVdkbFFtbHVZWEo1VzJrZ0t5QXhYU0E5SUdaaFkzUnZjanRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEVsdFlXZGxRbWx1WVhKNVcya2dLeUF5WFNBOUlHWmhZM1J2Y2p0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHpaV3htTG1acGJIUmxjaUE5UFNBblkyOXNiM0luS1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUkpiV0ZuWlVKcGJtRnllVnRwWFNBOUlHTnZkbVZ5U1cxaFoyVkNhVzVoY25sYmFWMDdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYTjFiSFJKYldGblpVSnBibUZ5ZVZ0cElDc2dNVjBnUFNCamIzWmxja2x0WVdkbFFtbHVZWEo1VzJrZ0t5QXhYVHRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEVsdFlXZGxRbWx1WVhKNVcya2dLeUF5WFNBOUlHTnZkbVZ5U1cxaFoyVkNhVzVoY25sYmFTQXJJREpkTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEVsdFlXZGxRbWx1WVhKNVcya2dLeUF6WFNBOUlHTnZkbVZ5U1cxaFoyVkNhVzVoY25sYmFTQXJJRE5kTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBRMkZ1ZG1GekxtZGxkRU52Ym5SbGVIUW9KekprSnlrdWNIVjBTVzFoWjJWRVlYUmhLSEpsYzNWc2RFbHRZV2RsUkdGMFlTd2dNQ3dnTUNrN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUJ3WVhSMFpYSnVVRzl6ZEdsdmJpQTlJRjl4Y21OdlpHVXVVVkpWZEdsc0xtZGxkRkJoZEhSbGNtNVFiM05wZEdsdmJpaHNaWFpsYkNrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCd1lYUjBaWEp1VUc5emRHbHZiaTVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJxSUQwZ01Ec2dhaUE4SUhCaGRIUmxjbTVRYjNOMGFXOXVMbXhsYm1kMGFEc2dhaUFyUFNBeEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMllYSWdlQ0E5SUhCaGRIUmxjbTVRYjNOMGFXOXVXMmxkTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUhrZ1BTQndZWFIwWlhKdVVHOXpkR2x2Ymx0cVhUdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDZ2hLSGdnUFQwZ05pQW1KaUI1SUQwOUlEVXdJSHg4SUhrZ1BUMGdOaUFtSmlCNElEMDlJRFV3SUh4OElIZ2dQVDBnTmlBbUppQjVJRDA5SURZcEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbFkzUllJRDBnTXlBcUlDaDRJQzBnTWlrZ0t5QXhNanRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2NtVmpkRmtnUFNBeklDb2dLSGtnTFNBeUtTQXJJREV5TzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQnlaV04wVjJsa2RHZ2dQU0F6SUNvZ0tIZ2dLeUF6S1NBcklERXlJQzBnY21WamRGZzdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbFkzUklaV2xuYUhRZ1BTQXpJQ29nS0hrZ0t5QXpLU0FySURFeUlDMGdjbVZqZEZrN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCeVpXTjBSR0YwWVNBOUlIRnlRMkZ1ZG1GekxtZGxkRU52Ym5SbGVIUW9KekprSnlrdVoyVjBTVzFoWjJWRVlYUmhLSEpsWTNSWUxDQnlaV04wV1N3Z2NtVmpkRmRwWkhSb0xDQnlaV04wU0dWcFoyaDBLVHRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUkRZVzUyWVhNdVoyVjBRMjl1ZEdWNGRDZ25NbVFuS1M1d2RYUkpiV0ZuWlVSaGRHRW9jbVZqZEVSaGRHRXNJSEpsWTNSWUxDQnlaV04wV1NrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdWc0xtbHVibVZ5U0ZSTlRDQTlJQ2NuTzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1ZzTG1Gd2NHVnVaRU5vYVd4a0tISmxjM1ZzZEVOaGJuWmhjeWs3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVYSFFnSUNBZ0lDQWdJSDFjYmx4MElDQWdJSDFkTENCYmUxeHVYSFFnSUNBZ0lDQWdJR3RsZVRvZ0owUkZSa0ZWVEZSVEp5eGNibHgwSUNBZ0lDQWdJQ0JuWlhRNklHWjFibU4wYVc5dUlHZGxkQ2dwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSHRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGJIVmxPaUFuSnl4Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHWnBiSFJsY2pvZ0ozUm9jbVZ6YUc5c1pDZGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ2ZUdGNibHgwSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0I5WFNrN1hHNWNkQ0FnSUNCeVpYUjFjbTRnVVVGeWREdGNibHgwZlNncE8xeHVYSFJjYmx4MGQybHVaRzkzTGxGQmNuUWdQU0JSUVhKME8xeHVYSFJsZUhCdmNuUnpMbVJsWm1GMWJIUWdQU0IzYVc1a2IzY3VVVUZ5ZER0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURFZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3lrZ2UxeHVYRzVjZEZ3aWRYTmxJSE4wY21samRGd2lPMXh1WEhSY2JseDBaWGh3YjNKMGN5NWZYMlZ6VFc5a2RXeGxJRDBnZEhKMVpUdGNibHgwWEc1Y2RHVjRjRzl5ZEhNdVpHVm1ZWFZzZENBOUlHWjFibU4wYVc5dUlDaHBibk4wWVc1alpTd2dRMjl1YzNSeWRXTjBiM0lwSUh0Y2JseDBJQ0JwWmlBb0lTaHBibk4wWVc1alpTQnBibk4wWVc1alpXOW1JRU52Ym5OMGNuVmpkRzl5S1NrZ2UxeHVYSFFnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpaGNJa05oYm01dmRDQmpZV3hzSUdFZ1kyeGhjM01nWVhNZ1lTQm1kVzVqZEdsdmJsd2lLVHRjYmx4MElDQjlYRzVjZEgwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBeUlDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseDBYRzVjZEdWNGNHOXlkSE11WDE5bGMwMXZaSFZzWlNBOUlIUnlkV1U3WEc1Y2RGeHVYSFIyWVhJZ1gyUmxabWx1WlZCeWIzQmxjblI1SUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3pLVHRjYmx4MFhHNWNkSFpoY2lCZlpHVm1hVzVsVUhKdmNHVnlkSGt5SUQwZ1gybHVkR1Z5YjNCU1pYRjFhWEpsUkdWbVlYVnNkQ2hmWkdWbWFXNWxVSEp2Y0dWeWRIa3BPMXh1WEhSY2JseDBablZ1WTNScGIyNGdYMmx1ZEdWeWIzQlNaWEYxYVhKbFJHVm1ZWFZzZENodlltb3BJSHNnY21WMGRYSnVJRzlpYWlBbUppQnZZbW91WDE5bGMwMXZaSFZzWlNBL0lHOWlhaUE2SUhzZ1pHVm1ZWFZzZERvZ2IySnFJSDA3SUgxY2JseDBYRzVjZEdWNGNHOXlkSE11WkdWbVlYVnNkQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNibHgwSUNCbWRXNWpkR2x2YmlCa1pXWnBibVZRY205d1pYSjBhV1Z6S0hSaGNtZGxkQ3dnY0hKdmNITXBJSHRjYmx4MElDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnY0hKdmNITXViR1Z1WjNSb095QnBLeXNwSUh0Y2JseDBJQ0FnSUNBZ2RtRnlJR1JsYzJOeWFYQjBiM0lnUFNCd2NtOXdjMXRwWFR0Y2JseDBJQ0FnSUNBZ1pHVnpZM0pwY0hSdmNpNWxiblZ0WlhKaFlteGxJRDBnWkdWelkzSnBjSFJ2Y2k1bGJuVnRaWEpoWW14bElIeDhJR1poYkhObE8xeHVYSFFnSUNBZ0lDQmtaWE5qY21sd2RHOXlMbU52Ym1acFozVnlZV0pzWlNBOUlIUnlkV1U3WEc1Y2RDQWdJQ0FnSUdsbUlDaGNJblpoYkhWbFhDSWdhVzRnWkdWelkzSnBjSFJ2Y2lrZ1pHVnpZM0pwY0hSdmNpNTNjbWwwWVdKc1pTQTlJSFJ5ZFdVN1hHNWNkQ0FnSUNBZ0lDZ3dMQ0JmWkdWbWFXNWxVSEp2Y0dWeWRIa3lMbVJsWm1GMWJIUXBLSFJoY21kbGRDd2daR1Z6WTNKcGNIUnZjaTVyWlhrc0lHUmxjMk55YVhCMGIzSXBPMXh1WEhRZ0lDQWdmVnh1WEhRZ0lIMWNibHgwWEc1Y2RDQWdjbVYwZFhKdUlHWjFibU4wYVc5dUlDaERiMjV6ZEhKMVkzUnZjaXdnY0hKdmRHOVFjbTl3Y3l3Z2MzUmhkR2xqVUhKdmNITXBJSHRjYmx4MElDQWdJR2xtSUNod2NtOTBiMUJ5YjNCektTQmtaV1pwYm1WUWNtOXdaWEowYVdWektFTnZibk4wY25WamRHOXlMbkJ5YjNSdmRIbHdaU3dnY0hKdmRHOVFjbTl3Y3lrN1hHNWNkQ0FnSUNCcFppQW9jM1JoZEdsalVISnZjSE1wSUdSbFptbHVaVkJ5YjNCbGNuUnBaWE1vUTI5dWMzUnlkV04wYjNJc0lITjBZWFJwWTFCeWIzQnpLVHRjYmx4MElDQWdJSEpsZEhWeWJpQkRiMjV6ZEhKMVkzUnZjanRjYmx4MElDQjlPMXh1WEhSOUtDazdYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQXpJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwSUh0Y2JseHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSHNnWENKa1pXWmhkV3gwWENJNklGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OQ2tzSUY5ZlpYTk5iMlIxYkdVNklIUnlkV1VnZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURRZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OU2s3WEc1Y2RIWmhjaUFrVDJKcVpXTjBJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnNEtTNVBZbXBsWTNRN1hHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdaR1ZtYVc1bFVISnZjR1Z5ZEhrb2FYUXNJR3RsZVN3Z1pHVnpZeWw3WEc1Y2RDQWdjbVYwZFhKdUlDUlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvYVhRc0lHdGxlU3dnWkdWell5azdYRzVjZEgwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBMUlDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUjJZWElnSkdWNGNHOXlkQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05pazdYRzVjZEM4dklERTVMakV1TWk0MElDOGdNVFV1TWk0ekxqWWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0U4c0lGQXNJRUYwZEhKcFluVjBaWE1wWEc1Y2RDUmxlSEJ2Y25Rb0pHVjRjRzl5ZEM1VElDc2dKR1Y0Y0c5eWRDNUdJQ29nSVY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01UWXBMQ0FuVDJKcVpXTjBKeXdnZTJSbFptbHVaVkJ5YjNCbGNuUjVPaUJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RFeUtTNW1mU2s3WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUEySUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSMllYSWdaMnh2WW1Gc0lDQWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnM0tWeHVYSFFnSUN3Z1kyOXlaU0FnSUNBZ0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWc0S1Z4dVhIUWdJQ3dnWTNSNElDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzVLVnh1WEhRZ0lDd2dhR2xrWlNBZ0lDQWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlneE1TbGNibHgwSUNBc0lGQlNUMVJQVkZsUVJTQTlJQ2R3Y205MGIzUjVjR1VuTzF4dVhIUmNibHgwZG1GeUlDUmxlSEJ2Y25RZ1BTQm1kVzVqZEdsdmJpaDBlWEJsTENCdVlXMWxMQ0J6YjNWeVkyVXBlMXh1WEhRZ0lIWmhjaUJKVTE5R1QxSkRSVVFnUFNCMGVYQmxJQ1lnSkdWNGNHOXlkQzVHWEc1Y2RDQWdJQ0FzSUVsVFgwZE1UMEpCVENBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtkY2JseDBJQ0FnSUN3Z1NWTmZVMVJCVkVsRElEMGdkSGx3WlNBbUlDUmxlSEJ2Y25RdVUxeHVYSFFnSUNBZ0xDQkpVMTlRVWs5VVR5QWdQU0IwZVhCbElDWWdKR1Y0Y0c5eWRDNVFYRzVjZENBZ0lDQXNJRWxUWDBKSlRrUWdJQ0E5SUhSNWNHVWdKaUFrWlhod2IzSjBMa0pjYmx4MElDQWdJQ3dnU1ZOZlYxSkJVQ0FnSUQwZ2RIbHdaU0FtSUNSbGVIQnZjblF1VjF4dVhIUWdJQ0FnTENCbGVIQnZjblJ6SUNBZ1BTQkpVMTlIVEU5Q1FVd2dQeUJqYjNKbElEb2dZMjl5WlZ0dVlXMWxYU0I4ZkNBb1kyOXlaVnR1WVcxbFhTQTlJSHQ5S1Z4dVhIUWdJQ0FnTENCbGVIQlFjbTkwYnlBZ1BTQmxlSEJ2Y25SelcxQlNUMVJQVkZsUVJWMWNibHgwSUNBZ0lDd2dkR0Z5WjJWMElDQWdJRDBnU1ZOZlIweFBRa0ZNSUQ4Z1oyeHZZbUZzSURvZ1NWTmZVMVJCVkVsRElEOGdaMnh2WW1Gc1cyNWhiV1ZkSURvZ0tHZHNiMkpoYkZ0dVlXMWxYU0I4ZkNCN2ZTbGJVRkpQVkU5VVdWQkZYVnh1WEhRZ0lDQWdMQ0JyWlhrc0lHOTNiaXdnYjNWME8xeHVYSFFnSUdsbUtFbFRYMGRNVDBKQlRDbHpiM1Z5WTJVZ1BTQnVZVzFsTzF4dVhIUWdJR1p2Y2loclpYa2dhVzRnYzI5MWNtTmxLWHRjYmx4MElDQWdJQzh2SUdOdmJuUmhhVzV6SUdsdUlHNWhkR2wyWlZ4dVhIUWdJQ0FnYjNkdUlEMGdJVWxUWDBaUFVrTkZSQ0FtSmlCMFlYSm5aWFFnSmlZZ2RHRnlaMlYwVzJ0bGVWMGdJVDA5SUhWdVpHVm1hVzVsWkR0Y2JseDBJQ0FnSUdsbUtHOTNiaUFtSmlCclpYa2dhVzRnWlhod2IzSjBjeWxqYjI1MGFXNTFaVHRjYmx4MElDQWdJQzh2SUdWNGNHOXlkQ0J1WVhScGRtVWdiM0lnY0dGemMyVmtYRzVjZENBZ0lDQnZkWFFnUFNCdmQyNGdQeUIwWVhKblpYUmJhMlY1WFNBNklITnZkWEpqWlZ0clpYbGRPMXh1WEhRZ0lDQWdMeThnY0hKbGRtVnVkQ0JuYkc5aVlXd2djRzlzYkhWMGFXOXVJR1p2Y2lCdVlXMWxjM0JoWTJWelhHNWNkQ0FnSUNCbGVIQnZjblJ6VzJ0bGVWMGdQU0JKVTE5SFRFOUNRVXdnSmlZZ2RIbHdaVzltSUhSaGNtZGxkRnRyWlhsZElDRTlJQ2RtZFc1amRHbHZiaWNnUHlCemIzVnlZMlZiYTJWNVhWeHVYSFFnSUNBZ0x5OGdZbWx1WkNCMGFXMWxjbk1nZEc4Z1oyeHZZbUZzSUdadmNpQmpZV3hzSUdaeWIyMGdaWGh3YjNKMElHTnZiblJsZUhSY2JseDBJQ0FnSURvZ1NWTmZRa2xPUkNBbUppQnZkMjRnUHlCamRIZ29iM1YwTENCbmJHOWlZV3dwWEc1Y2RDQWdJQ0F2THlCM2NtRndJR2RzYjJKaGJDQmpiMjV6ZEhKMVkzUnZjbk1nWm05eUlIQnlaWFpsYm5RZ1kyaGhibWRsSUhSb1pXMGdhVzRnYkdsaWNtRnllVnh1WEhRZ0lDQWdPaUJKVTE5WFVrRlFJQ1ltSUhSaGNtZGxkRnRyWlhsZElEMDlJRzkxZENBL0lDaG1kVzVqZEdsdmJpaERLWHRjYmx4MElDQWdJQ0FnZG1GeUlFWWdQU0JtZFc1amRHbHZiaWhoTENCaUxDQmpLWHRjYmx4MElDQWdJQ0FnSUNCcFppaDBhR2x6SUdsdWMzUmhibU5sYjJZZ1F5bDdYRzVjZENBZ0lDQWdJQ0FnSUNCemQybDBZMmdvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ2w3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ01Eb2djbVYwZFhKdUlHNWxkeUJETzF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElERTZJSEpsZEhWeWJpQnVaWGNnUXloaEtUdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ1kyRnpaU0F5T2lCeVpYUjFjbTRnYm1WM0lFTW9ZU3dnWWlrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0I5SUhKbGRIVnliaUJ1WlhjZ1F5aGhMQ0JpTENCaktUdGNibHgwSUNBZ0lDQWdJQ0I5SUhKbGRIVnliaUJETG1Gd2NHeDVLSFJvYVhNc0lHRnlaM1Z0Wlc1MGN5azdYRzVjZENBZ0lDQWdJSDA3WEc1Y2RDQWdJQ0FnSUVaYlVGSlBWRTlVV1ZCRlhTQTlJRU5iVUZKUFZFOVVXVkJGWFR0Y2JseDBJQ0FnSUNBZ2NtVjBkWEp1SUVZN1hHNWNkQ0FnSUNBdkx5QnRZV3RsSUhOMFlYUnBZeUIyWlhKemFXOXVjeUJtYjNJZ2NISnZkRzkwZVhCbElHMWxkR2h2WkhOY2JseDBJQ0FnSUgwcEtHOTFkQ2tnT2lCSlUxOVFVazlVVHlBbUppQjBlWEJsYjJZZ2IzVjBJRDA5SUNkbWRXNWpkR2x2YmljZ1B5QmpkSGdvUm5WdVkzUnBiMjR1WTJGc2JDd2diM1YwS1NBNklHOTFkRHRjYmx4MElDQWdJQzh2SUdWNGNHOXlkQ0J3Y205MGJ5QnRaWFJvYjJSeklIUnZJR052Y21VdUpVTlBUbE5VVWxWRFZFOVNKUzV0WlhSb2IyUnpMaVZPUVUxRkpWeHVYSFFnSUNBZ2FXWW9TVk5mVUZKUFZFOHBlMXh1WEhRZ0lDQWdJQ0FvWlhod2IzSjBjeTUyYVhKMGRXRnNJSHg4SUNobGVIQnZjblJ6TG5acGNuUjFZV3dnUFNCN2ZTa3BXMnRsZVYwZ1BTQnZkWFE3WEc1Y2RDQWdJQ0FnSUM4dklHVjRjRzl5ZENCd2NtOTBieUJ0WlhSb2IyUnpJSFJ2SUdOdmNtVXVKVU5QVGxOVVVsVkRWRTlTSlM1d2NtOTBiM1I1Y0dVdUpVNUJUVVVsWEc1Y2RDQWdJQ0FnSUdsbUtIUjVjR1VnSmlBa1pYaHdiM0owTGxJZ0ppWWdaWGh3VUhKdmRHOGdKaVlnSVdWNGNGQnliM1J2VzJ0bGVWMHBhR2xrWlNobGVIQlFjbTkwYnl3Z2EyVjVMQ0J2ZFhRcE8xeHVYSFFnSUNBZ2ZWeHVYSFFnSUgxY2JseDBmVHRjYmx4MEx5OGdkSGx3WlNCaWFYUnRZWEJjYmx4MEpHVjRjRzl5ZEM1R0lEMGdNVHNnSUNBdkx5Qm1iM0pqWldSY2JseDBKR1Y0Y0c5eWRDNUhJRDBnTWpzZ0lDQXZMeUJuYkc5aVlXeGNibHgwSkdWNGNHOXlkQzVUSUQwZ05Ec2dJQ0F2THlCemRHRjBhV05jYmx4MEpHVjRjRzl5ZEM1UUlEMGdPRHNnSUNBdkx5QndjbTkwYjF4dVhIUWtaWGh3YjNKMExrSWdQU0F4TmpzZ0lDOHZJR0pwYm1SY2JseDBKR1Y0Y0c5eWRDNVhJRDBnTXpJN0lDQXZMeUIzY21Gd1hHNWNkQ1JsZUhCdmNuUXVWU0E5SURZME95QWdMeThnYzJGbVpWeHVYSFFrWlhod2IzSjBMbElnUFNBeE1qZzdJQzh2SUhKbFlXd2djSEp2ZEc4Z2JXVjBhRzlrSUdadmNpQmdiR2xpY21GeWVXQWdYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnSkdWNGNHOXlkRHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRGNnS2k5Y2JpOHFLaW92SUdaMWJtTjBhVzl1S0cxdlpIVnNaU3dnWlhod2IzSjBjeWtnZTF4dVhHNWNkQzh2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5NmJHOXBjbTlqYXk5amIzSmxMV3B6TDJsemMzVmxjeTg0TmlOcGMzTjFaV052YlcxbGJuUXRNVEUxTnpVNU1ESTRYRzVjZEhaaGNpQm5iRzlpWVd3Z1BTQnRiMlIxYkdVdVpYaHdiM0owY3lBOUlIUjVjR1Z2WmlCM2FXNWtiM2NnSVQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVlnZDJsdVpHOTNMazFoZEdnZ1BUMGdUV0YwYUZ4dVhIUWdJRDhnZDJsdVpHOTNJRG9nZEhsd1pXOW1JSE5sYkdZZ0lUMGdKM1Z1WkdWbWFXNWxaQ2NnSmlZZ2MyVnNaaTVOWVhSb0lEMDlJRTFoZEdnZ1B5QnpaV3htSURvZ1JuVnVZM1JwYjI0b0ozSmxkSFZ5YmlCMGFHbHpKeWtvS1R0Y2JseDBhV1lvZEhsd1pXOW1JRjlmWnlBOVBTQW5iblZ0WW1WeUp5bGZYMmNnUFNCbmJHOWlZV3c3SUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFd4cGJtVWdibTh0ZFc1a1pXWmNibHh1THlvcUtpOGdmU3hjYmk4cUlEZ2dLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5a2dlMXh1WEc1Y2RIWmhjaUJqYjNKbElEMGdiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjdkbVZ5YzJsdmJqb2dKekl1TkM0d0ozMDdYRzVjZEdsbUtIUjVjR1Z2WmlCZlgyVWdQVDBnSjI1MWJXSmxjaWNwWDE5bElEMGdZMjl5WlRzZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJHbHVaU0J1YnkxMWJtUmxabHh1WEc0dktpb3FMeUI5TEZ4dUx5b2dPU0FxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS1NCN1hHNWNibHgwTHk4Z2IzQjBhVzl1WVd3Z0x5QnphVzF3YkdVZ1kyOXVkR1Y0ZENCaWFXNWthVzVuWEc1Y2RIWmhjaUJoUm5WdVkzUnBiMjRnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktERXdLVHRjYmx4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlobWJpd2dkR2hoZEN3Z2JHVnVaM1JvS1h0Y2JseDBJQ0JoUm5WdVkzUnBiMjRvWm00cE8xeHVYSFFnSUdsbUtIUm9ZWFFnUFQwOUlIVnVaR1ZtYVc1bFpDbHlaWFIxY200Z1ptNDdYRzVjZENBZ2MzZHBkR05vS0d4bGJtZDBhQ2w3WEc1Y2RDQWdJQ0JqWVhObElERTZJSEpsZEhWeWJpQm1kVzVqZEdsdmJpaGhLWHRjYmx4MElDQWdJQ0FnY21WMGRYSnVJR1p1TG1OaGJHd29kR2hoZEN3Z1lTazdYRzVjZENBZ0lDQjlPMXh1WEhRZ0lDQWdZMkZ6WlNBeU9pQnlaWFIxY200Z1puVnVZM1JwYjI0b1lTd2dZaWw3WEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJtYmk1allXeHNLSFJvWVhRc0lHRXNJR0lwTzF4dVhIUWdJQ0FnZlR0Y2JseDBJQ0FnSUdOaGMyVWdNem9nY21WMGRYSnVJR1oxYm1OMGFXOXVLR0VzSUdJc0lHTXBlMXh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdabTR1WTJGc2JDaDBhR0YwTENCaExDQmlMQ0JqS1R0Y2JseDBJQ0FnSUgwN1hHNWNkQ0FnZlZ4dVhIUWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpZ3ZLaUF1TGk1aGNtZHpJQ292S1h0Y2JseDBJQ0FnSUhKbGRIVnliaUJtYmk1aGNIQnNlU2gwYUdGMExDQmhjbWQxYldWdWRITXBPMXh1WEhRZ0lIMDdYRzVjZEgwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBeE1DQXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SektTQjdYRzVjYmx4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlocGRDbDdYRzVjZENBZ2FXWW9kSGx3Wlc5bUlHbDBJQ0U5SUNkbWRXNWpkR2x2YmljcGRHaHliM2NnVkhsd1pVVnljbTl5S0dsMElDc2dKeUJwY3lCdWIzUWdZU0JtZFc1amRHbHZiaUVuS1R0Y2JseDBJQ0J5WlhSMWNtNGdhWFE3WEc1Y2RIMDdYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQXhNU0FxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS1NCN1hHNWNibHgwZG1GeUlHUlFJQ0FnSUNBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RFeUtWeHVYSFFnSUN3Z1kzSmxZWFJsUkdWell5QTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTWpBcE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTVRZcElEOGdablZ1WTNScGIyNG9iMkpxWldOMExDQnJaWGtzSUhaaGJIVmxLWHRjYmx4MElDQnlaWFIxY200Z1pGQXVaaWh2WW1wbFkzUXNJR3RsZVN3Z1kzSmxZWFJsUkdWell5Z3hMQ0IyWVd4MVpTa3BPMXh1WEhSOUlEb2dablZ1WTNScGIyNG9iMkpxWldOMExDQnJaWGtzSUhaaGJIVmxLWHRjYmx4MElDQnZZbXBsWTNSYmEyVjVYU0E5SUhaaGJIVmxPMXh1WEhRZ0lISmxkSFZ5YmlCdlltcGxZM1E3WEc1Y2RIMDdYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQXhNaUFxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS1NCN1hHNWNibHgwZG1GeUlHRnVUMkpxWldOMElDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3hNeWxjYmx4MElDQXNJRWxGT0Y5RVQwMWZSRVZHU1U1RklEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWd4TlNsY2JseDBJQ0FzSUhSdlVISnBiV2wwYVhabElDQWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlneE9TbGNibHgwSUNBc0lHUlFJQ0FnSUNBZ0lDQWdJQ0FnSUQwZ1QySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUjVPMXh1WEhSY2JseDBaWGh3YjNKMGN5NW1JRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlneE5pa2dQeUJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrZ09pQm1kVzVqZEdsdmJpQmtaV1pwYm1WUWNtOXdaWEowZVNoUExDQlFMQ0JCZEhSeWFXSjFkR1Z6S1h0Y2JseDBJQ0JoYms5aWFtVmpkQ2hQS1R0Y2JseDBJQ0JRSUQwZ2RHOVFjbWx0YVhScGRtVW9VQ3dnZEhKMVpTazdYRzVjZENBZ1lXNVBZbXBsWTNRb1FYUjBjbWxpZFhSbGN5azdYRzVjZENBZ2FXWW9TVVU0WDBSUFRWOUVSVVpKVGtVcGRISjVJSHRjYmx4MElDQWdJSEpsZEhWeWJpQmtVQ2hQTENCUUxDQkJkSFJ5YVdKMWRHVnpLVHRjYmx4MElDQjlJR05oZEdOb0tHVXBleUF2S2lCbGJYQjBlU0FxTHlCOVhHNWNkQ0FnYVdZb0oyZGxkQ2NnYVc0Z1FYUjBjbWxpZFhSbGN5QjhmQ0FuYzJWMEp5QnBiaUJCZEhSeWFXSjFkR1Z6S1hSb2NtOTNJRlI1Y0dWRmNuSnZjaWduUVdOalpYTnpiM0p6SUc1dmRDQnpkWEJ3YjNKMFpXUWhKeWs3WEc1Y2RDQWdhV1lvSjNaaGJIVmxKeUJwYmlCQmRIUnlhV0oxZEdWektVOWJVRjBnUFNCQmRIUnlhV0oxZEdWekxuWmhiSFZsTzF4dVhIUWdJSEpsZEhWeWJpQlBPMXh1WEhSOU8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ01UTWdLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5d2dYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWtnZTF4dVhHNWNkSFpoY2lCcGMwOWlhbVZqZENBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVFFwTzF4dVhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHbDBLWHRjYmx4MElDQnBaaWdoYVhOUFltcGxZM1FvYVhRcEtYUm9jbTkzSUZSNWNHVkZjbkp2Y2locGRDQXJJQ2NnYVhNZ2JtOTBJR0Z1SUc5aWFtVmpkQ0VuS1R0Y2JseDBJQ0J5WlhSMWNtNGdhWFE3WEc1Y2RIMDdYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQXhOQ0FxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpLU0I3WEc1Y2JseDBiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHBkQ2w3WEc1Y2RDQWdjbVYwZFhKdUlIUjVjR1Z2WmlCcGRDQTlQVDBnSjI5aWFtVmpkQ2NnUHlCcGRDQWhQVDBnYm5Wc2JDQTZJSFI1Y0dWdlppQnBkQ0E5UFQwZ0oyWjFibU4wYVc5dUp6dGNibHgwZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURFMUlDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOUlDRmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLREUyS1NBbUppQWhYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWd4Tnlrb1puVnVZM1JwYjI0b0tYdGNibHgwSUNCeVpYUjFjbTRnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVGdwS0Nka2FYWW5LU3dnSjJFbkxDQjdaMlYwT2lCbWRXNWpkR2x2YmlncGV5QnlaWFIxY200Z056c2dmWDBwTG1FZ0lUMGdOenRjYmx4MGZTazdYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQXhOaUFxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS1NCN1hHNWNibHgwTHk4Z1ZHaGhibXNuY3lCSlJUZ2dabTl5SUdocGN5Qm1kVzV1ZVNCa1pXWnBibVZRY205d1pYSjBlVnh1WEhSdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUNGZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktERTNLU2htZFc1amRHbHZiaWdwZTF4dVhIUWdJSEpsZEhWeWJpQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvZTMwc0lDZGhKeXdnZTJkbGREb2dablZ1WTNScGIyNG9LWHNnY21WMGRYSnVJRGM3SUgxOUtTNWhJQ0U5SURjN1hHNWNkSDBwTzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTVRjZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3lrZ2UxeHVYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvWlhobFl5bDdYRzVjZENBZ2RISjVJSHRjYmx4MElDQWdJSEpsZEhWeWJpQWhJV1Y0WldNb0tUdGNibHgwSUNCOUlHTmhkR05vS0dVcGUxeHVYSFFnSUNBZ2NtVjBkWEp1SUhSeWRXVTdYRzVjZENBZ2ZWeHVYSFI5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTVRnZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RIWmhjaUJwYzA5aWFtVmpkQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01UUXBYRzVjZENBZ0xDQmtiMk4xYldWdWRDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTnlrdVpHOWpkVzFsYm5SY2JseDBJQ0F2THlCcGJpQnZiR1FnU1VVZ2RIbHdaVzltSUdSdlkzVnRaVzUwTG1OeVpXRjBaVVZzWlcxbGJuUWdhWE1nSjI5aWFtVmpkQ2RjYmx4MElDQXNJR2x6SUQwZ2FYTlBZbXBsWTNRb1pHOWpkVzFsYm5RcElDWW1JR2x6VDJKcVpXTjBLR1J2WTNWdFpXNTBMbU55WldGMFpVVnNaVzFsYm5RcE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwS1h0Y2JseDBJQ0J5WlhSMWNtNGdhWE1nUHlCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLR2wwS1NBNklIdDlPMXh1WEhSOU8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ01Ua2dLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5d2dYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWtnZTF4dVhHNWNkQzh2SURjdU1TNHhJRlJ2VUhKcGJXbDBhWFpsS0dsdWNIVjBJRnNzSUZCeVpXWmxjbkpsWkZSNWNHVmRLVnh1WEhSMllYSWdhWE5QWW1wbFkzUWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RFMEtUdGNibHgwTHk4Z2FXNXpkR1ZoWkNCdlppQjBhR1VnUlZNMklITndaV01nZG1WeWMybHZiaXdnZDJVZ1pHbGtiaWQwSUdsdGNHeGxiV1Z1ZENCQVFIUnZVSEpwYldsMGFYWmxJR05oYzJWY2JseDBMeThnWVc1a0lIUm9aU0J6WldOdmJtUWdZWEpuZFcxbGJuUWdMU0JtYkdGbklDMGdjSEpsWm1WeWNtVmtJSFI1Y0dVZ2FYTWdZU0J6ZEhKcGJtZGNibHgwYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhwZEN3Z1V5bDdYRzVjZENBZ2FXWW9JV2x6VDJKcVpXTjBLR2wwS1NseVpYUjFjbTRnYVhRN1hHNWNkQ0FnZG1GeUlHWnVMQ0IyWVd3N1hHNWNkQ0FnYVdZb1V5QW1KaUIwZVhCbGIyWWdLR1p1SUQwZ2FYUXVkRzlUZEhKcGJtY3BJRDA5SUNkbWRXNWpkR2x2YmljZ0ppWWdJV2x6VDJKcVpXTjBLSFpoYkNBOUlHWnVMbU5oYkd3b2FYUXBLU2x5WlhSMWNtNGdkbUZzTzF4dVhIUWdJR2xtS0hSNWNHVnZaaUFvWm00Z1BTQnBkQzUyWVd4MVpVOW1LU0E5UFNBblpuVnVZM1JwYjI0bklDWW1JQ0ZwYzA5aWFtVmpkQ2gyWVd3Z1BTQm1iaTVqWVd4c0tHbDBLU2twY21WMGRYSnVJSFpoYkR0Y2JseDBJQ0JwWmlnaFV5QW1KaUIwZVhCbGIyWWdLR1p1SUQwZ2FYUXVkRzlUZEhKcGJtY3BJRDA5SUNkbWRXNWpkR2x2YmljZ0ppWWdJV2x6VDJKcVpXTjBLSFpoYkNBOUlHWnVMbU5oYkd3b2FYUXBLU2x5WlhSMWNtNGdkbUZzTzF4dVhIUWdJSFJvY205M0lGUjVjR1ZGY25KdmNpaGNJa05oYmlkMElHTnZiblpsY25RZ2IySnFaV04wSUhSdklIQnlhVzFwZEdsMlpTQjJZV3gxWlZ3aUtUdGNibHgwZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURJd0lDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNcElIdGNibHh1WEhSdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dKcGRHMWhjQ3dnZG1Gc2RXVXBlMXh1WEhRZ0lISmxkSFZ5YmlCN1hHNWNkQ0FnSUNCbGJuVnRaWEpoWW14bElDQTZJQ0VvWW1sMGJXRndJQ1lnTVNrc1hHNWNkQ0FnSUNCamIyNW1hV2QxY21GaWJHVTZJQ0VvWW1sMGJXRndJQ1lnTWlrc1hHNWNkQ0FnSUNCM2NtbDBZV0pzWlNBZ0lDQTZJQ0VvWW1sMGJXRndJQ1lnTkNrc1hHNWNkQ0FnSUNCMllXeDFaU0FnSUNBZ0lDQTZJSFpoYkhWbFhHNWNkQ0FnZlR0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJREl4SUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSMllYSWdYMTlYUlVKUVFVTkxYMEZOUkY5RVJVWkpUa1ZmUmtGRFZFOVNXVjlmTENCZlgxZEZRbEJCUTB0ZlFVMUVYMFJGUmtsT1JWOUJVbEpCV1Y5ZkxDQmZYMWRGUWxCQlEwdGZRVTFFWDBSRlJrbE9SVjlTUlZOVlRGUmZYenNuZFhObElITjBjbWxqZENjN1hHNWNkRnh1WEhSMllYSWdYM1I1Y0dWdlpqSWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RJeUtUdGNibHgwWEc1Y2RIWmhjaUJmZEhsd1pXOW1NeUE5SUY5cGJuUmxjbTl3VW1WeGRXbHlaVVJsWm1GMWJIUW9YM1I1Y0dWdlpqSXBPMXh1WEhSY2JseDBablZ1WTNScGIyNGdYMmx1ZEdWeWIzQlNaWEYxYVhKbFJHVm1ZWFZzZENodlltb3BJSHNnY21WMGRYSnVJRzlpYWlBbUppQnZZbW91WDE5bGMwMXZaSFZzWlNBL0lHOWlhaUE2SUhzZ1pHVm1ZWFZzZERvZ2IySnFJSDA3SUgxY2JseDBYRzVjZEhaaGNpQnhjbU52WkdVZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc1Y2RDQWdkbUZ5SUhGeVkyOWtaU0E5SUdaMWJtTjBhVzl1SUhGeVkyOWtaU2gwZVhCbFRuVnRZbVZ5TENCbGNuSnZja052Y25KbFkzUnBiMjVNWlhabGJDa2dlMXh1WEhSY2JseDBJQ0FnSUhaaGNpQlFRVVF3SUQwZ01IaEZRenRjYmx4MElDQWdJSFpoY2lCUVFVUXhJRDBnTUhneE1UdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ1gzUjVjR1ZPZFcxaVpYSWdQU0IwZVhCbFRuVnRZbVZ5TzF4dVhIUWdJQ0FnZG1GeUlGOWxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ0E5SUZGU1JYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXeGJaWEp5YjNKRGIzSnlaV04wYVc5dVRHVjJaV3hkTzF4dVhIUWdJQ0FnZG1GeUlGOXRiMlIxYkdWeklEMGdiblZzYkR0Y2JseDBJQ0FnSUhaaGNpQmZiVzlrZFd4bFEyOTFiblFnUFNBd08xeHVYSFFnSUNBZ2RtRnlJRjlrWVhSaFEyRmphR1VnUFNCdWRXeHNPMXh1WEhRZ0lDQWdkbUZ5SUY5a1lYUmhUR2x6ZENBOUlHNWxkeUJCY25KaGVTZ3BPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQnRZV3RsU1cxd2JDQTlJR1oxYm1OMGFXOXVJRzFoYTJWSmJYQnNLSFJsYzNRc0lHMWhjMnRRWVhSMFpYSnVLU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQmZiVzlrZFd4bFEyOTFiblFnUFNCZmRIbHdaVTUxYldKbGNpQXFJRFFnS3lBeE56dGNibHgwSUNBZ0lDQWdYMjF2WkhWc1pYTWdQU0JtZFc1amRHbHZiaUFvYlc5a2RXeGxRMjkxYm5RcElIdGNibHgwSUNBZ0lDQWdJQ0IyWVhJZ2JXOWtkV3hsY3lBOUlHNWxkeUJCY25KaGVTaHRiMlIxYkdWRGIzVnVkQ2s3WEc1Y2RDQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2NtOTNJRDBnTURzZ2NtOTNJRHdnYlc5a2RXeGxRMjkxYm5RN0lISnZkeUFyUFNBeEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNCdGIyUjFiR1Z6VzNKdmQxMGdQU0J1WlhjZ1FYSnlZWGtvYlc5a2RXeGxRMjkxYm5RcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnWm05eUlDaDJZWElnWTI5c0lEMGdNRHNnWTI5c0lEd2diVzlrZFd4bFEyOTFiblE3SUdOdmJDQXJQU0F4S1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUcxdlpIVnNaWE5iY205M1hWdGpiMnhkSUQwZ2JuVnNiRHRjYmx4MElDQWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUNBZ2NtVjBkWEp1SUcxdlpIVnNaWE03WEc1Y2RDQWdJQ0FnSUgwb1gyMXZaSFZzWlVOdmRXNTBLVHRjYmx4MFhHNWNkQ0FnSUNBZ0lITmxkSFZ3VUc5emFYUnBiMjVRY205aVpWQmhkSFJsY200b01Dd2dNQ2s3WEc1Y2RDQWdJQ0FnSUhObGRIVndVRzl6YVhScGIyNVFjbTlpWlZCaGRIUmxjbTRvWDIxdlpIVnNaVU52ZFc1MElDMGdOeXdnTUNrN1hHNWNkQ0FnSUNBZ0lITmxkSFZ3VUc5emFYUnBiMjVRY205aVpWQmhkSFJsY200b01Dd2dYMjF2WkhWc1pVTnZkVzUwSUMwZ055azdYRzVjZENBZ0lDQWdJSE5sZEhWd1VHOXphWFJwYjI1QlpHcDFjM1JRWVhSMFpYSnVLQ2s3WEc1Y2RDQWdJQ0FnSUhObGRIVndWR2x0YVc1blVHRjBkR1Z5YmlncE8xeHVYSFFnSUNBZ0lDQnpaWFIxY0ZSNWNHVkpibVp2S0hSbGMzUXNJRzFoYzJ0UVlYUjBaWEp1S1R0Y2JseDBYRzVjZENBZ0lDQWdJR2xtSUNoZmRIbHdaVTUxYldKbGNpQStQU0EzS1NCN1hHNWNkQ0FnSUNBZ0lDQWdjMlYwZFhCVWVYQmxUblZ0WW1WeUtIUmxjM1FwTzF4dVhIUWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0JwWmlBb1gyUmhkR0ZEWVdOb1pTQTlQU0J1ZFd4c0tTQjdYRzVjZENBZ0lDQWdJQ0FnWDJSaGRHRkRZV05vWlNBOUlHTnlaV0YwWlVSaGRHRW9YM1I1Y0dWT2RXMWlaWElzSUY5bGNuSnZja052Y25KbFkzUnBiMjVNWlhabGJDd2dYMlJoZEdGTWFYTjBLVHRjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdiV0Z3UkdGMFlTaGZaR0YwWVVOaFkyaGxMQ0J0WVhOclVHRjBkR1Z5YmlrN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJSFpoY2lCelpYUjFjRkJ2YzJsMGFXOXVVSEp2WW1WUVlYUjBaWEp1SUQwZ1puVnVZM1JwYjI0Z2MyVjBkWEJRYjNOcGRHbHZibEJ5YjJKbFVHRjBkR1Z5YmloeWIzY3NJR052YkNrZ2UxeHVYSFJjYmx4MElDQWdJQ0FnWm05eUlDaDJZWElnY2lBOUlDMHhPeUJ5SUR3OUlEYzdJSElnS3owZ01Ta2dlMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQnBaaUFvY205M0lDc2djaUE4UFNBdE1TQjhmQ0JmYlc5a2RXeGxRMjkxYm5RZ1BEMGdjbTkzSUNzZ2Npa2dZMjl1ZEdsdWRXVTdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHTWdQU0F0TVRzZ1l5QThQU0EzT3lCaklDczlJREVwSUh0Y2JseDBYRzVjZENBZ0lDQWdJQ0FnSUNCcFppQW9ZMjlzSUNzZ1l5QThQU0F0TVNCOGZDQmZiVzlrZFd4bFEyOTFiblFnUEQwZ1kyOXNJQ3NnWXlrZ1kyOXVkR2x1ZFdVN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ2FXWWdLREFnUEQwZ2NpQW1KaUJ5SUR3OUlEWWdKaVlnS0dNZ1BUMGdNQ0I4ZkNCaklEMDlJRFlwSUh4OElEQWdQRDBnWXlBbUppQmpJRHc5SURZZ0ppWWdLSElnUFQwZ01DQjhmQ0J5SUQwOUlEWXBJSHg4SURJZ1BEMGdjaUFtSmlCeUlEdzlJRFFnSmlZZ01pQThQU0JqSUNZbUlHTWdQRDBnTkNrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCZmJXOWtkV3hsYzF0eWIzY2dLeUJ5WFZ0amIyd2dLeUJqWFNBOUlIUnlkV1U3WEc1Y2RDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCZmJXOWtkV3hsYzF0eWIzY2dLeUJ5WFZ0amIyd2dLeUJqWFNBOUlHWmhiSE5sTzF4dVhIUWdJQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUgxY2JseDBJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ1oyVjBRbVZ6ZEUxaGMydFFZWFIwWlhKdUlEMGdablZ1WTNScGIyNGdaMlYwUW1WemRFMWhjMnRRWVhSMFpYSnVLQ2tnZTF4dVhIUmNibHgwSUNBZ0lDQWdkbUZ5SUcxcGJreHZjM1JRYjJsdWRDQTlJREE3WEc1Y2RDQWdJQ0FnSUhaaGNpQndZWFIwWlhKdUlEMGdNRHRjYmx4MFhHNWNkQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dPRHNnYVNBclBTQXhLU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJRzFoYTJWSmJYQnNLSFJ5ZFdVc0lHa3BPMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQjJZWElnYkc5emRGQnZhVzUwSUQwZ1VWSlZkR2xzTG1kbGRFeHZjM1JRYjJsdWRDaGZkR2hwY3lrN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUdsbUlDaHBJRDA5SURBZ2ZId2diV2x1VEc5emRGQnZhVzUwSUQ0Z2JHOXpkRkJ2YVc1MEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNCdGFXNU1iM04wVUc5cGJuUWdQU0JzYjNOMFVHOXBiblE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQndZWFIwWlhKdUlEMGdhVHRjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJ3WVhSMFpYSnVPMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdjMlYwZFhCVWFXMXBibWRRWVhSMFpYSnVJRDBnWm5WdVkzUnBiMjRnYzJWMGRYQlVhVzFwYm1kUVlYUjBaWEp1S0NrZ2UxeHVYSFJjYmx4MElDQWdJQ0FnWm05eUlDaDJZWElnY2lBOUlEZzdJSElnUENCZmJXOWtkV3hsUTI5MWJuUWdMU0E0T3lCeUlDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ0lDQnBaaUFvWDIxdlpIVnNaWE5iY2wxYk5sMGdJVDBnYm5Wc2JDa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUY5dGIyUjFiR1Z6VzNKZFd6WmRJRDBnY2lBbElESWdQVDBnTUR0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFJjYmx4MElDQWdJQ0FnWm05eUlDaDJZWElnWXlBOUlEZzdJR01nUENCZmJXOWtkV3hsUTI5MWJuUWdMU0E0T3lCaklDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ0lDQnBaaUFvWDIxdlpIVnNaWE5iTmwxYlkxMGdJVDBnYm5Wc2JDa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUY5dGIyUjFiR1Z6V3paZFcyTmRJRDBnWXlBbElESWdQVDBnTUR0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ2MyVjBkWEJRYjNOcGRHbHZia0ZrYW5WemRGQmhkSFJsY200Z1BTQm1kVzVqZEdsdmJpQnpaWFIxY0ZCdmMybDBhVzl1UVdScWRYTjBVR0YwZEdWeWJpZ3BJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lIWmhjaUJ3YjNNZ1BTQlJVbFYwYVd3dVoyVjBVR0YwZEdWeWJsQnZjMmwwYVc5dUtGOTBlWEJsVG5WdFltVnlLVHRjYmx4MFhHNWNkQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2djRzl6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR29nUFNBd095QnFJRHdnY0c5ekxteGxibWQwYURzZ2FpQXJQU0F4S1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ2RtRnlJSEp2ZHlBOUlIQnZjMXRwWFR0Y2JseDBJQ0FnSUNBZ0lDQWdJSFpoY2lCamIyd2dQU0J3YjNOYmFsMDdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lDQWdhV1lnS0Y5dGIyUjFiR1Z6VzNKdmQxMWJZMjlzWFNBaFBTQnVkV3hzS1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuUnBiblZsTzF4dVhIUWdJQ0FnSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJSElnUFNBdE1qc2djaUE4UFNBeU95QnlJQ3M5SURFcElIdGNibHgwWEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR01nUFNBdE1qc2dZeUE4UFNBeU95QmpJQ3M5SURFcElIdGNibHgwWEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tISWdQVDBnTFRJZ2ZId2djaUE5UFNBeUlIeDhJR01nUFQwZ0xUSWdmSHdnWXlBOVBTQXlJSHg4SUhJZ1BUMGdNQ0FtSmlCaklEMDlJREFwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGOXRiMlIxYkdWelczSnZkeUFySUhKZFcyTnZiQ0FySUdOZElEMGdkSEoxWlR0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1gyMXZaSFZzWlhOYmNtOTNJQ3NnY2wxYlkyOXNJQ3NnWTEwZ1BTQm1ZV3h6WlR0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JseDBJQ0FnSUNBZ0lDQWdJSDFjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlITmxkSFZ3Vkhsd1pVNTFiV0psY2lBOUlHWjFibU4wYVc5dUlITmxkSFZ3Vkhsd1pVNTFiV0psY2loMFpYTjBLU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQjJZWElnWW1sMGN5QTlJRkZTVlhScGJDNW5aWFJDUTBoVWVYQmxUblZ0WW1WeUtGOTBlWEJsVG5WdFltVnlLVHRjYmx4MFhHNWNkQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dNVGc3SUdrZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNBZ0lIWmhjaUJ0YjJRZ1BTQWhkR1Z6ZENBbUppQW9ZbWwwY3lBK1BpQnBJQ1lnTVNrZ1BUMGdNVHRjYmx4MElDQWdJQ0FnSUNCZmJXOWtkV3hsYzF0TllYUm9MbVpzYjI5eUtHa2dMeUF6S1YxYmFTQWxJRE1nS3lCZmJXOWtkV3hsUTI5MWJuUWdMU0E0SUMwZ00xMGdQU0J0YjJRN1hHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z01UZzdJR2tnS3owZ01Ta2dlMXh1WEhRZ0lDQWdJQ0FnSUhaaGNpQnRiMlFnUFNBaGRHVnpkQ0FtSmlBb1ltbDBjeUErUGlCcElDWWdNU2tnUFQwZ01UdGNibHgwSUNBZ0lDQWdJQ0JmYlc5a2RXeGxjMXRwSUNVZ015QXJJRjl0YjJSMWJHVkRiM1Z1ZENBdElEZ2dMU0F6WFZ0TllYUm9MbVpzYjI5eUtHa2dMeUF6S1YwZ1BTQnRiMlE3WEc1Y2RDQWdJQ0FnSUgxY2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdkbUZ5SUhObGRIVndWSGx3WlVsdVptOGdQU0JtZFc1amRHbHZiaUJ6WlhSMWNGUjVjR1ZKYm1adktIUmxjM1FzSUcxaGMydFFZWFIwWlhKdUtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCMllYSWdaR0YwWVNBOUlGOWxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ0E4UENBeklId2diV0Z6YTFCaGRIUmxjbTQ3WEc1Y2RDQWdJQ0FnSUhaaGNpQmlhWFJ6SUQwZ1VWSlZkR2xzTG1kbGRFSkRTRlI1Y0dWSmJtWnZLR1JoZEdFcE8xeHVYSFJjYmx4MElDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENBeE5Uc2dhU0FyUFNBeEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lIWmhjaUJ0YjJRZ1BTQWhkR1Z6ZENBbUppQW9ZbWwwY3lBK1BpQnBJQ1lnTVNrZ1BUMGdNVHRjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdhV1lnS0drZ1BDQTJLU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQmZiVzlrZFd4bGMxdHBYVnM0WFNBOUlHMXZaRHRjYmx4MElDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHa2dQQ0E0S1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0JmYlc5a2RXeGxjMXRwSUNzZ01WMWJPRjBnUFNCdGIyUTdYRzVjZENBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmx4MElDQWdJQ0FnSUNBZ0lGOXRiMlIxYkdWelcxOXRiMlIxYkdWRGIzVnVkQ0F0SURFMUlDc2dhVjFiT0YwZ1BTQnRiMlE3WEc1Y2RDQWdJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElERTFPeUJwSUNzOUlERXBJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdkbUZ5SUcxdlpDQTlJQ0YwWlhOMElDWW1JQ2hpYVhSeklENCtJR2tnSmlBeEtTQTlQU0F4TzF4dVhIUmNibHgwSUNBZ0lDQWdJQ0JwWmlBb2FTQThJRGdwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJRjl0YjJSMWJHVnpXemhkVzE5dGIyUjFiR1ZEYjNWdWRDQXRJR2tnTFNBeFhTQTlJRzF2WkR0Y2JseDBJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2tnUENBNUtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNCZmJXOWtkV3hsYzFzNFhWc3hOU0F0SUdrZ0xTQXhJQ3NnTVYwZ1BTQnRiMlE3WEc1Y2RDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJRjl0YjJSMWJHVnpXemhkV3pFMUlDMGdhU0F0SURGZElEMGdiVzlrTzF4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ1gyMXZaSFZzWlhOYlgyMXZaSFZzWlVOdmRXNTBJQzBnT0YxYk9GMGdQU0FoZEdWemREdGNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlHMWhjRVJoZEdFZ1BTQm1kVzVqZEdsdmJpQnRZWEJFWVhSaEtHUmhkR0VzSUcxaGMydFFZWFIwWlhKdUtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCMllYSWdhVzVqSUQwZ0xURTdYRzVjZENBZ0lDQWdJSFpoY2lCeWIzY2dQU0JmYlc5a2RXeGxRMjkxYm5RZ0xTQXhPMXh1WEhRZ0lDQWdJQ0IyWVhJZ1ltbDBTVzVrWlhnZ1BTQTNPMXh1WEhRZ0lDQWdJQ0IyWVhJZ1lubDBaVWx1WkdWNElEMGdNRHRjYmx4MElDQWdJQ0FnZG1GeUlHMWhjMnRHZFc1aklEMGdVVkpWZEdsc0xtZGxkRTFoYzJ0R2RXNWpkR2x2YmlodFlYTnJVR0YwZEdWeWJpazdYRzVjZEZ4dVhIUWdJQ0FnSUNCbWIzSWdLSFpoY2lCamIyd2dQU0JmYlc5a2RXeGxRMjkxYm5RZ0xTQXhPeUJqYjJ3Z1BpQXdPeUJqYjJ3Z0xUMGdNaWtnZTF4dVhIUmNibHgwSUNBZ0lDQWdJQ0JwWmlBb1kyOXNJRDA5SURZcElHTnZiQ0F0UFNBeE8xeHVYSFJjYmx4MElDQWdJQ0FnSUNCM2FHbHNaU0FvZEhKMVpTa2dlMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR01nUFNBd095QmpJRHdnTWpzZ1l5QXJQU0F4S1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvWDIxdlpIVnNaWE5iY205M1hWdGpiMndnTFNCalhTQTlQU0J1ZFd4c0tTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQmtZWEpySUQwZ1ptRnNjMlU3WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hpZVhSbFNXNWtaWGdnUENCa1lYUmhMbXhsYm1kMGFDa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWkdGeWF5QTlJQ2hrWVhSaFcySjVkR1ZKYm1SbGVGMGdQajQrSUdKcGRFbHVaR1Y0SUNZZ01Ta2dQVDBnTVR0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCdFlYTnJJRDBnYldGemEwWjFibU1vY205M0xDQmpiMndnTFNCaktUdGNibHgwWEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHMWhjMnNwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHUmhjbXNnUFNBaFpHRnlhenRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lGOXRiMlIxYkdWelczSnZkMTFiWTI5c0lDMGdZMTBnUFNCa1lYSnJPMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJR0pwZEVsdVpHVjRJQzA5SURFN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoaWFYUkpibVJsZUNBOVBTQXRNU2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lubDBaVWx1WkdWNElDczlJREU3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaWFYUkpibVJsZUNBOUlEYzdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQjlYRzVjZENBZ0lDQWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0FnSUNBZ2NtOTNJQ3M5SUdsdVl6dGNibHgwWEc1Y2RDQWdJQ0FnSUNBZ0lDQnBaaUFvY205M0lEd2dNQ0I4ZkNCZmJXOWtkV3hsUTI5MWJuUWdQRDBnY205M0tTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lISnZkeUF0UFNCcGJtTTdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lHbHVZeUE5SUMxcGJtTTdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dVhIUWdJQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUgxY2JseDBJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ1kzSmxZWFJsUW5sMFpYTWdQU0JtZFc1amRHbHZiaUJqY21WaGRHVkNlWFJsY3loaWRXWm1aWElzSUhKelFteHZZMnR6S1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ2IyWm1jMlYwSUQwZ01EdGNibHgwWEc1Y2RDQWdJQ0FnSUhaaGNpQnRZWGhFWTBOdmRXNTBJRDBnTUR0Y2JseDBJQ0FnSUNBZ2RtRnlJRzFoZUVWalEyOTFiblFnUFNBd08xeHVYSFJjYmx4MElDQWdJQ0FnZG1GeUlHUmpaR0YwWVNBOUlHNWxkeUJCY25KaGVTaHljMEpzYjJOcmN5NXNaVzVuZEdncE8xeHVYSFFnSUNBZ0lDQjJZWElnWldOa1lYUmhJRDBnYm1WM0lFRnljbUY1S0hKelFteHZZMnR6TG14bGJtZDBhQ2s3WEc1Y2RGeHVYSFFnSUNBZ0lDQm1iM0lnS0haaGNpQnlJRDBnTURzZ2NpQThJSEp6UW14dlkydHpMbXhsYm1kMGFEc2djaUFyUFNBeEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lIWmhjaUJrWTBOdmRXNTBJRDBnY25OQ2JHOWphM05iY2wwdVpHRjBZVU52ZFc1ME8xeHVYSFFnSUNBZ0lDQWdJSFpoY2lCbFkwTnZkVzUwSUQwZ2NuTkNiRzlqYTNOYmNsMHVkRzkwWVd4RGIzVnVkQ0F0SUdSalEyOTFiblE3WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJRzFoZUVSalEyOTFiblFnUFNCTllYUm9MbTFoZUNodFlYaEVZME52ZFc1MExDQmtZME52ZFc1MEtUdGNibHgwSUNBZ0lDQWdJQ0J0WVhoRlkwTnZkVzUwSUQwZ1RXRjBhQzV0WVhnb2JXRjRSV05EYjNWdWRDd2daV05EYjNWdWRDazdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lHUmpaR0YwWVZ0eVhTQTlJRzVsZHlCQmNuSmhlU2hrWTBOdmRXNTBLVHRjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JrWTJSaGRHRmJjbDB1YkdWdVozUm9PeUJwSUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNBZ0lHUmpaR0YwWVZ0eVhWdHBYU0E5SURCNFptWWdKaUJpZFdabVpYSXVaMlYwUW5WbVptVnlLQ2xiYVNBcklHOW1abk5sZEYwN1hHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUc5bVpuTmxkQ0FyUFNCa1kwTnZkVzUwTzF4dVhIUmNibHgwSUNBZ0lDQWdJQ0IyWVhJZ2NuTlFiMng1SUQwZ1VWSlZkR2xzTG1kbGRFVnljbTl5UTI5eWNtVmpkRkJ2YkhsdWIyMXBZV3dvWldORGIzVnVkQ2s3WEc1Y2RDQWdJQ0FnSUNBZ2RtRnlJSEpoZDFCdmJIa2dQU0J4Y2xCdmJIbHViMjFwWVd3b1pHTmtZWFJoVzNKZExDQnljMUJ2YkhrdVoyVjBUR1Z1WjNSb0tDa2dMU0F4S1R0Y2JseDBYRzVjZENBZ0lDQWdJQ0FnZG1GeUlHMXZaRkJ2YkhrZ1BTQnlZWGRRYjJ4NUxtMXZaQ2h5YzFCdmJIa3BPMXh1WEhRZ0lDQWdJQ0FnSUdWalpHRjBZVnR5WFNBOUlHNWxkeUJCY25KaGVTaHljMUJ2YkhrdVoyVjBUR1Z1WjNSb0tDa2dMU0F4S1R0Y2JseDBJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR1ZqWkdGMFlWdHlYUzVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ2RtRnlJRzF2WkVsdVpHVjRJRDBnYVNBcklHMXZaRkJ2YkhrdVoyVjBUR1Z1WjNSb0tDa2dMU0JsWTJSaGRHRmJjbDB1YkdWdVozUm9PMXh1WEhRZ0lDQWdJQ0FnSUNBZ1pXTmtZWFJoVzNKZFcybGRJRDBnYlc5a1NXNWtaWGdnUGowZ01DQS9JRzF2WkZCdmJIa3VaMlYwUVhRb2JXOWtTVzVrWlhncElEb2dNRHRjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUhaaGNpQjBiM1JoYkVOdlpHVkRiM1Z1ZENBOUlEQTdYRzVjZENBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnY25OQ2JHOWphM011YkdWdVozUm9PeUJwSUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNCMGIzUmhiRU52WkdWRGIzVnVkQ0FyUFNCeWMwSnNiMk5yYzF0cFhTNTBiM1JoYkVOdmRXNTBPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQjJZWElnWkdGMFlTQTlJRzVsZHlCQmNuSmhlU2gwYjNSaGJFTnZaR1ZEYjNWdWRDazdYRzVjZENBZ0lDQWdJSFpoY2lCcGJtUmxlQ0E5SURBN1hHNWNkRnh1WEhRZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUcxaGVFUmpRMjkxYm5RN0lHa2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJSElnUFNBd095QnlJRHdnY25OQ2JHOWphM011YkdWdVozUm9PeUJ5SUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNBZ0lHbG1JQ2hwSUR3Z1pHTmtZWFJoVzNKZExteGxibWQwYUNrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhXMmx1WkdWNFhTQTlJR1JqWkdGMFlWdHlYVnRwWFR0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnYVc1a1pYZ2dLejBnTVR0Y2JseDBJQ0FnSUNBZ0lDQWdJSDFjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JXRjRSV05EYjNWdWREc2dhU0FyUFNBeEtTQjdYRzVjZENBZ0lDQWdJQ0FnWm05eUlDaDJZWElnY2lBOUlEQTdJSElnUENCeWMwSnNiMk5yY3k1c1pXNW5kR2c3SUhJZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdhV1lnS0drZ1BDQmxZMlJoZEdGYmNsMHViR1Z1WjNSb0tTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0ZiYVc1a1pYaGRJRDBnWldOa1lYUmhXM0pkVzJsZE8xeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCcGJtUmxlQ0FyUFNBeE8xeHVYSFFnSUNBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ2NtVjBkWEp1SUdSaGRHRTdYRzVjZENBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmpjbVZoZEdWRVlYUmhJRDBnWm5WdVkzUnBiMjRnWTNKbFlYUmxSR0YwWVNoMGVYQmxUblZ0WW1WeUxDQmxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ3dnWkdGMFlVeHBjM1FwSUh0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCeWMwSnNiMk5yY3lBOUlGRlNVbE5DYkc5amF5NW5aWFJTVTBKc2IyTnJjeWgwZVhCbFRuVnRZbVZ5TENCbGNuSnZja052Y25KbFkzUnBiMjVNWlhabGJDazdYRzVjZEZ4dVhIUWdJQ0FnSUNCMllYSWdZblZtWm1WeUlEMGdjWEpDYVhSQ2RXWm1aWElvS1R0Y2JseDBYRzVjZENBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWkdGMFlVeHBjM1F1YkdWdVozUm9PeUJwSUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNCMllYSWdaR0YwWVNBOUlHUmhkR0ZNYVhOMFcybGRPMXh1WEhRZ0lDQWdJQ0FnSUdKMVptWmxjaTV3ZFhRb1pHRjBZUzVuWlhSTmIyUmxLQ2tzSURRcE8xeHVYSFFnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvWkdGMFlTNW5aWFJNWlc1bmRHZ29LU3dnVVZKVmRHbHNMbWRsZEV4bGJtZDBhRWx1UW1sMGN5aGtZWFJoTG1kbGRFMXZaR1VvS1N3Z2RIbHdaVTUxYldKbGNpa3BPMXh1WEhRZ0lDQWdJQ0FnSUdSaGRHRXVkM0pwZEdVb1luVm1abVZ5S1R0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFJjYmx4MElDQWdJQ0FnZG1GeUlIUnZkR0ZzUkdGMFlVTnZkVzUwSUQwZ01EdGNibHgwSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J5YzBKc2IyTnJjeTVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1WEhRZ0lDQWdJQ0FnSUhSdmRHRnNSR0YwWVVOdmRXNTBJQ3M5SUhKelFteHZZMnR6VzJsZExtUmhkR0ZEYjNWdWREdGNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ2FXWWdLR0oxWm1abGNpNW5aWFJNWlc1bmRHaEpia0pwZEhNb0tTQStJSFJ2ZEdGc1JHRjBZVU52ZFc1MElDb2dPQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblkyOWtaU0JzWlc1bmRHZ2diM1psY21ac2IzY3VJQ2duSUNzZ1luVm1abVZ5TG1kbGRFeGxibWQwYUVsdVFtbDBjeWdwSUNzZ0p6NG5JQ3NnZEc5MFlXeEVZWFJoUTI5MWJuUWdLaUE0SUNzZ0p5a25LVHRjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdhV1lnS0dKMVptWmxjaTVuWlhSTVpXNW5kR2hKYmtKcGRITW9LU0FySURRZ1BEMGdkRzkwWVd4RVlYUmhRMjkxYm5RZ0tpQTRLU0I3WEc1Y2RDQWdJQ0FnSUNBZ1luVm1abVZ5TG5CMWRDZ3dMQ0EwS1R0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFJjYmx4MElDQWdJQ0FnZDJocGJHVWdLR0oxWm1abGNpNW5aWFJNWlc1bmRHaEpia0pwZEhNb0tTQWxJRGdnSVQwZ01Da2dlMXh1WEhRZ0lDQWdJQ0FnSUdKMVptWmxjaTV3ZFhSQ2FYUW9abUZzYzJVcE8xeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCM2FHbHNaU0FvZEhKMVpTa2dlMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQnBaaUFvWW5WbVptVnlMbWRsZEV4bGJtZDBhRWx1UW1sMGN5Z3BJRDQ5SUhSdmRHRnNSR0YwWVVOdmRXNTBJQ29nT0NrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzVjZENBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNBZ0lHSjFabVpsY2k1d2RYUW9VRUZFTUN3Z09DazdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lHbG1JQ2hpZFdabVpYSXVaMlYwVEdWdVozUm9TVzVDYVhSektDa2dQajBnZEc5MFlXeEVZWFJoUTI5MWJuUWdLaUE0S1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0JpY21WaGF6dGNibHgwSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUNBZ1luVm1abVZ5TG5CMWRDaFFRVVF4TENBNEtUdGNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ2NtVjBkWEp1SUdOeVpXRjBaVUo1ZEdWektHSjFabVpsY2l3Z2NuTkNiRzlqYTNNcE8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NWhaR1JFWVhSaElEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHMXZaR1VwSUh0Y2JseDBYRzVjZENBZ0lDQWdJRzF2WkdVZ1BTQnRiMlJsSUh4OElDZENlWFJsSnp0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCdVpYZEVZWFJoSUQwZ2JuVnNiRHRjYmx4MFhHNWNkQ0FnSUNBZ0lITjNhWFJqYUNBb2JXOWtaU2tnZTF4dVhIUWdJQ0FnSUNBZ0lHTmhjMlVnSjA1MWJXVnlhV01uT2x4dVhIUWdJQ0FnSUNBZ0lDQWdibVYzUkdGMFlTQTlJSEZ5VG5WdFltVnlLR1JoZEdFcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzVjZENBZ0lDQWdJQ0FnWTJGelpTQW5RV3h3YUdGdWRXMWxjbWxqSnpwY2JseDBJQ0FnSUNBZ0lDQWdJRzVsZDBSaGRHRWdQU0J4Y2tGc2NHaGhUblZ0S0dSaGRHRXBPMXh1WEhRZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEc1Y2RDQWdJQ0FnSUNBZ1kyRnpaU0FuUW5sMFpTYzZYRzVjZENBZ0lDQWdJQ0FnSUNCdVpYZEVZWFJoSUQwZ2NYSTRRbWwwUW5sMFpTaGtZWFJoS1R0Y2JseDBJQ0FnSUNBZ0lDQWdJR0p5WldGck8xeHVYSFFnSUNBZ0lDQWdJR05oYzJVZ0owdGhibXBwSnpwY2JseDBJQ0FnSUNBZ0lDQWdJRzVsZDBSaGRHRWdQU0J4Y2t0aGJtcHBLR1JoZEdFcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzVjZENBZ0lDQWdJQ0FnWkdWbVlYVnNkRHBjYmx4MElDQWdJQ0FnSUNBZ0lIUm9jbTkzSUNkdGIyUmxPaWNnS3lCdGIyUmxPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQmZaR0YwWVV4cGMzUXVjSFZ6YUNodVpYZEVZWFJoS1R0Y2JseDBJQ0FnSUNBZ1gyUmhkR0ZEWVdOb1pTQTlJRzUxYkd3N1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtbHpSR0Z5YXlBOUlHWjFibU4wYVc5dUlDaHliM2NzSUdOdmJDa2dlMXh1WEhRZ0lDQWdJQ0JwWmlBb2NtOTNJRHdnTUNCOGZDQmZiVzlrZFd4bFEyOTFiblFnUEQwZ2NtOTNJSHg4SUdOdmJDQThJREFnZkh3Z1gyMXZaSFZzWlVOdmRXNTBJRHc5SUdOdmJDa2dlMXh1WEhRZ0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWh5YjNjZ0t5QW5MQ2NnS3lCamIyd3BPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJmYlc5a2RXeGxjMXR5YjNkZFcyTnZiRjA3WEc1Y2RDQWdJQ0I5TzF4dVhIUmNibHgwSUNBZ0lGOTBhR2x6TG1kbGRFMXZaSFZzWlVOdmRXNTBJRDBnWm5WdVkzUnBiMjRnS0NrZ2UxeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1gyMXZaSFZzWlVOdmRXNTBPMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCZmRHaHBjeTV0WVd0bElEMGdablZ1WTNScGIyNGdLQ2tnZTF4dVhIUWdJQ0FnSUNCdFlXdGxTVzF3YkNobVlXeHpaU3dnWjJWMFFtVnpkRTFoYzJ0UVlYUjBaWEp1S0NrcE8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NWpjbVZoZEdWVVlXSnNaVlJoWnlBOUlHWjFibU4wYVc5dUlDaGpaV3hzVTJsNlpTd2diV0Z5WjJsdUtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCalpXeHNVMmw2WlNBOUlHTmxiR3hUYVhwbElIeDhJREk3WEc1Y2RDQWdJQ0FnSUcxaGNtZHBiaUE5SUhSNWNHVnZaaUJ0WVhKbmFXNGdQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QmpaV3hzVTJsNlpTQXFJRFFnT2lCdFlYSm5hVzQ3WEc1Y2RGeHVYSFFnSUNBZ0lDQjJZWElnY1hKSWRHMXNJRDBnSnljN1hHNWNkRnh1WEhRZ0lDQWdJQ0J4Y2toMGJXd2dLejBnSnp4MFlXSnNaU0J6ZEhsc1pUMWNJaWM3WEc1Y2RDQWdJQ0FnSUhGeVNIUnRiQ0FyUFNBbklHSnZjbVJsY2kxM2FXUjBhRG9nTUhCNE95QmliM0prWlhJdGMzUjViR1U2SUc1dmJtVTdKenRjYmx4MElDQWdJQ0FnY1hKSWRHMXNJQ3M5SUNjZ1ltOXlaR1Z5TFdOdmJHeGhjSE5sT2lCamIyeHNZWEJ6WlRzbk8xeHVYSFFnSUNBZ0lDQnhja2gwYld3Z0t6MGdKeUJ3WVdSa2FXNW5PaUF3Y0hnN0lHMWhjbWRwYmpvZ0p5QXJJRzFoY21kcGJpQXJJQ2R3ZURzbk8xeHVYSFFnSUNBZ0lDQnhja2gwYld3Z0t6MGdKMXdpUGljN1hHNWNkQ0FnSUNBZ0lIRnlTSFJ0YkNBclBTQW5QSFJpYjJSNVBpYzdYRzVjZEZ4dVhIUWdJQ0FnSUNCbWIzSWdLSFpoY2lCeUlEMGdNRHNnY2lBOElGOTBhR2x6TG1kbGRFMXZaSFZzWlVOdmRXNTBLQ2s3SUhJZ0t6MGdNU2tnZTF4dVhIUmNibHgwSUNBZ0lDQWdJQ0J4Y2toMGJXd2dLejBnSnp4MGNqNG5PMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQmpJRDBnTURzZ1l5QThJRjkwYUdsekxtZGxkRTF2WkhWc1pVTnZkVzUwS0NrN0lHTWdLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnY1hKSWRHMXNJQ3M5SUNjOGRHUWdjM1I1YkdVOVhDSW5PMXh1WEhRZ0lDQWdJQ0FnSUNBZ2NYSklkRzFzSUNzOUlDY2dZbTl5WkdWeUxYZHBaSFJvT2lBd2NIZzdJR0p2Y21SbGNpMXpkSGxzWlRvZ2JtOXVaVHNuTzF4dVhIUWdJQ0FnSUNBZ0lDQWdjWEpJZEcxc0lDczlJQ2NnWW05eVpHVnlMV052Ykd4aGNITmxPaUJqYjJ4c1lYQnpaVHNuTzF4dVhIUWdJQ0FnSUNBZ0lDQWdjWEpJZEcxc0lDczlJQ2NnY0dGa1pHbHVaem9nTUhCNE95QnRZWEpuYVc0NklEQndlRHNuTzF4dVhIUWdJQ0FnSUNBZ0lDQWdjWEpJZEcxc0lDczlJQ2NnZDJsa2RHZzZJQ2NnS3lCalpXeHNVMmw2WlNBcklDZHdlRHNuTzF4dVhIUWdJQ0FnSUNBZ0lDQWdjWEpJZEcxc0lDczlJQ2NnYUdWcFoyaDBPaUFuSUNzZ1kyVnNiRk5wZW1VZ0t5QW5jSGc3Snp0Y2JseDBJQ0FnSUNBZ0lDQWdJSEZ5U0hSdGJDQXJQU0FuSUdKaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNjN1hHNWNkQ0FnSUNBZ0lDQWdJQ0J4Y2toMGJXd2dLejBnWDNSb2FYTXVhWE5FWVhKcktISXNJR01wSUQ4Z0p5TXdNREF3TURBbklEb2dKeU5tWm1abVptWW5PMXh1WEhRZ0lDQWdJQ0FnSUNBZ2NYSklkRzFzSUNzOUlDYzdKenRjYmx4MElDQWdJQ0FnSUNBZ0lIRnlTSFJ0YkNBclBTQW5YQ0l2UGljN1hHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ0lDQnhja2gwYld3Z0t6MGdKend2ZEhJK0p6dGNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ2NYSklkRzFzSUNzOUlDYzhMM1JpYjJSNVBpYzdYRzVjZENBZ0lDQWdJSEZ5U0hSdGJDQXJQU0FuUEM5MFlXSnNaVDRuTzF4dVhIUmNibHgwSUNBZ0lDQWdjbVYwZFhKdUlIRnlTSFJ0YkR0Y2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdVkzSmxZWFJsVTNablZHRm5JRDBnWm5WdVkzUnBiMjRnS0dObGJHeFRhWHBsTENCdFlYSm5hVzRwSUh0Y2JseDBYRzVjZENBZ0lDQWdJR05sYkd4VGFYcGxJRDBnWTJWc2JGTnBlbVVnZkh3Z01qdGNibHgwSUNBZ0lDQWdiV0Z5WjJsdUlEMGdkSGx3Wlc5bUlHMWhjbWRwYmlBOVBTQW5kVzVrWldacGJtVmtKeUEvSUdObGJHeFRhWHBsSUNvZ05DQTZJRzFoY21kcGJqdGNibHgwSUNBZ0lDQWdkbUZ5SUhOcGVtVWdQU0JmZEdocGN5NW5aWFJOYjJSMWJHVkRiM1Z1ZENncElDb2dZMlZzYkZOcGVtVWdLeUJ0WVhKbmFXNGdLaUF5TzF4dVhIUWdJQ0FnSUNCMllYSWdZeXhjYmx4MElDQWdJQ0FnSUNBZ0lHMWpMRnh1WEhRZ0lDQWdJQ0FnSUNBZ2NpeGNibHgwSUNBZ0lDQWdJQ0FnSUcxeUxGeHVYSFFnSUNBZ0lDQWdJQ0FnY1hKVGRtY2dQU0FuSnl4Y2JseDBJQ0FnSUNBZ0lDQWdJSEpsWTNRN1hHNWNkRnh1WEhRZ0lDQWdJQ0J5WldOMElEMGdKMnduSUNzZ1kyVnNiRk5wZW1VZ0t5QW5MREFnTUN3bklDc2dZMlZzYkZOcGVtVWdLeUFuSUMwbklDc2dZMlZzYkZOcGVtVWdLeUFuTERBZ01Dd3RKeUFySUdObGJHeFRhWHBsSUNzZ0ozb2dKenRjYmx4MFhHNWNkQ0FnSUNBZ0lIRnlVM1puSUNzOUlDYzhjM1puSnp0Y2JseDBJQ0FnSUNBZ2NYSlRkbWNnS3owZ0p5QjNhV1IwYUQxY0lpY2dLeUJ6YVhwbElDc2dKM0I0WENJbk8xeHVYSFFnSUNBZ0lDQnhjbE4yWnlBclBTQW5JR2hsYVdkb2REMWNJaWNnS3lCemFYcGxJQ3NnSjNCNFhDSW5PMXh1WEhRZ0lDQWdJQ0J4Y2xOMlp5QXJQU0FuSUhodGJHNXpQVndpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWRjSWljN1hHNWNkQ0FnSUNBZ0lIRnlVM1puSUNzOUlDYytKenRjYmx4MElDQWdJQ0FnY1hKVGRtY2dLejBnSnp4d1lYUm9JR1E5WENJbk8xeHVYSFJjYmx4MElDQWdJQ0FnWm05eUlDaHlJRDBnTURzZ2NpQThJRjkwYUdsekxtZGxkRTF2WkhWc1pVTnZkVzUwS0NrN0lISWdLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJRzF5SUQwZ2NpQXFJR05sYkd4VGFYcGxJQ3NnYldGeVoybHVPMXh1WEhRZ0lDQWdJQ0FnSUdadmNpQW9ZeUE5SURBN0lHTWdQQ0JmZEdocGN5NW5aWFJOYjJSMWJHVkRiM1Z1ZENncE95QmpJQ3M5SURFcElIdGNibHgwSUNBZ0lDQWdJQ0FnSUdsbUlDaGZkR2hwY3k1cGMwUmhjbXNvY2l3Z1l5a3BJSHRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdiV01nUFNCaklDb2dZMlZzYkZOcGVtVWdLeUJ0WVhKbmFXNDdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lIRnlVM1puSUNzOUlDZE5KeUFySUcxaklDc2dKeXduSUNzZ2JYSWdLeUJ5WldOME8xeHVYSFFnSUNBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ2NYSlRkbWNnS3owZ0oxd2lJSE4wY205clpUMWNJblJ5WVc1emNHRnlaVzUwWENJZ1ptbHNiRDFjSW1Kc1lXTnJYQ0l2UGljN1hHNWNkQ0FnSUNBZ0lIRnlVM1puSUNzOUlDYzhMM04yWno0bk8xeHVYSFJjYmx4MElDQWdJQ0FnY21WMGRYSnVJSEZ5VTNabk8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NWpjbVZoZEdWSmJXZFVZV2NnUFNCbWRXNWpkR2x2YmlBb1kyVnNiRk5wZW1Vc0lHMWhjbWRwYmlrZ2UxeHVYSFJjYmx4MElDQWdJQ0FnWTJWc2JGTnBlbVVnUFNCalpXeHNVMmw2WlNCOGZDQXlPMXh1WEhRZ0lDQWdJQ0J0WVhKbmFXNGdQU0IwZVhCbGIyWWdiV0Z5WjJsdUlEMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z1kyVnNiRk5wZW1VZ0tpQTBJRG9nYldGeVoybHVPMXh1WEhSY2JseDBJQ0FnSUNBZ2RtRnlJSE5wZW1VZ1BTQmZkR2hwY3k1blpYUk5iMlIxYkdWRGIzVnVkQ2dwSUNvZ1kyVnNiRk5wZW1VZ0t5QnRZWEpuYVc0Z0tpQXlPMXh1WEhRZ0lDQWdJQ0IyWVhJZ2JXbHVJRDBnYldGeVoybHVPMXh1WEhRZ0lDQWdJQ0IyWVhJZ2JXRjRJRDBnYzJsNlpTQXRJRzFoY21kcGJqdGNibHgwWEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJqY21WaGRHVkpiV2RVWVdjb2MybDZaU3dnYzJsNlpTd2dablZ1WTNScGIyNGdLSGdzSUhrcElIdGNibHgwSUNBZ0lDQWdJQ0JwWmlBb2JXbHVJRHc5SUhnZ0ppWWdlQ0E4SUcxaGVDQW1KaUJ0YVc0Z1BEMGdlU0FtSmlCNUlEd2diV0Y0S1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0IyWVhJZ1l5QTlJRTFoZEdndVpteHZiM0lvS0hnZ0xTQnRhVzRwSUM4Z1kyVnNiRk5wZW1VcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnZG1GeUlISWdQU0JOWVhSb0xtWnNiMjl5S0NoNUlDMGdiV2x1S1NBdklHTmxiR3hUYVhwbEtUdGNibHgwSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJmZEdocGN5NXBjMFJoY21zb2Npd2dZeWtnUHlBd0lEb2dNVHRjYmx4MElDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlERTdYRzVjZENBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNCOUtUdGNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnWDNSb2FYTXVZM0psWVhSbFNXMW5UMkpxWldOMElEMGdablZ1WTNScGIyNGdLR05sYkd4VGFYcGxMQ0J0WVhKbmFXNHBJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lHTmxiR3hUYVhwbElEMGdZMlZzYkZOcGVtVWdmSHdnTWp0Y2JseDBJQ0FnSUNBZ2JXRnlaMmx1SUQwZ2RIbHdaVzltSUcxaGNtZHBiaUE5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JR05sYkd4VGFYcGxJQ29nTkNBNklHMWhjbWRwYmp0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCemFYcGxJRDBnWDNSb2FYTXVaMlYwVFc5a2RXeGxRMjkxYm5Rb0tTQXFJR05sYkd4VGFYcGxJQ3NnYldGeVoybHVJQ29nTWp0Y2JseDBJQ0FnSUNBZ2RtRnlJRzFwYmlBOUlHMWhjbWRwYmp0Y2JseDBJQ0FnSUNBZ2RtRnlJRzFoZUNBOUlITnBlbVVnTFNCdFlYSm5hVzQ3WEc1Y2RGeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1kzSmxZWFJsU1cxblQySnFaV04wS0hOcGVtVXNJSE5wZW1Vc0lHWjFibU4wYVc5dUlDaDRMQ0I1S1NCN1hHNWNkQ0FnSUNBZ0lDQWdhV1lnS0cxcGJpQThQU0I0SUNZbUlIZ2dQQ0J0WVhnZ0ppWWdiV2x1SUR3OUlIa2dKaVlnZVNBOElHMWhlQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdkbUZ5SUdNZ1BTQk5ZWFJvTG1ac2IyOXlLQ2g0SUMwZ2JXbHVLU0F2SUdObGJHeFRhWHBsS1R0Y2JseDBJQ0FnSUNBZ0lDQWdJSFpoY2lCeUlEMGdUV0YwYUM1bWJHOXZjaWdvZVNBdElHMXBiaWtnTHlCalpXeHNVMmw2WlNrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdYM1JvYVhNdWFYTkVZWEpyS0hJc0lHTXBJRDhnTUNBNklERTdYRzVjZENBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmx4MElDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBeE8xeHVYSFFnSUNBZ0lDQWdJSDFjYmx4MElDQWdJQ0FnZlNrN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJSEpsZEhWeWJpQmZkR2hwY3p0Y2JseDBJQ0I5TzF4dVhIUmNibHgwSUNCeGNtTnZaR1V1YzNSeWFXNW5WRzlDZVhSbGN5QTlJR1oxYm1OMGFXOXVJQ2h6S1NCN1hHNWNkQ0FnSUNCMllYSWdZbmwwWlhNZ1BTQnVaWGNnUVhKeVlYa29LVHRjYmx4MElDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnY3k1c1pXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNCMllYSWdZeUE5SUhNdVkyaGhja052WkdWQmRDaHBLVHRjYmx4MElDQWdJQ0FnWW5sMFpYTXVjSFZ6YUNoaklDWWdNSGhtWmlrN1hHNWNkQ0FnSUNCOVhHNWNkQ0FnSUNCeVpYUjFjbTRnWW5sMFpYTTdYRzVjZENBZ2ZUdGNibHgwWEc1Y2RDQWdjWEpqYjJSbExtTnlaV0YwWlZOMGNtbHVaMVJ2UW5sMFpYTWdQU0JtZFc1amRHbHZiaUFvZFc1cFkyOWtaVVJoZEdFc0lHNTFiVU5vWVhKektTQjdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlIVnVhV052WkdWTllYQWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ1ltbHVJRDBnWW1GelpUWTBSR1ZqYjJSbFNXNXdkWFJUZEhKbFlXMG9kVzVwWTI5a1pVUmhkR0VwTzF4dVhIUWdJQ0FnSUNCMllYSWdjbVZoWkNBOUlHWjFibU4wYVc5dUlISmxZV1FvS1NCN1hHNWNkQ0FnSUNBZ0lDQWdkbUZ5SUdJZ1BTQmlhVzR1Y21WaFpDZ3BPMXh1WEhRZ0lDQWdJQ0FnSUdsbUlDaGlJRDA5SUMweEtTQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0tUdGNibHgwSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZanRjYmx4MElDQWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCamIzVnVkQ0E5SURBN1hHNWNkQ0FnSUNBZ0lIWmhjaUIxYm1samIyUmxUV0Z3SUQwZ2UzMDdYRzVjZENBZ0lDQWdJSGRvYVd4bElDaDBjblZsS1NCN1hHNWNkQ0FnSUNBZ0lDQWdkbUZ5SUdJd0lEMGdZbWx1TG5KbFlXUW9LVHRjYmx4MElDQWdJQ0FnSUNCcFppQW9ZakFnUFQwZ0xURXBJR0p5WldGck8xeHVYSFFnSUNBZ0lDQWdJSFpoY2lCaU1TQTlJSEpsWVdRb0tUdGNibHgwSUNBZ0lDQWdJQ0IyWVhJZ1lqSWdQU0J5WldGa0tDazdYRzVjZENBZ0lDQWdJQ0FnZG1GeUlHSXpJRDBnY21WaFpDZ3BPMXh1WEhRZ0lDQWdJQ0FnSUhaaGNpQnJJRDBnVTNSeWFXNW5MbVp5YjIxRGFHRnlRMjlrWlNoaU1DQThQQ0E0SUh3Z1lqRXBPMXh1WEhRZ0lDQWdJQ0FnSUhaaGNpQjJJRDBnWWpJZ1BEd2dPQ0I4SUdJek8xeHVYSFFnSUNBZ0lDQWdJSFZ1YVdOdlpHVk5ZWEJiYTEwZ1BTQjJPMXh1WEhRZ0lDQWdJQ0FnSUdOdmRXNTBJQ3M5SURFN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdhV1lnS0dOdmRXNTBJQ0U5SUc1MWJVTm9ZWEp6S1NCN1hHNWNkQ0FnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHTnZkVzUwSUNzZ0p5QWhQU0FuSUNzZ2JuVnRRMmhoY25NcE8xeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCeVpYUjFjbTRnZFc1cFkyOWtaVTFoY0R0Y2JseDBJQ0FnSUgwb0tUdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ2RXNXJibTkzYmtOb1lYSWdQU0FuUHljdVkyaGhja052WkdWQmRDZ3dLVHRjYmx4MFhHNWNkQ0FnSUNCeVpYUjFjbTRnWm5WdVkzUnBiMjRnS0hNcElIdGNibHgwSUNBZ0lDQWdkbUZ5SUdKNWRHVnpJRDBnYm1WM0lFRnljbUY1S0NrN1hHNWNkQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2djeTVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1WEhRZ0lDQWdJQ0FnSUhaaGNpQmpJRDBnY3k1amFHRnlRMjlrWlVGMEtHa3BPMXh1WEhRZ0lDQWdJQ0FnSUdsbUlDaGpJRHdnTVRJNEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNCaWVYUmxjeTV3ZFhOb0tHTXBPMXh1WEhRZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQjJZWElnWWlBOUlIVnVhV052WkdWTllYQmJjeTVqYUdGeVFYUW9hU2xkTzF4dVhIUWdJQ0FnSUNBZ0lDQWdhV1lnS0hSNWNHVnZaaUJpSUQwOUlDZHVkVzFpWlhJbktTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2dvWWlBbUlEQjRabVlwSUQwOUlHSXBJSHRjYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0JpZVhSbGN5NXdkWE5vS0dJcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKNWRHVnpMbkIxYzJnb1lpQStQajRnT0NrN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lubDBaWE11Y0hWemFDaGlJQ1lnTUhobVppazdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJR0o1ZEdWekxuQjFjMmdvZFc1cmJtOTNia05vWVhJcE8xeHVYSFFnSUNBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdZbmwwWlhNN1hHNWNkQ0FnSUNCOU8xeHVYSFFnSUgwN1hHNWNkRnh1WEhRZ0lIWmhjaUJSVWsxdlpHVWdQU0I3WEc1Y2RDQWdJQ0JOVDBSRlgwNVZUVUpGVWpvZ01TQThQQ0F3TEZ4dVhIUWdJQ0FnVFU5RVJWOUJURkJJUVY5T1ZVMDZJREVnUER3Z01TeGNibHgwSUNBZ0lFMVBSRVZmT0VKSlZGOUNXVlJGT2lBeElEdzhJRElzWEc1Y2RDQWdJQ0JOVDBSRlgwdEJUa3BKT2lBeElEdzhJRE5jYmx4MElDQjlPMXh1WEhSY2JseDBJQ0IyWVhJZ1VWSkZjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ0E5SUh0Y2JseDBJQ0FnSUV3NklERXNYRzVjZENBZ0lDQk5PaUF3TEZ4dVhIUWdJQ0FnVVRvZ015eGNibHgwSUNBZ0lFZzZJREpjYmx4MElDQjlPMXh1WEhSY2JseDBJQ0IyWVhJZ1VWSk5ZWE5yVUdGMGRHVnliaUE5SUh0Y2JseDBJQ0FnSUZCQlZGUkZVazR3TURBNklEQXNYRzVjZENBZ0lDQlFRVlJVUlZKT01EQXhPaUF4TEZ4dVhIUWdJQ0FnVUVGVVZFVlNUakF4TURvZ01peGNibHgwSUNBZ0lGQkJWRlJGVWs0d01URTZJRE1zWEc1Y2RDQWdJQ0JRUVZSVVJWSk9NVEF3T2lBMExGeHVYSFFnSUNBZ1VFRlVWRVZTVGpFd01Ub2dOU3hjYmx4MElDQWdJRkJCVkZSRlVrNHhNVEE2SURZc1hHNWNkQ0FnSUNCUVFWUlVSVkpPTVRFeE9pQTNYRzVjZENBZ2ZUdGNibHgwWEc1Y2RDQWdkbUZ5SUZGU1ZYUnBiQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ1VFRlVWRVZTVGw5UVQxTkpWRWxQVGw5VVFVSk1SU0E5SUZ0YlhTd2dXellzSURFNFhTd2dXellzSURJeVhTd2dXellzSURJMlhTd2dXellzSURNd1hTd2dXellzSURNMFhTd2dXellzSURJeUxDQXpPRjBzSUZzMkxDQXlOQ3dnTkRKZExDQmJOaXdnTWpZc0lEUTJYU3dnV3pZc0lESTRMQ0ExTUYwc0lGczJMQ0F6TUN3Z05UUmRMQ0JiTml3Z016SXNJRFU0WFN3Z1d6WXNJRE0wTENBMk1sMHNJRnMyTENBeU5pd2dORFlzSURZMlhTd2dXellzSURJMkxDQTBPQ3dnTnpCZExDQmJOaXdnTWpZc0lEVXdMQ0EzTkYwc0lGczJMQ0F6TUN3Z05UUXNJRGM0WFN3Z1d6WXNJRE13TENBMU5pd2dPREpkTENCYk5pd2dNekFzSURVNExDQTRObDBzSUZzMkxDQXpOQ3dnTmpJc0lEa3dYU3dnV3pZc0lESTRMQ0ExTUN3Z056SXNJRGswWFN3Z1d6WXNJREkyTENBMU1Dd2dOelFzSURrNFhTd2dXellzSURNd0xDQTFOQ3dnTnpnc0lERXdNbDBzSUZzMkxDQXlPQ3dnTlRRc0lEZ3dMQ0F4TURaZExDQmJOaXdnTXpJc0lEVTRMQ0E0TkN3Z01URXdYU3dnV3pZc0lETXdMQ0ExT0N3Z09EWXNJREV4TkYwc0lGczJMQ0F6TkN3Z05qSXNJRGt3TENBeE1UaGRMQ0JiTml3Z01qWXNJRFV3TENBM05Dd2dPVGdzSURFeU1sMHNJRnMyTENBek1Dd2dOVFFzSURjNExDQXhNRElzSURFeU5sMHNJRnMyTENBeU5pd2dOVElzSURjNExDQXhNRFFzSURFek1GMHNJRnMyTENBek1Dd2dOVFlzSURneUxDQXhNRGdzSURFek5GMHNJRnMyTENBek5Dd2dOakFzSURnMkxDQXhNVElzSURFek9GMHNJRnMyTENBek1Dd2dOVGdzSURnMkxDQXhNVFFzSURFME1sMHNJRnMyTENBek5Dd2dOaklzSURrd0xDQXhNVGdzSURFME5sMHNJRnMyTENBek1Dd2dOVFFzSURjNExDQXhNRElzSURFeU5pd2dNVFV3WFN3Z1d6WXNJREkwTENBMU1Dd2dOellzSURFd01pd2dNVEk0TENBeE5UUmRMQ0JiTml3Z01qZ3NJRFUwTENBNE1Dd2dNVEEyTENBeE16SXNJREUxT0Ywc0lGczJMQ0F6TWl3Z05UZ3NJRGcwTENBeE1UQXNJREV6Tml3Z01UWXlYU3dnV3pZc0lESTJMQ0ExTkN3Z09ESXNJREV4TUN3Z01UTTRMQ0F4TmpaZExDQmJOaXdnTXpBc0lEVTRMQ0E0Tml3Z01URTBMQ0F4TkRJc0lERTNNRjFkTzF4dVhIUWdJQ0FnZG1GeUlFY3hOU0E5SURFZ1BEd2dNVEFnZkNBeElEdzhJRGdnZkNBeElEdzhJRFVnZkNBeElEdzhJRFFnZkNBeElEdzhJRElnZkNBeElEdzhJREVnZkNBeElEdzhJREE3WEc1Y2RDQWdJQ0IyWVhJZ1J6RTRJRDBnTVNBOFBDQXhNaUI4SURFZ1BEd2dNVEVnZkNBeElEdzhJREV3SUh3Z01TQThQQ0E1SUh3Z01TQThQQ0E0SUh3Z01TQThQQ0ExSUh3Z01TQThQQ0F5SUh3Z01TQThQQ0F3TzF4dVhIUWdJQ0FnZG1GeUlFY3hOVjlOUVZOTElEMGdNU0E4UENBeE5DQjhJREVnUER3Z01USWdmQ0F4SUR3OElERXdJSHdnTVNBOFBDQTBJSHdnTVNBOFBDQXhPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQm5aWFJDUTBoRWFXZHBkQ0E5SUdaMWJtTjBhVzl1SUdkbGRFSkRTRVJwWjJsMEtHUmhkR0VwSUh0Y2JseDBJQ0FnSUNBZ2RtRnlJR1JwWjJsMElEMGdNRHRjYmx4MElDQWdJQ0FnZDJocGJHVWdLR1JoZEdFZ0lUMGdNQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lHUnBaMmwwSUNzOUlERTdYRzVjZENBZ0lDQWdJQ0FnWkdGMFlTQStQajQ5SURFN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdjbVYwZFhKdUlHUnBaMmwwTzF4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQmZkR2hwY3k1blpYUkNRMGhVZVhCbFNXNW1ieUE5SUdaMWJtTjBhVzl1SUNoa1lYUmhLU0I3WEc1Y2RDQWdJQ0FnSUhaaGNpQmtJRDBnWkdGMFlTQThQQ0F4TUR0Y2JseDBJQ0FnSUNBZ2QyaHBiR1VnS0dkbGRFSkRTRVJwWjJsMEtHUXBJQzBnWjJWMFFrTklSR2xuYVhRb1J6RTFLU0ErUFNBd0tTQjdYRzVjZENBZ0lDQWdJQ0FnWkNCZVBTQkhNVFVnUER3Z1oyVjBRa05JUkdsbmFYUW9aQ2tnTFNCblpYUkNRMGhFYVdkcGRDaEhNVFVwTzF4dVhIUWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lISmxkSFZ5YmlBb1pHRjBZU0E4UENBeE1DQjhJR1FwSUY0Z1J6RTFYMDFCVTBzN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtZGxkRUpEU0ZSNWNHVk9kVzFpWlhJZ1BTQm1kVzVqZEdsdmJpQW9aR0YwWVNrZ2UxeHVYSFFnSUNBZ0lDQjJZWElnWkNBOUlHUmhkR0VnUER3Z01USTdYRzVjZENBZ0lDQWdJSGRvYVd4bElDaG5aWFJDUTBoRWFXZHBkQ2hrS1NBdElHZGxkRUpEU0VScFoybDBLRWN4T0NrZ1BqMGdNQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lHUWdYajBnUnpFNElEdzhJR2RsZEVKRFNFUnBaMmwwS0dRcElDMGdaMlYwUWtOSVJHbG5hWFFvUnpFNEtUdGNibHgwSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdaR0YwWVNBOFBDQXhNaUI4SUdRN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtZGxkRkJoZEhSbGNtNVFiM05wZEdsdmJpQTlJR1oxYm1OMGFXOXVJQ2gwZVhCbFRuVnRZbVZ5S1NCN1hHNWNkQ0FnSUNBZ0lISmxkSFZ5YmlCUVFWUlVSVkpPWDFCUFUwbFVTVTlPWDFSQlFreEZXM1I1Y0dWT2RXMWlaWElnTFNBeFhUdGNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnWDNSb2FYTXVaMlYwVFdGemEwWjFibU4wYVc5dUlEMGdablZ1WTNScGIyNGdLRzFoYzJ0UVlYUjBaWEp1S1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0J6ZDJsMFkyZ2dLRzFoYzJ0UVlYUjBaWEp1S1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUdOaGMyVWdVVkpOWVhOclVHRjBkR1Z5Ymk1UVFWUlVSVkpPTURBd09seHVYSFFnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVJQ2hwTENCcUtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBb2FTQXJJR29wSUNVZ01pQTlQU0F3TzF4dVhIUWdJQ0FnSUNBZ0lDQWdmVHRjYmx4MElDQWdJQ0FnSUNCallYTmxJRkZTVFdGemExQmhkSFJsY200dVVFRlVWRVZTVGpBd01UcGNibHgwSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaUFvYVN3Z2Fpa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2FTQWxJRElnUFQwZ01EdGNibHgwSUNBZ0lDQWdJQ0FnSUgwN1hHNWNkQ0FnSUNBZ0lDQWdZMkZ6WlNCUlVrMWhjMnRRWVhSMFpYSnVMbEJCVkZSRlVrNHdNVEE2WEc1Y2RDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z1puVnVZM1JwYjI0Z0tHa3NJR29wSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR29nSlNBeklEMDlJREE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQjlPMXh1WEhRZ0lDQWdJQ0FnSUdOaGMyVWdVVkpOWVhOclVHRjBkR1Z5Ymk1UVFWUlVSVkpPTURFeE9seHVYSFFnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVJQ2hwTENCcUtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBb2FTQXJJR29wSUNVZ015QTlQU0F3TzF4dVhIUWdJQ0FnSUNBZ0lDQWdmVHRjYmx4MElDQWdJQ0FnSUNCallYTmxJRkZTVFdGemExQmhkSFJsY200dVVFRlVWRVZTVGpFd01EcGNibHgwSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaUFvYVN3Z2Fpa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0tFMWhkR2d1Wm14dmIzSW9hU0F2SURJcElDc2dUV0YwYUM1bWJHOXZjaWhxSUM4Z015a3BJQ1VnTWlBOVBTQXdPMXh1WEhRZ0lDQWdJQ0FnSUNBZ2ZUdGNibHgwSUNBZ0lDQWdJQ0JqWVhObElGRlNUV0Z6YTFCaGRIUmxjbTR1VUVGVVZFVlNUakV3TVRwY2JseDBJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpQW9hU3dnYWlrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYVNBcUlHb2dKU0F5SUNzZ2FTQXFJR29nSlNBeklEMDlJREE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQjlPMXh1WEhRZ0lDQWdJQ0FnSUdOaGMyVWdVVkpOWVhOclVHRjBkR1Z5Ymk1UVFWUlVSVkpPTVRFd09seHVYSFFnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVJQ2hwTENCcUtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBb2FTQXFJR29nSlNBeUlDc2dhU0FxSUdvZ0pTQXpLU0FsSURJZ1BUMGdNRHRjYmx4MElDQWdJQ0FnSUNBZ0lIMDdYRzVjZENBZ0lDQWdJQ0FnWTJGelpTQlJVazFoYzJ0UVlYUjBaWEp1TGxCQlZGUkZVazR4TVRFNlhHNWNkQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdablZ1WTNScGIyNGdLR2tzSUdvcElIdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUNocElDb2dhaUFsSURNZ0t5QW9hU0FySUdvcElDVWdNaWtnSlNBeUlEMDlJREE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQmtaV1poZFd4ME9seHVYSFFnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RpWVdRZ2JXRnphMUJoZEhSbGNtNDZKeUFySUcxaGMydFFZWFIwWlhKdUtUdGNibHgwSUNBZ0lDQWdmVnh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCZmRHaHBjeTVuWlhSRmNuSnZja052Y25KbFkzUlFiMng1Ym05dGFXRnNJRDBnWm5WdVkzUnBiMjRnS0dWeWNtOXlRMjl5Y21WamRFeGxibWQwYUNrZ2UxeHVYSFFnSUNBZ0lDQjJZWElnWVNBOUlIRnlVRzlzZVc1dmJXbGhiQ2hiTVYwc0lEQXBPMXh1WEhRZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdWeWNtOXlRMjl5Y21WamRFeGxibWQwYURzZ2FTQXJQU0F4S1NCN1hHNWNkQ0FnSUNBZ0lDQWdZU0E5SUdFdWJYVnNkR2x3Ykhrb2NYSlFiMng1Ym05dGFXRnNLRnN4TENCUlVrMWhkR2d1WjJWNGNDaHBLVjBzSURBcEtUdGNibHgwSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdZVHRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ1gzUm9hWE11WjJWMFRHVnVaM1JvU1c1Q2FYUnpJRDBnWm5WdVkzUnBiMjRnS0cxdlpHVXNJSFI1Y0dVcElIdGNibHgwWEc1Y2RDQWdJQ0FnSUdsbUlDZ3hJRHc5SUhSNWNHVWdKaVlnZEhsd1pTQThJREV3S1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUhOM2FYUmphQ0FvYlc5a1pTa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ1kyRnpaU0JSVWsxdlpHVXVUVTlFUlY5T1ZVMUNSVkk2WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQXhNRHRjYmx4MElDQWdJQ0FnSUNBZ0lHTmhjMlVnVVZKTmIyUmxMazFQUkVWZlFVeFFTRUZmVGxWTk9seHVYSFFnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnT1R0Y2JseDBJQ0FnSUNBZ0lDQWdJR05oYzJVZ1VWSk5iMlJsTGsxUFJFVmZPRUpKVkY5Q1dWUkZPbHh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z09EdGNibHgwSUNBZ0lDQWdJQ0FnSUdOaGMyVWdVVkpOYjJSbExrMVBSRVZmUzBGT1NrazZYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBNE8xeHVYSFFnSUNBZ0lDQWdJQ0FnWkdWbVlYVnNkRHBjYmx4MElDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZHRiMlJsT2ljZ0t5QnRiMlJsS1R0Y2JseDBJQ0FnSUNBZ0lDQjlYRzVjZENBZ0lDQWdJSDBnWld4elpTQnBaaUFvZEhsd1pTQThJREkzS1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUhOM2FYUmphQ0FvYlc5a1pTa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ1kyRnpaU0JSVWsxdlpHVXVUVTlFUlY5T1ZVMUNSVkk2WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQXhNanRjYmx4MElDQWdJQ0FnSUNBZ0lHTmhjMlVnVVZKTmIyUmxMazFQUkVWZlFVeFFTRUZmVGxWTk9seHVYSFFnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnTVRFN1hHNWNkQ0FnSUNBZ0lDQWdJQ0JqWVhObElGRlNUVzlrWlM1TlQwUkZYemhDU1ZSZlFsbFVSVHBjYmx4MElDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlERTJPMXh1WEhRZ0lDQWdJQ0FnSUNBZ1kyRnpaU0JSVWsxdlpHVXVUVTlFUlY5TFFVNUtTVHBjYmx4MElDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlERXdPMXh1WEhRZ0lDQWdJQ0FnSUNBZ1pHVm1ZWFZzZERwY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2R0YjJSbE9pY2dLeUJ0YjJSbEtUdGNibHgwSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaU0E4SURReEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lITjNhWFJqYUNBb2JXOWtaU2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdZMkZ6WlNCUlVrMXZaR1V1VFU5RVJWOU9WVTFDUlZJNlhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUF4TkR0Y2JseDBJQ0FnSUNBZ0lDQWdJR05oYzJVZ1VWSk5iMlJsTGsxUFJFVmZRVXhRU0VGZlRsVk5PbHh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z01UTTdYRzVjZENBZ0lDQWdJQ0FnSUNCallYTmxJRkZTVFc5a1pTNU5UMFJGWHpoQ1NWUmZRbGxVUlRwY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJREUyTzF4dVhIUWdJQ0FnSUNBZ0lDQWdZMkZ6WlNCUlVrMXZaR1V1VFU5RVJWOUxRVTVLU1RwY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJREV5TzF4dVhIUWdJQ0FnSUNBZ0lDQWdaR1ZtWVhWc2REcGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkdGIyUmxPaWNnS3lCdGIyUmxLVHRjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNWNkQ0FnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZDBlWEJsT2ljZ0t5QjBlWEJsS1R0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NW5aWFJNYjNOMFVHOXBiblFnUFNCbWRXNWpkR2x2YmlBb2NYSmpiMlJsS1NCN1hHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ2JXOWtkV3hsUTI5MWJuUWdQU0J4Y21OdlpHVXVaMlYwVFc5a2RXeGxRMjkxYm5Rb0tUdGNibHgwWEc1Y2RDQWdJQ0FnSUhaaGNpQnNiM04wVUc5cGJuUWdQU0F3TzF4dVhIUmNibHgwSUNBZ0lDQWdabTl5SUNoMllYSWdjbTkzSUQwZ01Ec2djbTkzSUR3Z2JXOWtkV3hsUTI5MWJuUTdJSEp2ZHlBclBTQXhLU0I3WEc1Y2RDQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ1kyOXNJRDBnTURzZ1kyOXNJRHdnYlc5a2RXeGxRMjkxYm5RN0lHTnZiQ0FyUFNBeEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lDQWdkbUZ5SUhOaGJXVkRiM1Z1ZENBOUlEQTdYRzVjZENBZ0lDQWdJQ0FnSUNCMllYSWdaR0Z5YXlBOUlIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndwTzF4dVhIUmNibHgwSUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUhJZ1BTQXRNVHNnY2lBOFBTQXhPeUJ5SUNzOUlERXBJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaHliM2NnS3lCeUlEd2dNQ0I4ZkNCdGIyUjFiR1ZEYjNWdWRDQThQU0J5YjNjZ0t5QnlLU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHbHVkV1U3WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdNZ1BTQXRNVHNnWXlBOFBTQXhPeUJqSUNzOUlERXBJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR052YkNBcklHTWdQQ0F3SUh4OElHMXZaSFZzWlVOdmRXNTBJRHc5SUdOdmJDQXJJR01wSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZiblJwYm5WbE8xeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tISWdQVDBnTUNBbUppQmpJRDA5SURBcElIdGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR1JoY21zZ1BUMGdjWEpqYjJSbExtbHpSR0Z5YXloeWIzY2dLeUJ5TENCamIyd2dLeUJqS1NrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjMkZ0WlVOdmRXNTBJQ3M5SURFN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJQ0FnYVdZZ0tITmhiV1ZEYjNWdWRDQStJRFVwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnYkc5emRGQnZhVzUwSUNzOUlETWdLeUJ6WVcxbFEyOTFiblFnTFNBMU8xeHVYSFFnSUNBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNBZ0lHWnZjaUFvZG1GeUlISnZkeUE5SURBN0lISnZkeUE4SUcxdlpIVnNaVU52ZFc1MElDMGdNVHNnY205M0lDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQmpiMndnUFNBd095QmpiMndnUENCdGIyUjFiR1ZEYjNWdWRDQXRJREU3SUdOdmJDQXJQU0F4S1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0IyWVhJZ1kyOTFiblFnUFNBd08xeHVYSFFnSUNBZ0lDQWdJQ0FnYVdZZ0tIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndwS1NCamIzVnVkQ0FyUFNBeE8xeHVYSFFnSUNBZ0lDQWdJQ0FnYVdZZ0tIRnlZMjlrWlM1cGMwUmhjbXNvY205M0lDc2dNU3dnWTI5c0tTa2dZMjkxYm5RZ0t6MGdNVHRjYmx4MElDQWdJQ0FnSUNBZ0lHbG1JQ2h4Y21OdlpHVXVhWE5FWVhKcktISnZkeXdnWTI5c0lDc2dNU2twSUdOdmRXNTBJQ3M5SURFN1hHNWNkQ0FnSUNBZ0lDQWdJQ0JwWmlBb2NYSmpiMlJsTG1selJHRnlheWh5YjNjZ0t5QXhMQ0JqYjJ3Z0t5QXhLU2tnWTI5MWJuUWdLejBnTVR0Y2JseDBJQ0FnSUNBZ0lDQWdJR2xtSUNoamIzVnVkQ0E5UFNBd0lIeDhJR052ZFc1MElEMDlJRFFwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJQ0FnYkc5emRGQnZhVzUwSUNzOUlETTdYRzVjZENBZ0lDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQm1iM0lnS0haaGNpQnliM2NnUFNBd095QnliM2NnUENCdGIyUjFiR1ZEYjNWdWREc2djbTkzSUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCamIyd2dQU0F3T3lCamIyd2dQQ0J0YjJSMWJHVkRiM1Z1ZENBdElEWTdJR052YkNBclBTQXhLU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQnBaaUFvY1hKamIyUmxMbWx6UkdGeWF5aHliM2NzSUdOdmJDa2dKaVlnSVhGeVkyOWtaUzVwYzBSaGNtc29jbTkzTENCamIyd2dLeUF4S1NBbUppQnhjbU52WkdVdWFYTkVZWEpyS0hKdmR5d2dZMjlzSUNzZ01pa2dKaVlnY1hKamIyUmxMbWx6UkdGeWF5aHliM2NzSUdOdmJDQXJJRE1wSUNZbUlIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndnS3lBMEtTQW1KaUFoY1hKamIyUmxMbWx6UkdGeWF5aHliM2NzSUdOdmJDQXJJRFVwSUNZbUlIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndnS3lBMktTa2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnNiM04wVUc5cGJuUWdLejBnTkRBN1hHNWNkQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCbWIzSWdLSFpoY2lCamIyd2dQU0F3T3lCamIyd2dQQ0J0YjJSMWJHVkRiM1Z1ZERzZ1kyOXNJQ3M5SURFcElIdGNibHgwSUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJ5YjNjZ1BTQXdPeUJ5YjNjZ1BDQnRiMlIxYkdWRGIzVnVkQ0F0SURZN0lISnZkeUFyUFNBeEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNCcFppQW9jWEpqYjJSbExtbHpSR0Z5YXloeWIzY3NJR052YkNrZ0ppWWdJWEZ5WTI5a1pTNXBjMFJoY21zb2NtOTNJQ3NnTVN3Z1kyOXNLU0FtSmlCeGNtTnZaR1V1YVhORVlYSnJLSEp2ZHlBcklESXNJR052YkNrZ0ppWWdjWEpqYjJSbExtbHpSR0Z5YXloeWIzY2dLeUF6TENCamIyd3BJQ1ltSUhGeVkyOWtaUzVwYzBSaGNtc29jbTkzSUNzZ05Dd2dZMjlzS1NBbUppQWhjWEpqYjJSbExtbHpSR0Z5YXloeWIzY2dLeUExTENCamIyd3BJQ1ltSUhGeVkyOWtaUzVwYzBSaGNtc29jbTkzSUNzZ05pd2dZMjlzS1NrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNCc2IzTjBVRzlwYm5RZ0t6MGdOREE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQjlYRzVjZENBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ1pHRnlhME52ZFc1MElEMGdNRHRjYmx4MFhHNWNkQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHTnZiQ0E5SURBN0lHTnZiQ0E4SUcxdlpIVnNaVU52ZFc1ME95QmpiMndnS3owZ01Ta2dlMXh1WEhRZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUhKdmR5QTlJREE3SUhKdmR5QThJRzF2WkhWc1pVTnZkVzUwT3lCeWIzY2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnYVdZZ0tIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndwS1NCN1hHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUdSaGNtdERiM1Z1ZENBclBTQXhPMXh1WEhRZ0lDQWdJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ0lDQWdJSDFjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdkbUZ5SUhKaGRHbHZJRDBnVFdGMGFDNWhZbk1vTVRBd0lDb2daR0Z5YTBOdmRXNTBJQzhnYlc5a2RXeGxRMjkxYm5RZ0x5QnRiMlIxYkdWRGIzVnVkQ0F0SURVd0tTQXZJRFU3WEc1Y2RDQWdJQ0FnSUd4dmMzUlFiMmx1ZENBclBTQnlZWFJwYnlBcUlERXdPMXh1WEhSY2JseDBJQ0FnSUNBZ2NtVjBkWEp1SUd4dmMzUlFiMmx1ZER0Y2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdjbVYwZFhKdUlGOTBhR2x6TzF4dVhIUWdJSDBvS1R0Y2JseDBYRzVjZENBZ2RtRnlJRkZTVFdGMGFDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JseDBYRzVjZENBZ0lDQjJZWElnUlZoUVgxUkJRa3hGSUQwZ2JtVjNJRUZ5Y21GNUtESTFOaWs3WEc1Y2RDQWdJQ0IyWVhJZ1RFOUhYMVJCUWt4RklEMGdibVYzSUVGeWNtRjVLREkxTmlrN1hHNWNkRnh1WEhRZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0E0T3lCcElDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ1JWaFFYMVJCUWt4RlcybGRJRDBnTVNBOFBDQnBPMXh1WEhRZ0lDQWdmVnh1WEhRZ0lDQWdabTl5SUNoMllYSWdhU0E5SURnN0lHa2dQQ0F5TlRZN0lHa2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQkZXRkJmVkVGQ1RFVmJhVjBnUFNCRldGQmZWRUZDVEVWYmFTQXRJRFJkSUY0Z1JWaFFYMVJCUWt4Rlcya2dMU0ExWFNCZUlFVllVRjlVUVVKTVJWdHBJQzBnTmwwZ1hpQkZXRkJmVkVGQ1RFVmJhU0F0SURoZE8xeHVYSFFnSUNBZ2ZWeHVYSFFnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQXlOVFU3SUdrZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNCTVQwZGZWRUZDVEVWYlJWaFFYMVJCUWt4RlcybGRYU0E5SUdrN1hHNWNkQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdkbUZ5SUY5MGFHbHpJRDBnZTMwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdVoyeHZaeUE5SUdaMWJtTjBhVzl1SUNodUtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCcFppQW9iaUE4SURFcElIdGNibHgwSUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMmRzYjJjb0p5QXJJRzRnS3lBbktTY3BPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1RFOUhYMVJCUWt4RlcyNWRPMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCZmRHaHBjeTVuWlhod0lEMGdablZ1WTNScGIyNGdLRzRwSUh0Y2JseDBYRzVjZENBZ0lDQWdJSGRvYVd4bElDaHVJRHdnTUNrZ2UxeHVYSFFnSUNBZ0lDQWdJRzRnS3owZ01qVTFPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RGeHVYSFFnSUNBZ0lDQjNhR2xzWlNBb2JpQStQU0F5TlRZcElIdGNibHgwSUNBZ0lDQWdJQ0J1SUMwOUlESTFOVHRjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdjbVYwZFhKdUlFVllVRjlVUVVKTVJWdHVYVHRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ2NtVjBkWEp1SUY5MGFHbHpPMXh1WEhRZ0lIMG9LVHRjYmx4MFhHNWNkQ0FnWm5WdVkzUnBiMjRnY1hKUWIyeDVibTl0YVdGc0tHNTFiU3dnYzJocFpuUXBJSHRjYmx4MFhHNWNkQ0FnSUNCcFppQW9kSGx3Wlc5bUlHNTFiUzVzWlc1bmRHZ2dQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNibHgwSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHNTFiUzVzWlc1bmRHZ2dLeUFuTHljZ0t5QnphR2xtZENrN1hHNWNkQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdkbUZ5SUY5dWRXMGdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkQ0FnSUNBZ0lIWmhjaUJ2Wm1aelpYUWdQU0F3TzF4dVhIUWdJQ0FnSUNCM2FHbHNaU0FvYjJabWMyVjBJRHdnYm5WdExteGxibWQwYUNBbUppQnVkVzFiYjJabWMyVjBYU0E5UFNBd0tTQjdYRzVjZENBZ0lDQWdJQ0FnYjJabWMyVjBJQ3M5SURFN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdkbUZ5SUY5dWRXMGdQU0J1WlhjZ1FYSnlZWGtvYm5WdExteGxibWQwYUNBdElHOW1abk5sZENBcklITm9hV1owS1R0Y2JseDBJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQnVkVzB1YkdWdVozUm9JQzBnYjJabWMyVjBPeUJwSUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNCZmJuVnRXMmxkSUQwZ2JuVnRXMmtnS3lCdlptWnpaWFJkTzF4dVhIUWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lISmxkSFZ5YmlCZmJuVnRPMXh1WEhRZ0lDQWdmU2dwTzF4dVhIUmNibHgwSUNBZ0lIWmhjaUJmZEdocGN5QTlJSHQ5TzF4dVhIUmNibHgwSUNBZ0lGOTBhR2x6TG1kbGRFRjBJRDBnWm5WdVkzUnBiMjRnS0dsdVpHVjRLU0I3WEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJmYm5WdFcybHVaR1Y0WFR0Y2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdVoyVjBUR1Z1WjNSb0lEMGdablZ1WTNScGIyNGdLQ2tnZTF4dVhIUWdJQ0FnSUNCeVpYUjFjbTRnWDI1MWJTNXNaVzVuZEdnN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtMTFiSFJwY0d4NUlEMGdablZ1WTNScGIyNGdLR1VwSUh0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCdWRXMGdQU0J1WlhjZ1FYSnlZWGtvWDNSb2FYTXVaMlYwVEdWdVozUm9LQ2tnS3lCbExtZGxkRXhsYm1kMGFDZ3BJQzBnTVNrN1hHNWNkRnh1WEhRZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUY5MGFHbHpMbWRsZEV4bGJtZDBhQ2dwT3lCcElDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnFJRDBnTURzZ2FpQThJR1V1WjJWMFRHVnVaM1JvS0NrN0lHb2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnYm5WdFcya2dLeUJxWFNCZVBTQlJVazFoZEdndVoyVjRjQ2hSVWsxaGRHZ3VaMnh2WnloZmRHaHBjeTVuWlhSQmRDaHBLU2tnS3lCUlVrMWhkR2d1WjJ4dlp5aGxMbWRsZEVGMEtHb3BLU2s3WEc1Y2RDQWdJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCeVpYUjFjbTRnY1hKUWIyeDVibTl0YVdGc0tHNTFiU3dnTUNrN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtMXZaQ0E5SUdaMWJtTjBhVzl1SUNobEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCcFppQW9YM1JvYVhNdVoyVjBUR1Z1WjNSb0tDa2dMU0JsTG1kbGRFeGxibWQwYUNncElEd2dNQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lISmxkSFZ5YmlCZmRHaHBjenRjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdkbUZ5SUhKaGRHbHZJRDBnVVZKTllYUm9MbWRzYjJjb1gzUm9hWE11WjJWMFFYUW9NQ2twSUMwZ1VWSk5ZWFJvTG1kc2IyY29aUzVuWlhSQmRDZ3dLU2s3WEc1Y2RGeHVYSFFnSUNBZ0lDQjJZWElnYm5WdElEMGdibVYzSUVGeWNtRjVLRjkwYUdsekxtZGxkRXhsYm1kMGFDZ3BLVHRjYmx4MElDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCZmRHaHBjeTVuWlhSTVpXNW5kR2dvS1RzZ2FTQXJQU0F4S1NCN1hHNWNkQ0FnSUNBZ0lDQWdiblZ0VzJsZElEMGdYM1JvYVhNdVoyVjBRWFFvYVNrN1hHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1pTNW5aWFJNWlc1bmRHZ29LVHNnYVNBclBTQXhLU0I3WEc1Y2RDQWdJQ0FnSUNBZ2JuVnRXMmxkSUY0OUlGRlNUV0YwYUM1blpYaHdLRkZTVFdGMGFDNW5iRzluS0dVdVoyVjBRWFFvYVNrcElDc2djbUYwYVc4cE8xeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCeVpYUjFjbTRnY1hKUWIyeDVibTl0YVdGc0tHNTFiU3dnTUNrdWJXOWtLR1VwTzF4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc1Y2RDQWdmVHRjYmx4MFhHNWNkQ0FnZG1GeUlGRlNVbE5DYkc5amF5QTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JseDBYRzVjZENBZ0lDQjJZWElnVWxOZlFreFBRMHRmVkVGQ1RFVWdQU0JiV3pFc0lESTJMQ0F4T1Ywc0lGc3hMQ0F5Tml3Z01UWmRMQ0JiTVN3Z01qWXNJREV6WFN3Z1d6RXNJREkyTENBNVhTd2dXekVzSURRMExDQXpORjBzSUZzeExDQTBOQ3dnTWpoZExDQmJNU3dnTkRRc0lESXlYU3dnV3pFc0lEUTBMQ0F4Tmwwc0lGc3hMQ0EzTUN3Z05UVmRMQ0JiTVN3Z056QXNJRFEwWFN3Z1d6SXNJRE0xTENBeE4xMHNJRnN5TENBek5Td2dNVE5kTENCYk1Td2dNVEF3TENBNE1GMHNJRnN5TENBMU1Dd2dNekpkTENCYk1pd2dOVEFzSURJMFhTd2dXelFzSURJMUxDQTVYU3dnV3pFc0lERXpOQ3dnTVRBNFhTd2dXeklzSURZM0xDQTBNMTBzSUZzeUxDQXpNeXdnTVRVc0lESXNJRE0wTENBeE5sMHNJRnN5TENBek15d2dNVEVzSURJc0lETTBMQ0F4TWwwc0lGc3lMQ0E0Tml3Z05qaGRMQ0JiTkN3Z05ETXNJREkzWFN3Z1d6UXNJRFF6TENBeE9WMHNJRnMwTENBME15d2dNVFZkTENCYk1pd2dPVGdzSURjNFhTd2dXelFzSURRNUxDQXpNVjBzSUZzeUxDQXpNaXdnTVRRc0lEUXNJRE16TENBeE5WMHNJRnMwTENBek9Td2dNVE1zSURFc0lEUXdMQ0F4TkYwc0lGc3lMQ0F4TWpFc0lEazNYU3dnV3pJc0lEWXdMQ0F6T0N3Z01pd2dOakVzSURNNVhTd2dXelFzSURRd0xDQXhPQ3dnTWl3Z05ERXNJREU1WFN3Z1d6UXNJRFF3TENBeE5Dd2dNaXdnTkRFc0lERTFYU3dnV3pJc0lERTBOaXdnTVRFMlhTd2dXek1zSURVNExDQXpOaXdnTWl3Z05Ua3NJRE0zWFN3Z1d6UXNJRE0yTENBeE5pd2dOQ3dnTXpjc0lERTNYU3dnV3pRc0lETTJMQ0F4TWl3Z05Dd2dNemNzSURFelhTd2dXeklzSURnMkxDQTJPQ3dnTWl3Z09EY3NJRFk1WFN3Z1d6UXNJRFk1TENBME15d2dNU3dnTnpBc0lEUTBYU3dnV3pZc0lEUXpMQ0F4T1N3Z01pd2dORFFzSURJd1hTd2dXellzSURRekxDQXhOU3dnTWl3Z05EUXNJREUyWFN3Z1d6UXNJREV3TVN3Z09ERmRMQ0JiTVN3Z09EQXNJRFV3TENBMExDQTRNU3dnTlRGZExDQmJOQ3dnTlRBc0lESXlMQ0EwTENBMU1Td2dNak5kTENCYk15d2dNellzSURFeUxDQTRMQ0F6Tnl3Z01UTmRMQ0JiTWl3Z01URTJMQ0E1TWl3Z01pd2dNVEUzTENBNU0xMHNJRnMyTENBMU9Dd2dNellzSURJc0lEVTVMQ0F6TjEwc0lGczBMQ0EwTml3Z01qQXNJRFlzSURRM0xDQXlNVjBzSUZzM0xDQTBNaXdnTVRRc0lEUXNJRFF6TENBeE5WMHNJRnMwTENBeE16TXNJREV3TjEwc0lGczRMQ0ExT1N3Z016Y3NJREVzSURZd0xDQXpPRjBzSUZzNExDQTBOQ3dnTWpBc0lEUXNJRFExTENBeU1WMHNJRnN4TWl3Z016TXNJREV4TENBMExDQXpOQ3dnTVRKZExDQmJNeXdnTVRRMUxDQXhNVFVzSURFc0lERTBOaXdnTVRFMlhTd2dXelFzSURZMExDQTBNQ3dnTlN3Z05qVXNJRFF4WFN3Z1d6RXhMQ0F6Tml3Z01UWXNJRFVzSURNM0xDQXhOMTBzSUZzeE1Td2dNellzSURFeUxDQTFMQ0F6Tnl3Z01UTmRMQ0JiTlN3Z01UQTVMQ0E0Tnl3Z01Td2dNVEV3TENBNE9GMHNJRnMxTENBMk5Td2dOREVzSURVc0lEWTJMQ0EwTWwwc0lGczFMQ0ExTkN3Z01qUXNJRGNzSURVMUxDQXlOVjBzSUZzeE1Td2dNellzSURFeUxDQTNMQ0F6Tnl3Z01UTmRMQ0JiTlN3Z01USXlMQ0E1T0N3Z01Td2dNVEl6TENBNU9WMHNJRnMzTENBM015d2dORFVzSURNc0lEYzBMQ0EwTmwwc0lGc3hOU3dnTkRNc0lERTVMQ0F5TENBME5Dd2dNakJkTENCYk15d2dORFVzSURFMUxDQXhNeXdnTkRZc0lERTJYU3dnV3pFc0lERXpOU3dnTVRBM0xDQTFMQ0F4TXpZc0lERXdPRjBzSUZzeE1Dd2dOelFzSURRMkxDQXhMQ0EzTlN3Z05EZGRMQ0JiTVN3Z05UQXNJREl5TENBeE5Td2dOVEVzSURJelhTd2dXeklzSURReUxDQXhOQ3dnTVRjc0lEUXpMQ0F4TlYwc0lGczFMQ0F4TlRBc0lERXlNQ3dnTVN3Z01UVXhMQ0F4TWpGZExDQmJPU3dnTmprc0lEUXpMQ0EwTENBM01Dd2dORFJkTENCYk1UY3NJRFV3TENBeU1pd2dNU3dnTlRFc0lESXpYU3dnV3pJc0lEUXlMQ0F4TkN3Z01Ua3NJRFF6TENBeE5WMHNJRnN6TENBeE5ERXNJREV4TXl3Z05Dd2dNVFF5TENBeE1UUmRMQ0JiTXl3Z056QXNJRFEwTENBeE1Td2dOekVzSURRMVhTd2dXekUzTENBME55d2dNakVzSURRc0lEUTRMQ0F5TWwwc0lGczVMQ0F6T1N3Z01UTXNJREUyTENBME1Dd2dNVFJkTENCYk15d2dNVE0xTENBeE1EY3NJRFVzSURFek5pd2dNVEE0WFN3Z1d6TXNJRFkzTENBME1Td2dNVE1zSURZNExDQTBNbDBzSUZzeE5Td2dOVFFzSURJMExDQTFMQ0ExTlN3Z01qVmRMQ0JiTVRVc0lEUXpMQ0F4TlN3Z01UQXNJRFEwTENBeE5sMHNJRnMwTENBeE5EUXNJREV4Tml3Z05Dd2dNVFExTENBeE1UZGRMQ0JiTVRjc0lEWTRMQ0EwTWwwc0lGc3hOeXdnTlRBc0lESXlMQ0EyTENBMU1Td2dNak5kTENCYk1Ua3NJRFEyTENBeE5pd2dOaXdnTkRjc0lERTNYU3dnV3pJc0lERXpPU3dnTVRFeExDQTNMQ0F4TkRBc0lERXhNbDBzSUZzeE55d2dOelFzSURRMlhTd2dXemNzSURVMExDQXlOQ3dnTVRZc0lEVTFMQ0F5TlYwc0lGc3pOQ3dnTXpjc0lERXpYU3dnV3pRc0lERTFNU3dnTVRJeExDQTFMQ0F4TlRJc0lERXlNbDBzSUZzMExDQTNOU3dnTkRjc0lERTBMQ0EzTml3Z05EaGRMQ0JiTVRFc0lEVTBMQ0F5TkN3Z01UUXNJRFUxTENBeU5WMHNJRnN4Tml3Z05EVXNJREUxTENBeE5Dd2dORFlzSURFMlhTd2dXellzSURFME55d2dNVEUzTENBMExDQXhORGdzSURFeE9GMHNJRnMyTENBM015d2dORFVzSURFMExDQTNOQ3dnTkRaZExDQmJNVEVzSURVMExDQXlOQ3dnTVRZc0lEVTFMQ0F5TlYwc0lGc3pNQ3dnTkRZc0lERTJMQ0F5TENBME55d2dNVGRkTENCYk9Dd2dNVE15TENBeE1EWXNJRFFzSURFek15d2dNVEEzWFN3Z1d6Z3NJRGMxTENBME55d2dNVE1zSURjMkxDQTBPRjBzSUZzM0xDQTFOQ3dnTWpRc0lESXlMQ0ExTlN3Z01qVmRMQ0JiTWpJc0lEUTFMQ0F4TlN3Z01UTXNJRFEyTENBeE5sMHNJRnN4TUN3Z01UUXlMQ0F4TVRRc0lESXNJREUwTXl3Z01URTFYU3dnV3pFNUxDQTNOQ3dnTkRZc0lEUXNJRGMxTENBME4xMHNJRnN5T0N3Z05UQXNJREl5TENBMkxDQTFNU3dnTWpOZExDQmJNek1zSURRMkxDQXhOaXdnTkN3Z05EY3NJREUzWFN3Z1d6Z3NJREUxTWl3Z01USXlMQ0EwTENBeE5UTXNJREV5TTEwc0lGc3lNaXdnTnpNc0lEUTFMQ0F6TENBM05Dd2dORFpkTENCYk9Dd2dOVE1zSURJekxDQXlOaXdnTlRRc0lESTBYU3dnV3pFeUxDQTBOU3dnTVRVc0lESTRMQ0EwTml3Z01UWmRMQ0JiTXl3Z01UUTNMQ0F4TVRjc0lERXdMQ0F4TkRnc0lERXhPRjBzSUZzekxDQTNNeXdnTkRVc0lESXpMQ0EzTkN3Z05EWmRMQ0JiTkN3Z05UUXNJREkwTENBek1Td2dOVFVzSURJMVhTd2dXekV4TENBME5Td2dNVFVzSURNeExDQTBOaXdnTVRaZExDQmJOeXdnTVRRMkxDQXhNVFlzSURjc0lERTBOeXdnTVRFM1hTd2dXekl4TENBM015d2dORFVzSURjc0lEYzBMQ0EwTmwwc0lGc3hMQ0ExTXl3Z01qTXNJRE0zTENBMU5Dd2dNalJkTENCYk1Ua3NJRFExTENBeE5Td2dNallzSURRMkxDQXhObDBzSUZzMUxDQXhORFVzSURFeE5Td2dNVEFzSURFME5pd2dNVEUyWFN3Z1d6RTVMQ0EzTlN3Z05EY3NJREV3TENBM05pd2dORGhkTENCYk1UVXNJRFUwTENBeU5Dd2dNalVzSURVMUxDQXlOVjBzSUZzeU15d2dORFVzSURFMUxDQXlOU3dnTkRZc0lERTJYU3dnV3pFekxDQXhORFVzSURFeE5Td2dNeXdnTVRRMkxDQXhNVFpkTENCYk1pd2dOelFzSURRMkxDQXlPU3dnTnpVc0lEUTNYU3dnV3pReUxDQTFOQ3dnTWpRc0lERXNJRFUxTENBeU5WMHNJRnN5TXl3Z05EVXNJREUxTENBeU9Dd2dORFlzSURFMlhTd2dXekUzTENBeE5EVXNJREV4TlYwc0lGc3hNQ3dnTnpRc0lEUTJMQ0F5TXl3Z056VXNJRFEzWFN3Z1d6RXdMQ0ExTkN3Z01qUXNJRE0xTENBMU5Td2dNalZkTENCYk1Ua3NJRFExTENBeE5Td2dNelVzSURRMkxDQXhObDBzSUZzeE55d2dNVFExTENBeE1UVXNJREVzSURFME5pd2dNVEUyWFN3Z1d6RTBMQ0EzTkN3Z05EWXNJREl4TENBM05Td2dORGRkTENCYk1qa3NJRFUwTENBeU5Dd2dNVGtzSURVMUxDQXlOVjBzSUZzeE1Td2dORFVzSURFMUxDQTBOaXdnTkRZc0lERTJYU3dnV3pFekxDQXhORFVzSURFeE5Td2dOaXdnTVRRMkxDQXhNVFpkTENCYk1UUXNJRGMwTENBME5pd2dNak1zSURjMUxDQTBOMTBzSUZzME5Dd2dOVFFzSURJMExDQTNMQ0ExTlN3Z01qVmRMQ0JiTlRrc0lEUTJMQ0F4Tml3Z01Td2dORGNzSURFM1hTd2dXekV5TENBeE5URXNJREV5TVN3Z055d2dNVFV5TENBeE1qSmRMQ0JiTVRJc0lEYzFMQ0EwTnl3Z01qWXNJRGMyTENBME9GMHNJRnN6T1N3Z05UUXNJREkwTENBeE5Dd2dOVFVzSURJMVhTd2dXekl5TENBME5Td2dNVFVzSURReExDQTBOaXdnTVRaZExDQmJOaXdnTVRVeExDQXhNakVzSURFMExDQXhOVElzSURFeU1sMHNJRnMyTENBM05Td2dORGNzSURNMExDQTNOaXdnTkRoZExDQmJORFlzSURVMExDQXlOQ3dnTVRBc0lEVTFMQ0F5TlYwc0lGc3lMQ0EwTlN3Z01UVXNJRFkwTENBME5pd2dNVFpkTENCYk1UY3NJREUxTWl3Z01USXlMQ0EwTENBeE5UTXNJREV5TTEwc0lGc3lPU3dnTnpRc0lEUTJMQ0F4TkN3Z056VXNJRFEzWFN3Z1d6UTVMQ0ExTkN3Z01qUXNJREV3TENBMU5Td2dNalZkTENCYk1qUXNJRFExTENBeE5Td2dORFlzSURRMkxDQXhObDBzSUZzMExDQXhOVElzSURFeU1pd2dNVGdzSURFMU15d2dNVEl6WFN3Z1d6RXpMQ0EzTkN3Z05EWXNJRE15TENBM05Td2dORGRkTENCYk5EZ3NJRFUwTENBeU5Dd2dNVFFzSURVMUxDQXlOVjBzSUZzME1pd2dORFVzSURFMUxDQXpNaXdnTkRZc0lERTJYU3dnV3pJd0xDQXhORGNzSURFeE55d2dOQ3dnTVRRNExDQXhNVGhkTENCYk5EQXNJRGMxTENBME55d2dOeXdnTnpZc0lEUTRYU3dnV3pRekxDQTFOQ3dnTWpRc0lESXlMQ0ExTlN3Z01qVmRMQ0JiTVRBc0lEUTFMQ0F4TlN3Z05qY3NJRFEyTENBeE5sMHNJRnN4T1N3Z01UUTRMQ0F4TVRnc0lEWXNJREUwT1N3Z01URTVYU3dnV3pFNExDQTNOU3dnTkRjc0lETXhMQ0EzTml3Z05EaGRMQ0JiTXpRc0lEVTBMQ0F5TkN3Z016UXNJRFUxTENBeU5WMHNJRnN5TUN3Z05EVXNJREUxTENBMk1Td2dORFlzSURFMlhWMDdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlIRnlVbE5DYkc5amF5QTlJR1oxYm1OMGFXOXVJSEZ5VWxOQ2JHOWpheWgwYjNSaGJFTnZkVzUwTENCa1lYUmhRMjkxYm5RcElIdGNibHgwSUNBZ0lDQWdkbUZ5SUY5MGFHbHpJRDBnZTMwN1hHNWNkQ0FnSUNBZ0lGOTBhR2x6TG5SdmRHRnNRMjkxYm5RZ1BTQjBiM1JoYkVOdmRXNTBPMXh1WEhRZ0lDQWdJQ0JmZEdocGN5NWtZWFJoUTI5MWJuUWdQU0JrWVhSaFEyOTFiblE3WEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlGOTBhR2x6SUQwZ2UzMDdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlHZGxkRkp6UW14dlkydFVZV0pzWlNBOUlHWjFibU4wYVc5dUlHZGxkRkp6UW14dlkydFVZV0pzWlNoMGVYQmxUblZ0WW1WeUxDQmxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ2tnZTF4dVhIUmNibHgwSUNBZ0lDQWdjM2RwZEdOb0lDaGxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lHTmhjMlVnVVZKRmNuSnZja052Y25KbFkzUnBiMjVNWlhabGJDNU1PbHh1WEhRZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUZKVFgwSk1UME5MWDFSQlFreEZXeWgwZVhCbFRuVnRZbVZ5SUMwZ01Ta2dLaUEwSUNzZ01GMDdYRzVjZENBZ0lDQWdJQ0FnWTJGelpTQlJVa1Z5Y205eVEyOXljbVZqZEdsdmJreGxkbVZzTGswNlhHNWNkQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdVbE5mUWt4UFEwdGZWRUZDVEVWYktIUjVjR1ZPZFcxaVpYSWdMU0F4S1NBcUlEUWdLeUF4WFR0Y2JseDBJQ0FnSUNBZ0lDQmpZWE5sSUZGU1JYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXd3VVVHBjYmx4MElDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCU1UxOUNURTlEUzE5VVFVSk1SVnNvZEhsd1pVNTFiV0psY2lBdElERXBJQ29nTkNBcklESmRPMXh1WEhRZ0lDQWdJQ0FnSUdOaGMyVWdVVkpGY25KdmNrTnZjbkpsWTNScGIyNU1aWFpsYkM1SU9seHVYSFFnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJRkpUWDBKTVQwTkxYMVJCUWt4Rld5aDBlWEJsVG5WdFltVnlJQzBnTVNrZ0tpQTBJQ3NnTTEwN1hHNWNkQ0FnSUNBZ0lDQWdaR1ZtWVhWc2REcGNibHgwSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIxYm1SbFptbHVaV1E3WEc1Y2RDQWdJQ0FnSUgxY2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdVoyVjBVbE5DYkc5amEzTWdQU0JtZFc1amRHbHZiaUFvZEhsd1pVNTFiV0psY2l3Z1pYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXd3BJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lIWmhjaUJ5YzBKc2IyTnJJRDBnWjJWMFVuTkNiRzlqYTFSaFlteGxLSFI1Y0dWT2RXMWlaWElzSUdWeWNtOXlRMjl5Y21WamRHbHZia3hsZG1Wc0tUdGNibHgwWEc1Y2RDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2NuTkNiRzlqYXlBOVBTQW5kVzVrWldacGJtVmtKeWtnZTF4dVhIUWdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblltRmtJSEp6SUdKc2IyTnJJRUFnZEhsd1pVNTFiV0psY2pvbklDc2dkSGx3WlU1MWJXSmxjaUFySUNjdlpYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXdzZKeUFySUdWeWNtOXlRMjl5Y21WamRHbHZia3hsZG1Wc0tUdGNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ2RtRnlJR3hsYm1kMGFDQTlJSEp6UW14dlkyc3ViR1Z1WjNSb0lDOGdNenRjYmx4MFhHNWNkQ0FnSUNBZ0lIWmhjaUJzYVhOMElEMGdibVYzSUVGeWNtRjVLQ2s3WEc1Y2RGeHVYSFFnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3hsYm1kMGFEc2dhU0FyUFNBeEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lIWmhjaUJqYjNWdWRDQTlJSEp6UW14dlkydGJhU0FxSURNZ0t5QXdYVHRjYmx4MElDQWdJQ0FnSUNCMllYSWdkRzkwWVd4RGIzVnVkQ0E5SUhKelFteHZZMnRiYVNBcUlETWdLeUF4WFR0Y2JseDBJQ0FnSUNBZ0lDQjJZWElnWkdGMFlVTnZkVzUwSUQwZ2NuTkNiRzlqYTF0cElDb2dNeUFySURKZE8xeHVYSFJjYmx4MElDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcUlEMGdNRHNnYWlBOElHTnZkVzUwT3lCcUlDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJR3hwYzNRdWNIVnphQ2h4Y2xKVFFteHZZMnNvZEc5MFlXeERiM1Z1ZEN3Z1pHRjBZVU52ZFc1MEtTazdYRzVjZENBZ0lDQWdJQ0FnZlZ4dVhIUWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdiR2x6ZER0Y2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdjbVYwZFhKdUlGOTBhR2x6TzF4dVhIUWdJSDBvS1R0Y2JseDBYRzVjZENBZ2RtRnlJSEZ5UW1sMFFuVm1abVZ5SUQwZ1puVnVZM1JwYjI0Z2NYSkNhWFJDZFdabVpYSW9LU0I3WEc1Y2RGeHVYSFFnSUNBZ2RtRnlJRjlpZFdabVpYSWdQU0J1WlhjZ1FYSnlZWGtvS1R0Y2JseDBJQ0FnSUhaaGNpQmZiR1Z1WjNSb0lEMGdNRHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdYM1JvYVhNZ1BTQjdmVHRjYmx4MFhHNWNkQ0FnSUNCZmRHaHBjeTVuWlhSQ2RXWm1aWElnUFNCbWRXNWpkR2x2YmlBb0tTQjdYRzVjZENBZ0lDQWdJSEpsZEhWeWJpQmZZblZtWm1WeU8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NW5aWFJCZENBOUlHWjFibU4wYVc5dUlDaHBibVJsZUNrZ2UxeHVYSFFnSUNBZ0lDQjJZWElnWW5WbVNXNWtaWGdnUFNCTllYUm9MbVpzYjI5eUtHbHVaR1Y0SUM4Z09DazdYRzVjZENBZ0lDQWdJSEpsZEhWeWJpQW9YMkoxWm1abGNsdGlkV1pKYm1SbGVGMGdQajQrSURjZ0xTQnBibVJsZUNBbElEZ2dKaUF4S1NBOVBTQXhPMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCZmRHaHBjeTV3ZFhRZ1BTQm1kVzVqZEdsdmJpQW9iblZ0TENCc1pXNW5kR2dwSUh0Y2JseDBJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQnNaVzVuZEdnN0lHa2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJRjkwYUdsekxuQjFkRUpwZENnb2JuVnRJRDQrUGlCc1pXNW5kR2dnTFNCcElDMGdNU0FtSURFcElEMDlJREVwTzF4dVhIUWdJQ0FnSUNCOVhHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtZGxkRXhsYm1kMGFFbHVRbWwwY3lBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmx4MElDQWdJQ0FnY21WMGRYSnVJRjlzWlc1bmRHZzdYRzVjZENBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUY5MGFHbHpMbkIxZEVKcGRDQTlJR1oxYm1OMGFXOXVJQ2hpYVhRcElIdGNibHgwWEc1Y2RDQWdJQ0FnSUhaaGNpQmlkV1pKYm1SbGVDQTlJRTFoZEdndVpteHZiM0lvWDJ4bGJtZDBhQ0F2SURncE8xeHVYSFFnSUNBZ0lDQnBaaUFvWDJKMVptWmxjaTVzWlc1bmRHZ2dQRDBnWW5WbVNXNWtaWGdwSUh0Y2JseDBJQ0FnSUNBZ0lDQmZZblZtWm1WeUxuQjFjMmdvTUNrN1hHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUdsbUlDaGlhWFFwSUh0Y2JseDBJQ0FnSUNBZ0lDQmZZblZtWm1WeVcySjFaa2x1WkdWNFhTQjhQU0F3ZURnd0lENCtQaUJmYkdWdVozUm9JQ1VnT0R0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFJjYmx4MElDQWdJQ0FnWDJ4bGJtZDBhQ0FyUFNBeE8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0J5WlhSMWNtNGdYM1JvYVhNN1hHNWNkQ0FnZlR0Y2JseDBYRzVjZENBZ2RtRnlJSEZ5VG5WdFltVnlJRDBnWm5WdVkzUnBiMjRnY1hKT2RXMWlaWElvWkdGMFlTa2dlMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmZiVzlrWlNBOUlGRlNUVzlrWlM1TlQwUkZYMDVWVFVKRlVqdGNibHgwSUNBZ0lIWmhjaUJmWkdGMFlTQTlJR1JoZEdFN1hHNWNkRnh1WEhRZ0lDQWdkbUZ5SUY5MGFHbHpJRDBnZTMwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdVoyVjBUVzlrWlNBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmx4MElDQWdJQ0FnY21WMGRYSnVJRjl0YjJSbE8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NW5aWFJNWlc1bmRHZ2dQU0JtZFc1amRHbHZiaUFvWW5WbVptVnlLU0I3WEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJmWkdGMFlTNXNaVzVuZEdnN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxuZHlhWFJsSUQwZ1puVnVZM1JwYjI0Z0tHSjFabVpsY2lrZ2UxeHVYSFJjYmx4MElDQWdJQ0FnZG1GeUlHUmhkR0VnUFNCZlpHRjBZVHRjYmx4MFhHNWNkQ0FnSUNBZ0lIWmhjaUJwSUQwZ01EdGNibHgwWEc1Y2RDQWdJQ0FnSUhkb2FXeGxJQ2hwSUNzZ01pQThJR1JoZEdFdWJHVnVaM1JvS1NCN1hHNWNkQ0FnSUNBZ0lDQWdZblZtWm1WeUxuQjFkQ2h6ZEhKVWIwNTFiU2hrWVhSaExuTjFZbk4wY21sdVp5aHBMQ0JwSUNzZ015a3BMQ0F4TUNrN1hHNWNkQ0FnSUNBZ0lDQWdhU0FyUFNBek8xeHVYSFFnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNCcFppQW9hU0E4SUdSaGRHRXViR1Z1WjNSb0tTQjdYRzVjZENBZ0lDQWdJQ0FnYVdZZ0tHUmhkR0V1YkdWdVozUm9JQzBnYVNBOVBTQXhLU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQmlkV1ptWlhJdWNIVjBLSE4wY2xSdlRuVnRLR1JoZEdFdWMzVmljM1J5YVc1bktHa3NJR2tnS3lBeEtTa3NJRFFwTzF4dVhIUWdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9aR0YwWVM1c1pXNW5kR2dnTFNCcElEMDlJRElwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvYzNSeVZHOU9kVzBvWkdGMFlTNXpkV0p6ZEhKcGJtY29hU3dnYVNBcklESXBLU3dnTnlrN1hHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0I5TzF4dVhIUmNibHgwSUNBZ0lIWmhjaUJ6ZEhKVWIwNTFiU0E5SUdaMWJtTjBhVzl1SUhOMGNsUnZUblZ0S0hNcElIdGNibHgwSUNBZ0lDQWdkbUZ5SUc1MWJTQTlJREE3WEc1Y2RDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2N5NXNaVzVuZEdnN0lHa2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJRzUxYlNBOUlHNTFiU0FxSURFd0lDc2dZMmhoZEZSdlRuVnRLSE11WTJoaGNrRjBLR2twS1R0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFFnSUNBZ0lDQnlaWFIxY200Z2JuVnRPMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdZMmhoZEZSdlRuVnRJRDBnWm5WdVkzUnBiMjRnWTJoaGRGUnZUblZ0S0dNcElIdGNibHgwSUNBZ0lDQWdhV1lnS0Njd0p5QThQU0JqSUNZbUlHTWdQRDBnSnprbktTQjdYRzVjZENBZ0lDQWdJQ0FnY21WMGRYSnVJR011WTJoaGNrTnZaR1ZCZENnd0tTQXRJQ2N3Snk1amFHRnlRMjlrWlVGMEtEQXBPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUhSb2NtOTNJQ2RwYkd4bFoyRnNJR05vWVhJZ09pY2dLeUJqTzF4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc1Y2RDQWdmVHRjYmx4MFhHNWNkQ0FnZG1GeUlIRnlRV3h3YUdGT2RXMGdQU0JtZFc1amRHbHZiaUJ4Y2tGc2NHaGhUblZ0S0dSaGRHRXBJSHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdYMjF2WkdVZ1BTQlJVazF2WkdVdVRVOUVSVjlCVEZCSVFWOU9WVTA3WEc1Y2RDQWdJQ0IyWVhJZ1gyUmhkR0VnUFNCa1lYUmhPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEhSY2JseDBJQ0FnSUY5MGFHbHpMbWRsZEUxdlpHVWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkQ0FnSUNBZ0lISmxkSFZ5YmlCZmJXOWtaVHRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ1gzUm9hWE11WjJWMFRHVnVaM1JvSUQwZ1puVnVZM1JwYjI0Z0tHSjFabVpsY2lrZ2UxeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1gyUmhkR0V1YkdWdVozUm9PMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCZmRHaHBjeTUzY21sMFpTQTlJR1oxYm1OMGFXOXVJQ2hpZFdabVpYSXBJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lIWmhjaUJ6SUQwZ1gyUmhkR0U3WEc1Y2RGeHVYSFFnSUNBZ0lDQjJZWElnYVNBOUlEQTdYRzVjZEZ4dVhIUWdJQ0FnSUNCM2FHbHNaU0FvYVNBcklERWdQQ0J6TG14bGJtZDBhQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lHSjFabVpsY2k1d2RYUW9aMlYwUTI5a1pTaHpMbU5vWVhKQmRDaHBLU2tnS2lBME5TQXJJR2RsZEVOdlpHVW9jeTVqYUdGeVFYUW9hU0FySURFcEtTd2dNVEVwTzF4dVhIUWdJQ0FnSUNBZ0lHa2dLejBnTWp0Y2JseDBJQ0FnSUNBZ2ZWeHVYSFJjYmx4MElDQWdJQ0FnYVdZZ0tHa2dQQ0J6TG14bGJtZDBhQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lHSjFabVpsY2k1d2RYUW9aMlYwUTI5a1pTaHpMbU5vWVhKQmRDaHBLU2tzSURZcE8xeHVYSFFnSUNBZ0lDQjlYRzVjZENBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQm5aWFJEYjJSbElEMGdablZ1WTNScGIyNGdaMlYwUTI5a1pTaGpLU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQnBaaUFvSnpBbklEdzlJR01nSmlZZ1l5QThQU0FuT1NjcElIdGNibHgwSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZeTVqYUdGeVEyOWtaVUYwS0RBcElDMGdKekFuTG1Ob1lYSkRiMlJsUVhRb01DazdYRzVjZENBZ0lDQWdJSDBnWld4elpTQnBaaUFvSjBFbklEdzlJR01nSmlZZ1l5QThQU0FuV2ljcElIdGNibHgwSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZeTVqYUdGeVEyOWtaVUYwS0RBcElDMGdKMEVuTG1Ob1lYSkRiMlJsUVhRb01Da2dLeUF4TUR0Y2JseDBJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JseDBJQ0FnSUNBZ0lDQnpkMmwwWTJnZ0tHTXBJSHRjYmx4MElDQWdJQ0FnSUNBZ0lHTmhjMlVnSnlBbk9seHVYSFFnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnTXpZN1hHNWNkQ0FnSUNBZ0lDQWdJQ0JqWVhObElDY2tKenBjYmx4MElDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlETTNPMXh1WEhRZ0lDQWdJQ0FnSUNBZ1kyRnpaU0FuSlNjNlhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUF6T0R0Y2JseDBJQ0FnSUNBZ0lDQWdJR05oYzJVZ0p5b25PbHh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z016azdYRzVjZENBZ0lDQWdJQ0FnSUNCallYTmxJQ2NySnpwY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJRFF3TzF4dVhIUWdJQ0FnSUNBZ0lDQWdZMkZ6WlNBbkxTYzZYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBME1UdGNibHgwSUNBZ0lDQWdJQ0FnSUdOaGMyVWdKeTRuT2x4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdOREk3WEc1Y2RDQWdJQ0FnSUNBZ0lDQmpZWE5sSUNjdkp6cGNibHgwSUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SURRek8xeHVYSFFnSUNBZ0lDQWdJQ0FnWTJGelpTQW5PaWM2WEc1Y2RDQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQTBORHRjYmx4MElDQWdJQ0FnSUNBZ0lHUmxabUYxYkhRNlhHNWNkQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJQ2RwYkd4bFoyRnNJR05vWVhJZ09pY2dLeUJqTzF4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVnh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCeVpYUjFjbTRnWDNSb2FYTTdYRzVjZENBZ2ZUdGNibHgwWEc1Y2RDQWdkbUZ5SUhGeU9FSnBkRUo1ZEdVZ1BTQm1kVzVqZEdsdmJpQnhjamhDYVhSQ2VYUmxLR1JoZEdFcElIdGNibHgwWEc1Y2RDQWdJQ0IyWVhJZ1gyMXZaR1VnUFNCUlVrMXZaR1V1VFU5RVJWODRRa2xVWDBKWlZFVTdYRzVjZENBZ0lDQjJZWElnWDJSaGRHRWdQU0JrWVhSaE8xeHVYSFFnSUNBZ2RtRnlJRjlpZVhSbGN5QTlJSEZ5WTI5a1pTNXpkSEpwYm1kVWIwSjVkR1Z6S0dSaGRHRXBPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEhSY2JseDBJQ0FnSUY5MGFHbHpMbWRsZEUxdlpHVWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkQ0FnSUNBZ0lISmxkSFZ5YmlCZmJXOWtaVHRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ1gzUm9hWE11WjJWMFRHVnVaM1JvSUQwZ1puVnVZM1JwYjI0Z0tHSjFabVpsY2lrZ2UxeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1gySjVkR1Z6TG14bGJtZDBhRHRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ1gzUm9hWE11ZDNKcGRHVWdQU0JtZFc1amRHbHZiaUFvWW5WbVptVnlLU0I3WEc1Y2RDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1gySjVkR1Z6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc1Y2RDQWdJQ0FnSUNBZ1luVm1abVZ5TG5CMWRDaGZZbmwwWlhOYmFWMHNJRGdwTzF4dVhIUWdJQ0FnSUNCOVhHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJSEpsZEhWeWJpQmZkR2hwY3p0Y2JseDBJQ0I5TzF4dVhIUmNibHgwSUNCMllYSWdjWEpMWVc1cWFTQTlJR1oxYm1OMGFXOXVJSEZ5UzJGdWFta29aR0YwWVNrZ2UxeHVYSFJjYmx4MElDQWdJSFpoY2lCZmJXOWtaU0E5SUZGU1RXOWtaUzVOVDBSRlgwdEJUa3BKTzF4dVhIUWdJQ0FnZG1GeUlGOWtZWFJoSUQwZ1pHRjBZVHRjYmx4MElDQWdJSFpoY2lCZllubDBaWE1nUFNCeGNtTnZaR1V1YzNSeWFXNW5WRzlDZVhSbGN5aGtZWFJoS1R0Y2JseDBYRzVjZENBZ0lDQWhablZ1WTNScGIyNGdLR01zSUdOdlpHVXBJSHRjYmx4MElDQWdJQ0FnZG1GeUlIUmxjM1FnUFNCeGNtTnZaR1V1YzNSeWFXNW5WRzlDZVhSbGN5aGpLVHRjYmx4MElDQWdJQ0FnYVdZZ0tIUmxjM1F1YkdWdVozUm9JQ0U5SURJZ2ZId2dLSFJsYzNSYk1GMGdQRHdnT0NCOElIUmxjM1JiTVYwcElDRTlJR052WkdVcElIdGNibHgwSUNBZ0lDQWdJQ0IwYUhKdmR5QW5jMnBwY3lCdWIzUWdjM1Z3Y0c5eWRHVmtMaWM3WEc1Y2RDQWdJQ0FnSUgxY2JseDBJQ0FnSUgwb0oxeGNkVFV6UTBJbkxDQXdlRGszTkRZcE8xeHVYSFJjYmx4MElDQWdJSFpoY2lCZmRHaHBjeUE5SUh0OU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxtZGxkRTF2WkdVZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc1Y2RDQWdJQ0FnSUhKbGRIVnliaUJmYlc5a1pUdGNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnWDNSb2FYTXVaMlYwVEdWdVozUm9JRDBnWm5WdVkzUnBiMjRnS0dKMVptWmxjaWtnZTF4dVhIUWdJQ0FnSUNCeVpYUjFjbTRnZm40b1gySjVkR1Z6TG14bGJtZDBhQ0F2SURJcE8xeHVYSFFnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0JmZEdocGN5NTNjbWwwWlNBOUlHWjFibU4wYVc5dUlDaGlkV1ptWlhJcElIdGNibHgwWEc1Y2RDQWdJQ0FnSUhaaGNpQmtZWFJoSUQwZ1gySjVkR1Z6TzF4dVhIUmNibHgwSUNBZ0lDQWdkbUZ5SUdrZ1BTQXdPMXh1WEhSY2JseDBJQ0FnSUNBZ2QyaHBiR1VnS0drZ0t5QXhJRHdnWkdGMFlTNXNaVzVuZEdncElIdGNibHgwWEc1Y2RDQWdJQ0FnSUNBZ2RtRnlJR01nUFNBb01IaG1aaUFtSUdSaGRHRmJhVjBwSUR3OElEZ2dmQ0F3ZUdabUlDWWdaR0YwWVZ0cElDc2dNVjA3WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJR2xtSUNnd2VEZ3hOREFnUEQwZ1l5QW1KaUJqSUR3OUlEQjRPVVpHUXlrZ2UxeHVYSFFnSUNBZ0lDQWdJQ0FnWXlBdFBTQXdlRGd4TkRBN1hHNWNkQ0FnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2d3ZUVVd05EQWdQRDBnWXlBbUppQmpJRHc5SURCNFJVSkNSaWtnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdZeUF0UFNBd2VFTXhOREE3WEc1Y2RDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJSFJvY205M0lDZHBiR3hsWjJGc0lHTm9ZWElnWVhRZ0p5QXJJQ2hwSUNzZ01Ta2dLeUFuTHljZ0t5QmpPMXh1WEhRZ0lDQWdJQ0FnSUgxY2JseDBYRzVjZENBZ0lDQWdJQ0FnWXlBOUlDaGpJRDQrUGlBNElDWWdNSGhtWmlrZ0tpQXdlRU13SUNzZ0tHTWdKaUF3ZUdabUtUdGNibHgwWEc1Y2RDQWdJQ0FnSUNBZ1luVm1abVZ5TG5CMWRDaGpMQ0F4TXlrN1hHNWNkRnh1WEhRZ0lDQWdJQ0FnSUdrZ0t6MGdNanRjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdhV1lnS0drZ1BDQmtZWFJoTG14bGJtZDBhQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lIUm9jbTkzSUNkcGJHeGxaMkZzSUdOb1lYSWdZWFFnSnlBcklDaHBJQ3NnTVNrN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnY21WMGRYSnVJRjkwYUdsek8xeHVYSFFnSUgwN1hHNWNkRnh1WEhRZ0lIWmhjaUJpZVhSbFFYSnlZWGxQZFhSd2RYUlRkSEpsWVcwZ1BTQm1kVzVqZEdsdmJpQmllWFJsUVhKeVlYbFBkWFJ3ZFhSVGRISmxZVzBvS1NCN1hHNWNkRnh1WEhRZ0lDQWdkbUZ5SUY5aWVYUmxjeUE5SUc1bGR5QkJjbkpoZVNncE8xeHVYSFJjYmx4MElDQWdJSFpoY2lCZmRHaHBjeUE5SUh0OU8xeHVYSFJjYmx4MElDQWdJRjkwYUdsekxuZHlhWFJsUW5sMFpTQTlJR1oxYm1OMGFXOXVJQ2hpS1NCN1hHNWNkQ0FnSUNBZ0lGOWllWFJsY3k1d2RYTm9LR0lnSmlBd2VHWm1LVHRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ1gzUm9hWE11ZDNKcGRHVlRhRzl5ZENBOUlHWjFibU4wYVc5dUlDaHBLU0I3WEc1Y2RDQWdJQ0FnSUY5MGFHbHpMbmR5YVhSbFFubDBaU2hwS1R0Y2JseDBJQ0FnSUNBZ1gzUm9hWE11ZDNKcGRHVkNlWFJsS0drZ1BqNCtJRGdwTzF4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQmZkR2hwY3k1M2NtbDBaVUo1ZEdWeklEMGdablZ1WTNScGIyNGdLR0lzSUc5bVppd2diR1Z1S1NCN1hHNWNkQ0FnSUNBZ0lHOW1aaUE5SUc5bVppQjhmQ0F3TzF4dVhIUWdJQ0FnSUNCc1pXNGdQU0JzWlc0Z2ZId2dZaTVzWlc1bmRHZzdYRzVjZENBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYkdWdU95QnBJQ3M5SURFcElIdGNibHgwSUNBZ0lDQWdJQ0JmZEdocGN5NTNjbWwwWlVKNWRHVW9ZbHRwSUNzZ2IyWm1YU2s3WEc1Y2RDQWdJQ0FnSUgxY2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdWQzSnBkR1ZUZEhKcGJtY2dQU0JtZFc1amRHbHZiaUFvY3lrZ2UxeHVYSFFnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJSE11YkdWdVozUm9PeUJwSUNzOUlERXBJSHRjYmx4MElDQWdJQ0FnSUNCZmRHaHBjeTUzY21sMFpVSjVkR1VvY3k1amFHRnlRMjlrWlVGMEtHa3BLVHRjYmx4MElDQWdJQ0FnZlZ4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQmZkR2hwY3k1MGIwSjVkR1ZCY25KaGVTQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JseDBJQ0FnSUNBZ2NtVjBkWEp1SUY5aWVYUmxjenRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ1gzUm9hWE11ZEc5VGRISnBibWNnUFNCbWRXNWpkR2x2YmlBb0tTQjdYRzVjZENBZ0lDQWdJSFpoY2lCeklEMGdKeWM3WEc1Y2RDQWdJQ0FnSUhNZ0t6MGdKMXNuTzF4dVhIUWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElGOWllWFJsY3k1c1pXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNBZ0lHbG1JQ2hwSUQ0Z01Da2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ2N5QXJQU0FuTENjN1hHNWNkQ0FnSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0FnSUhNZ0t6MGdYMko1ZEdWelcybGRPMXh1WEhRZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUhNZ0t6MGdKMTBuTzF4dVhIUWdJQ0FnSUNCeVpYUjFjbTRnY3p0Y2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdjbVYwZFhKdUlGOTBhR2x6TzF4dVhIUWdJSDA3WEc1Y2RGeHVYSFFnSUhaaGNpQmlZWE5sTmpSRmJtTnZaR1ZQZFhSd2RYUlRkSEpsWVcwZ1BTQm1kVzVqZEdsdmJpQmlZWE5sTmpSRmJtTnZaR1ZQZFhSd2RYUlRkSEpsWVcwb0tTQjdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlGOWlkV1ptWlhJZ1BTQXdPMXh1WEhRZ0lDQWdkbUZ5SUY5aWRXWnNaVzRnUFNBd08xeHVYSFFnSUNBZ2RtRnlJRjlzWlc1bmRHZ2dQU0F3TzF4dVhIUWdJQ0FnZG1GeUlGOWlZWE5sTmpRZ1BTQW5KenRjYmx4MFhHNWNkQ0FnSUNCMllYSWdYM1JvYVhNZ1BTQjdmVHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdkM0pwZEdWRmJtTnZaR1ZrSUQwZ1puVnVZM1JwYjI0Z2QzSnBkR1ZGYm1OdlpHVmtLR0lwSUh0Y2JseDBJQ0FnSUNBZ1gySmhjMlUyTkNBclBTQlRkSEpwYm1jdVpuSnZiVU5vWVhKRGIyUmxLR1Z1WTI5a1pTaGlJQ1lnTUhnelppa3BPMXh1WEhRZ0lDQWdmVHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdaVzVqYjJSbElEMGdablZ1WTNScGIyNGdaVzVqYjJSbEtHNHBJSHRjYmx4MElDQWdJQ0FnYVdZZ0tHNGdQQ0F3S1NCN2ZTQmxiSE5sSUdsbUlDaHVJRHdnTWpZcElIdGNibHgwSUNBZ0lDQWdJQ0J5WlhSMWNtNGdNSGcwTVNBcklHNDdYRzVjZENBZ0lDQWdJSDBnWld4elpTQnBaaUFvYmlBOElEVXlLU0I3WEc1Y2RDQWdJQ0FnSUNBZ2NtVjBkWEp1SURCNE5qRWdLeUFvYmlBdElESTJLVHRjYmx4MElDQWdJQ0FnZlNCbGJITmxJR2xtSUNodUlEd2dOaklwSUh0Y2JseDBJQ0FnSUNBZ0lDQnlaWFIxY200Z01IZ3pNQ0FySUNodUlDMGdOVElwTzF4dVhIUWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHNGdQVDBnTmpJcElIdGNibHgwSUNBZ0lDQWdJQ0J5WlhSMWNtNGdNSGd5WWp0Y2JseDBJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHVJRDA5SURZektTQjdYRzVjZENBZ0lDQWdJQ0FnY21WMGRYSnVJREI0TW1ZN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZHVPaWNnS3lCdUtUdGNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnWDNSb2FYTXVkM0pwZEdWQ2VYUmxJRDBnWm5WdVkzUnBiMjRnS0c0cElIdGNibHgwWEc1Y2RDQWdJQ0FnSUY5aWRXWm1aWElnUFNCZlluVm1abVZ5SUR3OElEZ2dmQ0J1SUNZZ01IaG1aanRjYmx4MElDQWdJQ0FnWDJKMVpteGxiaUFyUFNBNE8xeHVYSFFnSUNBZ0lDQmZiR1Z1WjNSb0lDczlJREU3WEc1Y2RGeHVYSFFnSUNBZ0lDQjNhR2xzWlNBb1gySjFabXhsYmlBK1BTQTJLU0I3WEc1Y2RDQWdJQ0FnSUNBZ2QzSnBkR1ZGYm1OdlpHVmtLRjlpZFdabVpYSWdQajQrSUY5aWRXWnNaVzRnTFNBMktUdGNibHgwSUNBZ0lDQWdJQ0JmWW5WbWJHVnVJQzA5SURZN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnWDNSb2FYTXVabXgxYzJnZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQnBaaUFvWDJKMVpteGxiaUErSURBcElIdGNibHgwSUNBZ0lDQWdJQ0IzY21sMFpVVnVZMjlrWldRb1gySjFabVpsY2lBOFBDQTJJQzBnWDJKMVpteGxiaWs3WEc1Y2RDQWdJQ0FnSUNBZ1gySjFabVpsY2lBOUlEQTdYRzVjZENBZ0lDQWdJQ0FnWDJKMVpteGxiaUE5SURBN1hHNWNkQ0FnSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0FnSUdsbUlDaGZiR1Z1WjNSb0lDVWdNeUFoUFNBd0tTQjdYRzVjZENBZ0lDQWdJQ0FnZG1GeUlIQmhaR3hsYmlBOUlETWdMU0JmYkdWdVozUm9JQ1VnTXp0Y2JseDBJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJSEJoWkd4bGJqc2dhU0FyUFNBeEtTQjdYRzVjZENBZ0lDQWdJQ0FnSUNCZlltRnpaVFkwSUNzOUlDYzlKenRjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lIMDdYRzVjZEZ4dVhIUWdJQ0FnWDNSb2FYTXVkRzlUZEhKcGJtY2dQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkQ0FnSUNBZ0lISmxkSFZ5YmlCZlltRnpaVFkwTzF4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc1Y2RDQWdmVHRjYmx4MFhHNWNkQ0FnZG1GeUlHSmhjMlUyTkVSbFkyOWtaVWx1Y0hWMFUzUnlaV0Z0SUQwZ1puVnVZM1JwYjI0Z1ltRnpaVFkwUkdWamIyUmxTVzV3ZFhSVGRISmxZVzBvYzNSeUtTQjdYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlGOXpkSElnUFNCemRISTdYRzVjZENBZ0lDQjJZWElnWDNCdmN5QTlJREE3WEc1Y2RDQWdJQ0IyWVhJZ1gySjFabVpsY2lBOUlEQTdYRzVjZENBZ0lDQjJZWElnWDJKMVpteGxiaUE5SURBN1hHNWNkRnh1WEhRZ0lDQWdkbUZ5SUY5MGFHbHpJRDBnZTMwN1hHNWNkRnh1WEhRZ0lDQWdYM1JvYVhNdWNtVmhaQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNibHgwWEc1Y2RDQWdJQ0FnSUhkb2FXeGxJQ2hmWW5WbWJHVnVJRHdnT0NrZ2UxeHVYSFJjYmx4MElDQWdJQ0FnSUNCcFppQW9YM0J2Y3lBK1BTQmZjM1J5TG14bGJtZDBhQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdhV1lnS0Y5aWRXWnNaVzRnUFQwZ01Da2dlMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0xURTdYRzVjZENBZ0lDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KM1Z1Wlhod1pXTjBaV1FnWlc1a0lHOW1JR1pwYkdVdUx5Y2dLeUJmWW5WbWJHVnVLVHRjYmx4MElDQWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0FnSUhaaGNpQmpJRDBnWDNOMGNpNWphR0Z5UVhRb1gzQnZjeWs3WEc1Y2RDQWdJQ0FnSUNBZ1gzQnZjeUFyUFNBeE8xeHVYSFJjYmx4MElDQWdJQ0FnSUNCcFppQW9ZeUE5UFNBblBTY3BJSHRjYmx4MElDQWdJQ0FnSUNBZ0lGOWlkV1pzWlc0Z1BTQXdPMXh1WEhRZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUMweE8xeHVYSFFnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvWXk1dFlYUmphQ2d2WGx4Y2N5UXZLU2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzVjZENBZ0lDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdJQ0JmWW5WbVptVnlJRDBnWDJKMVptWmxjaUE4UENBMklId2daR1ZqYjJSbEtHTXVZMmhoY2tOdlpHVkJkQ2d3S1NrN1hHNWNkQ0FnSUNBZ0lDQWdYMkoxWm14bGJpQXJQU0EyTzF4dVhIUWdJQ0FnSUNCOVhHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ2JpQTlJRjlpZFdabVpYSWdQajQrSUY5aWRXWnNaVzRnTFNBNElDWWdNSGhtWmp0Y2JseDBJQ0FnSUNBZ1gySjFabXhsYmlBdFBTQTRPMXh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdianRjYmx4MElDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ2RtRnlJR1JsWTI5a1pTQTlJR1oxYm1OMGFXOXVJR1JsWTI5a1pTaGpLU0I3WEc1Y2RDQWdJQ0FnSUdsbUlDZ3dlRFF4SUR3OUlHTWdKaVlnWXlBOFBTQXdlRFZoS1NCN1hHNWNkQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHTWdMU0F3ZURReE8xeHVYSFFnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLREI0TmpFZ1BEMGdZeUFtSmlCaklEdzlJREI0TjJFcElIdGNibHgwSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZeUF0SURCNE5qRWdLeUF5Tmp0Y2JseDBJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDZ3dlRE13SUR3OUlHTWdKaVlnWXlBOFBTQXdlRE01S1NCN1hHNWNkQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHTWdMU0F3ZURNd0lDc2dOVEk3WEc1Y2RDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1l5QTlQU0F3ZURKaUtTQjdYRzVjZENBZ0lDQWdJQ0FnY21WMGRYSnVJRFl5TzF4dVhIUWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHTWdQVDBnTUhneVppa2dlMXh1WEhRZ0lDQWdJQ0FnSUhKbGRIVnliaUEyTXp0Y2JseDBJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JseDBJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0oyTTZKeUFySUdNcE8xeHVYSFFnSUNBZ0lDQjlYRzVjZENBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNibHgwSUNCOU8xeHVYSFJjYmx4MElDQjJZWElnWjJsbVNXMWhaMlVnUFNCbWRXNWpkR2x2YmlCbmFXWkpiV0ZuWlNoM2FXUjBhQ3dnYUdWcFoyaDBLU0I3WEc1Y2RGeHVYSFFnSUNBZ2RtRnlJRjkzYVdSMGFDQTlJSGRwWkhSb08xeHVYSFFnSUNBZ2RtRnlJRjlvWldsbmFIUWdQU0JvWldsbmFIUTdYRzVjZENBZ0lDQjJZWElnWDJSaGRHRWdQU0J1WlhjZ1FYSnlZWGtvZDJsa2RHZ2dLaUJvWldsbmFIUXBPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEhSY2JseDBJQ0FnSUY5MGFHbHpMbk5sZEZCcGVHVnNJRDBnWm5WdVkzUnBiMjRnS0hnc0lIa3NJSEJwZUdWc0tTQjdYRzVjZENBZ0lDQWdJRjlrWVhSaFcza2dLaUJmZDJsa2RHZ2dLeUI0WFNBOUlIQnBlR1ZzTzF4dVhIUWdJQ0FnZlR0Y2JseDBYRzVjZENBZ0lDQmZkR2hwY3k1M2NtbDBaU0E5SUdaMWJtTjBhVzl1SUNodmRYUXBJSHRjYmx4MFhHNWNkQ0FnSUNBZ0lHOTFkQzUzY21sMFpWTjBjbWx1WnlnblIwbEdPRGRoSnlrN1hHNWNkRnh1WEhRZ0lDQWdJQ0J2ZFhRdWQzSnBkR1ZUYUc5eWRDaGZkMmxrZEdncE8xeHVYSFFnSUNBZ0lDQnZkWFF1ZDNKcGRHVlRhRzl5ZENoZmFHVnBaMmgwS1R0Y2JseDBYRzVjZENBZ0lDQWdJRzkxZEM1M2NtbDBaVUo1ZEdVb01IZzRNQ2s3WEc1Y2RDQWdJQ0FnSUc5MWRDNTNjbWwwWlVKNWRHVW9NQ2s3WEc1Y2RDQWdJQ0FnSUc5MWRDNTNjbWwwWlVKNWRHVW9NQ2s3WEc1Y2RGeHVYSFFnSUNBZ0lDQnZkWFF1ZDNKcGRHVkNlWFJsS0RCNE1EQXBPMXh1WEhRZ0lDQWdJQ0J2ZFhRdWQzSnBkR1ZDZVhSbEtEQjRNREFwTzF4dVhIUWdJQ0FnSUNCdmRYUXVkM0pwZEdWQ2VYUmxLREI0TURBcE8xeHVYSFJjYmx4MElDQWdJQ0FnYjNWMExuZHlhWFJsUW5sMFpTZ3dlR1ptS1R0Y2JseDBJQ0FnSUNBZ2IzVjBMbmR5YVhSbFFubDBaU2d3ZUdabUtUdGNibHgwSUNBZ0lDQWdiM1YwTG5keWFYUmxRbmwwWlNnd2VHWm1LVHRjYmx4MFhHNWNkQ0FnSUNBZ0lHOTFkQzUzY21sMFpWTjBjbWx1WnlnbkxDY3BPMXh1WEhRZ0lDQWdJQ0J2ZFhRdWQzSnBkR1ZUYUc5eWRDZ3dLVHRjYmx4MElDQWdJQ0FnYjNWMExuZHlhWFJsVTJodmNuUW9NQ2s3WEc1Y2RDQWdJQ0FnSUc5MWRDNTNjbWwwWlZOb2IzSjBLRjkzYVdSMGFDazdYRzVjZENBZ0lDQWdJRzkxZEM1M2NtbDBaVk5vYjNKMEtGOW9aV2xuYUhRcE8xeHVYSFFnSUNBZ0lDQnZkWFF1ZDNKcGRHVkNlWFJsS0RBcE8xeHVYSFJjYmx4MElDQWdJQ0FnZG1GeUlHeDZkMDFwYmtOdlpHVlRhWHBsSUQwZ01qdGNibHgwSUNBZ0lDQWdkbUZ5SUhKaGMzUmxjaUE5SUdkbGRFeGFWMUpoYzNSbGNpaHNlbmROYVc1RGIyUmxVMmw2WlNrN1hHNWNkRnh1WEhRZ0lDQWdJQ0J2ZFhRdWQzSnBkR1ZDZVhSbEtHeDZkMDFwYmtOdlpHVlRhWHBsS1R0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCdlptWnpaWFFnUFNBd08xeHVYSFJjYmx4MElDQWdJQ0FnZDJocGJHVWdLSEpoYzNSbGNpNXNaVzVuZEdnZ0xTQnZabVp6WlhRZ1BpQXlOVFVwSUh0Y2JseDBJQ0FnSUNBZ0lDQnZkWFF1ZDNKcGRHVkNlWFJsS0RJMU5TazdYRzVjZENBZ0lDQWdJQ0FnYjNWMExuZHlhWFJsUW5sMFpYTW9jbUZ6ZEdWeUxDQnZabVp6WlhRc0lESTFOU2s3WEc1Y2RDQWdJQ0FnSUNBZ2IyWm1jMlYwSUNzOUlESTFOVHRjYmx4MElDQWdJQ0FnZlZ4dVhIUmNibHgwSUNBZ0lDQWdiM1YwTG5keWFYUmxRbmwwWlNoeVlYTjBaWEl1YkdWdVozUm9JQzBnYjJabWMyVjBLVHRjYmx4MElDQWdJQ0FnYjNWMExuZHlhWFJsUW5sMFpYTW9jbUZ6ZEdWeUxDQnZabVp6WlhRc0lISmhjM1JsY2k1c1pXNW5kR2dnTFNCdlptWnpaWFFwTzF4dVhIUWdJQ0FnSUNCdmRYUXVkM0pwZEdWQ2VYUmxLREI0TURBcE8xeHVYSFJjYmx4MElDQWdJQ0FnYjNWMExuZHlhWFJsVTNSeWFXNW5LQ2M3SnlrN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJSFpoY2lCaWFYUlBkWFJ3ZFhSVGRISmxZVzBnUFNCbWRXNWpkR2x2YmlCaWFYUlBkWFJ3ZFhSVGRISmxZVzBvYjNWMEtTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCMllYSWdYMjkxZENBOUlHOTFkRHRjYmx4MElDQWdJQ0FnZG1GeUlGOWlhWFJNWlc1bmRHZ2dQU0F3TzF4dVhIUWdJQ0FnSUNCMllYSWdYMkpwZEVKMVptWmxjaUE5SURBN1hHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ1gzUm9hWE1nUFNCN2ZUdGNibHgwWEc1Y2RDQWdJQ0FnSUY5MGFHbHpMbmR5YVhSbElEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHeGxibWQwYUNrZ2UxeHVYSFJjYmx4MElDQWdJQ0FnSUNCcFppQW9aR0YwWVNBK1BqNGdiR1Z1WjNSb0lDRTlJREFwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25iR1Z1WjNSb0lHOTJaWEluS1R0Y2JseDBJQ0FnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lIZG9hV3hsSUNoZlltbDBUR1Z1WjNSb0lDc2diR1Z1WjNSb0lENDlJRGdwSUh0Y2JseDBJQ0FnSUNBZ0lDQWdJRjl2ZFhRdWQzSnBkR1ZDZVhSbEtEQjRabVlnSmlBb1pHRjBZU0E4UENCZlltbDBUR1Z1WjNSb0lId2dYMkpwZEVKMVptWmxjaWtwTzF4dVhIUWdJQ0FnSUNBZ0lDQWdiR1Z1WjNSb0lDMDlJRGdnTFNCZlltbDBUR1Z1WjNSb08xeHVYSFFnSUNBZ0lDQWdJQ0FnWkdGMFlTQStQajQ5SURnZ0xTQmZZbWwwVEdWdVozUm9PMXh1WEhRZ0lDQWdJQ0FnSUNBZ1gySnBkRUoxWm1abGNpQTlJREE3WEc1Y2RDQWdJQ0FnSUNBZ0lDQmZZbWwwVEdWdVozUm9JRDBnTUR0Y2JseDBJQ0FnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lGOWlhWFJDZFdabVpYSWdQU0JrWVhSaElEdzhJRjlpYVhSTVpXNW5kR2dnZkNCZlltbDBRblZtWm1WeU8xeHVYSFFnSUNBZ0lDQWdJRjlpYVhSTVpXNW5kR2dnUFNCZlltbDBUR1Z1WjNSb0lDc2diR1Z1WjNSb08xeHVYSFFnSUNBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUNBZ1gzUm9hWE11Wm14MWMyZ2dQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkQ0FnSUNBZ0lDQWdhV1lnS0Y5aWFYUk1aVzVuZEdnZ1BpQXdLU0I3WEc1Y2RDQWdJQ0FnSUNBZ0lDQmZiM1YwTG5keWFYUmxRbmwwWlNoZlltbDBRblZtWm1WeUtUdGNibHgwSUNBZ0lDQWdJQ0I5WEc1Y2RDQWdJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdJQ0J5WlhSMWNtNGdYM1JvYVhNN1hHNWNkQ0FnSUNCOU8xeHVYSFJjYmx4MElDQWdJSFpoY2lCblpYUk1XbGRTWVhOMFpYSWdQU0JtZFc1amRHbHZiaUJuWlhSTVdsZFNZWE4wWlhJb2JIcDNUV2x1UTI5a1pWTnBlbVVwSUh0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCamJHVmhja052WkdVZ1BTQXhJRHc4SUd4NmQwMXBia052WkdWVGFYcGxPMXh1WEhRZ0lDQWdJQ0IyWVhJZ1pXNWtRMjlrWlNBOUlDZ3hJRHc4SUd4NmQwMXBia052WkdWVGFYcGxLU0FySURFN1hHNWNkQ0FnSUNBZ0lIWmhjaUJpYVhSTVpXNW5kR2dnUFNCc2VuZE5hVzVEYjJSbFUybDZaU0FySURFN1hHNWNkRnh1WEhRZ0lDQWdJQ0IyWVhJZ2RHRmliR1VnUFNCc2VuZFVZV0pzWlNncE8xeHVYSFJjYmx4MElDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCamJHVmhja052WkdVN0lHa2dLejBnTVNrZ2UxeHVYSFFnSUNBZ0lDQWdJSFJoWW14bExtRmtaQ2hUZEhKcGJtY3Vabkp2YlVOb1lYSkRiMlJsS0drcEtUdGNibHgwSUNBZ0lDQWdmVnh1WEhRZ0lDQWdJQ0IwWVdKc1pTNWhaR1FvVTNSeWFXNW5MbVp5YjIxRGFHRnlRMjlrWlNoamJHVmhja052WkdVcEtUdGNibHgwSUNBZ0lDQWdkR0ZpYkdVdVlXUmtLRk4wY21sdVp5NW1jbTl0UTJoaGNrTnZaR1VvWlc1a1EyOWtaU2twTzF4dVhIUmNibHgwSUNBZ0lDQWdkbUZ5SUdKNWRHVlBkWFFnUFNCaWVYUmxRWEp5WVhsUGRYUndkWFJUZEhKbFlXMG9LVHRjYmx4MElDQWdJQ0FnZG1GeUlHSnBkRTkxZENBOUlHSnBkRTkxZEhCMWRGTjBjbVZoYlNoaWVYUmxUM1YwS1R0Y2JseDBYRzVjZENBZ0lDQWdJR0pwZEU5MWRDNTNjbWwwWlNoamJHVmhja052WkdVc0lHSnBkRXhsYm1kMGFDazdYRzVjZEZ4dVhIUWdJQ0FnSUNCMllYSWdaR0YwWVVsdVpHVjRJRDBnTUR0Y2JseDBYRzVjZENBZ0lDQWdJSFpoY2lCeklEMGdVM1J5YVc1bkxtWnliMjFEYUdGeVEyOWtaU2hmWkdGMFlWdGtZWFJoU1c1a1pYaGRLVHRjYmx4MElDQWdJQ0FnWkdGMFlVbHVaR1Y0SUNzOUlERTdYRzVjZEZ4dVhIUWdJQ0FnSUNCM2FHbHNaU0FvWkdGMFlVbHVaR1Y0SUR3Z1gyUmhkR0V1YkdWdVozUm9LU0I3WEc1Y2RGeHVYSFFnSUNBZ0lDQWdJSFpoY2lCaklEMGdVM1J5YVc1bkxtWnliMjFEYUdGeVEyOWtaU2hmWkdGMFlWdGtZWFJoU1c1a1pYaGRLVHRjYmx4MElDQWdJQ0FnSUNCa1lYUmhTVzVrWlhnZ0t6MGdNVHRjYmx4MFhHNWNkQ0FnSUNBZ0lDQWdhV1lnS0hSaFlteGxMbU52Ym5SaGFXNXpLSE1nS3lCaktTa2dlMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJSE1nUFNCeklDc2dZenRjYmx4MElDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dVhIUmNibHgwSUNBZ0lDQWdJQ0FnSUdKcGRFOTFkQzUzY21sMFpTaDBZV0pzWlM1cGJtUmxlRTltS0hNcExDQmlhWFJNWlc1bmRHZ3BPMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJR2xtSUNoMFlXSnNaUzV6YVhwbEtDa2dQQ0F3ZUdabVppa2dlMXh1WEhSY2JseDBJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUmhZbXhsTG5OcGVtVW9LU0E5UFNBeElEdzhJR0pwZEV4bGJtZDBhQ2tnZTF4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKcGRFeGxibWQwYUNBclBTQXhPMXh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnSUNBZ0lDQWdJQ0IwWVdKc1pTNWhaR1FvY3lBcklHTXBPMXh1WEhRZ0lDQWdJQ0FnSUNBZ2ZWeHVYSFJjYmx4MElDQWdJQ0FnSUNBZ0lITWdQU0JqTzF4dVhIUWdJQ0FnSUNBZ0lIMWNibHgwSUNBZ0lDQWdmVnh1WEhSY2JseDBJQ0FnSUNBZ1ltbDBUM1YwTG5keWFYUmxLSFJoWW14bExtbHVaR1Y0VDJZb2N5a3NJR0pwZEV4bGJtZDBhQ2s3WEc1Y2RGeHVYSFFnSUNBZ0lDQmlhWFJQZFhRdWQzSnBkR1VvWlc1a1EyOWtaU3dnWW1sMFRHVnVaM1JvS1R0Y2JseDBYRzVjZENBZ0lDQWdJR0pwZEU5MWRDNW1iSFZ6YUNncE8xeHVYSFJjYmx4MElDQWdJQ0FnY21WMGRYSnVJR0o1ZEdWUGRYUXVkRzlDZVhSbFFYSnlZWGtvS1R0Y2JseDBJQ0FnSUgwN1hHNWNkRnh1WEhRZ0lDQWdkbUZ5SUd4NmQxUmhZbXhsSUQwZ1puVnVZM1JwYjI0Z2JIcDNWR0ZpYkdVb0tTQjdYRzVjZEZ4dVhIUWdJQ0FnSUNCMllYSWdYMjFoY0NBOUlIdDlPMXh1WEhRZ0lDQWdJQ0IyWVhJZ1gzTnBlbVVnUFNBd08xeHVYSFJjYmx4MElDQWdJQ0FnZG1GeUlGOTBhR2x6SUQwZ2UzMDdYRzVjZEZ4dVhIUWdJQ0FnSUNCZmRHaHBjeTVoWkdRZ1BTQm1kVzVqZEdsdmJpQW9hMlY1S1NCN1hHNWNkQ0FnSUNBZ0lDQWdhV1lnS0Y5MGFHbHpMbU52Ym5SaGFXNXpLR3RsZVNrcElIdGNibHgwSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduWkhWd0lHdGxlVG9uSUNzZ2EyVjVLVHRjYmx4MElDQWdJQ0FnSUNCOVhHNWNkQ0FnSUNBZ0lDQWdYMjFoY0Z0clpYbGRJRDBnWDNOcGVtVTdYRzVjZENBZ0lDQWdJQ0FnWDNOcGVtVWdLejBnTVR0Y2JseDBJQ0FnSUNBZ2ZUdGNibHgwWEc1Y2RDQWdJQ0FnSUY5MGFHbHpMbk5wZW1VZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc1Y2RDQWdJQ0FnSUNBZ2NtVjBkWEp1SUY5emFYcGxPMXh1WEhRZ0lDQWdJQ0I5TzF4dVhIUmNibHgwSUNBZ0lDQWdYM1JvYVhNdWFXNWtaWGhQWmlBOUlHWjFibU4wYVc5dUlDaHJaWGtwSUh0Y2JseDBJQ0FnSUNBZ0lDQnlaWFIxY200Z1gyMWhjRnRyWlhsZE8xeHVYSFFnSUNBZ0lDQjlPMXh1WEhSY2JseDBJQ0FnSUNBZ1gzUm9hWE11WTI5dWRHRnBibk1nUFNCbWRXNWpkR2x2YmlBb2EyVjVLU0I3WEc1Y2RDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSNWNHVnZaaUJmYldGd1cydGxlVjBnSVQwZ0ozVnVaR1ZtYVc1bFpDYzdYRzVjZENBZ0lDQWdJSDA3WEc1Y2RGeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc1Y2RDQWdJQ0I5TzF4dVhIUmNibHgwSUNBZ0lISmxkSFZ5YmlCZmRHaHBjenRjYmx4MElDQjlPMXh1WEhSY2JseDBJQ0IyWVhJZ1kzSmxZWFJsU1cxblZHRm5JRDBnWm5WdVkzUnBiMjRnWTNKbFlYUmxTVzFuVkdGbktIZHBaSFJvTENCb1pXbG5hSFFzSUdkbGRGQnBlR1ZzTENCaGJIUXBJSHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdaMmxtSUQwZ1oybG1TVzFoWjJVb2QybGtkR2dzSUdobGFXZG9kQ2s3WEc1Y2RDQWdJQ0JtYjNJZ0tIWmhjaUI1SUQwZ01Ec2dlU0E4SUdobGFXZG9kRHNnZVNBclBTQXhLU0I3WEc1Y2RDQWdJQ0FnSUdadmNpQW9kbUZ5SUhnZ1BTQXdPeUI0SUR3Z2QybGtkR2c3SUhnZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNBZ0lHZHBaaTV6WlhSUWFYaGxiQ2g0TENCNUxDQm5aWFJRYVhobGJDaDRMQ0I1S1NrN1hHNWNkQ0FnSUNBZ0lIMWNibHgwSUNBZ0lIMWNibHgwWEc1Y2RDQWdJQ0IyWVhJZ1lpQTlJR0o1ZEdWQmNuSmhlVTkxZEhCMWRGTjBjbVZoYlNncE8xeHVYSFFnSUNBZ1oybG1MbmR5YVhSbEtHSXBPMXh1WEhSY2JseDBJQ0FnSUhaaGNpQmlZWE5sTmpRZ1BTQmlZWE5sTmpSRmJtTnZaR1ZQZFhSd2RYUlRkSEpsWVcwb0tUdGNibHgwSUNBZ0lIWmhjaUJpZVhSbGN5QTlJR0l1ZEc5Q2VYUmxRWEp5WVhrb0tUdGNibHgwSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dZbmwwWlhNdWJHVnVaM1JvT3lCcElDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ1ltRnpaVFkwTG5keWFYUmxRbmwwWlNoaWVYUmxjMXRwWFNrN1hHNWNkQ0FnSUNCOVhHNWNkQ0FnSUNCaVlYTmxOalF1Wm14MWMyZ29LVHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdhVzFuSUQwZ0p5YzdYRzVjZENBZ0lDQnBiV2NnS3owZ0p6eHBiV2NuTzF4dVhIUWdJQ0FnYVcxbklDczlJQ2NnYzNKalBWd2lKenRjYmx4MElDQWdJR2x0WnlBclBTQW5aR0YwWVRwcGJXRm5aUzluYVdZN1ltRnpaVFkwTENjN1hHNWNkQ0FnSUNCcGJXY2dLejBnWW1GelpUWTBPMXh1WEhRZ0lDQWdhVzFuSUNzOUlDZGNJaWM3WEc1Y2RDQWdJQ0JwYldjZ0t6MGdKeUIzYVdSMGFEMWNJaWM3WEc1Y2RDQWdJQ0JwYldjZ0t6MGdkMmxrZEdnN1hHNWNkQ0FnSUNCcGJXY2dLejBnSjF3aUp6dGNibHgwSUNBZ0lHbHRaeUFyUFNBbklHaGxhV2RvZEQxY0lpYzdYRzVjZENBZ0lDQnBiV2NnS3owZ2FHVnBaMmgwTzF4dVhIUWdJQ0FnYVcxbklDczlJQ2RjSWljN1hHNWNkQ0FnSUNCcFppQW9ZV3gwS1NCN1hHNWNkQ0FnSUNBZ0lHbHRaeUFyUFNBbklHRnNkRDFjSWljN1hHNWNkQ0FnSUNBZ0lHbHRaeUFyUFNCaGJIUTdYRzVjZENBZ0lDQWdJR2x0WnlBclBTQW5YQ0luTzF4dVhIUWdJQ0FnZlZ4dVhIUWdJQ0FnYVcxbklDczlJQ2N2UGljN1hHNWNkRnh1WEhRZ0lDQWdjbVYwZFhKdUlHbHRaenRjYmx4MElDQjlPMXh1WEhSY2JseDBJQ0IyWVhJZ1kzSmxZWFJsU1cxblQySnFaV04wSUQwZ1puVnVZM1JwYjI0Z1kzSmxZWFJsU1cxblQySnFaV04wS0hkcFpIUm9MQ0JvWldsbmFIUXNJR2RsZEZCcGVHVnNLU0I3WEc1Y2RGeHVYSFFnSUNBZ2RtRnlJR2RwWmlBOUlHZHBaa2x0WVdkbEtIZHBaSFJvTENCb1pXbG5hSFFwTzF4dVhIUWdJQ0FnWm05eUlDaDJZWElnZVNBOUlEQTdJSGtnUENCb1pXbG5hSFE3SUhrZ0t6MGdNU2tnZTF4dVhIUWdJQ0FnSUNCbWIzSWdLSFpoY2lCNElEMGdNRHNnZUNBOElIZHBaSFJvT3lCNElDczlJREVwSUh0Y2JseDBJQ0FnSUNBZ0lDQm5hV1l1YzJWMFVHbDRaV3dvZUN3Z2VTd2daMlYwVUdsNFpXd29lQ3dnZVNrcE8xeHVYSFFnSUNBZ0lDQjlYRzVjZENBZ0lDQjlYRzVjZEZ4dVhIUWdJQ0FnZG1GeUlHSWdQU0JpZVhSbFFYSnlZWGxQZFhSd2RYUlRkSEpsWVcwb0tUdGNibHgwSUNBZ0lHZHBaaTUzY21sMFpTaGlLVHRjYmx4MFhHNWNkQ0FnSUNCMllYSWdZbUZ6WlRZMElEMGdZbUZ6WlRZMFJXNWpiMlJsVDNWMGNIVjBVM1J5WldGdEtDazdYRzVjZENBZ0lDQjJZWElnWW5sMFpYTWdQU0JpTG5SdlFubDBaVUZ5Y21GNUtDazdYRzVjZENBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR0o1ZEdWekxteGxibWQwYURzZ2FTQXJQU0F4S1NCN1hHNWNkQ0FnSUNBZ0lHSmhjMlUyTkM1M2NtbDBaVUo1ZEdVb1lubDBaWE5iYVYwcE8xeHVYSFFnSUNBZ2ZWeHVYSFFnSUNBZ1ltRnpaVFkwTG1ac2RYTm9LQ2s3WEc1Y2RGeHVYSFFnSUNBZ2RtRnlJR2x0WnlBOUlHNWxkeUJKYldGblpTZ3BPMXh1WEhRZ0lDQWdhVzFuTG5OeVl5QTlJQ2RrWVhSaE9tbHRZV2RsTDJkcFpqdGlZWE5sTmpRc0p5QXJJR0poYzJVMk5EdGNibHgwSUNBZ0lHbHRaeTUzYVdSMGFDQTlJSGRwWkhSb08xeHVYSFFnSUNBZ2FXMW5MbWhsYVdkb2RDQTlJR2hsYVdkb2REdGNibHgwWEc1Y2RDQWdJQ0J5WlhSMWNtNGdhVzFuTzF4dVhIUWdJSDA3WEc1Y2RGeHVYSFFnSUhKbGRIVnliaUI3WEc1Y2RDQWdJQ0JSVWtOdlpHVTZJSEZ5WTI5a1pTeGNibHgwSUNBZ0lGRlNWWFJwYkRvZ1VWSlZkR2xzWEc1Y2RDQWdmVHRjYmx4MGZTZ3BPMXh1WEhSY2JseDBLR1oxYm1OMGFXOXVJQ2htWVdOMGIzSjVLU0I3WEc1Y2RDQWdhV1lnS0hSeWRXVXBJSHRjYmx4MElDQWdJQ0VvWDE5WFJVSlFRVU5MWDBGTlJGOUVSVVpKVGtWZlFWSlNRVmxmWHlBOUlGdGRMQ0JmWDFkRlFsQkJRMHRmUVUxRVgwUkZSa2xPUlY5R1FVTlVUMUpaWDE4Z1BTQW9abUZqZEc5eWVTa3NJRjlmVjBWQ1VFRkRTMTlCVFVSZlJFVkdTVTVGWDFKRlUxVk1WRjlmSUQwZ0tIUjVjR1Z2WmlCZlgxZEZRbEJCUTB0ZlFVMUVYMFJGUmtsT1JWOUdRVU5VVDFKWlgxOGdQVDA5SUNkbWRXNWpkR2x2YmljZ1B5QW9YMTlYUlVKUVFVTkxYMEZOUkY5RVJVWkpUa1ZmUmtGRFZFOVNXVjlmTG1Gd2NHeDVLR1Y0Y0c5eWRITXNJRjlmVjBWQ1VFRkRTMTlCVFVSZlJFVkdTVTVGWDBGU1VrRlpYMThwS1NBNklGOWZWMFZDVUVGRFMxOUJUVVJmUkVWR1NVNUZYMFpCUTFSUFVsbGZYeWtzSUY5ZlYwVkNVRUZEUzE5QlRVUmZSRVZHU1U1RlgxSkZVMVZNVkY5ZklDRTlQU0IxYm1SbFptbHVaV1FnSmlZZ0tHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1gxOVhSVUpRUVVOTFgwRk5SRjlFUlVaSlRrVmZVa1ZUVlV4VVgxOHBLVHRjYmx4MElDQjlJR1ZzYzJVZ2FXWWdLQ2gwZVhCbGIyWWdaWGh3YjNKMGN5QTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QW5kVzVrWldacGJtVmtKeUE2SUNnd0xDQmZkSGx3Wlc5bU15NWtaV1poZFd4MEtTaGxlSEJ2Y25SektTa2dQVDA5SUNkdlltcGxZM1FuS1NCN1hHNWNkQ0FnSUNCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaaFkzUnZjbmtvS1R0Y2JseDBJQ0I5WEc1Y2RIMHBLR1oxYm1OMGFXOXVJQ2dwSUh0Y2JseDBJQ0J5WlhSMWNtNGdlMXh1WEhRZ0lDQWdVVkpEYjJSbE9pQnhjbU52WkdVdVVWSkRiMlJsTEZ4dVhIUWdJQ0FnVVZKVmRHbHNPaUJ4Y21OdlpHVXVVVkpWZEdsc1hHNWNkQ0FnZlR0Y2JseDBmU2s3WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUF5TWlBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MFhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2RGeHVYSFJsZUhCdmNuUnpMbDlmWlhOTmIyUjFiR1VnUFNCMGNuVmxPMXh1WEhSY2JseDBkbUZ5SUY5cGRHVnlZWFJ2Y2lBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9Nak1wTzF4dVhIUmNibHgwZG1GeUlGOXBkR1Z5WVhSdmNqSWdQU0JmYVc1MFpYSnZjRkpsY1hWcGNtVkVaV1poZFd4MEtGOXBkR1Z5WVhSdmNpazdYRzVjZEZ4dVhIUjJZWElnWDNONWJXSnZiQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05Ua3BPMXh1WEhSY2JseDBkbUZ5SUY5emVXMWliMnd5SUQwZ1gybHVkR1Z5YjNCU1pYRjFhWEpsUkdWbVlYVnNkQ2hmYzNsdFltOXNLVHRjYmx4MFhHNWNkSFpoY2lCZmRIbHdaVzltSUQwZ2RIbHdaVzltSUY5emVXMWliMnd5TG1SbFptRjFiSFFnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCMGVYQmxiMllnWDJsMFpYSmhkRzl5TWk1a1pXWmhkV3gwSUQwOVBTQmNJbk41YldKdmJGd2lJRDhnWm5WdVkzUnBiMjRnS0c5aWFpa2dleUJ5WlhSMWNtNGdkSGx3Wlc5bUlHOWlhanNnZlNBNklHWjFibU4wYVc5dUlDaHZZbW9wSUhzZ2NtVjBkWEp1SUc5aWFpQW1KaUIwZVhCbGIyWWdYM041YldKdmJESXVaR1ZtWVhWc2RDQTlQVDBnWENKbWRXNWpkR2x2Ymx3aUlDWW1JRzlpYWk1amIyNXpkSEoxWTNSdmNpQTlQVDBnWDNONWJXSnZiREl1WkdWbVlYVnNkQ0FtSmlCdlltb2dJVDA5SUY5emVXMWliMnd5TG1SbFptRjFiSFF1Y0hKdmRHOTBlWEJsSUQ4Z1hDSnplVzFpYjJ4Y0lpQTZJSFI1Y0dWdlppQnZZbW83SUgwN1hHNWNkRnh1WEhSbWRXNWpkR2x2YmlCZmFXNTBaWEp2Y0ZKbGNYVnBjbVZFWldaaGRXeDBLRzlpYWlrZ2V5QnlaWFIxY200Z2IySnFJQ1ltSUc5aWFpNWZYMlZ6VFc5a2RXeGxJRDhnYjJKcUlEb2dleUJrWldaaGRXeDBPaUJ2WW1vZ2ZUc2dmVnh1WEhSY2JseDBaWGh3YjNKMGN5NWtaV1poZFd4MElEMGdkSGx3Wlc5bUlGOXplVzFpYjJ3eUxtUmxabUYxYkhRZ1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQmZkSGx3Wlc5bUtGOXBkR1Z5WVhSdmNqSXVaR1ZtWVhWc2RDa2dQVDA5SUZ3aWMzbHRZbTlzWENJZ1B5Qm1kVzVqZEdsdmJpQW9iMkpxS1NCN1hHNWNkQ0FnY21WMGRYSnVJSFI1Y0dWdlppQnZZbW9nUFQwOUlGd2lkVzVrWldacGJtVmtYQ0lnUHlCY0luVnVaR1ZtYVc1bFpGd2lJRG9nWDNSNWNHVnZaaWh2WW1vcE8xeHVYSFI5SURvZ1puVnVZM1JwYjI0Z0tHOWlhaWtnZTF4dVhIUWdJSEpsZEhWeWJpQnZZbW9nSmlZZ2RIbHdaVzltSUY5emVXMWliMnd5TG1SbFptRjFiSFFnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCdlltb3VZMjl1YzNSeWRXTjBiM0lnUFQwOUlGOXplVzFpYjJ3eUxtUmxabUYxYkhRZ0ppWWdiMkpxSUNFOVBTQmZjM2x0WW05c01pNWtaV1poZFd4MExuQnliM1J2ZEhsd1pTQS9JRndpYzNsdFltOXNYQ0lnT2lCMGVYQmxiMllnYjJKcUlEMDlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlEOGdYQ0oxYm1SbFptbHVaV1JjSWlBNklGOTBlWEJsYjJZb2IySnFLVHRjYmx4MGZUdGNibHh1THlvcUtpOGdmU3hjYmk4cUlESXpJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwSUh0Y2JseHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSHNnWENKa1pXWmhkV3gwWENJNklGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NalFwTENCZlgyVnpUVzlrZFd4bE9pQjBjblZsSUgwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBeU5DQXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLU0I3WEc1Y2JseDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWd5TlNrN1hHNWNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTlRRcE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTlRncExtWW9KMmwwWlhKaGRHOXlKeWs3WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUF5TlNBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MEozVnpaU0J6ZEhKcFkzUW5PMXh1WEhSMllYSWdKR0YwSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NallwS0hSeWRXVXBPMXh1WEhSY2JseDBMeThnTWpFdU1TNHpMakkzSUZOMGNtbHVaeTV3Y205MGIzUjVjR1ZiUUVCcGRHVnlZWFJ2Y2wwb0tWeHVYSFJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RJNUtTaFRkSEpwYm1jc0lDZFRkSEpwYm1jbkxDQm1kVzVqZEdsdmJpaHBkR1Z5WVhSbFpDbDdYRzVjZENBZ2RHaHBjeTVmZENBOUlGTjBjbWx1WnlocGRHVnlZWFJsWkNrN0lDOHZJSFJoY21kbGRGeHVYSFFnSUhSb2FYTXVYMmtnUFNBd095QWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QnVaWGgwSUdsdVpHVjRYRzVjZEM4dklESXhMakV1TlM0eUxqRWdKVk4wY21sdVowbDBaWEpoZEc5eVVISnZkRzkwZVhCbEpTNXVaWGgwS0NsY2JseDBmU3dnWm5WdVkzUnBiMjRvS1h0Y2JseDBJQ0IyWVhJZ1R5QWdJQ0FnUFNCMGFHbHpMbDkwWEc1Y2RDQWdJQ0FzSUdsdVpHVjRJRDBnZEdocGN5NWZhVnh1WEhRZ0lDQWdMQ0J3YjJsdWREdGNibHgwSUNCcFppaHBibVJsZUNBK1BTQlBMbXhsYm1kMGFDbHlaWFIxY200Z2UzWmhiSFZsT2lCMWJtUmxabWx1WldRc0lHUnZibVU2SUhSeWRXVjlPMXh1WEhRZ0lIQnZhVzUwSUQwZ0pHRjBLRThzSUdsdVpHVjRLVHRjYmx4MElDQjBhR2x6TGw5cElDczlJSEJ2YVc1MExteGxibWQwYUR0Y2JseDBJQ0J5WlhSMWNtNGdlM1poYkhWbE9pQndiMmx1ZEN3Z1pHOXVaVG9nWm1Gc2MyVjlPMXh1WEhSOUtUdGNibHh1THlvcUtpOGdmU3hjYmk4cUlESTJJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwSUh0Y2JseHVYSFIyWVhJZ2RHOUpiblJsWjJWeUlEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWd5TnlsY2JseDBJQ0FzSUdSbFptbHVaV1FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NamdwTzF4dVhIUXZMeUIwY25WbElDQXRQaUJUZEhKcGJtY2pZWFJjYmx4MEx5OGdabUZzYzJVZ0xUNGdVM1J5YVc1bkkyTnZaR1ZRYjJsdWRFRjBYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvVkU5ZlUxUlNTVTVIS1h0Y2JseDBJQ0J5WlhSMWNtNGdablZ1WTNScGIyNG9kR2hoZEN3Z2NHOXpLWHRjYmx4MElDQWdJSFpoY2lCeklEMGdVM1J5YVc1bktHUmxabWx1WldRb2RHaGhkQ2twWEc1Y2RDQWdJQ0FnSUN3Z2FTQTlJSFJ2U1c1MFpXZGxjaWh3YjNNcFhHNWNkQ0FnSUNBZ0lDd2diQ0E5SUhNdWJHVnVaM1JvWEc1Y2RDQWdJQ0FnSUN3Z1lTd2dZanRjYmx4MElDQWdJR2xtS0drZ1BDQXdJSHg4SUdrZ1BqMGdiQ2x5WlhSMWNtNGdWRTlmVTFSU1NVNUhJRDhnSnljZ09pQjFibVJsWm1sdVpXUTdYRzVjZENBZ0lDQmhJRDBnY3k1amFHRnlRMjlrWlVGMEtHa3BPMXh1WEhRZ0lDQWdjbVYwZFhKdUlHRWdQQ0F3ZUdRNE1EQWdmSHdnWVNBK0lEQjRaR0ptWmlCOGZDQnBJQ3NnTVNBOVBUMGdiQ0I4ZkNBb1lpQTlJSE11WTJoaGNrTnZaR1ZCZENocElDc2dNU2twSUR3Z01IaGtZekF3SUh4OElHSWdQaUF3ZUdSbVptWmNibHgwSUNBZ0lDQWdQeUJVVDE5VFZGSkpUa2NnUHlCekxtTm9ZWEpCZENocEtTQTZJR0ZjYmx4MElDQWdJQ0FnT2lCVVQxOVRWRkpKVGtjZ1B5QnpMbk5zYVdObEtHa3NJR2tnS3lBeUtTQTZJQ2hoSUMwZ01IaGtPREF3SUR3OElERXdLU0FySUNoaUlDMGdNSGhrWXpBd0tTQXJJREI0TVRBd01EQTdYRzVjZENBZ2ZUdGNibHgwZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURJM0lDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNcElIdGNibHh1WEhRdkx5QTNMakV1TkNCVWIwbHVkR1ZuWlhKY2JseDBkbUZ5SUdObGFXd2dJRDBnVFdGMGFDNWpaV2xzWEc1Y2RDQWdMQ0JtYkc5dmNpQTlJRTFoZEdndVpteHZiM0k3WEc1Y2RHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1WEhRZ0lISmxkSFZ5YmlCcGMwNWhUaWhwZENBOUlDdHBkQ2tnUHlBd0lEb2dLR2wwSUQ0Z01DQS9JR1pzYjI5eUlEb2dZMlZwYkNrb2FYUXBPMXh1WEhSOU8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ01qZ2dLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5a2dlMXh1WEc1Y2RDOHZJRGN1TWk0eElGSmxjWFZwY21WUFltcGxZM1JEYjJWeVkybGliR1VvWVhKbmRXMWxiblFwWEc1Y2RHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1WEhRZ0lHbG1LR2wwSUQwOUlIVnVaR1ZtYVc1bFpDbDBhSEp2ZHlCVWVYQmxSWEp5YjNJb1hDSkRZVzRuZENCallXeHNJRzFsZEdodlpDQnZiaUFnWENJZ0t5QnBkQ2s3WEc1Y2RDQWdjbVYwZFhKdUlHbDBPMXh1WEhSOU8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ01qa2dLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5d2dYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWtnZTF4dVhHNWNkQ2QxYzJVZ2MzUnlhV04wSnp0Y2JseDBkbUZ5SUV4SlFsSkJVbGtnSUNBZ0lDQWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnek1DbGNibHgwSUNBc0lDUmxlSEJ2Y25RZ0lDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzJLVnh1WEhRZ0lDd2djbVZrWldacGJtVWdJQ0FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE14S1Z4dVhIUWdJQ3dnYUdsa1pTQWdJQ0FnSUNBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RFeEtWeHVYSFFnSUN3Z2FHRnpJQ0FnSUNBZ0lDQWdJQ0FnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktETXlLVnh1WEhRZ0lDd2dTWFJsY21GMGIzSnpJQ0FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE16S1Z4dVhIUWdJQ3dnSkdsMFpYSkRjbVZoZEdVZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RNMEtWeHVYSFFnSUN3Z2MyVjBWRzlUZEhKcGJtZFVZV2NnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktEVXdLVnh1WEhRZ0lDd2daMlYwVUhKdmRHOTBlWEJsVDJZZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFV5S1Z4dVhIUWdJQ3dnU1ZSRlVrRlVUMUlnSUNBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RVeEtTZ25hWFJsY21GMGIzSW5LVnh1WEhRZ0lDd2dRbFZIUjFrZ0lDQWdJQ0FnSUNBZ1BTQWhLRnRkTG10bGVYTWdKaVlnSjI1bGVIUW5JR2x1SUZ0ZExtdGxlWE1vS1NrZ0x5OGdVMkZtWVhKcElHaGhjeUJpZFdkbmVTQnBkR1Z5WVhSdmNuTWdkeTl2SUdCdVpYaDBZRnh1WEhRZ0lDd2dSa1pmU1ZSRlVrRlVUMUlnSUNBZ1BTQW5RRUJwZEdWeVlYUnZjaWRjYmx4MElDQXNJRXRGV1ZNZ0lDQWdJQ0FnSUNBZ0lEMGdKMnRsZVhNblhHNWNkQ0FnTENCV1FVeFZSVk1nSUNBZ0lDQWdJQ0E5SUNkMllXeDFaWE1uTzF4dVhIUmNibHgwZG1GeUlISmxkSFZ5YmxSb2FYTWdQU0JtZFc1amRHbHZiaWdwZXlCeVpYUjFjbTRnZEdocGN6c2dmVHRjYmx4MFhHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9RbUZ6WlN3Z1RrRk5SU3dnUTI5dWMzUnlkV04wYjNJc0lHNWxlSFFzSUVSRlJrRlZURlFzSUVsVFgxTkZWQ3dnUms5U1EwVkVLWHRjYmx4MElDQWthWFJsY2tOeVpXRjBaU2hEYjI1emRISjFZM1J2Y2l3Z1RrRk5SU3dnYm1WNGRDazdYRzVjZENBZ2RtRnlJR2RsZEUxbGRHaHZaQ0E5SUdaMWJtTjBhVzl1S0d0cGJtUXBlMXh1WEhRZ0lDQWdhV1lvSVVKVlIwZFpJQ1ltSUd0cGJtUWdhVzRnY0hKdmRHOHBjbVYwZFhKdUlIQnliM1J2VzJ0cGJtUmRPMXh1WEhRZ0lDQWdjM2RwZEdOb0tHdHBibVFwZTF4dVhIUWdJQ0FnSUNCallYTmxJRXRGV1ZNNklISmxkSFZ5YmlCbWRXNWpkR2x2YmlCclpYbHpLQ2w3SUhKbGRIVnliaUJ1WlhjZ1EyOXVjM1J5ZFdOMGIzSW9kR2hwY3l3Z2EybHVaQ2s3SUgwN1hHNWNkQ0FnSUNBZ0lHTmhjMlVnVmtGTVZVVlRPaUJ5WlhSMWNtNGdablZ1WTNScGIyNGdkbUZzZFdWektDbDdJSEpsZEhWeWJpQnVaWGNnUTI5dWMzUnlkV04wYjNJb2RHaHBjeXdnYTJsdVpDazdJSDA3WEc1Y2RDQWdJQ0I5SUhKbGRIVnliaUJtZFc1amRHbHZiaUJsYm5SeWFXVnpLQ2w3SUhKbGRIVnliaUJ1WlhjZ1EyOXVjM1J5ZFdOMGIzSW9kR2hwY3l3Z2EybHVaQ2s3SUgwN1hHNWNkQ0FnZlR0Y2JseDBJQ0IyWVhJZ1ZFRkhJQ0FnSUNBZ0lDQTlJRTVCVFVVZ0t5QW5JRWwwWlhKaGRHOXlKMXh1WEhRZ0lDQWdMQ0JFUlVaZlZrRk1WVVZUSUQwZ1JFVkdRVlZNVkNBOVBTQldRVXhWUlZOY2JseDBJQ0FnSUN3Z1ZrRk1WVVZUWDBKVlJ5QTlJR1poYkhObFhHNWNkQ0FnSUNBc0lIQnliM1J2SUNBZ0lDQWdQU0JDWVhObExuQnliM1J2ZEhsd1pWeHVYSFFnSUNBZ0xDQWtibUYwYVhabElDQWdJRDBnY0hKdmRHOWJTVlJGVWtGVVQxSmRJSHg4SUhCeWIzUnZXMFpHWDBsVVJWSkJWRTlTWFNCOGZDQkVSVVpCVlV4VUlDWW1JSEJ5YjNSdlcwUkZSa0ZWVEZSZFhHNWNkQ0FnSUNBc0lDUmtaV1poZFd4MElDQWdQU0FrYm1GMGFYWmxJSHg4SUdkbGRFMWxkR2h2WkNoRVJVWkJWVXhVS1Z4dVhIUWdJQ0FnTENBa1pXNTBjbWxsY3lBZ0lEMGdSRVZHUVZWTVZDQS9JQ0ZFUlVaZlZrRk1WVVZUSUQ4Z0pHUmxabUYxYkhRZ09pQm5aWFJOWlhSb2IyUW9KMlZ1ZEhKcFpYTW5LU0E2SUhWdVpHVm1hVzVsWkZ4dVhIUWdJQ0FnTENBa1lXNTVUbUYwYVhabElEMGdUa0ZOUlNBOVBTQW5RWEp5WVhrbklEOGdjSEp2ZEc4dVpXNTBjbWxsY3lCOGZDQWtibUYwYVhabElEb2dKRzVoZEdsMlpWeHVYSFFnSUNBZ0xDQnRaWFJvYjJSekxDQnJaWGtzSUVsMFpYSmhkRzl5VUhKdmRHOTBlWEJsTzF4dVhIUWdJQzh2SUVacGVDQnVZWFJwZG1WY2JseDBJQ0JwWmlna1lXNTVUbUYwYVhabEtYdGNibHgwSUNBZ0lFbDBaWEpoZEc5eVVISnZkRzkwZVhCbElEMGdaMlYwVUhKdmRHOTBlWEJsVDJZb0pHRnVlVTVoZEdsMlpTNWpZV3hzS0c1bGR5QkNZWE5sS1NrN1hHNWNkQ0FnSUNCcFppaEpkR1Z5WVhSdmNsQnliM1J2ZEhsd1pTQWhQVDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaU2w3WEc1Y2RDQWdJQ0FnSUM4dklGTmxkQ0JBUUhSdlUzUnlhVzVuVkdGbklIUnZJRzVoZEdsMlpTQnBkR1Z5WVhSdmNuTmNibHgwSUNBZ0lDQWdjMlYwVkc5VGRISnBibWRVWVdjb1NYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVc0lGUkJSeXdnZEhKMVpTazdYRzVjZENBZ0lDQWdJQzh2SUdacGVDQm1iM0lnYzI5dFpTQnZiR1FnWlc1bmFXNWxjMXh1WEhRZ0lDQWdJQ0JwWmlnaFRFbENVa0ZTV1NBbUppQWhhR0Z6S0VsMFpYSmhkRzl5VUhKdmRHOTBlWEJsTENCSlZFVlNRVlJQVWlrcGFHbGtaU2hKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU3dnU1ZSRlVrRlVUMUlzSUhKbGRIVnlibFJvYVhNcE8xeHVYSFFnSUNBZ2ZWeHVYSFFnSUgxY2JseDBJQ0F2THlCbWFYZ2dRWEp5WVhramUzWmhiSFZsY3l3Z1FFQnBkR1Z5WVhSdmNuMHVibUZ0WlNCcGJpQldPQ0F2SUVaR1hHNWNkQ0FnYVdZb1JFVkdYMVpCVEZWRlV5QW1KaUFrYm1GMGFYWmxJQ1ltSUNSdVlYUnBkbVV1Ym1GdFpTQWhQVDBnVmtGTVZVVlRLWHRjYmx4MElDQWdJRlpCVEZWRlUxOUNWVWNnUFNCMGNuVmxPMXh1WEhRZ0lDQWdKR1JsWm1GMWJIUWdQU0JtZFc1amRHbHZiaUIyWVd4MVpYTW9LWHNnY21WMGRYSnVJQ1J1WVhScGRtVXVZMkZzYkNoMGFHbHpLVHNnZlR0Y2JseDBJQ0I5WEc1Y2RDQWdMeThnUkdWbWFXNWxJR2wwWlhKaGRHOXlYRzVjZENBZ2FXWW9LQ0ZNU1VKU1FWSlpJSHg4SUVaUFVrTkZSQ2tnSmlZZ0tFSlZSMGRaSUh4OElGWkJURlZGVTE5Q1ZVY2dmSHdnSVhCeWIzUnZXMGxVUlZKQlZFOVNYU2twZTF4dVhIUWdJQ0FnYUdsa1pTaHdjbTkwYnl3Z1NWUkZVa0ZVVDFJc0lDUmtaV1poZFd4MEtUdGNibHgwSUNCOVhHNWNkQ0FnTHk4Z1VHeDFaeUJtYjNJZ2JHbGljbUZ5ZVZ4dVhIUWdJRWwwWlhKaGRHOXljMXRPUVUxRlhTQTlJQ1JrWldaaGRXeDBPMXh1WEhRZ0lFbDBaWEpoZEc5eWMxdFVRVWRkSUNBOUlISmxkSFZ5YmxSb2FYTTdYRzVjZENBZ2FXWW9SRVZHUVZWTVZDbDdYRzVjZENBZ0lDQnRaWFJvYjJSeklEMGdlMXh1WEhRZ0lDQWdJQ0IyWVd4MVpYTTZJQ0JFUlVaZlZrRk1WVVZUSUQ4Z0pHUmxabUYxYkhRZ09pQm5aWFJOWlhSb2IyUW9Wa0ZNVlVWVEtTeGNibHgwSUNBZ0lDQWdhMlY1Y3pvZ0lDQWdTVk5mVTBWVUlDQWdJQ0EvSUNSa1pXWmhkV3gwSURvZ1oyVjBUV1YwYUc5a0tFdEZXVk1wTEZ4dVhIUWdJQ0FnSUNCbGJuUnlhV1Z6T2lBa1pXNTBjbWxsYzF4dVhIUWdJQ0FnZlR0Y2JseDBJQ0FnSUdsbUtFWlBVa05GUkNsbWIzSW9hMlY1SUdsdUlHMWxkR2h2WkhNcGUxeHVYSFFnSUNBZ0lDQnBaaWdoS0d0bGVTQnBiaUJ3Y205MGJ5a3BjbVZrWldacGJtVW9jSEp2ZEc4c0lHdGxlU3dnYldWMGFHOWtjMXRyWlhsZEtUdGNibHgwSUNBZ0lIMGdaV3h6WlNBa1pYaHdiM0owS0NSbGVIQnZjblF1VUNBcklDUmxlSEJ2Y25RdVJpQXFJQ2hDVlVkSFdTQjhmQ0JXUVV4VlJWTmZRbFZIS1N3Z1RrRk5SU3dnYldWMGFHOWtjeWs3WEc1Y2RDQWdmVnh1WEhRZ0lISmxkSFZ5YmlCdFpYUm9iMlJ6TzF4dVhIUjlPMXh1WEc0dktpb3FMeUI5TEZ4dUx5b2dNekFnS2k5Y2JpOHFLaW92SUdaMWJtTjBhVzl1S0cxdlpIVnNaU3dnWlhod2IzSjBjeWtnZTF4dVhHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdkSEoxWlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURNeElDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVEVwTzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTXpJZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3lrZ2UxeHVYRzVjZEhaaGNpQm9ZWE5QZDI1UWNtOXdaWEowZVNBOUlIdDlMbWhoYzA5M2JsQnliM0JsY25SNU8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwTENCclpYa3BlMXh1WEhRZ0lISmxkSFZ5YmlCb1lYTlBkMjVRY205d1pYSjBlUzVqWVd4c0tHbDBMQ0JyWlhrcE8xeHVYSFI5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTXpNZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3lrZ2UxeHVYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnZTMwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBek5DQXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLU0I3WEc1Y2JseDBKM1Z6WlNCemRISnBZM1FuTzF4dVhIUjJZWElnWTNKbFlYUmxJQ0FnSUNBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RNMUtWeHVYSFFnSUN3Z1pHVnpZM0pwY0hSdmNpQWdJQ0FnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktESXdLVnh1WEhRZ0lDd2djMlYwVkc5VGRISnBibWRVWVdjZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFV3S1Z4dVhIUWdJQ3dnU1hSbGNtRjBiM0pRY205MGIzUjVjR1VnUFNCN2ZUdGNibHgwWEc1Y2RDOHZJREkxTGpFdU1pNHhMakVnSlVsMFpYSmhkRzl5VUhKdmRHOTBlWEJsSlZ0QVFHbDBaWEpoZEc5eVhTZ3BYRzVjZEY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01URXBLRWwwWlhKaGRHOXlVSEp2ZEc5MGVYQmxMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RVeEtTZ25hWFJsY21GMGIzSW5LU3dnWm5WdVkzUnBiMjRvS1hzZ2NtVjBkWEp1SUhSb2FYTTdJSDBwTzF4dVhIUmNibHgwYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhEYjI1emRISjFZM1J2Y2l3Z1RrRk5SU3dnYm1WNGRDbDdYRzVjZENBZ1EyOXVjM1J5ZFdOMGIzSXVjSEp2ZEc5MGVYQmxJRDBnWTNKbFlYUmxLRWwwWlhKaGRHOXlVSEp2ZEc5MGVYQmxMQ0I3Ym1WNGREb2daR1Z6WTNKcGNIUnZjaWd4TENCdVpYaDBLWDBwTzF4dVhIUWdJSE5sZEZSdlUzUnlhVzVuVkdGbktFTnZibk4wY25WamRHOXlMQ0JPUVUxRklDc2dKeUJKZEdWeVlYUnZjaWNwTzF4dVhIUjlPMXh1WEc0dktpb3FMeUI5TEZ4dUx5b2dNelVnS2k5Y2JpOHFLaW92SUdaMWJtTjBhVzl1S0cxdlpIVnNaU3dnWlhod2IzSjBjeXdnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlrZ2UxeHVYRzVjZEM4dklERTVMakV1TWk0eUlDOGdNVFV1TWk0ekxqVWdUMkpxWldOMExtTnlaV0YwWlNoUElGc3NJRkJ5YjNCbGNuUnBaWE5kS1Z4dVhIUjJZWElnWVc1UFltcGxZM1FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLREV6S1Z4dVhIUWdJQ3dnWkZCeklDQWdJQ0FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE0yS1Z4dVhIUWdJQ3dnWlc1MWJVSjFaMHRsZVhNZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFE0S1Z4dVhIUWdJQ3dnU1VWZlVGSlBWRThnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFExS1NnblNVVmZVRkpQVkU4bktWeHVYSFFnSUN3Z1JXMXdkSGtnSUNBZ0lDQWdQU0JtZFc1amRHbHZiaWdwZXlBdktpQmxiWEIwZVNBcUx5QjlYRzVjZENBZ0xDQlFVazlVVDFSWlVFVWdJQ0E5SUNkd2NtOTBiM1I1Y0dVbk8xeHVYSFJjYmx4MEx5OGdRM0psWVhSbElHOWlhbVZqZENCM2FYUm9JR1poYTJVZ1lHNTFiR3hnSUhCeWIzUnZkSGx3WlRvZ2RYTmxJR2xtY21GdFpTQlBZbXBsWTNRZ2QybDBhQ0JqYkdWaGNtVmtJSEJ5YjNSdmRIbHdaVnh1WEhSMllYSWdZM0psWVhSbFJHbGpkQ0E5SUdaMWJtTjBhVzl1S0NsN1hHNWNkQ0FnTHk4Z1ZHaHlZWE5vTENCM1lYTjBaU0JoYm1RZ2MyOWtiMjE1T2lCSlJTQkhReUJpZFdkY2JseDBJQ0IyWVhJZ2FXWnlZVzFsSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3hPQ2tvSjJsbWNtRnRaU2NwWEc1Y2RDQWdJQ0FzSUdrZ0lDQWdJQ0E5SUdWdWRXMUNkV2RMWlhsekxteGxibWQwYUZ4dVhIUWdJQ0FnTENCc2RDQWdJQ0FnUFNBblBDZGNibHgwSUNBZ0lDd2daM1FnSUNBZ0lEMGdKejRuWEc1Y2RDQWdJQ0FzSUdsbWNtRnRaVVJ2WTNWdFpXNTBPMXh1WEhRZ0lHbG1jbUZ0WlM1emRIbHNaUzVrYVhOd2JHRjVJRDBnSjI1dmJtVW5PMXh1WEhRZ0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9ORGtwTG1Gd2NHVnVaRU5vYVd4a0tHbG1jbUZ0WlNrN1hHNWNkQ0FnYVdaeVlXMWxMbk55WXlBOUlDZHFZWFpoYzJOeWFYQjBPaWM3SUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFd4cGJtVWdibTh0YzJOeWFYQjBMWFZ5YkZ4dVhIUWdJQzh2SUdOeVpXRjBaVVJwWTNRZ1BTQnBabkpoYldVdVkyOXVkR1Z1ZEZkcGJtUnZkeTVQWW1wbFkzUTdYRzVjZENBZ0x5OGdhSFJ0YkM1eVpXMXZkbVZEYUdsc1pDaHBabkpoYldVcE8xeHVYSFFnSUdsbWNtRnRaVVJ2WTNWdFpXNTBJRDBnYVdaeVlXMWxMbU52Ym5SbGJuUlhhVzVrYjNjdVpHOWpkVzFsYm5RN1hHNWNkQ0FnYVdaeVlXMWxSRzlqZFcxbGJuUXViM0JsYmlncE8xeHVYSFFnSUdsbWNtRnRaVVJ2WTNWdFpXNTBMbmR5YVhSbEtHeDBJQ3NnSjNOamNtbHdkQ2NnS3lCbmRDQXJJQ2RrYjJOMWJXVnVkQzVHUFU5aWFtVmpkQ2NnS3lCc2RDQXJJQ2N2YzJOeWFYQjBKeUFySUdkMEtUdGNibHgwSUNCcFpuSmhiV1ZFYjJOMWJXVnVkQzVqYkc5elpTZ3BPMXh1WEhRZ0lHTnlaV0YwWlVScFkzUWdQU0JwWm5KaGJXVkViMk4xYldWdWRDNUdPMXh1WEhRZ0lIZG9hV3hsS0drdExTbGtaV3hsZEdVZ1kzSmxZWFJsUkdsamRGdFFVazlVVDFSWlVFVmRXMlZ1ZFcxQ2RXZExaWGx6VzJsZFhUdGNibHgwSUNCeVpYUjFjbTRnWTNKbFlYUmxSR2xqZENncE8xeHVYSFI5TzF4dVhIUmNibHgwYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JQWW1wbFkzUXVZM0psWVhSbElIeDhJR1oxYm1OMGFXOXVJR055WldGMFpTaFBMQ0JRY205d1pYSjBhV1Z6S1h0Y2JseDBJQ0IyWVhJZ2NtVnpkV3gwTzF4dVhIUWdJR2xtS0U4Z0lUMDlJRzUxYkd3cGUxeHVYSFFnSUNBZ1JXMXdkSGxiVUZKUFZFOVVXVkJGWFNBOUlHRnVUMkpxWldOMEtFOHBPMXh1WEhRZ0lDQWdjbVZ6ZFd4MElEMGdibVYzSUVWdGNIUjVPMXh1WEhRZ0lDQWdSVzF3ZEhsYlVGSlBWRTlVV1ZCRlhTQTlJRzUxYkd3N1hHNWNkQ0FnSUNBdkx5QmhaR1FnWENKZlgzQnliM1J2WDE5Y0lpQm1iM0lnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUlIQnZiSGxtYVd4c1hHNWNkQ0FnSUNCeVpYTjFiSFJiU1VWZlVGSlBWRTlkSUQwZ1R6dGNibHgwSUNCOUlHVnNjMlVnY21WemRXeDBJRDBnWTNKbFlYUmxSR2xqZENncE8xeHVYSFFnSUhKbGRIVnliaUJRY205d1pYSjBhV1Z6SUQwOVBTQjFibVJsWm1sdVpXUWdQeUJ5WlhOMWJIUWdPaUJrVUhNb2NtVnpkV3gwTENCUWNtOXdaWEowYVdWektUdGNibHgwZlR0Y2JseHVYRzR2S2lvcUx5QjlMRnh1THlvZ016WWdLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5d2dYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWtnZTF4dVhHNWNkSFpoY2lCa1VDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVElwWEc1Y2RDQWdMQ0JoYms5aWFtVmpkQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01UTXBYRzVjZENBZ0xDQm5aWFJMWlhseklDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTXpjcE8xeHVYSFJjYmx4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktERTJLU0EvSUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGFXVnpJRG9nWm5WdVkzUnBiMjRnWkdWbWFXNWxVSEp2Y0dWeWRHbGxjeWhQTENCUWNtOXdaWEowYVdWektYdGNibHgwSUNCaGJrOWlhbVZqZENoUEtUdGNibHgwSUNCMllYSWdhMlY1Y3lBZ0lEMGdaMlYwUzJWNWN5aFFjbTl3WlhKMGFXVnpLVnh1WEhRZ0lDQWdMQ0JzWlc1bmRHZ2dQU0JyWlhsekxteGxibWQwYUZ4dVhIUWdJQ0FnTENCcElEMGdNRnh1WEhRZ0lDQWdMQ0JRTzF4dVhIUWdJSGRvYVd4bEtHeGxibWQwYUNBK0lHa3BaRkF1WmloUExDQlFJRDBnYTJWNWMxdHBLeXRkTENCUWNtOXdaWEowYVdWelcxQmRLVHRjYmx4MElDQnlaWFIxY200Z1R6dGNibHgwZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURNM0lDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUXZMeUF4T1M0eExqSXVNVFFnTHlBeE5TNHlMak11TVRRZ1QySnFaV04wTG10bGVYTW9UeWxjYmx4MGRtRnlJQ1JyWlhseklDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3pPQ2xjYmx4MElDQXNJR1Z1ZFcxQ2RXZExaWGx6SUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzBPQ2s3WEc1Y2RGeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRTlpYW1WamRDNXJaWGx6SUh4OElHWjFibU4wYVc5dUlHdGxlWE1vVHlsN1hHNWNkQ0FnY21WMGRYSnVJQ1JyWlhsektFOHNJR1Z1ZFcxQ2RXZExaWGx6S1R0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRE00SUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSMllYSWdhR0Z6SUNBZ0lDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3pNaWxjYmx4MElDQXNJSFJ2U1U5aWFtVmpkQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NemtwWEc1Y2RDQWdMQ0JoY25KaGVVbHVaR1Y0VDJZZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFF5S1NobVlXeHpaU2xjYmx4MElDQXNJRWxGWDFCU1QxUlBJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9ORFVwS0NkSlJWOVFVazlVVHljcE8xeHVYSFJjYmx4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlodlltcGxZM1FzSUc1aGJXVnpLWHRjYmx4MElDQjJZWElnVHlBZ0lDQWdJRDBnZEc5SlQySnFaV04wS0c5aWFtVmpkQ2xjYmx4MElDQWdJQ3dnYVNBZ0lDQWdJRDBnTUZ4dVhIUWdJQ0FnTENCeVpYTjFiSFFnUFNCYlhWeHVYSFFnSUNBZ0xDQnJaWGs3WEc1Y2RDQWdabTl5S0d0bGVTQnBiaUJQS1dsbUtHdGxlU0FoUFNCSlJWOVFVazlVVHlsb1lYTW9UeXdnYTJWNUtTQW1KaUJ5WlhOMWJIUXVjSFZ6YUNoclpYa3BPMXh1WEhRZ0lDOHZJRVJ2YmlkMElHVnVkVzBnWW5WbklDWWdhR2xrWkdWdUlHdGxlWE5jYmx4MElDQjNhR2xzWlNodVlXMWxjeTVzWlc1bmRHZ2dQaUJwS1dsbUtHaGhjeWhQTENCclpYa2dQU0J1WVcxbGMxdHBLeXRkS1NsN1hHNWNkQ0FnSUNCK1lYSnlZWGxKYm1SbGVFOW1LSEpsYzNWc2RDd2dhMlY1S1NCOGZDQnlaWE4xYkhRdWNIVnphQ2hyWlhrcE8xeHVYSFFnSUgxY2JseDBJQ0J5WlhSMWNtNGdjbVZ6ZFd4ME8xeHVYSFI5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTXprZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RDOHZJSFJ2SUdsdVpHVjRaV1FnYjJKcVpXTjBMQ0IwYjA5aWFtVmpkQ0IzYVhSb0lHWmhiR3hpWVdOcklHWnZjaUJ1YjI0dFlYSnlZWGt0YkdsclpTQkZVek1nYzNSeWFXNW5jMXh1WEhSMllYSWdTVTlpYW1WamRDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTkRBcFhHNWNkQ0FnTENCa1pXWnBibVZrSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3lPQ2s3WEc1Y2RHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1WEhRZ0lISmxkSFZ5YmlCSlQySnFaV04wS0dSbFptbHVaV1FvYVhRcEtUdGNibHgwZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURRd0lDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUXZMeUJtWVd4c1ltRmpheUJtYjNJZ2JtOXVMV0Z5Y21GNUxXeHBhMlVnUlZNeklHRnVaQ0J1YjI0dFpXNTFiV1Z5WVdKc1pTQnZiR1FnVmpnZ2MzUnlhVzVuYzF4dVhIUjJZWElnWTI5bUlEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcwTVNrN1hHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdUMkpxWldOMEtDZDZKeWt1Y0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVb01Da2dQeUJQWW1wbFkzUWdPaUJtZFc1amRHbHZiaWhwZENsN1hHNWNkQ0FnY21WMGRYSnVJR052WmlocGRDa2dQVDBnSjFOMGNtbHVaeWNnUHlCcGRDNXpjR3hwZENnbkp5a2dPaUJQWW1wbFkzUW9hWFFwTzF4dVhIUjlPMXh1WEc0dktpb3FMeUI5TEZ4dUx5b2dOREVnS2k5Y2JpOHFLaW92SUdaMWJtTjBhVzl1S0cxdlpIVnNaU3dnWlhod2IzSjBjeWtnZTF4dVhHNWNkSFpoY2lCMGIxTjBjbWx1WnlBOUlIdDlMblJ2VTNSeWFXNW5PMXh1WEhSY2JseDBiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHBkQ2w3WEc1Y2RDQWdjbVYwZFhKdUlIUnZVM1J5YVc1bkxtTmhiR3dvYVhRcExuTnNhV05sS0Rnc0lDMHhLVHRjYmx4MGZUdGNibHh1THlvcUtpOGdmU3hjYmk4cUlEUXlJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwSUh0Y2JseHVYSFF2THlCbVlXeHpaU0F0UGlCQmNuSmhlU05wYm1SbGVFOW1YRzVjZEM4dklIUnlkV1VnSUMwK0lFRnljbUY1STJsdVkyeDFaR1Z6WEc1Y2RIWmhjaUIwYjBsUFltcGxZM1FnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktETTVLVnh1WEhRZ0lDd2dkRzlNWlc1bmRHZ2dJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnME15bGNibHgwSUNBc0lIUnZTVzVrWlhnZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTkRRcE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLRWxUWDBsT1EweFZSRVZUS1h0Y2JseDBJQ0J5WlhSMWNtNGdablZ1WTNScGIyNG9KSFJvYVhNc0lHVnNMQ0JtY205dFNXNWtaWGdwZTF4dVhIUWdJQ0FnZG1GeUlFOGdJQ0FnSUNBOUlIUnZTVTlpYW1WamRDZ2tkR2hwY3lsY2JseDBJQ0FnSUNBZ0xDQnNaVzVuZEdnZ1BTQjBiMHhsYm1kMGFDaFBMbXhsYm1kMGFDbGNibHgwSUNBZ0lDQWdMQ0JwYm1SbGVDQWdQU0IwYjBsdVpHVjRLR1p5YjIxSmJtUmxlQ3dnYkdWdVozUm9LVnh1WEhRZ0lDQWdJQ0FzSUhaaGJIVmxPMXh1WEhRZ0lDQWdMeThnUVhKeVlYa2phVzVqYkhWa1pYTWdkWE5sY3lCVFlXMWxWbUZzZFdWYVpYSnZJR1Z4ZFdGc2FYUjVJR0ZzWjI5eWFYUm9iVnh1WEhRZ0lDQWdhV1lvU1ZOZlNVNURURlZFUlZNZ0ppWWdaV3dnSVQwZ1pXd3BkMmhwYkdVb2JHVnVaM1JvSUQ0Z2FXNWtaWGdwZTF4dVhIUWdJQ0FnSUNCMllXeDFaU0E5SUU5YmFXNWtaWGdySzEwN1hHNWNkQ0FnSUNBZ0lHbG1LSFpoYkhWbElDRTlJSFpoYkhWbEtYSmxkSFZ5YmlCMGNuVmxPMXh1WEhRZ0lDQWdMeThnUVhKeVlYa2pkRzlKYm1SbGVDQnBaMjV2Y21WeklHaHZiR1Z6TENCQmNuSmhlU05wYm1Oc2RXUmxjeUF0SUc1dmRGeHVYSFFnSUNBZ2ZTQmxiSE5sSUdadmNpZzdiR1Z1WjNSb0lENGdhVzVrWlhnN0lHbHVaR1Y0S3lzcGFXWW9TVk5mU1U1RFRGVkVSVk1nZkh3Z2FXNWtaWGdnYVc0Z1R5bDdYRzVjZENBZ0lDQWdJR2xtS0U5YmFXNWtaWGhkSUQwOVBTQmxiQ2x5WlhSMWNtNGdTVk5mU1U1RFRGVkVSVk1nZkh3Z2FXNWtaWGdnZkh3Z01EdGNibHgwSUNBZ0lIMGdjbVYwZFhKdUlDRkpVMTlKVGtOTVZVUkZVeUFtSmlBdE1UdGNibHgwSUNCOU8xeHVYSFI5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTkRNZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RDOHZJRGN1TVM0eE5TQlViMHhsYm1kMGFGeHVYSFIyWVhJZ2RHOUpiblJsWjJWeUlEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWd5TnlsY2JseDBJQ0FzSUcxcGJpQWdJQ0FnSUNBOUlFMWhkR2d1YldsdU8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwS1h0Y2JseDBJQ0J5WlhSMWNtNGdhWFFnUGlBd0lEOGdiV2x1S0hSdlNXNTBaV2RsY2locGRDa3NJREI0TVdabVptWm1abVptWm1abVptWXBJRG9nTURzZ0x5OGdjRzkzS0RJc0lEVXpLU0F0SURFZ1BUMGdPVEF3TnpFNU9USTFORGMwTURrNU1WeHVYSFI5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTkRRZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RIWmhjaUIwYjBsdWRHVm5aWElnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktESTNLVnh1WEhRZ0lDd2diV0Y0SUNBZ0lDQWdJRDBnVFdGMGFDNXRZWGhjYmx4MElDQXNJRzFwYmlBZ0lDQWdJQ0E5SUUxaGRHZ3ViV2x1TzF4dVhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHbHVaR1Y0TENCc1pXNW5kR2dwZTF4dVhIUWdJR2x1WkdWNElEMGdkRzlKYm5SbFoyVnlLR2x1WkdWNEtUdGNibHgwSUNCeVpYUjFjbTRnYVc1a1pYZ2dQQ0F3SUQ4Z2JXRjRLR2x1WkdWNElDc2diR1Z1WjNSb0xDQXdLU0E2SUcxcGJpaHBibVJsZUN3Z2JHVnVaM1JvS1R0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRFExSUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSMllYSWdjMmhoY21Wa0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcwTmlrb0oydGxlWE1uS1Z4dVhIUWdJQ3dnZFdsa0lDQWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnME55azdYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvYTJWNUtYdGNibHgwSUNCeVpYUjFjbTRnYzJoaGNtVmtXMnRsZVYwZ2ZId2dLSE5vWVhKbFpGdHJaWGxkSUQwZ2RXbGtLR3RsZVNrcE8xeHVYSFI5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTkRZZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RIWmhjaUJuYkc5aVlXd2dQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RjcFhHNWNkQ0FnTENCVFNFRlNSVVFnUFNBblgxOWpiM0psTFdwelgzTm9ZWEpsWkY5ZkoxeHVYSFFnSUN3Z2MzUnZjbVVnSUQwZ1oyeHZZbUZzVzFOSVFWSkZSRjBnZkh3Z0tHZHNiMkpoYkZ0VFNFRlNSVVJkSUQwZ2UzMHBPMXh1WEhSdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0d0bGVTbDdYRzVjZENBZ2NtVjBkWEp1SUhOMGIzSmxXMnRsZVYwZ2ZId2dLSE4wYjNKbFcydGxlVjBnUFNCN2ZTazdYRzVjZEgwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBME55QXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SektTQjdYRzVjYmx4MGRtRnlJR2xrSUQwZ01GeHVYSFFnSUN3Z2NIZ2dQU0JOWVhSb0xuSmhibVJ2YlNncE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR3RsZVNsN1hHNWNkQ0FnY21WMGRYSnVJQ2RUZVcxaWIyd29KeTVqYjI1allYUW9hMlY1SUQwOVBTQjFibVJsWm1sdVpXUWdQeUFuSnlBNklHdGxlU3dnSnlsZkp5d2dLQ3NyYVdRZ0t5QndlQ2t1ZEc5VGRISnBibWNvTXpZcEtUdGNibHgwZlR0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURRNElDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNcElIdGNibHh1WEhRdkx5QkpSU0E0TFNCa2IyNG5kQ0JsYm5WdElHSjFaeUJyWlhselhHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdLRnh1WEhRZ0lDZGpiMjV6ZEhKMVkzUnZjaXhvWVhOUGQyNVFjbTl3WlhKMGVTeHBjMUJ5YjNSdmRIbHdaVTltTEhCeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bExIUnZURzlqWVd4bFUzUnlhVzVuTEhSdlUzUnlhVzVuTEhaaGJIVmxUMlluWEc1Y2RDa3VjM0JzYVhRb0p5d25LVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRFE1SUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b055a3VaRzlqZFcxbGJuUWdKaVlnWkc5amRXMWxiblF1Wkc5amRXMWxiblJGYkdWdFpXNTBPMXh1WEc0dktpb3FMeUI5TEZ4dUx5b2dOVEFnS2k5Y2JpOHFLaW92SUdaMWJtTjBhVzl1S0cxdlpIVnNaU3dnWlhod2IzSjBjeXdnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlrZ2UxeHVYRzVjZEhaaGNpQmtaV1lnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktERXlLUzVtWEc1Y2RDQWdMQ0JvWVhNZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE15S1Z4dVhIUWdJQ3dnVkVGSElEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcxTVNrb0ozUnZVM1J5YVc1blZHRm5KeWs3WEc1Y2RGeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwTENCMFlXY3NJSE4wWVhRcGUxeHVYSFFnSUdsbUtHbDBJQ1ltSUNGb1lYTW9hWFFnUFNCemRHRjBJRDhnYVhRZ09pQnBkQzV3Y205MGIzUjVjR1VzSUZSQlJ5a3BaR1ZtS0dsMExDQlVRVWNzSUh0amIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdVc0lIWmhiSFZsT2lCMFlXZDlLVHRjYmx4MGZUdGNibHh1THlvcUtpOGdmU3hjYmk4cUlEVXhJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwSUh0Y2JseHVYSFIyWVhJZ2MzUnZjbVVnSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTkRZcEtDZDNhM01uS1Z4dVhIUWdJQ3dnZFdsa0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9ORGNwWEc1Y2RDQWdMQ0JUZVcxaWIyd2dJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzNLUzVUZVcxaWIyeGNibHgwSUNBc0lGVlRSVjlUV1UxQ1Qwd2dQU0IwZVhCbGIyWWdVM2x0WW05c0lEMDlJQ2RtZFc1amRHbHZiaWM3WEc1Y2RGeHVYSFIyWVhJZ0pHVjRjRzl5ZEhNZ1BTQnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHNWhiV1VwZTF4dVhIUWdJSEpsZEhWeWJpQnpkRzl5WlZ0dVlXMWxYU0I4ZkNBb2MzUnZjbVZiYm1GdFpWMGdQVnh1WEhRZ0lDQWdWVk5GWDFOWlRVSlBUQ0FtSmlCVGVXMWliMnhiYm1GdFpWMGdmSHdnS0ZWVFJWOVRXVTFDVDB3Z1B5QlRlVzFpYjJ3Z09pQjFhV1FwS0NkVGVXMWliMnd1SnlBcklHNWhiV1VwS1R0Y2JseDBmVHRjYmx4MFhHNWNkQ1JsZUhCdmNuUnpMbk4wYjNKbElEMGdjM1J2Y21VN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBMU1pQXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLU0I3WEc1Y2JseDBMeThnTVRrdU1TNHlMamtnTHlBeE5TNHlMak11TWlCUFltcGxZM1F1WjJWMFVISnZkRzkwZVhCbFQyWW9UeWxjYmx4MGRtRnlJR2hoY3lBZ0lDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3pNaWxjYmx4MElDQXNJSFJ2VDJKcVpXTjBJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzFNeWxjYmx4MElDQXNJRWxGWDFCU1QxUlBJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzBOU2tvSjBsRlgxQlNUMVJQSnlsY2JseDBJQ0FzSUU5aWFtVmpkRkJ5YjNSdklEMGdUMkpxWldOMExuQnliM1J2ZEhsd1pUdGNibHgwWEc1Y2RHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1QySnFaV04wTG1kbGRGQnliM1J2ZEhsd1pVOW1JSHg4SUdaMWJtTjBhVzl1S0U4cGUxeHVYSFFnSUU4Z1BTQjBiMDlpYW1WamRDaFBLVHRjYmx4MElDQnBaaWhvWVhNb1R5d2dTVVZmVUZKUFZFOHBLWEpsZEhWeWJpQlBXMGxGWDFCU1QxUlBYVHRjYmx4MElDQnBaaWgwZVhCbGIyWWdUeTVqYjI1emRISjFZM1J2Y2lBOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUU4Z2FXNXpkR0Z1WTJWdlppQlBMbU52Ym5OMGNuVmpkRzl5S1h0Y2JseDBJQ0FnSUhKbGRIVnliaUJQTG1OdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pUdGNibHgwSUNCOUlISmxkSFZ5YmlCUElHbHVjM1JoYm1ObGIyWWdUMkpxWldOMElEOGdUMkpxWldOMFVISnZkRzhnT2lCdWRXeHNPMXh1WEhSOU8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ05UTWdLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5d2dYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWtnZTF4dVhHNWNkQzh2SURjdU1TNHhNeUJVYjA5aWFtVmpkQ2hoY21kMWJXVnVkQ2xjYmx4MGRtRnlJR1JsWm1sdVpXUWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RJNEtUdGNibHgwYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhwZENsN1hHNWNkQ0FnY21WMGRYSnVJRTlpYW1WamRDaGtaV1pwYm1Wa0tHbDBLU2s3WEc1Y2RIMDdYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQTFOQ0FxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS1NCN1hHNWNibHgwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnMU5TazdYRzVjZEhaaGNpQm5iRzlpWVd3Z0lDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzNLVnh1WEhRZ0lDd2dhR2xrWlNBZ0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVEVwWEc1Y2RDQWdMQ0JKZEdWeVlYUnZjbk1nSUNBZ0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWd6TXlsY2JseDBJQ0FzSUZSUFgxTlVVa2xPUjE5VVFVY2dQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RVeEtTZ25kRzlUZEhKcGJtZFVZV2NuS1R0Y2JseDBYRzVjZEdadmNpaDJZWElnWTI5c2JHVmpkR2x2Ym5NZ1BTQmJKMDV2WkdWTWFYTjBKeXdnSjBSUFRWUnZhMlZ1VEdsemRDY3NJQ2ROWldScFlVeHBjM1FuTENBblUzUjViR1ZUYUdWbGRFeHBjM1FuTENBblExTlRVblZzWlV4cGMzUW5YU3dnYVNBOUlEQTdJR2tnUENBMU95QnBLeXNwZTF4dVhIUWdJSFpoY2lCT1FVMUZJQ0FnSUNBZ0lEMGdZMjlzYkdWamRHbHZibk5iYVYxY2JseDBJQ0FnSUN3Z1EyOXNiR1ZqZEdsdmJpQTlJR2RzYjJKaGJGdE9RVTFGWFZ4dVhIUWdJQ0FnTENCd2NtOTBieUFnSUNBZ0lEMGdRMjlzYkdWamRHbHZiaUFtSmlCRGIyeHNaV04wYVc5dUxuQnliM1J2ZEhsd1pUdGNibHgwSUNCcFppaHdjbTkwYnlBbUppQWhjSEp2ZEc5YlZFOWZVMVJTU1U1SFgxUkJSMTBwYUdsa1pTaHdjbTkwYnl3Z1ZFOWZVMVJTU1U1SFgxUkJSeXdnVGtGTlJTazdYRzVjZENBZ1NYUmxjbUYwYjNKelcwNUJUVVZkSUQwZ1NYUmxjbUYwYjNKekxrRnljbUY1TzF4dVhIUjlYRzVjYmk4cUtpb3ZJSDBzWEc0dktpQTFOU0FxTDF4dUx5b3FLaThnWm5WdVkzUnBiMjRvYlc5a2RXeGxMQ0JsZUhCdmNuUnpMQ0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS1NCN1hHNWNibHgwSjNWelpTQnpkSEpwWTNRbk8xeHVYSFIyWVhJZ1lXUmtWRzlWYm5OamIzQmhZbXhsY3lBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OVFlwWEc1Y2RDQWdMQ0J6ZEdWd0lDQWdJQ0FnSUNBZ0lDQWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnMU55bGNibHgwSUNBc0lFbDBaWEpoZEc5eWN5QWdJQ0FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE16S1Z4dVhIUWdJQ3dnZEc5SlQySnFaV04wSUNBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b016a3BPMXh1WEhSY2JseDBMeThnTWpJdU1TNHpMalFnUVhKeVlYa3VjSEp2ZEc5MGVYQmxMbVZ1ZEhKcFpYTW9LVnh1WEhRdkx5QXlNaTR4TGpNdU1UTWdRWEp5WVhrdWNISnZkRzkwZVhCbExtdGxlWE1vS1Z4dVhIUXZMeUF5TWk0eExqTXVNamtnUVhKeVlYa3VjSEp2ZEc5MGVYQmxMblpoYkhWbGN5Z3BYRzVjZEM4dklESXlMakV1TXk0ek1DQkJjbkpoZVM1d2NtOTBiM1I1Y0dWYlFFQnBkR1Z5WVhSdmNsMG9LVnh1WEhSdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01qa3BLRUZ5Y21GNUxDQW5RWEp5WVhrbkxDQm1kVzVqZEdsdmJpaHBkR1Z5WVhSbFpDd2dhMmx1WkNsN1hHNWNkQ0FnZEdocGN5NWZkQ0E5SUhSdlNVOWlhbVZqZENocGRHVnlZWFJsWkNrN0lDOHZJSFJoY21kbGRGeHVYSFFnSUhSb2FYTXVYMmtnUFNBd095QWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJ1WlhoMElHbHVaR1Y0WEc1Y2RDQWdkR2hwY3k1ZmF5QTlJR3RwYm1RN0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM4dklHdHBibVJjYmx4MEx5OGdNakl1TVM0MUxqSXVNU0FsUVhKeVlYbEpkR1Z5WVhSdmNsQnliM1J2ZEhsd1pTVXVibVY0ZENncFhHNWNkSDBzSUdaMWJtTjBhVzl1S0NsN1hHNWNkQ0FnZG1GeUlFOGdJQ0FnSUQwZ2RHaHBjeTVmZEZ4dVhIUWdJQ0FnTENCcmFXNWtJQ0E5SUhSb2FYTXVYMnRjYmx4MElDQWdJQ3dnYVc1a1pYZ2dQU0IwYUdsekxsOXBLeXM3WEc1Y2RDQWdhV1lvSVU4Z2ZId2dhVzVrWlhnZ1BqMGdUeTVzWlc1bmRHZ3BlMXh1WEhRZ0lDQWdkR2hwY3k1ZmRDQTlJSFZ1WkdWbWFXNWxaRHRjYmx4MElDQWdJSEpsZEhWeWJpQnpkR1Z3S0RFcE8xeHVYSFFnSUgxY2JseDBJQ0JwWmlocmFXNWtJRDA5SUNkclpYbHpKeUFnS1hKbGRIVnliaUJ6ZEdWd0tEQXNJR2x1WkdWNEtUdGNibHgwSUNCcFppaHJhVzVrSUQwOUlDZDJZV3gxWlhNbktYSmxkSFZ5YmlCemRHVndLREFzSUU5YmFXNWtaWGhkS1R0Y2JseDBJQ0J5WlhSMWNtNGdjM1JsY0Nnd0xDQmJhVzVrWlhnc0lFOWJhVzVrWlhoZFhTazdYRzVjZEgwc0lDZDJZV3gxWlhNbktUdGNibHgwWEc1Y2RDOHZJR0Z5WjNWdFpXNTBjMHhwYzNSYlFFQnBkR1Z5WVhSdmNsMGdhWE1nSlVGeWNtRjVVSEp2ZEc5ZmRtRnNkV1Z6SlNBb09TNDBMalF1Tml3Z09TNDBMalF1TnlsY2JseDBTWFJsY21GMGIzSnpMa0Z5WjNWdFpXNTBjeUE5SUVsMFpYSmhkRzl5Y3k1QmNuSmhlVHRjYmx4MFhHNWNkR0ZrWkZSdlZXNXpZMjl3WVdKc1pYTW9KMnRsZVhNbktUdGNibHgwWVdSa1ZHOVZibk5qYjNCaFlteGxjeWduZG1Gc2RXVnpKeWs3WEc1Y2RHRmtaRlJ2Vlc1elkyOXdZV0pzWlhNb0oyVnVkSEpwWlhNbktUdGNibHh1THlvcUtpOGdmU3hjYmk4cUlEVTJJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXBJSHRjYmx4dVhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtDbDdJQzhxSUdWdGNIUjVJQ292SUgwN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBMU55QXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SektTQjdYRzVjYmx4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2Ymloa2IyNWxMQ0IyWVd4MVpTbDdYRzVjZENBZ2NtVjBkWEp1SUh0MllXeDFaVG9nZG1Gc2RXVXNJR1J2Ym1VNklDRWhaRzl1WlgwN1hHNWNkSDA3WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUExT0NBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MFpYaHdiM0owY3k1bUlEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcxTVNrN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBMU9TQXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLU0I3WEc1Y2JseDBiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjdJRndpWkdWbVlYVnNkRndpT2lCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktEWXdLU3dnWDE5bGMwMXZaSFZzWlRvZ2RISjFaU0I5TzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTmpBZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OakVwTzF4dVhIUmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRGN5S1R0Y2JseDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWczTXlrN1hHNWNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTnpRcE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvT0NrdVUzbHRZbTlzTzF4dVhHNHZLaW9xTHlCOUxGeHVMeW9nTmpFZ0tpOWNiaThxS2lvdklHWjFibU4wYVc5dUtHMXZaSFZzWlN3Z1pYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5a2dlMXh1WEc1Y2RDZDFjMlVnYzNSeWFXTjBKenRjYmx4MEx5OGdSVU5OUVZOamNtbHdkQ0EySUhONWJXSnZiSE1nYzJocGJWeHVYSFIyWVhJZ1oyeHZZbUZzSUNBZ0lDQWdJQ0FnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktEY3BYRzVjZENBZ0xDQm9ZWE1nSUNBZ0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NeklwWEc1Y2RDQWdMQ0JFUlZORFVrbFFWRTlTVXlBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTVRZcFhHNWNkQ0FnTENBa1pYaHdiM0owSUNBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05pbGNibHgwSUNBc0lISmxaR1ZtYVc1bElDQWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3pNU2xjYmx4MElDQXNJRTFGVkVFZ0lDQWdJQ0FnSUNBZ0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcyTWlrdVMwVlpYRzVjZENBZ0xDQWtabUZwYkhNZ0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVGNwWEc1Y2RDQWdMQ0J6YUdGeVpXUWdJQ0FnSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTkRZcFhHNWNkQ0FnTENCelpYUlViMU4wY21sdVoxUmhaeUE5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05UQXBYRzVjZENBZ0xDQjFhV1FnSUNBZ0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9ORGNwWEc1Y2RDQWdMQ0IzYTNNZ0lDQWdJQ0FnSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTlRFcFhHNWNkQ0FnTENCM2EzTkZlSFFnSUNBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05UZ3BYRzVjZENBZ0xDQjNhM05FWldacGJtVWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9Oak1wWEc1Y2RDQWdMQ0JyWlhsUFppQWdJQ0FnSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTmpRcFhHNWNkQ0FnTENCbGJuVnRTMlY1Y3lBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05qVXBYRzVjZENBZ0xDQnBjMEZ5Y21GNUlDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OamdwWEc1Y2RDQWdMQ0JoYms5aWFtVmpkQ0FnSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTVRNcFhHNWNkQ0FnTENCMGIwbFBZbXBsWTNRZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b016a3BYRzVjZENBZ0xDQjBiMUJ5YVcxcGRHbDJaU0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NVGtwWEc1Y2RDQWdMQ0JqY21WaGRHVkVaWE5qSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTWpBcFhHNWNkQ0FnTENCZlkzSmxZWFJsSUNBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b016VXBYRzVjZENBZ0xDQm5UMUJPUlhoMElDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OamtwWEc1Y2RDQWdMQ0FrUjA5UVJDQWdJQ0FnSUNBZ0lDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTnpFcFhHNWNkQ0FnTENBa1JGQWdJQ0FnSUNBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01USXBYRzVjZENBZ0xDQWthMlY1Y3lBZ0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NemNwWEc1Y2RDQWdMQ0JuVDFCRUlDQWdJQ0FnSUNBZ0lDQTlJQ1JIVDFCRUxtWmNibHgwSUNBc0lHUlFJQ0FnSUNBZ0lDQWdJQ0FnSUQwZ0pFUlFMbVpjYmx4MElDQXNJR2RQVUU0Z0lDQWdJQ0FnSUNBZ0lEMGdaMDlRVGtWNGRDNW1YRzVjZENBZ0xDQWtVM2x0WW05c0lDQWdJQ0FnSUNBOUlHZHNiMkpoYkM1VGVXMWliMnhjYmx4MElDQXNJQ1JLVTA5T0lDQWdJQ0FnSUNBZ0lEMGdaMnh2WW1Gc0xrcFRUMDVjYmx4MElDQXNJRjl6ZEhKcGJtZHBabmtnSUNBZ0lEMGdKRXBUVDA0Z0ppWWdKRXBUVDA0dWMzUnlhVzVuYVdaNVhHNWNkQ0FnTENCUVVrOVVUMVJaVUVVZ0lDQWdJQ0E5SUNkd2NtOTBiM1I1Y0dVblhHNWNkQ0FnTENCSVNVUkVSVTRnSUNBZ0lDQWdJQ0E5SUhkcmN5Z25YMmhwWkdSbGJpY3BYRzVjZENBZ0xDQlVUMTlRVWtsTlNWUkpWa1VnSUNBOUlIZHJjeWduZEc5UWNtbHRhWFJwZG1VbktWeHVYSFFnSUN3Z2FYTkZiblZ0SUNBZ0lDQWdJQ0FnUFNCN2ZTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaVnh1WEhRZ0lDd2dVM2x0WW05c1VtVm5hWE4wY25rZ1BTQnphR0Z5WldRb0ozTjViV0p2YkMxeVpXZHBjM1J5ZVNjcFhHNWNkQ0FnTENCQmJHeFRlVzFpYjJ4eklDQWdJQ0E5SUhOb1lYSmxaQ2duYzNsdFltOXNjeWNwWEc1Y2RDQWdMQ0JQVUZONWJXSnZiSE1nSUNBZ0lDQTlJSE5vWVhKbFpDZ25iM0F0YzNsdFltOXNjeWNwWEc1Y2RDQWdMQ0JQWW1wbFkzUlFjbTkwYnlBZ0lDQTlJRTlpYW1WamRGdFFVazlVVDFSWlVFVmRYRzVjZENBZ0xDQlZVMFZmVGtGVVNWWkZJQ0FnSUNBOUlIUjVjR1Z2WmlBa1UzbHRZbTlzSUQwOUlDZG1kVzVqZEdsdmJpZGNibHgwSUNBc0lGRlBZbXBsWTNRZ0lDQWdJQ0FnSUQwZ1oyeHZZbUZzTGxGUFltcGxZM1E3WEc1Y2RDOHZJRVJ2YmlkMElIVnpaU0J6WlhSMFpYSnpJR2x1SUZGMElGTmpjbWx3ZEN3Z2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwzcHNiMmx5YjJOckwyTnZjbVV0YW5NdmFYTnpkV1Z6THpFM00xeHVYSFIyWVhJZ2MyVjBkR1Z5SUQwZ0lWRlBZbXBsWTNRZ2ZId2dJVkZQWW1wbFkzUmJVRkpQVkU5VVdWQkZYU0I4ZkNBaFVVOWlhbVZqZEZ0UVVrOVVUMVJaVUVWZExtWnBibVJEYUdsc1pEdGNibHgwWEc1Y2RDOHZJR1poYkd4aVlXTnJJR1p2Y2lCdmJHUWdRVzVrY205cFpDd2dhSFIwY0hNNkx5OWpiMlJsTG1kdmIyZHNaUzVqYjIwdmNDOTJPQzlwYzNOMVpYTXZaR1YwWVdsc1AybGtQVFk0TjF4dVhIUjJZWElnYzJWMFUzbHRZbTlzUkdWell5QTlJRVJGVTBOU1NWQlVUMUpUSUNZbUlDUm1ZV2xzY3lobWRXNWpkR2x2YmlncGUxeHVYSFFnSUhKbGRIVnliaUJmWTNKbFlYUmxLR1JRS0h0OUxDQW5ZU2NzSUh0Y2JseDBJQ0FnSUdkbGREb2dablZ1WTNScGIyNG9LWHNnY21WMGRYSnVJR1JRS0hSb2FYTXNJQ2RoSnl3Z2UzWmhiSFZsT2lBM2ZTa3VZVHNnZlZ4dVhIUWdJSDBwS1M1aElDRTlJRGM3WEc1Y2RIMHBJRDhnWm5WdVkzUnBiMjRvYVhRc0lHdGxlU3dnUkNsN1hHNWNkQ0FnZG1GeUlIQnliM1J2UkdWell5QTlJR2RQVUVRb1QySnFaV04wVUhKdmRHOHNJR3RsZVNrN1hHNWNkQ0FnYVdZb2NISnZkRzlFWlhOaktXUmxiR1YwWlNCUFltcGxZM1JRY205MGIxdHJaWGxkTzF4dVhIUWdJR1JRS0dsMExDQnJaWGtzSUVRcE8xeHVYSFFnSUdsbUtIQnliM1J2UkdWell5QW1KaUJwZENBaFBUMGdUMkpxWldOMFVISnZkRzhwWkZBb1QySnFaV04wVUhKdmRHOHNJR3RsZVN3Z2NISnZkRzlFWlhOaktUdGNibHgwZlNBNklHUlFPMXh1WEhSY2JseDBkbUZ5SUhkeVlYQWdQU0JtZFc1amRHbHZiaWgwWVdjcGUxeHVYSFFnSUhaaGNpQnplVzBnUFNCQmJHeFRlVzFpYjJ4elczUmhaMTBnUFNCZlkzSmxZWFJsS0NSVGVXMWliMnhiVUZKUFZFOVVXVkJGWFNrN1hHNWNkQ0FnYzNsdExsOXJJRDBnZEdGbk8xeHVYSFFnSUhKbGRIVnliaUJ6ZVcwN1hHNWNkSDA3WEc1Y2RGeHVYSFIyWVhJZ2FYTlRlVzFpYjJ3Z1BTQlZVMFZmVGtGVVNWWkZJQ1ltSUhSNWNHVnZaaUFrVTNsdFltOXNMbWwwWlhKaGRHOXlJRDA5SUNkemVXMWliMnduSUQ4Z1puVnVZM1JwYjI0b2FYUXBlMXh1WEhRZ0lISmxkSFZ5YmlCMGVYQmxiMllnYVhRZ1BUMGdKM041YldKdmJDYzdYRzVjZEgwZ09pQm1kVzVqZEdsdmJpaHBkQ2w3WEc1Y2RDQWdjbVYwZFhKdUlHbDBJR2x1YzNSaGJtTmxiMllnSkZONWJXSnZiRHRjYmx4MGZUdGNibHgwWEc1Y2RIWmhjaUFrWkdWbWFXNWxVSEp2Y0dWeWRIa2dQU0JtZFc1amRHbHZiaUJrWldacGJtVlFjbTl3WlhKMGVTaHBkQ3dnYTJWNUxDQkVLWHRjYmx4MElDQnBaaWhwZENBOVBUMGdUMkpxWldOMFVISnZkRzhwSkdSbFptbHVaVkJ5YjNCbGNuUjVLRTlRVTNsdFltOXNjeXdnYTJWNUxDQkVLVHRjYmx4MElDQmhiazlpYW1WamRDaHBkQ2s3WEc1Y2RDQWdhMlY1SUQwZ2RHOVFjbWx0YVhScGRtVW9hMlY1TENCMGNuVmxLVHRjYmx4MElDQmhiazlpYW1WamRDaEVLVHRjYmx4MElDQnBaaWhvWVhNb1FXeHNVM2x0WW05c2N5d2dhMlY1S1NsN1hHNWNkQ0FnSUNCcFppZ2hSQzVsYm5WdFpYSmhZbXhsS1h0Y2JseDBJQ0FnSUNBZ2FXWW9JV2hoY3locGRDd2dTRWxFUkVWT0tTbGtVQ2hwZEN3Z1NFbEVSRVZPTENCamNtVmhkR1ZFWlhOaktERXNJSHQ5S1NrN1hHNWNkQ0FnSUNBZ0lHbDBXMGhKUkVSRlRsMWJhMlY1WFNBOUlIUnlkV1U3WEc1Y2RDQWdJQ0I5SUdWc2MyVWdlMXh1WEhRZ0lDQWdJQ0JwWmlob1lYTW9hWFFzSUVoSlJFUkZUaWtnSmlZZ2FYUmJTRWxFUkVWT1hWdHJaWGxkS1dsMFcwaEpSRVJGVGwxYmEyVjVYU0E5SUdaaGJITmxPMXh1WEhRZ0lDQWdJQ0JFSUQwZ1gyTnlaV0YwWlNoRUxDQjdaVzUxYldWeVlXSnNaVG9nWTNKbFlYUmxSR1Z6WXlnd0xDQm1ZV3h6WlNsOUtUdGNibHgwSUNBZ0lIMGdjbVYwZFhKdUlITmxkRk41YldKdmJFUmxjMk1vYVhRc0lHdGxlU3dnUkNrN1hHNWNkQ0FnZlNCeVpYUjFjbTRnWkZBb2FYUXNJR3RsZVN3Z1JDazdYRzVjZEgwN1hHNWNkSFpoY2lBa1pHVm1hVzVsVUhKdmNHVnlkR2xsY3lBOUlHWjFibU4wYVc5dUlHUmxabWx1WlZCeWIzQmxjblJwWlhNb2FYUXNJRkFwZTF4dVhIUWdJR0Z1VDJKcVpXTjBLR2wwS1R0Y2JseDBJQ0IyWVhJZ2EyVjVjeUE5SUdWdWRXMUxaWGx6S0ZBZ1BTQjBiMGxQWW1wbFkzUW9VQ2twWEc1Y2RDQWdJQ0FzSUdrZ0lDQWdQU0F3WEc1Y2RDQWdJQ0FzSUd3Z1BTQnJaWGx6TG14bGJtZDBhRnh1WEhRZ0lDQWdMQ0JyWlhrN1hHNWNkQ0FnZDJocGJHVW9iQ0ErSUdrcEpHUmxabWx1WlZCeWIzQmxjblI1S0dsMExDQnJaWGtnUFNCclpYbHpXMmtySzEwc0lGQmJhMlY1WFNrN1hHNWNkQ0FnY21WMGRYSnVJR2wwTzF4dVhIUjlPMXh1WEhSMllYSWdKR055WldGMFpTQTlJR1oxYm1OMGFXOXVJR055WldGMFpTaHBkQ3dnVUNsN1hHNWNkQ0FnY21WMGRYSnVJRkFnUFQwOUlIVnVaR1ZtYVc1bFpDQS9JRjlqY21WaGRHVW9hWFFwSURvZ0pHUmxabWx1WlZCeWIzQmxjblJwWlhNb1gyTnlaV0YwWlNocGRDa3NJRkFwTzF4dVhIUjlPMXh1WEhSMllYSWdKSEJ5YjNCbGNuUjVTWE5GYm5WdFpYSmhZbXhsSUQwZ1puVnVZM1JwYjI0Z2NISnZjR1Z5ZEhsSmMwVnVkVzFsY21GaWJHVW9hMlY1S1h0Y2JseDBJQ0IyWVhJZ1JTQTlJR2x6Ulc1MWJTNWpZV3hzS0hSb2FYTXNJR3RsZVNBOUlIUnZVSEpwYldsMGFYWmxLR3RsZVN3Z2RISjFaU2twTzF4dVhIUWdJR2xtS0hSb2FYTWdQVDA5SUU5aWFtVmpkRkJ5YjNSdklDWW1JR2hoY3loQmJHeFRlVzFpYjJ4ekxDQnJaWGtwSUNZbUlDRm9ZWE1vVDFCVGVXMWliMnh6TENCclpYa3BLWEpsZEhWeWJpQm1ZV3h6WlR0Y2JseDBJQ0J5WlhSMWNtNGdSU0I4ZkNBaGFHRnpLSFJvYVhNc0lHdGxlU2tnZkh3Z0lXaGhjeWhCYkd4VGVXMWliMnh6TENCclpYa3BJSHg4SUdoaGN5aDBhR2x6TENCSVNVUkVSVTRwSUNZbUlIUm9hWE5iU0VsRVJFVk9YVnRyWlhsZElEOGdSU0E2SUhSeWRXVTdYRzVjZEgwN1hHNWNkSFpoY2lBa1oyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5SUQwZ1puVnVZM1JwYjI0Z1oyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5S0dsMExDQnJaWGtwZTF4dVhIUWdJR2wwSUNBOUlIUnZTVTlpYW1WamRDaHBkQ2s3WEc1Y2RDQWdhMlY1SUQwZ2RHOVFjbWx0YVhScGRtVW9hMlY1TENCMGNuVmxLVHRjYmx4MElDQnBaaWhwZENBOVBUMGdUMkpxWldOMFVISnZkRzhnSmlZZ2FHRnpLRUZzYkZONWJXSnZiSE1zSUd0bGVTa2dKaVlnSVdoaGN5aFBVRk41YldKdmJITXNJR3RsZVNrcGNtVjBkWEp1TzF4dVhIUWdJSFpoY2lCRUlEMGdaMDlRUkNocGRDd2dhMlY1S1R0Y2JseDBJQ0JwWmloRUlDWW1JR2hoY3loQmJHeFRlVzFpYjJ4ekxDQnJaWGtwSUNZbUlDRW9hR0Z6S0dsMExDQklTVVJFUlU0cElDWW1JR2wwVzBoSlJFUkZUbDFiYTJWNVhTa3BSQzVsYm5WdFpYSmhZbXhsSUQwZ2RISjFaVHRjYmx4MElDQnlaWFIxY200Z1JEdGNibHgwZlR0Y2JseDBkbUZ5SUNSblpYUlBkMjVRY205d1pYSjBlVTVoYldWeklEMGdablZ1WTNScGIyNGdaMlYwVDNkdVVISnZjR1Z5ZEhsT1lXMWxjeWhwZENsN1hHNWNkQ0FnZG1GeUlHNWhiV1Z6SUNBOUlHZFBVRTRvZEc5SlQySnFaV04wS0dsMEtTbGNibHgwSUNBZ0lDd2djbVZ6ZFd4MElEMGdXMTFjYmx4MElDQWdJQ3dnYVNBZ0lDQWdJRDBnTUZ4dVhIUWdJQ0FnTENCclpYazdYRzVjZENBZ2QyaHBiR1VvYm1GdFpYTXViR1Z1WjNSb0lENGdhU2w3WEc1Y2RDQWdJQ0JwWmlnaGFHRnpLRUZzYkZONWJXSnZiSE1zSUd0bGVTQTlJRzVoYldWelcya3JLMTBwSUNZbUlHdGxlU0FoUFNCSVNVUkVSVTRnSmlZZ2EyVjVJQ0U5SUUxRlZFRXBjbVZ6ZFd4MExuQjFjMmdvYTJWNUtUdGNibHgwSUNCOUlISmxkSFZ5YmlCeVpYTjFiSFE3WEc1Y2RIMDdYRzVjZEhaaGNpQWtaMlYwVDNkdVVISnZjR1Z5ZEhsVGVXMWliMnh6SUQwZ1puVnVZM1JwYjI0Z1oyVjBUM2R1VUhKdmNHVnlkSGxUZVcxaWIyeHpLR2wwS1h0Y2JseDBJQ0IyWVhJZ1NWTmZUMUFnSUQwZ2FYUWdQVDA5SUU5aWFtVmpkRkJ5YjNSdlhHNWNkQ0FnSUNBc0lHNWhiV1Z6SUNBOUlHZFBVRTRvU1ZOZlQxQWdQeUJQVUZONWJXSnZiSE1nT2lCMGIwbFBZbXBsWTNRb2FYUXBLVnh1WEhRZ0lDQWdMQ0J5WlhOMWJIUWdQU0JiWFZ4dVhIUWdJQ0FnTENCcElDQWdJQ0FnUFNBd1hHNWNkQ0FnSUNBc0lHdGxlVHRjYmx4MElDQjNhR2xzWlNodVlXMWxjeTVzWlc1bmRHZ2dQaUJwS1h0Y2JseDBJQ0FnSUdsbUtHaGhjeWhCYkd4VGVXMWliMnh6TENCclpYa2dQU0J1WVcxbGMxdHBLeXRkS1NBbUppQW9TVk5mVDFBZ1B5Qm9ZWE1vVDJKcVpXTjBVSEp2ZEc4c0lHdGxlU2tnT2lCMGNuVmxLU2x5WlhOMWJIUXVjSFZ6YUNoQmJHeFRlVzFpYjJ4elcydGxlVjBwTzF4dVhIUWdJSDBnY21WMGRYSnVJSEpsYzNWc2REdGNibHgwZlR0Y2JseDBYRzVjZEM4dklERTVMalF1TVM0eElGTjViV0p2YkNoYlpHVnpZM0pwY0hScGIyNWRLVnh1WEhScFppZ2hWVk5GWDA1QlZFbFdSU2w3WEc1Y2RDQWdKRk41YldKdmJDQTlJR1oxYm1OMGFXOXVJRk41YldKdmJDZ3BlMXh1WEhRZ0lDQWdhV1lvZEdocGN5QnBibk4wWVc1alpXOW1JQ1JUZVcxaWIyd3BkR2h5YjNjZ1ZIbHdaVVZ5Y205eUtDZFRlVzFpYjJ3Z2FYTWdibTkwSUdFZ1kyOXVjM1J5ZFdOMGIzSWhKeWs3WEc1Y2RDQWdJQ0IyWVhJZ2RHRm5JRDBnZFdsa0tHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnZ1BpQXdJRDhnWVhKbmRXMWxiblJ6V3pCZElEb2dkVzVrWldacGJtVmtLVHRjYmx4MElDQWdJSFpoY2lBa2MyVjBJRDBnWm5WdVkzUnBiMjRvZG1Gc2RXVXBlMXh1WEhRZ0lDQWdJQ0JwWmloMGFHbHpJRDA5UFNCUFltcGxZM1JRY205MGJ5a2tjMlYwTG1OaGJHd29UMUJUZVcxaWIyeHpMQ0IyWVd4MVpTazdYRzVjZENBZ0lDQWdJR2xtS0doaGN5aDBhR2x6TENCSVNVUkVSVTRwSUNZbUlHaGhjeWgwYUdselcwaEpSRVJGVGwwc0lIUmhaeWtwZEdocGMxdElTVVJFUlU1ZFczUmhaMTBnUFNCbVlXeHpaVHRjYmx4MElDQWdJQ0FnYzJWMFUzbHRZbTlzUkdWell5aDBhR2x6TENCMFlXY3NJR055WldGMFpVUmxjMk1vTVN3Z2RtRnNkV1VwS1R0Y2JseDBJQ0FnSUgwN1hHNWNkQ0FnSUNCcFppaEVSVk5EVWtsUVZFOVNVeUFtSmlCelpYUjBaWElwYzJWMFUzbHRZbTlzUkdWell5aFBZbXBsWTNSUWNtOTBieXdnZEdGbkxDQjdZMjl1Wm1sbmRYSmhZbXhsT2lCMGNuVmxMQ0J6WlhRNklDUnpaWFI5S1R0Y2JseDBJQ0FnSUhKbGRIVnliaUIzY21Gd0tIUmhaeWs3WEc1Y2RDQWdmVHRjYmx4MElDQnlaV1JsWm1sdVpTZ2tVM2x0WW05c1cxQlNUMVJQVkZsUVJWMHNJQ2QwYjFOMGNtbHVaeWNzSUdaMWJtTjBhVzl1SUhSdlUzUnlhVzVuS0NsN1hHNWNkQ0FnSUNCeVpYUjFjbTRnZEdocGN5NWZhenRjYmx4MElDQjlLVHRjYmx4MFhHNWNkQ0FnSkVkUFVFUXVaaUE5SUNSblpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0k3WEc1Y2RDQWdKRVJRTG1ZZ0lDQTlJQ1JrWldacGJtVlFjbTl3WlhKMGVUdGNibHgwSUNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktEY3dLUzVtSUQwZ1owOVFUa1Y0ZEM1bUlEMGdKR2RsZEU5M2JsQnliM0JsY25SNVRtRnRaWE03WEc1Y2RDQWdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcyTnlrdVppQWdQU0FrY0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVN1hHNWNkQ0FnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnMk5pa3VaaUE5SUNSblpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITTdYRzVjZEZ4dVhIUWdJR2xtS0VSRlUwTlNTVkJVVDFKVElDWW1JQ0ZmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RNd0tTbDdYRzVjZENBZ0lDQnlaV1JsWm1sdVpTaFBZbXBsWTNSUWNtOTBieXdnSjNCeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bEp5d2dKSEJ5YjNCbGNuUjVTWE5GYm5WdFpYSmhZbXhsTENCMGNuVmxLVHRjYmx4MElDQjlYRzVjZEZ4dVhIUWdJSGRyYzBWNGRDNW1JRDBnWm5WdVkzUnBiMjRvYm1GdFpTbDdYRzVjZENBZ0lDQnlaWFIxY200Z2QzSmhjQ2gzYTNNb2JtRnRaU2twTzF4dVhIUWdJSDFjYmx4MGZWeHVYSFJjYmx4MEpHVjRjRzl5ZENna1pYaHdiM0owTGtjZ0t5QWtaWGh3YjNKMExsY2dLeUFrWlhod2IzSjBMa1lnS2lBaFZWTkZYMDVCVkVsV1JTd2dlMU41YldKdmJEb2dKRk41YldKdmJIMHBPMXh1WEhSY2JseDBabTl5S0haaGNpQnplVzFpYjJ4eklEMGdLRnh1WEhRZ0lDOHZJREU1TGpRdU1pNHlMQ0F4T1M0MExqSXVNeXdnTVRrdU5DNHlMalFzSURFNUxqUXVNaTQyTENBeE9TNDBMakl1T0N3Z01Ua3VOQzR5TGprc0lERTVMalF1TWk0eE1Dd2dNVGt1TkM0eUxqRXhMQ0F4T1M0MExqSXVNVElzSURFNUxqUXVNaTR4TXl3Z01Ua3VOQzR5TGpFMFhHNWNkQ0FnSjJoaGMwbHVjM1JoYm1ObExHbHpRMjl1WTJGMFUzQnlaV0ZrWVdKc1pTeHBkR1Z5WVhSdmNpeHRZWFJqYUN4eVpYQnNZV05sTEhObFlYSmphQ3h6Y0dWamFXVnpMSE53YkdsMExIUnZVSEpwYldsMGFYWmxMSFJ2VTNSeWFXNW5WR0ZuTEhWdWMyTnZjR0ZpYkdWekoxeHVYSFFwTG5Od2JHbDBLQ2NzSnlrc0lHa2dQU0F3T3lCemVXMWliMnh6TG14bGJtZDBhQ0ErSUdrN0lDbDNhM01vYzNsdFltOXNjMXRwS3l0ZEtUdGNibHgwWEc1Y2RHWnZjaWgyWVhJZ2MzbHRZbTlzY3lBOUlDUnJaWGx6S0hkcmN5NXpkRzl5WlNrc0lHa2dQU0F3T3lCemVXMWliMnh6TG14bGJtZDBhQ0ErSUdrN0lDbDNhM05FWldacGJtVW9jM2x0WW05c2MxdHBLeXRkS1R0Y2JseDBYRzVjZENSbGVIQnZjblFvSkdWNGNHOXlkQzVUSUNzZ0pHVjRjRzl5ZEM1R0lDb2dJVlZUUlY5T1FWUkpWa1VzSUNkVGVXMWliMnduTENCN1hHNWNkQ0FnTHk4Z01Ua3VOQzR5TGpFZ1UzbHRZbTlzTG1admNpaHJaWGtwWEc1Y2RDQWdKMlp2Y2ljNklHWjFibU4wYVc5dUtHdGxlU2w3WEc1Y2RDQWdJQ0J5WlhSMWNtNGdhR0Z6S0ZONWJXSnZiRkpsWjJsemRISjVMQ0JyWlhrZ0t6MGdKeWNwWEc1Y2RDQWdJQ0FnSUQ4Z1UzbHRZbTlzVW1WbmFYTjBjbmxiYTJWNVhWeHVYSFFnSUNBZ0lDQTZJRk41YldKdmJGSmxaMmx6ZEhKNVcydGxlVjBnUFNBa1UzbHRZbTlzS0d0bGVTazdYRzVjZENBZ2ZTeGNibHgwSUNBdkx5QXhPUzQwTGpJdU5TQlRlVzFpYjJ3dWEyVjVSbTl5S0hONWJTbGNibHgwSUNCclpYbEdiM0k2SUdaMWJtTjBhVzl1SUd0bGVVWnZjaWhyWlhrcGUxeHVYSFFnSUNBZ2FXWW9hWE5UZVcxaWIyd29hMlY1S1NseVpYUjFjbTRnYTJWNVQyWW9VM2x0WW05c1VtVm5hWE4wY25rc0lHdGxlU2s3WEc1Y2RDQWdJQ0IwYUhKdmR5QlVlWEJsUlhKeWIzSW9hMlY1SUNzZ0p5QnBjeUJ1YjNRZ1lTQnplVzFpYjJ3aEp5azdYRzVjZENBZ2ZTeGNibHgwSUNCMWMyVlRaWFIwWlhJNklHWjFibU4wYVc5dUtDbDdJSE5sZEhSbGNpQTlJSFJ5ZFdVN0lIMHNYRzVjZENBZ2RYTmxVMmx0Y0d4bE9pQm1kVzVqZEdsdmJpZ3BleUJ6WlhSMFpYSWdQU0JtWVd4elpUc2dmVnh1WEhSOUtUdGNibHgwWEc1Y2RDUmxlSEJ2Y25Rb0pHVjRjRzl5ZEM1VElDc2dKR1Y0Y0c5eWRDNUdJQ29nSVZWVFJWOU9RVlJKVmtVc0lDZFBZbXBsWTNRbkxDQjdYRzVjZENBZ0x5OGdNVGt1TVM0eUxqSWdUMkpxWldOMExtTnlaV0YwWlNoUElGc3NJRkJ5YjNCbGNuUnBaWE5kS1Z4dVhIUWdJR055WldGMFpUb2dKR055WldGMFpTeGNibHgwSUNBdkx5QXhPUzR4TGpJdU5DQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvVHl3Z1VDd2dRWFIwY21saWRYUmxjeWxjYmx4MElDQmtaV1pwYm1WUWNtOXdaWEowZVRvZ0pHUmxabWx1WlZCeWIzQmxjblI1TEZ4dVhIUWdJQzh2SURFNUxqRXVNaTR6SUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGFXVnpLRThzSUZCeWIzQmxjblJwWlhNcFhHNWNkQ0FnWkdWbWFXNWxVSEp2Y0dWeWRHbGxjem9nSkdSbFptbHVaVkJ5YjNCbGNuUnBaWE1zWEc1Y2RDQWdMeThnTVRrdU1TNHlMallnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpaFBMQ0JRS1Z4dVhIUWdJR2RsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNqb2dKR2RsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpeGNibHgwSUNBdkx5QXhPUzR4TGpJdU55QlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxPWVcxbGN5aFBLVnh1WEhRZ0lHZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTTZJQ1JuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6TEZ4dVhIUWdJQzh2SURFNUxqRXVNaTQ0SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNb1R5bGNibHgwSUNCblpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITTZJQ1JuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhOY2JseDBmU2s3WEc1Y2RGeHVYSFF2THlBeU5DNHpMaklnU2xOUFRpNXpkSEpwYm1kcFpua29kbUZzZFdVZ1d5d2djbVZ3YkdGalpYSWdXeXdnYzNCaFkyVmRYU2xjYmx4MEpFcFRUMDRnSmlZZ0pHVjRjRzl5ZENna1pYaHdiM0owTGxNZ0t5QWtaWGh3YjNKMExrWWdLaUFvSVZWVFJWOU9RVlJKVmtVZ2ZId2dKR1poYVd4ektHWjFibU4wYVc5dUtDbDdYRzVjZENBZ2RtRnlJRk1nUFNBa1UzbHRZbTlzS0NrN1hHNWNkQ0FnTHk4Z1RWTWdSV1JuWlNCamIyNTJaWEowY3lCemVXMWliMndnZG1Gc2RXVnpJSFJ2SUVwVFQwNGdZWE1nZTMxY2JseDBJQ0F2THlCWFpXSkxhWFFnWTI5dWRtVnlkSE1nYzNsdFltOXNJSFpoYkhWbGN5QjBieUJLVTA5T0lHRnpJRzUxYkd4Y2JseDBJQ0F2THlCV09DQjBhSEp2ZDNNZ2IyNGdZbTk0WldRZ2MzbHRZbTlzYzF4dVhIUWdJSEpsZEhWeWJpQmZjM1J5YVc1bmFXWjVLRnRUWFNrZ0lUMGdKMXR1ZFd4c1hTY2dmSHdnWDNOMGNtbHVaMmxtZVNoN1lUb2dVMzBwSUNFOUlDZDdmU2NnZkh3Z1gzTjBjbWx1WjJsbWVTaFBZbXBsWTNRb1V5a3BJQ0U5SUNkN2ZTYzdYRzVjZEgwcEtTd2dKMHBUVDA0bkxDQjdYRzVjZENBZ2MzUnlhVzVuYVdaNU9pQm1kVzVqZEdsdmJpQnpkSEpwYm1kcFpua29hWFFwZTF4dVhIUWdJQ0FnYVdZb2FYUWdQVDA5SUhWdVpHVm1hVzVsWkNCOGZDQnBjMU41YldKdmJDaHBkQ2twY21WMGRYSnVPeUF2THlCSlJUZ2djbVYwZFhKdWN5QnpkSEpwYm1jZ2IyNGdkVzVrWldacGJtVmtYRzVjZENBZ0lDQjJZWElnWVhKbmN5QTlJRnRwZEYxY2JseDBJQ0FnSUNBZ0xDQnBJQ0FnSUQwZ01WeHVYSFFnSUNBZ0lDQXNJSEpsY0d4aFkyVnlMQ0FrY21Wd2JHRmpaWEk3WEc1Y2RDQWdJQ0IzYUdsc1pTaGhjbWQxYldWdWRITXViR1Z1WjNSb0lENGdhU2xoY21kekxuQjFjMmdvWVhKbmRXMWxiblJ6VzJrcksxMHBPMXh1WEhRZ0lDQWdjbVZ3YkdGalpYSWdQU0JoY21keld6RmRPMXh1WEhRZ0lDQWdhV1lvZEhsd1pXOW1JSEpsY0d4aFkyVnlJRDA5SUNkbWRXNWpkR2x2YmljcEpISmxjR3hoWTJWeUlEMGdjbVZ3YkdGalpYSTdYRzVjZENBZ0lDQnBaaWdrY21Wd2JHRmpaWElnZkh3Z0lXbHpRWEp5WVhrb2NtVndiR0ZqWlhJcEtYSmxjR3hoWTJWeUlEMGdablZ1WTNScGIyNG9hMlY1TENCMllXeDFaU2w3WEc1Y2RDQWdJQ0FnSUdsbUtDUnlaWEJzWVdObGNpbDJZV3gxWlNBOUlDUnlaWEJzWVdObGNpNWpZV3hzS0hSb2FYTXNJR3RsZVN3Z2RtRnNkV1VwTzF4dVhIUWdJQ0FnSUNCcFppZ2hhWE5UZVcxaWIyd29kbUZzZFdVcEtYSmxkSFZ5YmlCMllXeDFaVHRjYmx4MElDQWdJSDA3WEc1Y2RDQWdJQ0JoY21keld6RmRJRDBnY21Wd2JHRmpaWEk3WEc1Y2RDQWdJQ0J5WlhSMWNtNGdYM04wY21sdVoybG1lUzVoY0hCc2VTZ2tTbE5QVGl3Z1lYSm5jeWs3WEc1Y2RDQWdmVnh1WEhSOUtUdGNibHgwWEc1Y2RDOHZJREU1TGpRdU15NDBJRk41YldKdmJDNXdjbTkwYjNSNWNHVmJRRUIwYjFCeWFXMXBkR2wyWlYwb2FHbHVkQ2xjYmx4MEpGTjViV0p2YkZ0UVVrOVVUMVJaVUVWZFcxUlBYMUJTU1UxSlZFbFdSVjBnZkh3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3hNU2tvSkZONWJXSnZiRnRRVWs5VVQxUlpVRVZkTENCVVQxOVFVa2xOU1ZSSlZrVXNJQ1JUZVcxaWIyeGJVRkpQVkU5VVdWQkZYUzUyWVd4MVpVOW1LVHRjYmx4MEx5OGdNVGt1TkM0ekxqVWdVM2x0WW05c0xuQnliM1J2ZEhsd1pWdEFRSFJ2VTNSeWFXNW5WR0ZuWFZ4dVhIUnpaWFJVYjFOMGNtbHVaMVJoWnlna1UzbHRZbTlzTENBblUzbHRZbTlzSnlrN1hHNWNkQzh2SURJd0xqSXVNUzQ1SUUxaGRHaGJRRUIwYjFOMGNtbHVaMVJoWjExY2JseDBjMlYwVkc5VGRISnBibWRVWVdjb1RXRjBhQ3dnSjAxaGRHZ25MQ0IwY25WbEtUdGNibHgwTHk4Z01qUXVNeTR6SUVwVFQwNWJRRUIwYjFOMGNtbHVaMVJoWjExY2JseDBjMlYwVkc5VGRISnBibWRVWVdjb1oyeHZZbUZzTGtwVFQwNHNJQ2RLVTA5T0p5d2dkSEoxWlNrN1hHNWNiaThxS2lvdklIMHNYRzR2S2lBMk1pQXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLU0I3WEc1Y2JseDBkbUZ5SUUxRlZFRWdJQ0FnSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzBOeWtvSjIxbGRHRW5LVnh1WEhRZ0lDd2dhWE5QWW1wbFkzUWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RFMEtWeHVYSFFnSUN3Z2FHRnpJQ0FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE15S1Z4dVhIUWdJQ3dnYzJWMFJHVnpZeUFnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktERXlLUzVtWEc1Y2RDQWdMQ0JwWkNBZ0lDQWdJQ0E5SURBN1hHNWNkSFpoY2lCcGMwVjRkR1Z1YzJsaWJHVWdQU0JQWW1wbFkzUXVhWE5GZUhSbGJuTnBZbXhsSUh4OElHWjFibU4wYVc5dUtDbDdYRzVjZENBZ2NtVjBkWEp1SUhSeWRXVTdYRzVjZEgwN1hHNWNkSFpoY2lCR1VrVkZXa1VnUFNBaFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3hOeWtvWm5WdVkzUnBiMjRvS1h0Y2JseDBJQ0J5WlhSMWNtNGdhWE5GZUhSbGJuTnBZbXhsS0U5aWFtVmpkQzV3Y21WMlpXNTBSWGgwWlc1emFXOXVjeWg3ZlNrcE8xeHVYSFI5S1R0Y2JseDBkbUZ5SUhObGRFMWxkR0VnUFNCbWRXNWpkR2x2YmlocGRDbDdYRzVjZENBZ2MyVjBSR1Z6WXlocGRDd2dUVVZVUVN3Z2UzWmhiSFZsT2lCN1hHNWNkQ0FnSUNCcE9pQW5UeWNnS3lBcksybGtMQ0F2THlCdlltcGxZM1FnU1VSY2JseDBJQ0FnSUhjNklIdDlJQ0FnSUNBZ0lDQWdJQzh2SUhkbFlXc2dZMjlzYkdWamRHbHZibk1nU1VSelhHNWNkQ0FnZlgwcE8xeHVYSFI5TzF4dVhIUjJZWElnWm1GemRFdGxlU0E5SUdaMWJtTjBhVzl1S0dsMExDQmpjbVZoZEdVcGUxeHVYSFFnSUM4dklISmxkSFZ5YmlCd2NtbHRhWFJwZG1VZ2QybDBhQ0J3Y21WbWFYaGNibHgwSUNCcFppZ2hhWE5QWW1wbFkzUW9hWFFwS1hKbGRIVnliaUIwZVhCbGIyWWdhWFFnUFQwZ0ozTjViV0p2YkNjZ1B5QnBkQ0E2SUNoMGVYQmxiMllnYVhRZ1BUMGdKM04wY21sdVp5Y2dQeUFuVXljZ09pQW5VQ2NwSUNzZ2FYUTdYRzVjZENBZ2FXWW9JV2hoY3locGRDd2dUVVZVUVNrcGUxeHVYSFFnSUNBZ0x5OGdZMkZ1SjNRZ2MyVjBJRzFsZEdGa1lYUmhJSFJ2SUhWdVkyRjFaMmgwSUdaeWIzcGxiaUJ2WW1wbFkzUmNibHgwSUNBZ0lHbG1LQ0ZwYzBWNGRHVnVjMmxpYkdVb2FYUXBLWEpsZEhWeWJpQW5SaWM3WEc1Y2RDQWdJQ0F2THlCdWIzUWdibVZqWlhOellYSjVJSFJ2SUdGa1pDQnRaWFJoWkdGMFlWeHVYSFFnSUNBZ2FXWW9JV055WldGMFpTbHlaWFIxY200Z0owVW5PMXh1WEhRZ0lDQWdMeThnWVdSa0lHMXBjM05wYm1jZ2JXVjBZV1JoZEdGY2JseDBJQ0FnSUhObGRFMWxkR0VvYVhRcE8xeHVYSFFnSUM4dklISmxkSFZ5YmlCdlltcGxZM1FnU1VSY2JseDBJQ0I5SUhKbGRIVnliaUJwZEZ0TlJWUkJYUzVwTzF4dVhIUjlPMXh1WEhSMllYSWdaMlYwVjJWaGF5QTlJR1oxYm1OMGFXOXVLR2wwTENCamNtVmhkR1VwZTF4dVhIUWdJR2xtS0NGb1lYTW9hWFFzSUUxRlZFRXBLWHRjYmx4MElDQWdJQzh2SUdOaGJpZDBJSE5sZENCdFpYUmhaR0YwWVNCMGJ5QjFibU5oZFdkb2RDQm1jbTk2Wlc0Z2IySnFaV04wWEc1Y2RDQWdJQ0JwWmlnaGFYTkZlSFJsYm5OcFlteGxLR2wwS1NseVpYUjFjbTRnZEhKMVpUdGNibHgwSUNBZ0lDOHZJRzV2ZENCdVpXTmxjM05oY25rZ2RHOGdZV1JrSUcxbGRHRmtZWFJoWEc1Y2RDQWdJQ0JwWmlnaFkzSmxZWFJsS1hKbGRIVnliaUJtWVd4elpUdGNibHgwSUNBZ0lDOHZJR0ZrWkNCdGFYTnphVzVuSUcxbGRHRmtZWFJoWEc1Y2RDQWdJQ0J6WlhSTlpYUmhLR2wwS1R0Y2JseDBJQ0F2THlCeVpYUjFjbTRnYUdGemFDQjNaV0ZySUdOdmJHeGxZM1JwYjI1eklFbEVjMXh1WEhRZ0lIMGdjbVYwZFhKdUlHbDBXMDFGVkVGZExuYzdYRzVjZEgwN1hHNWNkQzh2SUdGa1pDQnRaWFJoWkdGMFlTQnZiaUJtY21WbGVtVXRabUZ0YVd4NUlHMWxkR2h2WkhNZ1kyRnNiR2x1WjF4dVhIUjJZWElnYjI1R2NtVmxlbVVnUFNCbWRXNWpkR2x2YmlocGRDbDdYRzVjZENBZ2FXWW9SbEpGUlZwRklDWW1JRzFsZEdFdVRrVkZSQ0FtSmlCcGMwVjRkR1Z1YzJsaWJHVW9hWFFwSUNZbUlDRm9ZWE1vYVhRc0lFMUZWRUVwS1hObGRFMWxkR0VvYVhRcE8xeHVYSFFnSUhKbGRIVnliaUJwZER0Y2JseDBmVHRjYmx4MGRtRnlJRzFsZEdFZ1BTQnRiMlIxYkdVdVpYaHdiM0owY3lBOUlIdGNibHgwSUNCTFJWazZJQ0FnSUNBZ1RVVlVRU3hjYmx4MElDQk9SVVZFT2lBZ0lDQWdabUZzYzJVc1hHNWNkQ0FnWm1GemRFdGxlVG9nSUdaaGMzUkxaWGtzWEc1Y2RDQWdaMlYwVjJWaGF6b2dJR2RsZEZkbFlXc3NYRzVjZENBZ2IyNUdjbVZsZW1VNklHOXVSbkpsWlhwbFhHNWNkSDA3WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUEyTXlBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MGRtRnlJR2RzYjJKaGJDQWdJQ0FnSUNBZ0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWczS1Z4dVhIUWdJQ3dnWTI5eVpTQWdJQ0FnSUNBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RncFhHNWNkQ0FnTENCTVNVSlNRVkpaSUNBZ0lDQWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b016QXBYRzVjZENBZ0xDQjNhM05GZUhRZ0lDQWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9OVGdwWEc1Y2RDQWdMQ0JrWldacGJtVlFjbTl3WlhKMGVTQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTVRJcExtWTdYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvYm1GdFpTbDdYRzVjZENBZ2RtRnlJQ1JUZVcxaWIyd2dQU0JqYjNKbExsTjViV0p2YkNCOGZDQW9ZMjl5WlM1VGVXMWliMndnUFNCTVNVSlNRVkpaSUQ4Z2UzMGdPaUJuYkc5aVlXd3VVM2x0WW05c0lIeDhJSHQ5S1R0Y2JseDBJQ0JwWmlodVlXMWxMbU5vWVhKQmRDZ3dLU0FoUFNBblh5Y2dKaVlnSVNodVlXMWxJR2x1SUNSVGVXMWliMndwS1dSbFptbHVaVkJ5YjNCbGNuUjVLQ1JUZVcxaWIyd3NJRzVoYldVc0lIdDJZV3gxWlRvZ2QydHpSWGgwTG1Zb2JtRnRaU2w5S1R0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRFkwSUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSMllYSWdaMlYwUzJWNWN5QWdJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlnek55bGNibHgwSUNBc0lIUnZTVTlpYW1WamRDQTlJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvTXprcE8xeHVYSFJ0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLRzlpYW1WamRDd2daV3dwZTF4dVhIUWdJSFpoY2lCUElDQWdJQ0FnUFNCMGIwbFBZbXBsWTNRb2IySnFaV04wS1Z4dVhIUWdJQ0FnTENCclpYbHpJQ0FnUFNCblpYUkxaWGx6S0U4cFhHNWNkQ0FnSUNBc0lHeGxibWQwYUNBOUlHdGxlWE11YkdWdVozUm9YRzVjZENBZ0lDQXNJR2x1WkdWNElDQTlJREJjYmx4MElDQWdJQ3dnYTJWNU8xeHVYSFFnSUhkb2FXeGxLR3hsYm1kMGFDQStJR2x1WkdWNEtXbG1LRTliYTJWNUlEMGdhMlY1YzF0cGJtUmxlQ3NyWFYwZ1BUMDlJR1ZzS1hKbGRIVnliaUJyWlhrN1hHNWNkSDA3WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUEyTlNBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MEx5OGdZV3hzSUdWdWRXMWxjbUZpYkdVZ2IySnFaV04wSUd0bGVYTXNJR2x1WTJ4MVpHVnpJSE41YldKdmJITmNibHgwZG1GeUlHZGxkRXRsZVhNZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRE0zS1Z4dVhIUWdJQ3dnWjA5UVV5QWdJQ0E5SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b05qWXBYRzVjZENBZ0xDQndTVVVnSUNBZ0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcyTnlrN1hHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9hWFFwZTF4dVhIUWdJSFpoY2lCeVpYTjFiSFFnSUNBZ0lEMGdaMlYwUzJWNWN5aHBkQ2xjYmx4MElDQWdJQ3dnWjJWMFUzbHRZbTlzY3lBOUlHZFBVRk11Wmp0Y2JseDBJQ0JwWmloblpYUlRlVzFpYjJ4ektYdGNibHgwSUNBZ0lIWmhjaUJ6ZVcxaWIyeHpJRDBnWjJWMFUzbHRZbTlzY3locGRDbGNibHgwSUNBZ0lDQWdMQ0JwYzBWdWRXMGdJRDBnY0VsRkxtWmNibHgwSUNBZ0lDQWdMQ0JwSUNBZ0lDQWdJRDBnTUZ4dVhIUWdJQ0FnSUNBc0lHdGxlVHRjYmx4MElDQWdJSGRvYVd4bEtITjViV0p2YkhNdWJHVnVaM1JvSUQ0Z2FTbHBaaWhwYzBWdWRXMHVZMkZzYkNocGRDd2dhMlY1SUQwZ2MzbHRZbTlzYzF0cEt5dGRLU2x5WlhOMWJIUXVjSFZ6YUNoclpYa3BPMXh1WEhRZ0lIMGdjbVYwZFhKdUlISmxjM1ZzZER0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRFkySUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1wSUh0Y2JseHVYSFJsZUhCdmNuUnpMbVlnUFNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbFRlVzFpYjJ4ek8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ05qY2dLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5a2dlMXh1WEc1Y2RHVjRjRzl5ZEhNdVppQTlJSHQ5TG5CeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bE8xeHVYRzR2S2lvcUx5QjlMRnh1THlvZ05qZ2dLaTljYmk4cUtpb3ZJR1oxYm1OMGFXOXVLRzF2WkhWc1pTd2daWGh3YjNKMGN5d2dYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWtnZTF4dVhHNWNkQzh2SURjdU1pNHlJRWx6UVhKeVlYa29ZWEpuZFcxbGJuUXBYRzVjZEhaaGNpQmpiMllnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktEUXhLVHRjYmx4MGJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCQmNuSmhlUzVwYzBGeWNtRjVJSHg4SUdaMWJtTjBhVzl1SUdselFYSnlZWGtvWVhKbktYdGNibHgwSUNCeVpYUjFjbTRnWTI5bUtHRnlaeWtnUFQwZ0owRnljbUY1Snp0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRFk1SUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhRdkx5Qm1ZV3hzWW1GamF5Qm1iM0lnU1VVeE1TQmlkV2RuZVNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbE9ZVzFsY3lCM2FYUm9JR2xtY21GdFpTQmhibVFnZDJsdVpHOTNYRzVjZEhaaGNpQjBiMGxQWW1wbFkzUWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RNNUtWeHVYSFFnSUN3Z1owOVFUaUFnSUNBZ0lEMGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWczTUNrdVpseHVYSFFnSUN3Z2RHOVRkSEpwYm1jZ0lEMGdlMzB1ZEc5VGRISnBibWM3WEc1Y2RGeHVYSFIyWVhJZ2QybHVaRzkzVG1GdFpYTWdQU0IwZVhCbGIyWWdkMmx1Wkc5M0lEMDlJQ2R2WW1wbFkzUW5JQ1ltSUhkcGJtUnZkeUFtSmlCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbE9ZVzFsYzF4dVhIUWdJRDhnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vZDJsdVpHOTNLU0E2SUZ0ZE8xeHVYSFJjYmx4MGRtRnlJR2RsZEZkcGJtUnZkMDVoYldWeklEMGdablZ1WTNScGIyNG9hWFFwZTF4dVhIUWdJSFJ5ZVNCN1hHNWNkQ0FnSUNCeVpYUjFjbTRnWjA5UVRpaHBkQ2s3WEc1Y2RDQWdmU0JqWVhSamFDaGxLWHRjYmx4MElDQWdJSEpsZEhWeWJpQjNhVzVrYjNkT1lXMWxjeTV6YkdsalpTZ3BPMXh1WEhRZ0lIMWNibHgwZlR0Y2JseDBYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpMbVlnUFNCbWRXNWpkR2x2YmlCblpYUlBkMjVRY205d1pYSjBlVTVoYldWektHbDBLWHRjYmx4MElDQnlaWFIxY200Z2QybHVaRzkzVG1GdFpYTWdKaVlnZEc5VGRISnBibWN1WTJGc2JDaHBkQ2tnUFQwZ0oxdHZZbXBsWTNRZ1YybHVaRzkzWFNjZ1B5Qm5aWFJYYVc1a2IzZE9ZVzFsY3locGRDa2dPaUJuVDFCT0tIUnZTVTlpYW1WamRDaHBkQ2twTzF4dVhIUjlPMXh1WEc1Y2JpOHFLaW92SUgwc1hHNHZLaUEzTUNBcUwxeHVMeW9xS2k4Z1puVnVZM1JwYjI0b2JXOWtkV3hsTENCbGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktTQjdYRzVjYmx4MEx5OGdNVGt1TVM0eUxqY2dMeUF4TlM0eUxqTXVOQ0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsT1lXMWxjeWhQS1Z4dVhIUjJZWElnSkd0bGVYTWdJQ0FnSUNBOUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NemdwWEc1Y2RDQWdMQ0JvYVdSa1pXNUxaWGx6SUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5ZzBPQ2t1WTI5dVkyRjBLQ2RzWlc1bmRHZ25MQ0FuY0hKdmRHOTBlWEJsSnlrN1hHNWNkRnh1WEhSbGVIQnZjblJ6TG1ZZ1BTQlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxPWVcxbGN5QjhmQ0JtZFc1amRHbHZiaUJuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0U4cGUxeHVYSFFnSUhKbGRIVnliaUFrYTJWNWN5aFBMQ0JvYVdSa1pXNUxaWGx6S1R0Y2JseDBmVHRjYmx4dUx5b3FLaThnZlN4Y2JpOHFJRGN4SUNvdlhHNHZLaW9xTHlCbWRXNWpkR2x2YmlodGIyUjFiR1VzSUdWNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cElIdGNibHh1WEhSMllYSWdjRWxGSUNBZ0lDQWdJQ0FnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFkzS1Z4dVhIUWdJQ3dnWTNKbFlYUmxSR1Z6WXlBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RJd0tWeHVYSFFnSUN3Z2RHOUpUMkpxWldOMElDQWdJQ0FnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktETTVLVnh1WEhRZ0lDd2dkRzlRY21sdGFYUnBkbVVnSUNBZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLREU1S1Z4dVhIUWdJQ3dnYUdGeklDQWdJQ0FnSUNBZ0lDQWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RNeUtWeHVYSFFnSUN3Z1NVVTRYMFJQVFY5RVJVWkpUa1VnUFNCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktERTFLVnh1WEhRZ0lDd2daMDlRUkNBZ0lDQWdJQ0FnSUNBZ1BTQlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5TzF4dVhIUmNibHgwWlhod2IzSjBjeTVtSUQwZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5Z3hOaWtnUHlCblQxQkVJRG9nWm5WdVkzUnBiMjRnWjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXlLRThzSUZBcGUxeHVYSFFnSUU4Z1BTQjBiMGxQWW1wbFkzUW9UeWs3WEc1Y2RDQWdVQ0E5SUhSdlVISnBiV2wwYVhabEtGQXNJSFJ5ZFdVcE8xeHVYSFFnSUdsbUtFbEZPRjlFVDAxZlJFVkdTVTVGS1hSeWVTQjdYRzVjZENBZ0lDQnlaWFIxY200Z1owOVFSQ2hQTENCUUtUdGNibHgwSUNCOUlHTmhkR05vS0dVcGV5QXZLaUJsYlhCMGVTQXFMeUI5WEc1Y2RDQWdhV1lvYUdGektFOHNJRkFwS1hKbGRIVnliaUJqY21WaGRHVkVaWE5qS0NGd1NVVXVaaTVqWVd4c0tFOHNJRkFwTENCUFcxQmRLVHRjYmx4MGZUdGNibHh1THlvcUtpOGdmU3hjYmk4cUlEY3lJQ292WEc0dktpb3FMeUJtZFc1amRHbHZiaWh0YjJSMWJHVXNJR1Y0Y0c5eWRITXBJSHRjYmx4dVhHNWNiaThxS2lvdklIMHNYRzR2S2lBM015QXFMMXh1THlvcUtpOGdablZ1WTNScGIyNG9iVzlrZFd4bExDQmxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLU0I3WEc1Y2JseDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWcyTXlrb0oyRnplVzVqU1hSbGNtRjBiM0luS1R0Y2JseHVMeW9xS2k4Z2ZTeGNiaThxSURjMElDb3ZYRzR2S2lvcUx5Qm1kVzVqZEdsdmJpaHRiMlIxYkdVc0lHVjRjRzl5ZEhNc0lGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHBJSHRjYmx4dVhIUmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRFl6S1NnbmIySnpaWEoyWVdKc1pTY3BPMXh1WEc0dktpb3FMeUI5TEZ4dUx5b2dOelVnS2k5Y2JpOHFLaW92SUdaMWJtTjBhVzl1S0cxdlpIVnNaU3dnWlhod2IzSjBjeXdnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlrZ2UxeHVYRzVjZENkMWMyVWdjM1J5YVdOMEp6dGNibHgwWEc1Y2RFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBlU2hsZUhCdmNuUnpMQ0JjSWw5ZlpYTk5iMlIxYkdWY0lpd2dlMXh1WEhRZ0lIWmhiSFZsT2lCMGNuVmxYRzVjZEgwcE8xeHVYSFJjYmx4MGRtRnlJRjlqYkdGemMwTmhiR3hEYUdWamF6SWdQU0JmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0RFcE8xeHVYSFJjYmx4MGRtRnlJRjlqYkdGemMwTmhiR3hEYUdWamF6TWdQU0JmYVc1MFpYSnZjRkpsY1hWcGNtVkVaV1poZFd4MEtGOWpiR0Z6YzBOaGJHeERhR1ZqYXpJcE8xeHVYSFJjYmx4MGRtRnlJRjlqY21WaGRHVkRiR0Z6Y3pJZ1BTQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRElwTzF4dVhIUmNibHgwZG1GeUlGOWpjbVZoZEdWRGJHRnpjek1nUFNCZmFXNTBaWEp2Y0ZKbGNYVnBjbVZFWldaaGRXeDBLRjlqY21WaGRHVkRiR0Z6Y3pJcE8xeHVYSFJjYmx4MFpuVnVZM1JwYjI0Z1gybHVkR1Z5YjNCU1pYRjFhWEpsUkdWbVlYVnNkQ2h2WW1vcElIc2djbVYwZFhKdUlHOWlhaUFtSmlCdlltb3VYMTlsYzAxdlpIVnNaU0EvSUc5aWFpQTZJSHNnWkdWbVlYVnNkRG9nYjJKcUlIMDdJSDFjYmx4MFhHNWNkSFpoY2lCVmRHbHNJRDBnWm5WdVkzUnBiMjRnS0NrZ2UxeHVYSFFnSUdaMWJtTjBhVzl1SUZWMGFXd29LU0I3WEc1Y2RDQWdJQ0FvTUN3Z1gyTnNZWE56UTJGc2JFTm9aV05yTXk1a1pXWmhkV3gwS1NoMGFHbHpMQ0JWZEdsc0tUdGNibHgwSUNCOVhHNWNkRnh1WEhRZ0lDZ3dMQ0JmWTNKbFlYUmxRMnhoYzNNekxtUmxabUYxYkhRcEtGVjBhV3dzSUc1MWJHd3NJRnQ3WEc1Y2RDQWdJQ0JyWlhrNklDZGpjbVZoZEdWRFlXNTJZWE1uTEZ4dVhIUWdJQ0FnZG1Gc2RXVTZJR1oxYm1OMGFXOXVJR055WldGMFpVTmhiblpoY3loemFYcGxMQ0JwYldGblpTa2dlMXh1WEhRZ0lDQWdJQ0IyWVhJZ1kyRnVkbUZ6SUQwZ1pHOWpkVzFsYm5RdVkzSmxZWFJsUld4bGJXVnVkQ2duWTJGdWRtRnpKeWs3WEc1Y2RDQWdJQ0FnSUdOaGJuWmhjeTUzYVdSMGFDQTlJSE5wZW1VN1hHNWNkQ0FnSUNBZ0lHTmhiblpoY3k1b1pXbG5hSFFnUFNCemFYcGxPMXh1WEhRZ0lDQWdJQ0JqWVc1MllYTXVaMlYwUTI5dWRHVjRkQ2duTW1RbktTNWtjbUYzU1cxaFoyVW9hVzFoWjJVc0lEQXNJREFzSUhOcGVtVXNJSE5wZW1VcE8xeHVYSFFnSUNBZ0lDQnlaWFIxY200Z1kyRnVkbUZ6TzF4dVhIUWdJQ0FnZlZ4dVhIUWdJSDBzSUh0Y2JseDBJQ0FnSUd0bGVUb2dKM1JvY21WemFHOXNaQ2NzWEc1Y2RDQWdJQ0IyWVd4MVpUb2dablZ1WTNScGIyNGdkR2h5WlhOb2IyeGtLSElzSUdjc0lHSXNJSFpoYkhWbEtTQjdYRzVjZENBZ0lDQWdJSEpsZEhWeWJpQXdMakl4TWpZZ0tpQnlJQ3NnTUM0M01UVXlJQ29nWnlBcklEQXVNRGN5TWlBcUlHSWdQajBnZG1Gc2RXVWdQeUF5TlRVZ09pQXdPMXh1WEhRZ0lDQWdmVnh1WEhRZ0lIMWRLVHRjYmx4MElDQnlaWFIxY200Z1ZYUnBiRHRjYmx4MGZTZ3BPMXh1WEhSY2JseDBaWGh3YjNKMGN5NWtaV1poZFd4MElEMGdWWFJwYkR0Y2JseHVMeW9xS2k4Z2ZWeHVMeW9xS2lvcUtpOGdYU2xjYm4wcE8xeHVPMXh1WEc1Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU0lDOHZYRzR2THlCeFlYSjBMbTFwYmk1cWN5SXNJaUJjZEM4dklGUm9aU0J0YjJSMWJHVWdZMkZqYUdWY2JpQmNkSFpoY2lCcGJuTjBZV3hzWldSTmIyUjFiR1Z6SUQwZ2UzMDdYRzVjYmlCY2RDOHZJRlJvWlNCeVpYRjFhWEpsSUdaMWJtTjBhVzl1WEc0Z1hIUm1kVzVqZEdsdmJpQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLRzF2WkhWc1pVbGtLU0I3WEc1Y2JpQmNkRngwTHk4Z1EyaGxZMnNnYVdZZ2JXOWtkV3hsSUdseklHbHVJR05oWTJobFhHNGdYSFJjZEdsbUtHbHVjM1JoYkd4bFpFMXZaSFZzWlhOYmJXOWtkV3hsU1dSZEtWeHVJRngwWEhSY2RISmxkSFZ5YmlCcGJuTjBZV3hzWldSTmIyUjFiR1Z6VzIxdlpIVnNaVWxrWFM1bGVIQnZjblJ6TzF4dVhHNGdYSFJjZEM4dklFTnlaV0YwWlNCaElHNWxkeUJ0YjJSMWJHVWdLR0Z1WkNCd2RYUWdhWFFnYVc1MGJ5QjBhR1VnWTJGamFHVXBYRzRnWEhSY2RIWmhjaUJ0YjJSMWJHVWdQU0JwYm5OMFlXeHNaV1JOYjJSMWJHVnpXMjF2WkhWc1pVbGtYU0E5SUh0Y2JpQmNkRngwWEhSbGVIQnZjblJ6T2lCN2ZTeGNiaUJjZEZ4MFhIUnBaRG9nYlc5a2RXeGxTV1FzWEc0Z1hIUmNkRngwYkc5aFpHVmtPaUJtWVd4elpWeHVJRngwWEhSOU8xeHVYRzRnWEhSY2RDOHZJRVY0WldOMWRHVWdkR2hsSUcxdlpIVnNaU0JtZFc1amRHbHZibHh1SUZ4MFhIUnRiMlIxYkdWelcyMXZaSFZzWlVsa1hTNWpZV3hzS0cxdlpIVnNaUzVsZUhCdmNuUnpMQ0J0YjJSMWJHVXNJRzF2WkhWc1pTNWxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLVHRjYmx4dUlGeDBYSFF2THlCR2JHRm5JSFJvWlNCdGIyUjFiR1VnWVhNZ2JHOWhaR1ZrWEc0Z1hIUmNkRzF2WkhWc1pTNXNiMkZrWldRZ1BTQjBjblZsTzF4dVhHNGdYSFJjZEM4dklGSmxkSFZ5YmlCMGFHVWdaWGh3YjNKMGN5QnZaaUIwYUdVZ2JXOWtkV3hsWEc0Z1hIUmNkSEpsZEhWeWJpQnRiMlIxYkdVdVpYaHdiM0owY3p0Y2JpQmNkSDFjYmx4dVhHNGdYSFF2THlCbGVIQnZjMlVnZEdobElHMXZaSFZzWlhNZ2IySnFaV04wSUNoZlgzZGxZbkJoWTJ0ZmJXOWtkV3hsYzE5ZktWeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1dElEMGdiVzlrZFd4bGN6dGNibHh1SUZ4MEx5OGdaWGh3YjNObElIUm9aU0J0YjJSMWJHVWdZMkZqYUdWY2JpQmNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMTh1WXlBOUlHbHVjM1JoYkd4bFpFMXZaSFZzWlhNN1hHNWNiaUJjZEM4dklGOWZkMlZpY0dGamExOXdkV0pzYVdOZmNHRjBhRjlmWEc0Z1hIUmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZMbkFnUFNCY0lpNHVMMlJwYzNRdlhDSTdYRzVjYmlCY2RDOHZJRXh2WVdRZ1pXNTBjbmtnYlc5a2RXeGxJR0Z1WkNCeVpYUjFjbTRnWlhod2IzSjBjMXh1SUZ4MGNtVjBkWEp1SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b01DazdYRzVjYmx4dVhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVpQXZMMXh1THk4Z2QyVmljR0ZqYXk5aWIyOTBjM1J5WVhBZ05tWTRNamhrTjJFMllqTXdaV05rT0dRelpEa2lMQ0pwYlhCdmNuUWdlMUZTUTI5a1pTd2dVVkpWZEdsc2ZTQm1jbTl0SUNjdUwzRnlZMjlrWlNjN1hHNXBiWEJ2Y25RZ1ZYUnBiQ0JtY205dElDY3VMM1YwYVd3bk8xeHVYRzVqYkdGemN5QlJRWEowSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvYjNCMGFXOXVjeWtnZTF4dUlDQWdJR2xtSUNoMGVYQmxiMllnYjNCMGFXOXVjeUE5UFQwZ0ozVnVaR1ZtYVc1bFpDY3BJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnblVVRnlkQ0J5WlhGMWFYSmxaQ0JnYjNCMGFXOXVjMkF1SnlrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllnYjNCMGFXOXVjeTUyWVd4MVpTQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWduVVVGeWRDQnlaWEYxYVhKbFpDQmdkbUZzZFdWZ0lHOXdkR2x2Ymk0bktUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1Z2WmlCdmNIUnBiMjV6TG1sdFlXZGxVR0YwYUNBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25VVUZ5ZENCeVpYRjFhWEpsWkNCZ2FXMWhaMlZRWVhSb1lDQnZjSFJwYjI0dUp5bGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QjBhR2x6TG5OcGVtVWdQU0FvZEhsd1pXOW1JRzl3ZEdsdmJuTXVjMmw2WlNBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUQ4Z1VVRnlkQzVFUlVaQlZVeFVVeTV6YVhwbElEb2diM0IwYVc5dWN5NXphWHBsTzF4dUlDQWdJSFJvYVhNdVptbHNkR1Z5SUQwZ0tIUjVjR1Z2WmlCdmNIUnBiMjV6TG1acGJIUmxjaUE5UFQwZ0ozVnVaR1ZtYVc1bFpDY3BJRDhnVVVGeWRDNUVSVVpCVlV4VVV5NW1hV3gwWlhJZ09pQnZjSFJwYjI1ekxtWnBiSFJsY2p0Y2JpQWdJQ0IwYUdsekxuWmhiSFZsSUQwZ2IzQjBhVzl1Y3k1MllXeDFaVHRjYmlBZ0lDQjBhR2x6TG1sdFlXZGxVR0YwYUNBOUlHOXdkR2x2Ym5NdWFXMWhaMlZRWVhSb08xeHVJQ0I5WEc1Y2JpQWdjM1JoZEdsaklHZGxkQ0JFUlVaQlZVeFVVeWdwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdlMXh1SUNBZ0lDQWdMeThnYzJsNlpUb2dNVGsxTEZ4dUlDQWdJQ0FnZG1Gc2RXVTZJQ2NuTEZ4dUlDQWdJQ0FnWm1sc2RHVnlPaUFuZEdoeVpYTm9iMnhrSjF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUcxaGEyVW9aV3dwSUh0Y2JpQWdJQ0IyWVhJZ2FXMWhaMlZUYVhwbElEMGdNVGsxTzF4dUlDQWdJSFpoY2lCd1lXUmthVzVuSUQwZ01USTdYRzRnSUNBZ2RtRnlJR3hsZG1Wc0lEMGdNVEE3WEc1Y2JpQWdJQ0IyWVhJZ2NYSWdQU0JSVWtOdlpHVW9iR1YyWld3c0lDZElKeWs3WEc0Z0lDQWdjWEl1WVdSa1JHRjBZU2gwYUdsekxuWmhiSFZsS1R0Y2JpQWdJQ0J4Y2k1dFlXdGxLQ2s3WEc0Z0lDQWdkbUZ5SUhGeVNXMWhaMlVnUFNCeGNpNWpjbVZoZEdWSmJXZFBZbXBsWTNRb015azdYRzVjYmlBZ0lDQjJZWElnYzJWc1ppQTlJSFJvYVhNN1hHNGdJQ0FnY1hKSmJXRm5aUzV2Ym14dllXUWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR052ZG1WeVNXMWhaMlVnUFNCdVpYY2dTVzFoWjJVb0tUdGNiaUFnSUNBZ0lDQWdZMjkyWlhKSmJXRm5aUzV6Y21NZ1BTQnpaV3htTG1sdFlXZGxVR0YwYUR0Y2JseHVJQ0FnSUNBZ0lDQjJZWElnY21WemRXeDBRMkZ1ZG1GeklEMGdWWFJwYkM1amNtVmhkR1ZEWVc1MllYTW9hVzFoWjJWVGFYcGxMQ0J4Y2tsdFlXZGxLVHRjYmlBZ0lDQWdJQ0FnZG1GeUlIRnlRMkZ1ZG1GeklEMGdWWFJwYkM1amNtVmhkR1ZEWVc1MllYTW9hVzFoWjJWVGFYcGxMQ0J4Y2tsdFlXZGxLVHRjYmx4dUlDQWdJQ0FnSUNCamIzWmxja2x0WVdkbExtOXViRzloWkNBOUlHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR052ZG1WeVNXMWhaMlV1ZDJsa2RHZ2dQQ0JqYjNabGNrbHRZV2RsTG1obGFXZG9kQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmRtVnlTVzFoWjJVdWFHVnBaMmgwSUQwZ0tHbHRZV2RsVTJsNlpTQXRJSEJoWkdScGJtY2dLaUF5S1NBcUlDZ3hMakFnS2lCamIzWmxja2x0WVdkbExtaGxhV2RvZENBdklHTnZkbVZ5U1cxaFoyVXVkMmxrZEdncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZkbVZ5U1cxaFoyVXVkMmxrZEdnZ1BTQnBiV0ZuWlZOcGVtVWdMU0J3WVdSa2FXNW5JQ29nTWp0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjkyWlhKSmJXRm5aUzUzYVdSMGFDQTlJQ2hwYldGblpWTnBlbVVnTFNCd1lXUmthVzVuSUNvZ01pa2dLaUFvTVM0d0lDb2dZMjkyWlhKSmJXRm5aUzUzYVdSMGFDQXZJR052ZG1WeVNXMWhaMlV1YUdWcFoyaDBLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjNabGNrbHRZV2RsTG1obGFXZG9kQ0E5SUdsdFlXZGxVMmw2WlNBdElIQmhaR1JwYm1jZ0tpQXlPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCMllYSWdZMjkyWlhKRFlXNTJZWE1nUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLQ2RqWVc1MllYTW5LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZkbVZ5UTJGdWRtRnpMbmRwWkhSb0lEMGdhVzFoWjJWVGFYcGxPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOTJaWEpEWVc1MllYTXVhR1ZwWjJoMElEMGdhVzFoWjJWVGFYcGxPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOTJaWEpEWVc1MllYTXVaMlYwUTI5dWRHVjRkQ2duTW1RbktTNWtjbUYzU1cxaFoyVW9ZMjkyWlhKSmJXRm5aU3dnY0dGa1pHbHVaeXdnY0dGa1pHbHVaeXdnYVcxaFoyVlRhWHBsSUMwZ2NHRmtaR2x1WnlBcUlESXNJR2x0WVdkbFUybDZaU0F0SUhCaFpHUnBibWNnS2lBeUtWeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCMllYSWdZMjkyWlhKSmJXRm5aVVJoZEdFZ1BTQmpiM1psY2tOaGJuWmhjeTVuWlhSRGIyNTBaWGgwS0NjeVpDY3BMbWRsZEVsdFlXZGxSR0YwWVNnd0xDQXdMQ0JwYldGblpWTnBlbVVzSUdsdFlXZGxVMmw2WlNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ1kyOTJaWEpKYldGblpVSnBibUZ5ZVNBOUlHTnZkbVZ5U1cxaFoyVkVZWFJoTG1SaGRHRTdYRzRnSUNBZ0lDQWdJQ0FnSUNCMllYSWdjbVZ6ZFd4MFNXMWhaMlZFWVhSaElEMGdjbVZ6ZFd4MFEyRnVkbUZ6TG1kbGRFTnZiblJsZUhRb0p6SmtKeWt1WjJWMFNXMWhaMlZFWVhSaEtEQXNJREFzSUdsdFlXZGxVMmw2WlN3Z2FXMWhaMlZUYVhwbEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUhaaGNpQnlaWE4xYkhSSmJXRm5aVUpwYm1GeWVTQTlJSEpsYzNWc2RFbHRZV2RsUkdGMFlTNWtZWFJoTzF4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdOdmRtVnlTVzFoWjJWQ2FXNWhjbmt1YkdWdVozUm9PeUJwSUNzOUlEUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2VDQTlJRTFoZEdndVpteHZiM0lvYVNBdklEUXBJQ1VnYVcxaFoyVlRhWHBsTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQjVJRDBnVFdGMGFDNW1iRzl2Y2loTllYUm9MbVpzYjI5eUtHa2dMeUEwS1NBdklHbHRZV2RsVTJsNlpTazdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2VDQThJSEJoWkdScGJtY2dmSHdnZVNBOElIQmhaR1JwYm1jZ2ZId2dlQ0ErUFNCcGJXRm5aVk5wZW1VdGNHRmtaR2x1WnlCOGZDQjVJRDQ5SUdsdFlXZGxVMmw2WlMxd1lXUmthVzVuS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RFbHRZV2RsUW1sdVlYSjVXMmtyTTEwZ1BTQXdPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSGdsTXlBOVBTQXhJQ1ltSUhrbE15QTlQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2VDQThJRE0ySUNZbUlDaDVJRHdnTXpZZ2ZId2dlU0ErUFNCcGJXRm5aVk5wZW1VdE16WXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZiblJwYm5WbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZUNBK1BTQnBiV0ZuWlZOcGVtVXRNellnSmlZZ2VTQThJRE0yS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaHpaV3htTG1acGJIUmxjaUE5UFNBbmRHaHlaWE5vYjJ4a0p5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMllYSWdabUZqZEc5eUlEMGdWWFJwYkM1MGFISmxjMmh2YkdRb1kyOTJaWEpKYldGblpVSnBibUZ5ZVZ0cFhTd2dZMjkyWlhKSmJXRm5aVUpwYm1GeWVWdHBLekZkTENCamIzWmxja2x0WVdkbFFtbHVZWEo1VzJrck1sMHNJREV5TnlrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RFbHRZV2RsUW1sdVlYSjVXMmxkSUQwZ1ptRmpkRzl5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhSSmJXRm5aVUpwYm1GeWVWdHBLekZkSUQwZ1ptRmpkRzl5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhSSmJXRm5aVUpwYm1GeWVWdHBLekpkSUQwZ1ptRmpkRzl5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2MyVnNaaTVtYVd4MFpYSWdQVDBnSjJOdmJHOXlKeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhSSmJXRm5aVUpwYm1GeWVWdHBYU0E5SUdOdmRtVnlTVzFoWjJWQ2FXNWhjbmxiYVYwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RFbHRZV2RsUW1sdVlYSjVXMmtyTVYwZ1BTQmpiM1psY2tsdFlXZGxRbWx1WVhKNVcya3JNVjA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEVsdFlXZGxRbWx1WVhKNVcya3JNbDBnUFNCamIzWmxja2x0WVdkbFFtbHVZWEo1VzJrck1sMDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RFbHRZV2RsUW1sdVlYSjVXMmtyTTEwZ1BTQmpiM1psY2tsdFlXZGxRbWx1WVhKNVcya3JNMTA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEVOaGJuWmhjeTVuWlhSRGIyNTBaWGgwS0NjeVpDY3BMbkIxZEVsdFlXZGxSR0YwWVNoeVpYTjFiSFJKYldGblpVUmhkR0VzSURBc0lEQXBPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZWElnY0dGMGRHVnlibEJ2YzNScGIyNGdQU0JSVWxWMGFXd3VaMlYwVUdGMGRHVnlibEJ2YzJsMGFXOXVLR3hsZG1Wc0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2NHRjBkR1Z5YmxCdmMzUnBiMjR1YkdWdVozUm9PeUJwSUNzOUlERXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJxSUQwZ01Ec2dhaUE4SUhCaGRIUmxjbTVRYjNOMGFXOXVMbXhsYm1kMGFEc2dhaUFyUFNBeEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQjRJRDBnY0dGMGRHVnlibEJ2YzNScGIyNWJhVjA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUI1SUQwZ2NHRjBkR1Z5YmxCdmMzUnBiMjViYWwwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaEtDaDRJRDA5SURZZ0ppWWdlU0E5UFNBMU1Da2dmSHdnS0hrZ1BUMGdOaUFtSmlCNElEMDlJRFV3S1NCOGZDQW9lQ0E5UFNBMklDWW1JSGtnUFQwZ05pa3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2NtVmpkRmdnUFNBeklDb2dLSGd0TWlrZ0t5QXhNanRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCeVpXTjBXU0E5SURNZ0tpQW9lUzB5S1NBcklERXlPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbFkzUlhhV1IwYUNBOUlDZ3pJQ29nS0hnck15a2dLeUF4TWlrZ0xTQnlaV04wV0R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNpQnlaV04wU0dWcFoyaDBJRDBnS0RNZ0tpQW9lU3N6S1NBcklERXlLU0F0SUhKbFkzUlpPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2NtVmpkRVJoZEdFZ1BTQnhja05oYm5aaGN5NW5aWFJEYjI1MFpYaDBLQ2N5WkNjcExtZGxkRWx0WVdkbFJHRjBZU2h5WldOMFdDd2djbVZqZEZrc0lISmxZM1JYYVdSMGFDd2djbVZqZEVobGFXZG9kQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUkRZVzUyWVhNdVoyVjBRMjl1ZEdWNGRDZ25NbVFuS1M1d2RYUkpiV0ZuWlVSaGRHRW9jbVZqZEVSaGRHRXNJSEpsWTNSWUxDQnlaV04wV1NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSEpsYzNWc2RFTmhiblpoY3k1M2FXUjBhQ0E5SUhObGJHWXVjMmw2WlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUhKbGMzVnNkRU5oYm5aaGN5NW9aV2xuYUhRZ1BTQnpaV3htTG5OcGVtVTdYRzRnSUNBZ0lDQWdJQ0FnSUNCbGJDNXBibTVsY2toVVRVd2dQU0FuSnp0Y2JpQWdJQ0FnSUNBZ0lDQWdJR1ZzTG1Gd2NHVnVaRU5vYVd4a0tISmxjM1ZzZEVOaGJuWmhjeWs3WEc0Z0lDQWdJQ0FnSUgwN1hHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JuZHBibVJ2ZHk1UlFYSjBJRDBnVVVGeWREdGNibVY0Y0c5eWRDQmtaV1poZFd4MElIZHBibVJ2ZHk1UlFYSjBPMXh1WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDNGaGNuUXVhbk1pTENKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dVpYaHdiM0owY3k1ZlgyVnpUVzlrZFd4bElEMGdkSEoxWlR0Y2JseHVaWGh3YjNKMGN5NWtaV1poZFd4MElEMGdablZ1WTNScGIyNGdLR2x1YzNSaGJtTmxMQ0JEYjI1emRISjFZM1J2Y2lrZ2UxeHVJQ0JwWmlBb0lTaHBibk4wWVc1alpTQnBibk4wWVc1alpXOW1JRU52Ym5OMGNuVmpkRzl5S1NrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb1hDSkRZVzV1YjNRZ1kyRnNiQ0JoSUdOc1lYTnpJR0Z6SUdFZ1puVnVZM1JwYjI1Y0lpazdYRzRnSUgxY2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wySmhZbVZzTFhKMWJuUnBiV1V2YUdWc2NHVnljeTlqYkdGemMwTmhiR3hEYUdWamF5NXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVaWGh3YjNKMGN5NWZYMlZ6VFc5a2RXeGxJRDBnZEhKMVpUdGNibHh1ZG1GeUlGOWtaV1pwYm1WUWNtOXdaWEowZVNBOUlISmxjWFZwY21Vb1hDSXVMaTlqYjNKbExXcHpMMjlpYW1WamRDOWtaV1pwYm1VdGNISnZjR1Z5ZEhsY0lpazdYRzVjYm5aaGNpQmZaR1ZtYVc1bFVISnZjR1Z5ZEhreUlEMGdYMmx1ZEdWeWIzQlNaWEYxYVhKbFJHVm1ZWFZzZENoZlpHVm1hVzVsVUhKdmNHVnlkSGtwTzF4dVhHNW1kVzVqZEdsdmJpQmZhVzUwWlhKdmNGSmxjWFZwY21WRVpXWmhkV3gwS0c5aWFpa2dleUJ5WlhSMWNtNGdiMkpxSUNZbUlHOWlhaTVmWDJWelRXOWtkV3hsSUQ4Z2IySnFJRG9nZXlCa1pXWmhkV3gwT2lCdlltb2dmVHNnZlZ4dVhHNWxlSEJ2Y25SekxtUmxabUYxYkhRZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lHWjFibU4wYVc5dUlHUmxabWx1WlZCeWIzQmxjblJwWlhNb2RHRnlaMlYwTENCd2NtOXdjeWtnZTF4dUlDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnY0hKdmNITXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUhaaGNpQmtaWE5qY21sd2RHOXlJRDBnY0hKdmNITmJhVjA3WEc0Z0lDQWdJQ0JrWlhOamNtbHdkRzl5TG1WdWRXMWxjbUZpYkdVZ1BTQmtaWE5qY21sd2RHOXlMbVZ1ZFcxbGNtRmliR1VnZkh3Z1ptRnNjMlU3WEc0Z0lDQWdJQ0JrWlhOamNtbHdkRzl5TG1OdmJtWnBaM1Z5WVdKc1pTQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCcFppQW9YQ0oyWVd4MVpWd2lJR2x1SUdSbGMyTnlhWEIwYjNJcElHUmxjMk55YVhCMGIzSXVkM0pwZEdGaWJHVWdQU0IwY25WbE8xeHVJQ0FnSUNBZ0tEQXNJRjlrWldacGJtVlFjbTl3WlhKMGVUSXVaR1ZtWVhWc2RDa29kR0Z5WjJWMExDQmtaWE5qY21sd2RHOXlMbXRsZVN3Z1pHVnpZM0pwY0hSdmNpazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHWjFibU4wYVc5dUlDaERiMjV6ZEhKMVkzUnZjaXdnY0hKdmRHOVFjbTl3Y3l3Z2MzUmhkR2xqVUhKdmNITXBJSHRjYmlBZ0lDQnBaaUFvY0hKdmRHOVFjbTl3Y3lrZ1pHVm1hVzVsVUhKdmNHVnlkR2xsY3loRGIyNXpkSEoxWTNSdmNpNXdjbTkwYjNSNWNHVXNJSEJ5YjNSdlVISnZjSE1wTzF4dUlDQWdJR2xtSUNoemRHRjBhV05RY205d2N5a2daR1ZtYVc1bFVISnZjR1Z5ZEdsbGN5aERiMjV6ZEhKMVkzUnZjaXdnYzNSaGRHbGpVSEp2Y0hNcE8xeHVJQ0FnSUhKbGRIVnliaUJEYjI1emRISjFZM1J2Y2p0Y2JpQWdmVHRjYm4wb0tUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlltRmlaV3d0Y25WdWRHbHRaUzlvWld4d1pYSnpMMk55WldGMFpVTnNZWE56TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZXlCY0ltUmxabUYxYkhSY0lqb2djbVZ4ZFdseVpTaGNJbU52Y21VdGFuTXZiR2xpY21GeWVTOW1iaTl2WW1wbFkzUXZaR1ZtYVc1bExYQnliM0JsY25SNVhDSXBMQ0JmWDJWelRXOWtkV3hsT2lCMGNuVmxJSDA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMkpoWW1Wc0xYSjFiblJwYldVdlkyOXlaUzFxY3k5dlltcGxZM1F2WkdWbWFXNWxMWEJ5YjNCbGNuUjVMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F6WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJbkpsY1hWcGNtVW9KeTR1THk0dUwyMXZaSFZzWlhNdlpYTTJMbTlpYW1WamRDNWtaV1pwYm1VdGNISnZjR1Z5ZEhrbktUdGNiblpoY2lBa1QySnFaV04wSUQwZ2NtVnhkV2x5WlNnbkxpNHZMaTR2Ylc5a2RXeGxjeTlmWTI5eVpTY3BMazlpYW1WamREdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdaR1ZtYVc1bFVISnZjR1Z5ZEhrb2FYUXNJR3RsZVN3Z1pHVnpZeWw3WEc0Z0lISmxkSFZ5YmlBa1QySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUjVLR2wwTENCclpYa3NJR1JsYzJNcE8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyWnVMMjlpYW1WamRDOWtaV1pwYm1VdGNISnZjR1Z5ZEhrdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEUmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWRtRnlJQ1JsZUhCdmNuUWdQU0J5WlhGMWFYSmxLQ2N1TDE5bGVIQnZjblFuS1R0Y2JpOHZJREU1TGpFdU1pNDBJQzhnTVRVdU1pNHpMallnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtFOHNJRkFzSUVGMGRISnBZblYwWlhNcFhHNGtaWGh3YjNKMEtDUmxlSEJ2Y25RdVV5QXJJQ1JsZUhCdmNuUXVSaUFxSUNGeVpYRjFhWEpsS0NjdUwxOWtaWE5qY21sd2RHOXljeWNwTENBblQySnFaV04wSnl3Z2UyUmxabWx1WlZCeWIzQmxjblI1T2lCeVpYRjFhWEpsS0NjdUwxOXZZbXBsWTNRdFpIQW5LUzVtZlNrN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMlZ6Tmk1dlltcGxZM1F1WkdWbWFXNWxMWEJ5YjNCbGNuUjVMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0ExWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCbmJHOWlZV3dnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTluYkc5aVlXd25LVnh1SUNBc0lHTnZjbVVnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJOdmNtVW5LVnh1SUNBc0lHTjBlQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJOMGVDY3BYRzRnSUN3Z2FHbGtaU0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYUdsa1pTY3BYRzRnSUN3Z1VGSlBWRTlVV1ZCRklEMGdKM0J5YjNSdmRIbHdaU2M3WEc1Y2JuWmhjaUFrWlhod2IzSjBJRDBnWm5WdVkzUnBiMjRvZEhsd1pTd2dibUZ0WlN3Z2MyOTFjbU5sS1h0Y2JpQWdkbUZ5SUVsVFgwWlBVa05GUkNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtaY2JpQWdJQ0FzSUVsVFgwZE1UMEpCVENBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtkY2JpQWdJQ0FzSUVsVFgxTlVRVlJKUXlBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGxOY2JpQWdJQ0FzSUVsVFgxQlNUMVJQSUNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGxCY2JpQWdJQ0FzSUVsVFgwSkpUa1FnSUNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtKY2JpQWdJQ0FzSUVsVFgxZFNRVkFnSUNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGxkY2JpQWdJQ0FzSUdWNGNHOXlkSE1nSUNBOUlFbFRYMGRNVDBKQlRDQS9JR052Y21VZ09pQmpiM0psVzI1aGJXVmRJSHg4SUNoamIzSmxXMjVoYldWZElEMGdlMzBwWEc0Z0lDQWdMQ0JsZUhCUWNtOTBieUFnUFNCbGVIQnZjblJ6VzFCU1QxUlBWRmxRUlYxY2JpQWdJQ0FzSUhSaGNtZGxkQ0FnSUNBOUlFbFRYMGRNVDBKQlRDQS9JR2RzYjJKaGJDQTZJRWxUWDFOVVFWUkpReUEvSUdkc2IySmhiRnR1WVcxbFhTQTZJQ2huYkc5aVlXeGJibUZ0WlYwZ2ZId2dlMzBwVzFCU1QxUlBWRmxRUlYxY2JpQWdJQ0FzSUd0bGVTd2diM2R1TENCdmRYUTdYRzRnSUdsbUtFbFRYMGRNVDBKQlRDbHpiM1Z5WTJVZ1BTQnVZVzFsTzF4dUlDQm1iM0lvYTJWNUlHbHVJSE52ZFhKalpTbDdYRzRnSUNBZ0x5OGdZMjl1ZEdGcGJuTWdhVzRnYm1GMGFYWmxYRzRnSUNBZ2IzZHVJRDBnSVVsVFgwWlBVa05GUkNBbUppQjBZWEpuWlhRZ0ppWWdkR0Z5WjJWMFcydGxlVjBnSVQwOUlIVnVaR1ZtYVc1bFpEdGNiaUFnSUNCcFppaHZkMjRnSmlZZ2EyVjVJR2x1SUdWNGNHOXlkSE1wWTI5dWRHbHVkV1U3WEc0Z0lDQWdMeThnWlhod2IzSjBJRzVoZEdsMlpTQnZjaUJ3WVhOelpXUmNiaUFnSUNCdmRYUWdQU0J2ZDI0Z1B5QjBZWEpuWlhSYmEyVjVYU0E2SUhOdmRYSmpaVnRyWlhsZE8xeHVJQ0FnSUM4dklIQnlaWFpsYm5RZ1oyeHZZbUZzSUhCdmJHeDFkR2x2YmlCbWIzSWdibUZ0WlhOd1lXTmxjMXh1SUNBZ0lHVjRjRzl5ZEhOYmEyVjVYU0E5SUVsVFgwZE1UMEpCVENBbUppQjBlWEJsYjJZZ2RHRnlaMlYwVzJ0bGVWMGdJVDBnSjJaMWJtTjBhVzl1SnlBL0lITnZkWEpqWlZ0clpYbGRYRzRnSUNBZ0x5OGdZbWx1WkNCMGFXMWxjbk1nZEc4Z1oyeHZZbUZzSUdadmNpQmpZV3hzSUdaeWIyMGdaWGh3YjNKMElHTnZiblJsZUhSY2JpQWdJQ0E2SUVsVFgwSkpUa1FnSmlZZ2IzZHVJRDhnWTNSNEtHOTFkQ3dnWjJ4dlltRnNLVnh1SUNBZ0lDOHZJSGR5WVhBZ1oyeHZZbUZzSUdOdmJuTjBjblZqZEc5eWN5Qm1iM0lnY0hKbGRtVnVkQ0JqYUdGdVoyVWdkR2hsYlNCcGJpQnNhV0p5WVhKNVhHNGdJQ0FnT2lCSlUxOVhVa0ZRSUNZbUlIUmhjbWRsZEZ0clpYbGRJRDA5SUc5MWRDQS9JQ2htZFc1amRHbHZiaWhES1h0Y2JpQWdJQ0FnSUhaaGNpQkdJRDBnWm5WdVkzUnBiMjRvWVN3Z1lpd2dZeWw3WEc0Z0lDQWdJQ0FnSUdsbUtIUm9hWE1nYVc1emRHRnVZMlZ2WmlCREtYdGNiaUFnSUNBZ0lDQWdJQ0J6ZDJsMFkyZ29ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDbDdYRzRnSUNBZ0lDQWdJQ0FnSUNCallYTmxJREE2SUhKbGRIVnliaUJ1WlhjZ1F6dGNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdNVG9nY21WMGRYSnVJRzVsZHlCREtHRXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRnpaU0F5T2lCeVpYUjFjbTRnYm1WM0lFTW9ZU3dnWWlrN1hHNGdJQ0FnSUNBZ0lDQWdmU0J5WlhSMWNtNGdibVYzSUVNb1lTd2dZaXdnWXlrN1hHNGdJQ0FnSUNBZ0lIMGdjbVYwZFhKdUlFTXVZWEJ3Ykhrb2RHaHBjeXdnWVhKbmRXMWxiblJ6S1R0Y2JpQWdJQ0FnSUgwN1hHNGdJQ0FnSUNCR1cxQlNUMVJQVkZsUVJWMGdQU0JEVzFCU1QxUlBWRmxRUlYwN1hHNGdJQ0FnSUNCeVpYUjFjbTRnUmp0Y2JpQWdJQ0F2THlCdFlXdGxJSE4wWVhScFl5QjJaWEp6YVc5dWN5Qm1iM0lnY0hKdmRHOTBlWEJsSUcxbGRHaHZaSE5jYmlBZ0lDQjlLU2h2ZFhRcElEb2dTVk5mVUZKUFZFOGdKaVlnZEhsd1pXOW1JRzkxZENBOVBTQW5ablZ1WTNScGIyNG5JRDhnWTNSNEtFWjFibU4wYVc5dUxtTmhiR3dzSUc5MWRDa2dPaUJ2ZFhRN1hHNGdJQ0FnTHk4Z1pYaHdiM0owSUhCeWIzUnZJRzFsZEdodlpITWdkRzhnWTI5eVpTNGxRMDlPVTFSU1ZVTlVUMUlsTG0xbGRHaHZaSE11SlU1QlRVVWxYRzRnSUNBZ2FXWW9TVk5mVUZKUFZFOHBlMXh1SUNBZ0lDQWdLR1Y0Y0c5eWRITXVkbWx5ZEhWaGJDQjhmQ0FvWlhod2IzSjBjeTUyYVhKMGRXRnNJRDBnZTMwcEtWdHJaWGxkSUQwZ2IzVjBPMXh1SUNBZ0lDQWdMeThnWlhod2IzSjBJSEJ5YjNSdklHMWxkR2h2WkhNZ2RHOGdZMjl5WlM0bFEwOU9VMVJTVlVOVVQxSWxMbkJ5YjNSdmRIbHdaUzRsVGtGTlJTVmNiaUFnSUNBZ0lHbG1LSFI1Y0dVZ0ppQWtaWGh3YjNKMExsSWdKaVlnWlhod1VISnZkRzhnSmlZZ0lXVjRjRkJ5YjNSdlcydGxlVjBwYUdsa1pTaGxlSEJRY205MGJ5d2dhMlY1TENCdmRYUXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dWZUdGNiaTh2SUhSNWNHVWdZbWwwYldGd1hHNGtaWGh3YjNKMExrWWdQU0F4T3lBZ0lDOHZJR1p2Y21ObFpGeHVKR1Y0Y0c5eWRDNUhJRDBnTWpzZ0lDQXZMeUJuYkc5aVlXeGNiaVJsZUhCdmNuUXVVeUE5SURRN0lDQWdMeThnYzNSaGRHbGpYRzRrWlhod2IzSjBMbEFnUFNBNE95QWdJQzh2SUhCeWIzUnZYRzRrWlhod2IzSjBMa0lnUFNBeE5qc2dJQzh2SUdKcGJtUmNiaVJsZUhCdmNuUXVWeUE5SURNeU95QWdMeThnZDNKaGNGeHVKR1Y0Y0c5eWRDNVZJRDBnTmpRN0lDQXZMeUJ6WVdabFhHNGtaWGh3YjNKMExsSWdQU0F4TWpnN0lDOHZJSEpsWVd3Z2NISnZkRzhnYldWMGFHOWtJR1p2Y2lCZ2JHbGljbUZ5ZVdBZ1hHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlDUmxlSEJ2Y25RN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlsZUhCdmNuUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lMeThnYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDNwc2IybHliMk5yTDJOdmNtVXRhbk12YVhOemRXVnpMemcySTJsemMzVmxZMjl0YldWdWRDMHhNVFUzTlRrd01qaGNiblpoY2lCbmJHOWlZV3dnUFNCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhSNWNHVnZaaUIzYVc1a2IzY2dJVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWWdkMmx1Wkc5M0xrMWhkR2dnUFQwZ1RXRjBhRnh1SUNBL0lIZHBibVJ2ZHlBNklIUjVjR1Z2WmlCelpXeG1JQ0U5SUNkMWJtUmxabWx1WldRbklDWW1JSE5sYkdZdVRXRjBhQ0E5UFNCTllYUm9JRDhnYzJWc1ppQTZJRVoxYm1OMGFXOXVLQ2R5WlhSMWNtNGdkR2hwY3ljcEtDazdYRzVwWmloMGVYQmxiMllnWDE5bklEMDlJQ2R1ZFcxaVpYSW5LVjlmWnlBOUlHZHNiMkpoYkRzZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJHbHVaU0J1YnkxMWJtUmxabHh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZloyeHZZbUZzTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBM1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQmpiM0psSUQwZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN2RtVnljMmx2YmpvZ0p6SXVOQzR3SjMwN1hHNXBaaWgwZVhCbGIyWWdYMTlsSUQwOUlDZHVkVzFpWlhJbktWOWZaU0E5SUdOdmNtVTdJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1VZ2JtOHRkVzVrWldaY2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMk52Y21VdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEaGNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aUx5OGdiM0IwYVc5dVlXd2dMeUJ6YVcxd2JHVWdZMjl1ZEdWNGRDQmlhVzVrYVc1blhHNTJZWElnWVVaMWJtTjBhVzl1SUQwZ2NtVnhkV2x5WlNnbkxpOWZZUzFtZFc1amRHbHZiaWNwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlobWJpd2dkR2hoZEN3Z2JHVnVaM1JvS1h0Y2JpQWdZVVoxYm1OMGFXOXVLR1p1S1R0Y2JpQWdhV1lvZEdoaGRDQTlQVDBnZFc1a1pXWnBibVZrS1hKbGRIVnliaUJtYmp0Y2JpQWdjM2RwZEdOb0tHeGxibWQwYUNsN1hHNGdJQ0FnWTJGelpTQXhPaUJ5WlhSMWNtNGdablZ1WTNScGIyNG9ZU2w3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabTR1WTJGc2JDaDBhR0YwTENCaEtUdGNiaUFnSUNCOU8xeHVJQ0FnSUdOaGMyVWdNam9nY21WMGRYSnVJR1oxYm1OMGFXOXVLR0VzSUdJcGUxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdadUxtTmhiR3dvZEdoaGRDd2dZU3dnWWlrN1hHNGdJQ0FnZlR0Y2JpQWdJQ0JqWVhObElETTZJSEpsZEhWeWJpQm1kVzVqZEdsdmJpaGhMQ0JpTENCaktYdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbWJpNWpZV3hzS0hSb1lYUXNJR0VzSUdJc0lHTXBPMXh1SUNBZ0lIMDdYRzRnSUgxY2JpQWdjbVYwZFhKdUlHWjFibU4wYVc5dUtDOHFJQzR1TG1GeVozTWdLaThwZTF4dUlDQWdJSEpsZEhWeWJpQm1iaTVoY0hCc2VTaDBhR0YwTENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0I5TzF4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJOMGVDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdPVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHbDBLWHRjYmlBZ2FXWW9kSGx3Wlc5bUlHbDBJQ0U5SUNkbWRXNWpkR2x2YmljcGRHaHliM2NnVkhsd1pVVnljbTl5S0dsMElDc2dKeUJwY3lCdWIzUWdZU0JtZFc1amRHbHZiaUVuS1R0Y2JpQWdjbVYwZFhKdUlHbDBPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMkV0Wm5WdVkzUnBiMjR1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURFd1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQmtVQ0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmIySnFaV04wTFdSd0p5bGNiaUFnTENCamNtVmhkR1ZFWlhOaklEMGdjbVZ4ZFdseVpTZ25MaTlmY0hKdmNHVnlkSGt0WkdWell5Y3BPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0J5WlhGMWFYSmxLQ2N1TDE5a1pYTmpjbWx3ZEc5eWN5Y3BJRDhnWm5WdVkzUnBiMjRvYjJKcVpXTjBMQ0JyWlhrc0lIWmhiSFZsS1h0Y2JpQWdjbVYwZFhKdUlHUlFMbVlvYjJKcVpXTjBMQ0JyWlhrc0lHTnlaV0YwWlVSbGMyTW9NU3dnZG1Gc2RXVXBLVHRjYm4wZ09pQm1kVzVqZEdsdmJpaHZZbXBsWTNRc0lHdGxlU3dnZG1Gc2RXVXBlMXh1SUNCdlltcGxZM1JiYTJWNVhTQTlJSFpoYkhWbE8xeHVJQ0J5WlhSMWNtNGdiMkpxWldOME8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyaHBaR1V1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURFeFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQmhiazlpYW1WamRDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMkZ1TFc5aWFtVmpkQ2NwWEc0Z0lDd2dTVVU0WDBSUFRWOUVSVVpKVGtVZ1BTQnlaWEYxYVhKbEtDY3VMMTlwWlRndFpHOXRMV1JsWm1sdVpTY3BYRzRnSUN3Z2RHOVFjbWx0YVhScGRtVWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOTBieTF3Y21sdGFYUnBkbVVuS1Z4dUlDQXNJR1JRSUNBZ0lDQWdJQ0FnSUNBZ0lEMGdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1TzF4dVhHNWxlSEJ2Y25SekxtWWdQU0J5WlhGMWFYSmxLQ2N1TDE5a1pYTmpjbWx3ZEc5eWN5Y3BJRDhnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUlEb2dablZ1WTNScGIyNGdaR1ZtYVc1bFVISnZjR1Z5ZEhrb1R5d2dVQ3dnUVhSMGNtbGlkWFJsY3lsN1hHNGdJR0Z1VDJKcVpXTjBLRThwTzF4dUlDQlFJRDBnZEc5UWNtbHRhWFJwZG1Vb1VDd2dkSEoxWlNrN1hHNGdJR0Z1VDJKcVpXTjBLRUYwZEhKcFluVjBaWE1wTzF4dUlDQnBaaWhKUlRoZlJFOU5YMFJGUmtsT1JTbDBjbmtnZTF4dUlDQWdJSEpsZEhWeWJpQmtVQ2hQTENCUUxDQkJkSFJ5YVdKMWRHVnpLVHRjYmlBZ2ZTQmpZWFJqYUNobEtYc2dMeW9nWlcxd2RIa2dLaThnZlZ4dUlDQnBaaWduWjJWMEp5QnBiaUJCZEhSeWFXSjFkR1Z6SUh4OElDZHpaWFFuSUdsdUlFRjBkSEpwWW5WMFpYTXBkR2h5YjNjZ1ZIbHdaVVZ5Y205eUtDZEJZMk5sYzNOdmNuTWdibTkwSUhOMWNIQnZjblJsWkNFbktUdGNiaUFnYVdZb0ozWmhiSFZsSnlCcGJpQkJkSFJ5YVdKMWRHVnpLVTliVUYwZ1BTQkJkSFJ5YVdKMWRHVnpMblpoYkhWbE8xeHVJQ0J5WlhSMWNtNGdUenRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTl2WW1wbFkzUXRaSEF1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURFeVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQnBjMDlpYW1WamRDQTlJSEpsY1hWcGNtVW9KeTR2WDJsekxXOWlhbVZqZENjcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHBkQ2w3WEc0Z0lHbG1LQ0ZwYzA5aWFtVmpkQ2hwZENrcGRHaHliM2NnVkhsd1pVVnljbTl5S0dsMElDc2dKeUJwY3lCdWIzUWdZVzRnYjJKcVpXTjBJU2NwTzF4dUlDQnlaWFIxY200Z2FYUTdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZZVzR0YjJKcVpXTjBMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F4TTF4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0p0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwS1h0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCcGRDQTlQVDBnSjI5aWFtVmpkQ2NnUHlCcGRDQWhQVDBnYm5Wc2JDQTZJSFI1Y0dWdlppQnBkQ0E5UFQwZ0oyWjFibU4wYVc5dUp6dGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXBjeTF2WW1wbFkzUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREUwWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJbTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdJWEpsY1hWcGNtVW9KeTR2WDJSbGMyTnlhWEIwYjNKekp5a2dKaVlnSVhKbGNYVnBjbVVvSnk0dlgyWmhhV3h6Snlrb1puVnVZM1JwYjI0b0tYdGNiaUFnY21WMGRYSnVJRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowZVNoeVpYRjFhWEpsS0NjdUwxOWtiMjB0WTNKbFlYUmxKeWtvSjJScGRpY3BMQ0FuWVNjc0lIdG5aWFE2SUdaMWJtTjBhVzl1S0NsN0lISmxkSFZ5YmlBM095QjlmU2t1WVNBaFBTQTNPMXh1ZlNrN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlwWlRndFpHOXRMV1JsWm1sdVpTNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVFZjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lMeThnVkdoaGJtc25jeUJKUlRnZ1ptOXlJR2hwY3lCbWRXNXVlU0JrWldacGJtVlFjbTl3WlhKMGVWeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQWhjbVZ4ZFdseVpTZ25MaTlmWm1GcGJITW5LU2htZFc1amRHbHZiaWdwZTF4dUlDQnlaWFIxY200Z1QySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUjVLSHQ5TENBbllTY3NJSHRuWlhRNklHWjFibU4wYVc5dUtDbDdJSEpsZEhWeWJpQTNPeUI5ZlNrdVlTQWhQU0EzTzF4dWZTazdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5a1pYTmpjbWx3ZEc5eWN5NXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVFpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaGxlR1ZqS1h0Y2JpQWdkSEo1SUh0Y2JpQWdJQ0J5WlhSMWNtNGdJU0ZsZUdWaktDazdYRzRnSUgwZ1kyRjBZMmdvWlNsN1hHNGdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJSDFjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTltWVdsc2N5NXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVGRjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lkbUZ5SUdselQySnFaV04wSUQwZ2NtVnhkV2x5WlNnbkxpOWZhWE10YjJKcVpXTjBKeWxjYmlBZ0xDQmtiMk4xYldWdWRDQTlJSEpsY1hWcGNtVW9KeTR2WDJkc2IySmhiQ2NwTG1SdlkzVnRaVzUwWEc0Z0lDOHZJR2x1SUc5c1pDQkpSU0IwZVhCbGIyWWdaRzlqZFcxbGJuUXVZM0psWVhSbFJXeGxiV1Z1ZENCcGN5QW5iMkpxWldOMEoxeHVJQ0FzSUdseklEMGdhWE5QWW1wbFkzUW9aRzlqZFcxbGJuUXBJQ1ltSUdselQySnFaV04wS0dSdlkzVnRaVzUwTG1OeVpXRjBaVVZzWlcxbGJuUXBPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhwZENsN1hHNGdJSEpsZEhWeWJpQnBjeUEvSUdSdlkzVnRaVzUwTG1OeVpXRjBaVVZzWlcxbGJuUW9hWFFwSURvZ2UzMDdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZaRzl0TFdOeVpXRjBaUzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTVRoY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpTHk4Z055NHhMakVnVkc5UWNtbHRhWFJwZG1Vb2FXNXdkWFFnV3l3Z1VISmxabVZ5Y21Wa1ZIbHdaVjBwWEc1MllYSWdhWE5QWW1wbFkzUWdQU0J5WlhGMWFYSmxLQ2N1TDE5cGN5MXZZbXBsWTNRbktUdGNiaTh2SUdsdWMzUmxZV1FnYjJZZ2RHaGxJRVZUTmlCemNHVmpJSFpsY25OcGIyNHNJSGRsSUdScFpHNG5kQ0JwYlhCc1pXMWxiblFnUUVCMGIxQnlhVzFwZEdsMlpTQmpZWE5sWEc0dkx5QmhibVFnZEdobElITmxZMjl1WkNCaGNtZDFiV1Z1ZENBdElHWnNZV2NnTFNCd2NtVm1aWEp5WldRZ2RIbHdaU0JwY3lCaElITjBjbWx1WjF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlocGRDd2dVeWw3WEc0Z0lHbG1LQ0ZwYzA5aWFtVmpkQ2hwZENrcGNtVjBkWEp1SUdsME8xeHVJQ0IyWVhJZ1ptNHNJSFpoYkR0Y2JpQWdhV1lvVXlBbUppQjBlWEJsYjJZZ0tHWnVJRDBnYVhRdWRHOVRkSEpwYm1jcElEMDlJQ2RtZFc1amRHbHZiaWNnSmlZZ0lXbHpUMkpxWldOMEtIWmhiQ0E5SUdadUxtTmhiR3dvYVhRcEtTbHlaWFIxY200Z2RtRnNPMXh1SUNCcFppaDBlWEJsYjJZZ0tHWnVJRDBnYVhRdWRtRnNkV1ZQWmlrZ1BUMGdKMloxYm1OMGFXOXVKeUFtSmlBaGFYTlBZbXBsWTNRb2RtRnNJRDBnWm00dVkyRnNiQ2hwZENrcEtYSmxkSFZ5YmlCMllXdzdYRzRnSUdsbUtDRlRJQ1ltSUhSNWNHVnZaaUFvWm00Z1BTQnBkQzUwYjFOMGNtbHVaeWtnUFQwZ0oyWjFibU4wYVc5dUp5QW1KaUFoYVhOUFltcGxZM1FvZG1Gc0lEMGdabTR1WTJGc2JDaHBkQ2twS1hKbGRIVnliaUIyWVd3N1hHNGdJSFJvY205M0lGUjVjR1ZGY25KdmNpaGNJa05oYmlkMElHTnZiblpsY25RZ2IySnFaV04wSUhSdklIQnlhVzFwZEdsMlpTQjJZV3gxWlZ3aUtUdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOTBieTF3Y21sdGFYUnBkbVV1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURFNVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvWW1sMGJXRndMQ0IyWVd4MVpTbDdYRzRnSUhKbGRIVnliaUI3WEc0Z0lDQWdaVzUxYldWeVlXSnNaU0FnT2lBaEtHSnBkRzFoY0NBbUlERXBMRnh1SUNBZ0lHTnZibVpwWjNWeVlXSnNaVG9nSVNoaWFYUnRZWEFnSmlBeUtTeGNiaUFnSUNCM2NtbDBZV0pzWlNBZ0lDQTZJQ0VvWW1sMGJXRndJQ1lnTkNrc1hHNGdJQ0FnZG1Gc2RXVWdJQ0FnSUNBZ09pQjJZV3gxWlZ4dUlDQjlPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM0J5YjNCbGNuUjVMV1JsYzJNdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlESXdYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0lpOHZMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdFhHNHZMMXh1THk4Z1VWSWdRMjlrWlNCSFpXNWxjbUYwYjNJZ1ptOXlJRXBoZG1GVFkzSnBjSFJjYmk4dlhHNHZMeUJEYjNCNWNtbG5hSFFnS0dNcElESXdNRGtnUzJGNmRXaHBhMjhnUVhKaGMyVmNiaTh2WEc0dkx5QlZVa3c2SUdoMGRIQTZMeTkzZDNjdVpDMXdjbTlxWldOMExtTnZiUzljYmk4dlhHNHZMeUJNYVdObGJuTmxaQ0IxYm1SbGNpQjBhR1VnVFVsVUlHeHBZMlZ1YzJVNlhHNHZMeUFnYUhSMGNEb3ZMM2QzZHk1dmNHVnVjMjkxY21ObExtOXlaeTlzYVdObGJuTmxjeTl0YVhRdGJHbGpaVzV6WlM1d2FIQmNiaTh2WEc0dkx5QlVhR1VnZDI5eVpDQW5VVklnUTI5a1pTY2dhWE1nY21WbmFYTjBaWEpsWkNCMGNtRmtaVzFoY21zZ2IyWmNiaTh2SUVSRlRsTlBJRmRCVmtVZ1NVNURUMUpRVDFKQlZFVkVYRzR2THlBZ2FIUjBjRG92TDNkM2R5NWtaVzV6YnkxM1lYWmxMbU52YlM5eGNtTnZaR1V2Wm1GeGNHRjBaVzUwTFdVdWFIUnRiRnh1THk5Y2JpOHZMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdFhHNWNiblpoY2lCeGNtTnZaR1VnUFNCbWRXNWpkR2x2YmlncElIdGNibHh1SUNBdkx5MHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFZ4dUlDQXZMeUJ4Y21OdlpHVmNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmx4dUlDQXZLaXBjYmlBZ0lDb2djWEpqYjJSbFhHNGdJQ0FxSUVCd1lYSmhiU0IwZVhCbFRuVnRZbVZ5SURFZ2RHOGdOREJjYmlBZ0lDb2dRSEJoY21GdElHVnljbTl5UTI5eWNtVmpkR2x2Ymt4bGRtVnNJQ2RNSnl3blRTY3NKMUVuTENkSUoxeHVJQ0FnS2k5Y2JpQWdkbUZ5SUhGeVkyOWtaU0E5SUdaMWJtTjBhVzl1S0hSNWNHVk9kVzFpWlhJc0lHVnljbTl5UTI5eWNtVmpkR2x2Ymt4bGRtVnNLU0I3WEc1Y2JpQWdJQ0IyWVhJZ1VFRkVNQ0E5SURCNFJVTTdYRzRnSUNBZ2RtRnlJRkJCUkRFZ1BTQXdlREV4TzF4dVhHNGdJQ0FnZG1GeUlGOTBlWEJsVG5WdFltVnlJRDBnZEhsd1pVNTFiV0psY2p0Y2JpQWdJQ0IyWVhJZ1gyVnljbTl5UTI5eWNtVmpkR2x2Ymt4bGRtVnNJRDBnVVZKRmNuSnZja052Y25KbFkzUnBiMjVNWlhabGJGdGxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiRjA3WEc0Z0lDQWdkbUZ5SUY5dGIyUjFiR1Z6SUQwZ2JuVnNiRHRjYmlBZ0lDQjJZWElnWDIxdlpIVnNaVU52ZFc1MElEMGdNRHRjYmlBZ0lDQjJZWElnWDJSaGRHRkRZV05vWlNBOUlHNTFiR3c3WEc0Z0lDQWdkbUZ5SUY5a1lYUmhUR2x6ZENBOUlHNWxkeUJCY25KaGVTZ3BPMXh1WEc0Z0lDQWdkbUZ5SUY5MGFHbHpJRDBnZTMwN1hHNWNiaUFnSUNCMllYSWdiV0ZyWlVsdGNHd2dQU0JtZFc1amRHbHZiaWgwWlhOMExDQnRZWE5yVUdGMGRHVnliaWtnZTF4dVhHNGdJQ0FnSUNCZmJXOWtkV3hsUTI5MWJuUWdQU0JmZEhsd1pVNTFiV0psY2lBcUlEUWdLeUF4Tnp0Y2JpQWdJQ0FnSUY5dGIyUjFiR1Z6SUQwZ1puVnVZM1JwYjI0b2JXOWtkV3hsUTI5MWJuUXBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHMXZaSFZzWlhNZ1BTQnVaWGNnUVhKeVlYa29iVzlrZFd4bFEyOTFiblFwTzF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCeWIzY2dQU0F3T3lCeWIzY2dQQ0J0YjJSMWJHVkRiM1Z1ZERzZ2NtOTNJQ3M5SURFcElIdGNiaUFnSUNBZ0lDQWdJQ0J0YjJSMWJHVnpXM0p2ZDEwZ1BTQnVaWGNnUVhKeVlYa29iVzlrZFd4bFEyOTFiblFwTzF4dUlDQWdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHTnZiQ0E5SURBN0lHTnZiQ0E4SUcxdlpIVnNaVU52ZFc1ME95QmpiMndnS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JXOWtkV3hsYzF0eWIzZGRXMk52YkYwZ1BTQnVkV3hzTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiVzlrZFd4bGN6dGNiaUFnSUNBZ0lIMG9YMjF2WkhWc1pVTnZkVzUwS1R0Y2JseHVJQ0FnSUNBZ2MyVjBkWEJRYjNOcGRHbHZibEJ5YjJKbFVHRjBkR1Z5Ymlnd0xDQXdLVHRjYmlBZ0lDQWdJSE5sZEhWd1VHOXphWFJwYjI1UWNtOWlaVkJoZEhSbGNtNG9YMjF2WkhWc1pVTnZkVzUwSUMwZ055d2dNQ2s3WEc0Z0lDQWdJQ0J6WlhSMWNGQnZjMmwwYVc5dVVISnZZbVZRWVhSMFpYSnVLREFzSUY5dGIyUjFiR1ZEYjNWdWRDQXRJRGNwTzF4dUlDQWdJQ0FnYzJWMGRYQlFiM05wZEdsdmJrRmthblZ6ZEZCaGRIUmxjbTRvS1R0Y2JpQWdJQ0FnSUhObGRIVndWR2x0YVc1blVHRjBkR1Z5YmlncE8xeHVJQ0FnSUNBZ2MyVjBkWEJVZVhCbFNXNW1ieWgwWlhOMExDQnRZWE5yVUdGMGRHVnliaWs3WEc1Y2JpQWdJQ0FnSUdsbUlDaGZkSGx3WlU1MWJXSmxjaUErUFNBM0tTQjdYRzRnSUNBZ0lDQWdJSE5sZEhWd1ZIbHdaVTUxYldKbGNpaDBaWE4wS1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLRjlrWVhSaFEyRmphR1VnUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNCZlpHRjBZVU5oWTJobElEMGdZM0psWVhSbFJHRjBZU2hmZEhsd1pVNTFiV0psY2l3Z1gyVnljbTl5UTI5eWNtVmpkR2x2Ymt4bGRtVnNMQ0JmWkdGMFlVeHBjM1FwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCdFlYQkVZWFJoS0Y5a1lYUmhRMkZqYUdVc0lHMWhjMnRRWVhSMFpYSnVLVHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdkbUZ5SUhObGRIVndVRzl6YVhScGIyNVFjbTlpWlZCaGRIUmxjbTRnUFNCbWRXNWpkR2x2YmloeWIzY3NJR052YkNrZ2UxeHVYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnlJRDBnTFRFN0lISWdQRDBnTnpzZ2NpQXJQU0F4S1NCN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0hKdmR5QXJJSElnUEQwZ0xURWdmSHdnWDIxdlpIVnNaVU52ZFc1MElEdzlJSEp2ZHlBcklISXBJR052Ym5ScGJuVmxPMXh1WEc0Z0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdNZ1BTQXRNVHNnWXlBOFBTQTNPeUJqSUNzOUlERXBJSHRjYmx4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2hqYjJ3Z0t5QmpJRHc5SUMweElIeDhJRjl0YjJSMWJHVkRiM1Z1ZENBOFBTQmpiMndnS3lCaktTQmpiMjUwYVc1MVpUdGNibHh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ2dLREFnUEQwZ2NpQW1KaUJ5SUR3OUlEWWdKaVlnS0dNZ1BUMGdNQ0I4ZkNCaklEMDlJRFlwSUNsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZkh3Z0tEQWdQRDBnWXlBbUppQmpJRHc5SURZZ0ppWWdLSElnUFQwZ01DQjhmQ0J5SUQwOUlEWXBJQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdmSHdnS0RJZ1BEMGdjaUFtSmlCeUlEdzlJRFFnSmlZZ01pQThQU0JqSUNZbUlHTWdQRDBnTkNrZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCZmJXOWtkV3hsYzF0eWIzY2dLeUJ5WFZ0amIyd2dLeUJqWFNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRjl0YjJSMWJHVnpXM0p2ZHlBcklISmRXMk52YkNBcklHTmRJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhaaGNpQm5aWFJDWlhOMFRXRnphMUJoZEhSbGNtNGdQU0JtZFc1amRHbHZiaWdwSUh0Y2JseHVJQ0FnSUNBZ2RtRnlJRzFwYmt4dmMzUlFiMmx1ZENBOUlEQTdYRzRnSUNBZ0lDQjJZWElnY0dGMGRHVnliaUE5SURBN1hHNWNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dPRHNnYVNBclBTQXhLU0I3WEc1Y2JpQWdJQ0FnSUNBZ2JXRnJaVWx0Y0d3b2RISjFaU3dnYVNrN1hHNWNiaUFnSUNBZ0lDQWdkbUZ5SUd4dmMzUlFiMmx1ZENBOUlGRlNWWFJwYkM1blpYUk1iM04wVUc5cGJuUW9YM1JvYVhNcE8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNocElEMDlJREFnZkh3Z2JXbHVURzl6ZEZCdmFXNTBJRDRnYkc5emRGQnZhVzUwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdiV2x1VEc5emRGQnZhVzUwSUQwZ2JHOXpkRkJ2YVc1ME8xeHVJQ0FnSUNBZ0lDQWdJSEJoZEhSbGNtNGdQU0JwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCd1lYUjBaWEp1TzF4dUlDQWdJSDA3WEc1Y2JpQWdJQ0IyWVhJZ2MyVjBkWEJVYVcxcGJtZFFZWFIwWlhKdUlEMGdablZ1WTNScGIyNG9LU0I3WEc1Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUhJZ1BTQTRPeUJ5SUR3Z1gyMXZaSFZzWlVOdmRXNTBJQzBnT0RzZ2NpQXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hmYlc5a2RXeGxjMXR5WFZzMlhTQWhQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1gyMXZaSFZzWlhOYmNsMWJObDBnUFNBb2NpQWxJRElnUFQwZ01DazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR01nUFNBNE95QmpJRHdnWDIxdlpIVnNaVU52ZFc1MElDMGdPRHNnWXlBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaGZiVzlrZFd4bGMxczJYVnRqWFNBaFBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnWDIxdlpIVnNaWE5iTmwxYlkxMGdQU0FvWXlBbElESWdQVDBnTUNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhaaGNpQnpaWFIxY0ZCdmMybDBhVzl1UVdScWRYTjBVR0YwZEdWeWJpQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dVhHNGdJQ0FnSUNCMllYSWdjRzl6SUQwZ1VWSlZkR2xzTG1kbGRGQmhkSFJsY201UWIzTnBkR2x2YmloZmRIbHdaVTUxYldKbGNpazdYRzVjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnY0c5ekxteGxibWQwYURzZ2FTQXJQU0F4S1NCN1hHNWNiaUFnSUNBZ0lDQWdabTl5SUNoMllYSWdhaUE5SURBN0lHb2dQQ0J3YjNNdWJHVnVaM1JvT3lCcUlDczlJREVwSUh0Y2JseHVJQ0FnSUNBZ0lDQWdJSFpoY2lCeWIzY2dQU0J3YjNOYmFWMDdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHTnZiQ0E5SUhCdmMxdHFYVHRjYmx4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2hmYlc5a2RXeGxjMXR5YjNkZFcyTnZiRjBnSVQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdjaUE5SUMweU95QnlJRHc5SURJN0lISWdLejBnTVNrZ2UxeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCaklEMGdMVEk3SUdNZ1BEMGdNanNnWXlBclBTQXhLU0I3WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tISWdQVDBnTFRJZ2ZId2djaUE5UFNBeUlIeDhJR01nUFQwZ0xUSWdmSHdnWXlBOVBTQXlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I4ZkNBb2NpQTlQU0F3SUNZbUlHTWdQVDBnTUNrZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdYMjF2WkhWc1pYTmJjbTkzSUNzZ2NsMWJZMjlzSUNzZ1kxMGdQU0IwY25WbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUY5dGIyUjFiR1Z6VzNKdmR5QXJJSEpkVzJOdmJDQXJJR05kSUQwZ1ptRnNjMlU3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5TzF4dVhHNGdJQ0FnZG1GeUlITmxkSFZ3Vkhsd1pVNTFiV0psY2lBOUlHWjFibU4wYVc5dUtIUmxjM1FwSUh0Y2JseHVJQ0FnSUNBZ2RtRnlJR0pwZEhNZ1BTQlJVbFYwYVd3dVoyVjBRa05JVkhsd1pVNTFiV0psY2loZmRIbHdaVTUxYldKbGNpazdYRzVjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnTVRnN0lHa2dLejBnTVNrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnYlc5a0lEMGdLQ0YwWlhOMElDWW1JQ2dnS0dKcGRITWdQajRnYVNrZ0ppQXhLU0E5UFNBeEtUdGNiaUFnSUNBZ0lDQWdYMjF2WkhWc1pYTmJUV0YwYUM1bWJHOXZjaWhwSUM4Z015bGRXMmtnSlNBeklDc2dYMjF2WkhWc1pVTnZkVzUwSUMwZ09DQXRJRE5kSUQwZ2JXOWtPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SURFNE95QnBJQ3M5SURFcElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUcxdlpDQTlJQ2doZEdWemRDQW1KaUFvSUNoaWFYUnpJRDQrSUdrcElDWWdNU2tnUFQwZ01TazdYRzRnSUNBZ0lDQWdJRjl0YjJSMWJHVnpXMmtnSlNBeklDc2dYMjF2WkhWc1pVTnZkVzUwSUMwZ09DQXRJRE5kVzAxaGRHZ3VabXh2YjNJb2FTQXZJRE1wWFNBOUlHMXZaRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdkbUZ5SUhObGRIVndWSGx3WlVsdVptOGdQU0JtZFc1amRHbHZiaWgwWlhOMExDQnRZWE5yVUdGMGRHVnliaWtnZTF4dVhHNGdJQ0FnSUNCMllYSWdaR0YwWVNBOUlDaGZaWEp5YjNKRGIzSnlaV04wYVc5dVRHVjJaV3dnUER3Z015a2dmQ0J0WVhOclVHRjBkR1Z5Ymp0Y2JpQWdJQ0FnSUhaaGNpQmlhWFJ6SUQwZ1VWSlZkR2xzTG1kbGRFSkRTRlI1Y0dWSmJtWnZLR1JoZEdFcE8xeHVYRzRnSUNBZ0lDQXZMeUIyWlhKMGFXTmhiRnh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0F4TlRzZ2FTQXJQU0F4S1NCN1hHNWNiaUFnSUNBZ0lDQWdkbUZ5SUcxdlpDQTlJQ2doZEdWemRDQW1KaUFvSUNoaWFYUnpJRDQrSUdrcElDWWdNU2tnUFQwZ01TazdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHa2dQQ0EyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdYMjF2WkhWc1pYTmJhVjFiT0YwZ1BTQnRiMlE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FTQThJRGdwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmZiVzlrZFd4bGMxdHBJQ3NnTVYxYk9GMGdQU0J0YjJRN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdYMjF2WkhWc1pYTmJYMjF2WkhWc1pVTnZkVzUwSUMwZ01UVWdLeUJwWFZzNFhTQTlJRzF2WkR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQXZMeUJvYjNKcGVtOXVkR0ZzWEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SURFMU95QnBJQ3M5SURFcElIdGNibHh1SUNBZ0lDQWdJQ0IyWVhJZ2JXOWtJRDBnS0NGMFpYTjBJQ1ltSUNnZ0tHSnBkSE1nUGo0Z2FTa2dKaUF4S1NBOVBTQXhLVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9hU0E4SURncElIdGNiaUFnSUNBZ0lDQWdJQ0JmYlc5a2RXeGxjMXM0WFZ0ZmJXOWtkV3hsUTI5MWJuUWdMU0JwSUMwZ01WMGdQU0J0YjJRN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9hU0E4SURrcElIdGNiaUFnSUNBZ0lDQWdJQ0JmYlc5a2RXeGxjMXM0WFZzeE5TQXRJR2tnTFNBeElDc2dNVjBnUFNCdGIyUTdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnWDIxdlpIVnNaWE5iT0YxYk1UVWdMU0JwSUMwZ01WMGdQU0J0YjJRN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdMeThnWm1sNFpXUWdiVzlrZFd4bFhHNGdJQ0FnSUNCZmJXOWtkV3hsYzF0ZmJXOWtkV3hsUTI5MWJuUWdMU0E0WFZzNFhTQTlJQ2doZEdWemRDazdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lIWmhjaUJ0WVhCRVlYUmhJRDBnWm5WdVkzUnBiMjRvWkdGMFlTd2diV0Z6YTFCaGRIUmxjbTRwSUh0Y2JseHVJQ0FnSUNBZ2RtRnlJR2x1WXlBOUlDMHhPMXh1SUNBZ0lDQWdkbUZ5SUhKdmR5QTlJRjl0YjJSMWJHVkRiM1Z1ZENBdElERTdYRzRnSUNBZ0lDQjJZWElnWW1sMFNXNWtaWGdnUFNBM08xeHVJQ0FnSUNBZ2RtRnlJR0o1ZEdWSmJtUmxlQ0E5SURBN1hHNGdJQ0FnSUNCMllYSWdiV0Z6YTBaMWJtTWdQU0JSVWxWMGFXd3VaMlYwVFdGemEwWjFibU4wYVc5dUtHMWhjMnRRWVhSMFpYSnVLVHRjYmx4dUlDQWdJQ0FnWm05eUlDaDJZWElnWTI5c0lEMGdYMjF2WkhWc1pVTnZkVzUwSUMwZ01Uc2dZMjlzSUQ0Z01Ec2dZMjlzSUMwOUlESXBJSHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9ZMjlzSUQwOUlEWXBJR052YkNBdFBTQXhPMXh1WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2gwY25WbEtTQjdYRzVjYmlBZ0lDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCaklEMGdNRHNnWXlBOElESTdJR01nS3owZ01Ta2dlMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvWDIxdlpIVnNaWE5iY205M1hWdGpiMndnTFNCalhTQTlQU0J1ZFd4c0tTQjdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUdSaGNtc2dQU0JtWVd4elpUdGNibHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvWW5sMFpVbHVaR1Y0SUR3Z1pHRjBZUzVzWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JrWVhKcklEMGdLQ0FvSUNoa1lYUmhXMko1ZEdWSmJtUmxlRjBnUGo0K0lHSnBkRWx1WkdWNEtTQW1JREVwSUQwOUlERXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUcxaGMyc2dQU0J0WVhOclJuVnVZeWh5YjNjc0lHTnZiQ0F0SUdNcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h0WVhOcktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdaR0Z5YXlBOUlDRmtZWEpyTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWDIxdlpIVnNaWE5iY205M1hWdGpiMndnTFNCalhTQTlJR1JoY21zN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdKcGRFbHVaR1Y0SUMwOUlERTdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0dKcGRFbHVaR1Y0SUQwOUlDMHhLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWW5sMFpVbHVaR1Y0SUNzOUlERTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbWwwU1c1a1pYZ2dQU0EzTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdjbTkzSUNzOUlHbHVZenRjYmx4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h5YjNjZ1BDQXdJSHg4SUY5dGIyUjFiR1ZEYjNWdWRDQThQU0J5YjNjcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKdmR5QXRQU0JwYm1NN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwYm1NZ1BTQXRhVzVqTzF4dUlDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVHRjYmx4dUlDQWdJSFpoY2lCamNtVmhkR1ZDZVhSbGN5QTlJR1oxYm1OMGFXOXVLR0oxWm1abGNpd2djbk5DYkc5amEzTXBJSHRjYmx4dUlDQWdJQ0FnZG1GeUlHOW1abk5sZENBOUlEQTdYRzVjYmlBZ0lDQWdJSFpoY2lCdFlYaEVZME52ZFc1MElEMGdNRHRjYmlBZ0lDQWdJSFpoY2lCdFlYaEZZME52ZFc1MElEMGdNRHRjYmx4dUlDQWdJQ0FnZG1GeUlHUmpaR0YwWVNBOUlHNWxkeUJCY25KaGVTaHljMEpzYjJOcmN5NXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2RtRnlJR1ZqWkdGMFlTQTlJRzVsZHlCQmNuSmhlU2h5YzBKc2IyTnJjeTVzWlc1bmRHZ3BPMXh1WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJ5SUQwZ01Ec2djaUE4SUhKelFteHZZMnR6TG14bGJtZDBhRHNnY2lBclBTQXhLU0I3WEc1Y2JpQWdJQ0FnSUNBZ2RtRnlJR1JqUTI5MWJuUWdQU0J5YzBKc2IyTnJjMXR5WFM1a1lYUmhRMjkxYm5RN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsWTBOdmRXNTBJRDBnY25OQ2JHOWphM05iY2wwdWRHOTBZV3hEYjNWdWRDQXRJR1JqUTI5MWJuUTdYRzVjYmlBZ0lDQWdJQ0FnYldGNFJHTkRiM1Z1ZENBOUlFMWhkR2d1YldGNEtHMWhlRVJqUTI5MWJuUXNJR1JqUTI5MWJuUXBPMXh1SUNBZ0lDQWdJQ0J0WVhoRlkwTnZkVzUwSUQwZ1RXRjBhQzV0WVhnb2JXRjRSV05EYjNWdWRDd2daV05EYjNWdWRDazdYRzVjYmlBZ0lDQWdJQ0FnWkdOa1lYUmhXM0pkSUQwZ2JtVjNJRUZ5Y21GNUtHUmpRMjkxYm5RcE8xeHVYRzRnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWkdOa1lYUmhXM0pkTG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1pHTmtZWFJoVzNKZFcybGRJRDBnTUhobVppQW1JR0oxWm1abGNpNW5aWFJDZFdabVpYSW9LVnRwSUNzZ2IyWm1jMlYwWFR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnZabVp6WlhRZ0t6MGdaR05EYjNWdWREdGNibHh1SUNBZ0lDQWdJQ0IyWVhJZ2NuTlFiMng1SUQwZ1VWSlZkR2xzTG1kbGRFVnljbTl5UTI5eWNtVmpkRkJ2YkhsdWIyMXBZV3dvWldORGIzVnVkQ2s3WEc0Z0lDQWdJQ0FnSUhaaGNpQnlZWGRRYjJ4NUlEMGdjWEpRYjJ4NWJtOXRhV0ZzS0dSalpHRjBZVnR5WFN3Z2NuTlFiMng1TG1kbGRFeGxibWQwYUNncElDMGdNU2s3WEc1Y2JpQWdJQ0FnSUNBZ2RtRnlJRzF2WkZCdmJIa2dQU0J5WVhkUWIyeDVMbTF2WkNoeWMxQnZiSGtwTzF4dUlDQWdJQ0FnSUNCbFkyUmhkR0ZiY2wwZ1BTQnVaWGNnUVhKeVlYa29jbk5RYjJ4NUxtZGxkRXhsYm1kMGFDZ3BJQzBnTVNrN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2daV05rWVhSaFczSmRMbXhsYm1kMGFEc2dhU0FyUFNBeEtTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHMXZaRWx1WkdWNElEMGdhU0FySUcxdlpGQnZiSGt1WjJWMFRHVnVaM1JvS0NrZ0xTQmxZMlJoZEdGYmNsMHViR1Z1WjNSb08xeHVJQ0FnSUNBZ0lDQWdJR1ZqWkdGMFlWdHlYVnRwWFNBOUlDaHRiMlJKYm1SbGVDQStQU0F3S1Q4Z2JXOWtVRzlzZVM1blpYUkJkQ2h0YjJSSmJtUmxlQ2tnT2lBd08xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSFpoY2lCMGIzUmhiRU52WkdWRGIzVnVkQ0E5SURBN1hHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElISnpRbXh2WTJ0ekxteGxibWQwYURzZ2FTQXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lIUnZkR0ZzUTI5a1pVTnZkVzUwSUNzOUlISnpRbXh2WTJ0elcybGRMblJ2ZEdGc1EyOTFiblE3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhaaGNpQmtZWFJoSUQwZ2JtVjNJRUZ5Y21GNUtIUnZkR0ZzUTI5a1pVTnZkVzUwS1R0Y2JpQWdJQ0FnSUhaaGNpQnBibVJsZUNBOUlEQTdYRzVjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYldGNFJHTkRiM1Z1ZERzZ2FTQXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlISWdQU0F3T3lCeUlEd2djbk5DYkc5amEzTXViR1Z1WjNSb095QnlJQ3M5SURFcElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2FTQThJR1JqWkdGMFlWdHlYUzVzWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0ZiYVc1a1pYaGRJRDBnWkdOa1lYUmhXM0pkVzJsZE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVc1a1pYZ2dLejBnTVR0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCdFlYaEZZME52ZFc1ME95QnBJQ3M5SURFcElIdGNiaUFnSUNBZ0lDQWdabTl5SUNoMllYSWdjaUE5SURBN0lISWdQQ0J5YzBKc2IyTnJjeTVzWlc1bmRHZzdJSElnS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHBJRHdnWldOa1lYUmhXM0pkTG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdaR0YwWVZ0cGJtUmxlRjBnUFNCbFkyUmhkR0ZiY2wxYmFWMDdYRzRnSUNBZ0lDQWdJQ0FnSUNCcGJtUmxlQ0FyUFNBeE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCeVpYUjFjbTRnWkdGMFlUdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ2RtRnlJR055WldGMFpVUmhkR0VnUFNCbWRXNWpkR2x2YmloMGVYQmxUblZ0WW1WeUxDQmxjbkp2Y2tOdmNuSmxZM1JwYjI1TVpYWmxiQ3dnWkdGMFlVeHBjM1FwSUh0Y2JseHVJQ0FnSUNBZ2RtRnlJSEp6UW14dlkydHpJRDBnVVZKU1UwSnNiMk5yTG1kbGRGSlRRbXh2WTJ0ektIUjVjR1ZPZFcxaVpYSXNJR1Z5Y205eVEyOXljbVZqZEdsdmJreGxkbVZzS1R0Y2JseHVJQ0FnSUNBZ2RtRnlJR0oxWm1abGNpQTlJSEZ5UW1sMFFuVm1abVZ5S0NrN1hHNWNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2daR0YwWVV4cGMzUXViR1Z1WjNSb095QnBJQ3M5SURFcElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdSaGRHRWdQU0JrWVhSaFRHbHpkRnRwWFR0Y2JpQWdJQ0FnSUNBZ1luVm1abVZ5TG5CMWRDaGtZWFJoTG1kbGRFMXZaR1VvS1N3Z05DazdYRzRnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvWkdGMFlTNW5aWFJNWlc1bmRHZ29LU3dnVVZKVmRHbHNMbWRsZEV4bGJtZDBhRWx1UW1sMGN5aGtZWFJoTG1kbGRFMXZaR1VvS1N3Z2RIbHdaVTUxYldKbGNpa2dLVHRjYmlBZ0lDQWdJQ0FnWkdGMFlTNTNjbWwwWlNoaWRXWm1aWElwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QmpZV3hqSUc1MWJTQnRZWGdnWkdGMFlTNWNiaUFnSUNBZ0lIWmhjaUIwYjNSaGJFUmhkR0ZEYjNWdWRDQTlJREE3WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUhKelFteHZZMnR6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUhSdmRHRnNSR0YwWVVOdmRXNTBJQ3M5SUhKelFteHZZMnR6VzJsZExtUmhkR0ZEYjNWdWREdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdhV1lnS0dKMVptWmxjaTVuWlhSTVpXNW5kR2hKYmtKcGRITW9LU0ErSUhSdmRHRnNSR0YwWVVOdmRXNTBJQ29nT0NrZ2UxeHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0oyTnZaR1VnYkdWdVozUm9JRzkyWlhKbWJHOTNMaUFvSjF4dUlDQWdJQ0FnSUNBZ0lDc2dZblZtWm1WeUxtZGxkRXhsYm1kMGFFbHVRbWwwY3lncFhHNGdJQ0FnSUNBZ0lDQWdLeUFuUGlkY2JpQWdJQ0FnSUNBZ0lDQXJJSFJ2ZEdGc1JHRjBZVU52ZFc1MElDb2dPRnh1SUNBZ0lDQWdJQ0FnSUNzZ0p5a25LVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1pXNWtJR052WkdWY2JpQWdJQ0FnSUdsbUlDaGlkV1ptWlhJdVoyVjBUR1Z1WjNSb1NXNUNhWFJ6S0NrZ0t5QTBJRHc5SUhSdmRHRnNSR0YwWVVOdmRXNTBJQ29nT0NrZ2UxeHVJQ0FnSUNBZ0lDQmlkV1ptWlhJdWNIVjBLREFzSURRcE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQXZMeUJ3WVdSa2FXNW5YRzRnSUNBZ0lDQjNhR2xzWlNBb1luVm1abVZ5TG1kbGRFeGxibWQwYUVsdVFtbDBjeWdwSUNVZ09DQWhQU0F3S1NCN1hHNGdJQ0FnSUNBZ0lHSjFabVpsY2k1d2RYUkNhWFFvWm1Gc2MyVXBPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0F2THlCd1lXUmthVzVuWEc0Z0lDQWdJQ0IzYUdsc1pTQW9kSEoxWlNrZ2UxeHVYRzRnSUNBZ0lDQWdJR2xtSUNoaWRXWm1aWEl1WjJWMFRHVnVaM1JvU1c1Q2FYUnpLQ2tnUGowZ2RHOTBZV3hFWVhSaFEyOTFiblFnS2lBNEtTQjdYRzRnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnWW5WbVptVnlMbkIxZENoUVFVUXdMQ0E0S1R0Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvWW5WbVptVnlMbWRsZEV4bGJtZDBhRWx1UW1sMGN5Z3BJRDQ5SUhSdmRHRnNSR0YwWVVOdmRXNTBJQ29nT0NrZ2UxeHVJQ0FnSUNBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvVUVGRU1Td2dPQ2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJqY21WaGRHVkNlWFJsY3loaWRXWm1aWElzSUhKelFteHZZMnR6S1R0Y2JpQWdJQ0I5TzF4dVhHNGdJQ0FnWDNSb2FYTXVZV1JrUkdGMFlTQTlJR1oxYm1OMGFXOXVLR1JoZEdFc0lHMXZaR1VwSUh0Y2JseHVJQ0FnSUNBZ2JXOWtaU0E5SUcxdlpHVWdmSHdnSjBKNWRHVW5PMXh1WEc0Z0lDQWdJQ0IyWVhJZ2JtVjNSR0YwWVNBOUlHNTFiR3c3WEc1Y2JpQWdJQ0FnSUhOM2FYUmphQ2h0YjJSbEtTQjdYRzRnSUNBZ0lDQmpZWE5sSUNkT2RXMWxjbWxqSnlBNlhHNGdJQ0FnSUNBZ0lHNWxkMFJoZEdFZ1BTQnhjazUxYldKbGNpaGtZWFJoS1R0Y2JpQWdJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdJQ0JqWVhObElDZEJiSEJvWVc1MWJXVnlhV01uSURwY2JpQWdJQ0FnSUNBZ2JtVjNSR0YwWVNBOUlIRnlRV3h3YUdGT2RXMG9aR0YwWVNrN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJQ0FnWTJGelpTQW5RbmwwWlNjZ09seHVJQ0FnSUNBZ0lDQnVaWGRFWVhSaElEMGdjWEk0UW1sMFFubDBaU2hrWVhSaEtUdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCallYTmxJQ2RMWVc1cWFTY2dPbHh1SUNBZ0lDQWdJQ0J1WlhkRVlYUmhJRDBnY1hKTFlXNXFhU2hrWVhSaEtUdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCa1pXWmhkV3gwSURwY2JpQWdJQ0FnSUNBZ2RHaHliM2NnSjIxdlpHVTZKeUFySUcxdlpHVTdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJRjlrWVhSaFRHbHpkQzV3ZFhOb0tHNWxkMFJoZEdFcE8xeHVJQ0FnSUNBZ1gyUmhkR0ZEWVdOb1pTQTlJRzUxYkd3N1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbWx6UkdGeWF5QTlJR1oxYm1OMGFXOXVLSEp2ZHl3Z1kyOXNLU0I3WEc0Z0lDQWdJQ0JwWmlBb2NtOTNJRHdnTUNCOGZDQmZiVzlrZFd4bFEyOTFiblFnUEQwZ2NtOTNJSHg4SUdOdmJDQThJREFnZkh3Z1gyMXZaSFZzWlVOdmRXNTBJRHc5SUdOdmJDa2dlMXh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9jbTkzSUNzZ0p5d25JQ3NnWTI5c0tUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxkSFZ5YmlCZmJXOWtkV3hsYzF0eWIzZGRXMk52YkYwN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbWRsZEUxdlpIVnNaVU52ZFc1MElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdYMjF2WkhWc1pVTnZkVzUwTzF4dUlDQWdJSDA3WEc1Y2JpQWdJQ0JmZEdocGN5NXRZV3RsSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQnRZV3RsU1cxd2JDaG1ZV3h6WlN3Z1oyVjBRbVZ6ZEUxaGMydFFZWFIwWlhKdUtDa2dLVHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdYM1JvYVhNdVkzSmxZWFJsVkdGaWJHVlVZV2NnUFNCbWRXNWpkR2x2YmloalpXeHNVMmw2WlN3Z2JXRnlaMmx1S1NCN1hHNWNiaUFnSUNBZ0lHTmxiR3hUYVhwbElEMGdZMlZzYkZOcGVtVWdmSHdnTWp0Y2JpQWdJQ0FnSUcxaGNtZHBiaUE5SUNoMGVYQmxiMllnYldGeVoybHVJRDA5SUNkMWJtUmxabWx1WldRbktUOGdZMlZzYkZOcGVtVWdLaUEwSURvZ2JXRnlaMmx1TzF4dVhHNGdJQ0FnSUNCMllYSWdjWEpJZEcxc0lEMGdKeWM3WEc1Y2JpQWdJQ0FnSUhGeVNIUnRiQ0FyUFNBblBIUmhZbXhsSUhOMGVXeGxQVndpSnp0Y2JpQWdJQ0FnSUhGeVNIUnRiQ0FyUFNBbklHSnZjbVJsY2kxM2FXUjBhRG9nTUhCNE95QmliM0prWlhJdGMzUjViR1U2SUc1dmJtVTdKenRjYmlBZ0lDQWdJSEZ5U0hSdGJDQXJQU0FuSUdKdmNtUmxjaTFqYjJ4c1lYQnpaVG9nWTI5c2JHRndjMlU3Snp0Y2JpQWdJQ0FnSUhGeVNIUnRiQ0FyUFNBbklIQmhaR1JwYm1jNklEQndlRHNnYldGeVoybHVPaUFuSUNzZ2JXRnlaMmx1SUNzZ0ozQjRPeWM3WEc0Z0lDQWdJQ0J4Y2toMGJXd2dLejBnSjF3aVBpYzdYRzRnSUNBZ0lDQnhja2gwYld3Z0t6MGdKengwWW05a2VUNG5PMXh1WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJ5SUQwZ01Ec2djaUE4SUY5MGFHbHpMbWRsZEUxdlpIVnNaVU52ZFc1MEtDazdJSElnS3owZ01Ta2dlMXh1WEc0Z0lDQWdJQ0FnSUhGeVNIUnRiQ0FyUFNBblBIUnlQaWM3WEc1Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ1l5QTlJREE3SUdNZ1BDQmZkR2hwY3k1blpYUk5iMlIxYkdWRGIzVnVkQ2dwT3lCaklDczlJREVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnhja2gwYld3Z0t6MGdKengwWkNCemRIbHNaVDFjSWljN1hHNGdJQ0FnSUNBZ0lDQWdjWEpJZEcxc0lDczlJQ2NnWW05eVpHVnlMWGRwWkhSb09pQXdjSGc3SUdKdmNtUmxjaTF6ZEhsc1pUb2dibTl1WlRzbk8xeHVJQ0FnSUNBZ0lDQWdJSEZ5U0hSdGJDQXJQU0FuSUdKdmNtUmxjaTFqYjJ4c1lYQnpaVG9nWTI5c2JHRndjMlU3Snp0Y2JpQWdJQ0FnSUNBZ0lDQnhja2gwYld3Z0t6MGdKeUJ3WVdSa2FXNW5PaUF3Y0hnN0lHMWhjbWRwYmpvZ01IQjRPeWM3WEc0Z0lDQWdJQ0FnSUNBZ2NYSklkRzFzSUNzOUlDY2dkMmxrZEdnNklDY2dLeUJqWld4c1UybDZaU0FySUNkd2VEc25PMXh1SUNBZ0lDQWdJQ0FnSUhGeVNIUnRiQ0FyUFNBbklHaGxhV2RvZERvZ0p5QXJJR05sYkd4VGFYcGxJQ3NnSjNCNE95YzdYRzRnSUNBZ0lDQWdJQ0FnY1hKSWRHMXNJQ3M5SUNjZ1ltRmphMmR5YjNWdVpDMWpiMnh2Y2pvZ0p6dGNiaUFnSUNBZ0lDQWdJQ0J4Y2toMGJXd2dLejBnWDNSb2FYTXVhWE5FWVhKcktISXNJR01wUHlBbkl6QXdNREF3TUNjZ09pQW5JMlptWm1abVppYzdYRzRnSUNBZ0lDQWdJQ0FnY1hKSWRHMXNJQ3M5SUNjN0p6dGNiaUFnSUNBZ0lDQWdJQ0J4Y2toMGJXd2dLejBnSjF3aUx6NG5PMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2NYSklkRzFzSUNzOUlDYzhMM1J5UGljN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lIRnlTSFJ0YkNBclBTQW5QQzkwWW05a2VUNG5PMXh1SUNBZ0lDQWdjWEpJZEcxc0lDczlJQ2M4TDNSaFlteGxQaWM3WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJ4Y2toMGJXdzdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lGOTBhR2x6TG1OeVpXRjBaVk4yWjFSaFp5QTlJR1oxYm1OMGFXOXVLR05sYkd4VGFYcGxMQ0J0WVhKbmFXNHBJSHRjYmx4dUlDQWdJQ0FnWTJWc2JGTnBlbVVnUFNCalpXeHNVMmw2WlNCOGZDQXlPMXh1SUNBZ0lDQWdiV0Z5WjJsdUlEMGdLSFI1Y0dWdlppQnRZWEpuYVc0Z1BUMGdKM1Z1WkdWbWFXNWxaQ2NwUHlCalpXeHNVMmw2WlNBcUlEUWdPaUJ0WVhKbmFXNDdYRzRnSUNBZ0lDQjJZWElnYzJsNlpTQTlJRjkwYUdsekxtZGxkRTF2WkhWc1pVTnZkVzUwS0NrZ0tpQmpaV3hzVTJsNlpTQXJJRzFoY21kcGJpQXFJREk3WEc0Z0lDQWdJQ0IyWVhJZ1l5d2diV01zSUhJc0lHMXlMQ0J4Y2xOMlp6MG5KeXdnY21WamREdGNibHh1SUNBZ0lDQWdjbVZqZENBOUlDZHNKeUFySUdObGJHeFRhWHBsSUNzZ0p5d3dJREFzSnlBcklHTmxiR3hUYVhwbElDdGNiaUFnSUNBZ0lDQWdKeUF0SnlBcklHTmxiR3hUYVhwbElDc2dKeXd3SURBc0xTY2dLeUJqWld4c1UybDZaU0FySUNkNklDYzdYRzVjYmlBZ0lDQWdJSEZ5VTNabklDczlJQ2M4YzNabkp6dGNiaUFnSUNBZ0lIRnlVM1puSUNzOUlDY2dkMmxrZEdnOVhDSW5JQ3NnYzJsNlpTQXJJQ2R3ZUZ3aUp6dGNiaUFnSUNBZ0lIRnlVM1puSUNzOUlDY2dhR1ZwWjJoMFBWd2lKeUFySUhOcGVtVWdLeUFuY0hoY0lpYzdYRzRnSUNBZ0lDQnhjbE4yWnlBclBTQW5JSGh0Ykc1elBWd2lhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtZGNJaWM3WEc0Z0lDQWdJQ0J4Y2xOMlp5QXJQU0FuUGljN1hHNGdJQ0FnSUNCeGNsTjJaeUFyUFNBblBIQmhkR2dnWkQxY0lpYzdYRzVjYmlBZ0lDQWdJR1p2Y2lBb2NpQTlJREE3SUhJZ1BDQmZkR2hwY3k1blpYUk5iMlIxYkdWRGIzVnVkQ2dwT3lCeUlDczlJREVwSUh0Y2JpQWdJQ0FnSUNBZ2JYSWdQU0J5SUNvZ1kyVnNiRk5wZW1VZ0t5QnRZWEpuYVc0N1hHNGdJQ0FnSUNBZ0lHWnZjaUFvWXlBOUlEQTdJR01nUENCZmRHaHBjeTVuWlhSTmIyUjFiR1ZEYjNWdWRDZ3BPeUJqSUNzOUlERXBJSHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9YM1JvYVhNdWFYTkVZWEpyS0hJc0lHTXBJQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdiV01nUFNCakttTmxiR3hUYVhwbEsyMWhjbWRwYmp0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEZ5VTNabklDczlJQ2ROSnlBcklHMWpJQ3NnSnl3bklDc2diWElnS3lCeVpXTjBPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnhjbE4yWnlBclBTQW5YQ0lnYzNSeWIydGxQVndpZEhKaGJuTndZWEpsYm5SY0lpQm1hV3hzUFZ3aVlteGhZMnRjSWk4K0p6dGNiaUFnSUNBZ0lIRnlVM1puSUNzOUlDYzhMM04yWno0bk8xeHVYRzRnSUNBZ0lDQnlaWFIxY200Z2NYSlRkbWM3WEc0Z0lDQWdmVHRjYmx4dUlDQWdJRjkwYUdsekxtTnlaV0YwWlVsdFoxUmhaeUE5SUdaMWJtTjBhVzl1S0dObGJHeFRhWHBsTENCdFlYSm5hVzRwSUh0Y2JseHVJQ0FnSUNBZ1kyVnNiRk5wZW1VZ1BTQmpaV3hzVTJsNlpTQjhmQ0F5TzF4dUlDQWdJQ0FnYldGeVoybHVJRDBnS0hSNWNHVnZaaUJ0WVhKbmFXNGdQVDBnSjNWdVpHVm1hVzVsWkNjcFB5QmpaV3hzVTJsNlpTQXFJRFFnT2lCdFlYSm5hVzQ3WEc1Y2JpQWdJQ0FnSUhaaGNpQnphWHBsSUQwZ1gzUm9hWE11WjJWMFRXOWtkV3hsUTI5MWJuUW9LU0FxSUdObGJHeFRhWHBsSUNzZ2JXRnlaMmx1SUNvZ01qdGNiaUFnSUNBZ0lIWmhjaUJ0YVc0Z1BTQnRZWEpuYVc0N1hHNGdJQ0FnSUNCMllYSWdiV0Y0SUQwZ2MybDZaU0F0SUcxaGNtZHBianRjYmx4dUlDQWdJQ0FnY21WMGRYSnVJR055WldGMFpVbHRaMVJoWnloemFYcGxMQ0J6YVhwbExDQm1kVzVqZEdsdmJpaDRMQ0I1S1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2h0YVc0Z1BEMGdlQ0FtSmlCNElEd2diV0Y0SUNZbUlHMXBiaUE4UFNCNUlDWW1JSGtnUENCdFlYZ3BJSHRjYmlBZ0lDQWdJQ0FnSUNCMllYSWdZeUE5SUUxaGRHZ3VabXh2YjNJb0lDaDRJQzBnYldsdUtTQXZJR05sYkd4VGFYcGxLVHRjYmlBZ0lDQWdJQ0FnSUNCMllYSWdjaUE5SUUxaGRHZ3VabXh2YjNJb0lDaDVJQzBnYldsdUtTQXZJR05sYkd4VGFYcGxLVHRjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnWDNSb2FYTXVhWE5FWVhKcktISXNJR01wUHlBd0lEb2dNVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnTVR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTQXBPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQmZkR2hwY3k1amNtVmhkR1ZKYldkUFltcGxZM1FnUFNCbWRXNWpkR2x2YmloalpXeHNVMmw2WlN3Z2JXRnlaMmx1S1NCN1hHNWNiaUFnSUNBZ0lHTmxiR3hUYVhwbElEMGdZMlZzYkZOcGVtVWdmSHdnTWp0Y2JpQWdJQ0FnSUcxaGNtZHBiaUE5SUNoMGVYQmxiMllnYldGeVoybHVJRDA5SUNkMWJtUmxabWx1WldRbktUOGdZMlZzYkZOcGVtVWdLaUEwSURvZ2JXRnlaMmx1TzF4dVhHNGdJQ0FnSUNCMllYSWdjMmw2WlNBOUlGOTBhR2x6TG1kbGRFMXZaSFZzWlVOdmRXNTBLQ2tnS2lCalpXeHNVMmw2WlNBcklHMWhjbWRwYmlBcUlESTdYRzRnSUNBZ0lDQjJZWElnYldsdUlEMGdiV0Z5WjJsdU8xeHVJQ0FnSUNBZ2RtRnlJRzFoZUNBOUlITnBlbVVnTFNCdFlYSm5hVzQ3WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJqY21WaGRHVkpiV2RQWW1wbFkzUW9jMmw2WlN3Z2MybDZaU3dnWm5WdVkzUnBiMjRvZUN3Z2VTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2JXbHVJRHc5SUhnZ0ppWWdlQ0E4SUcxaGVDQW1KaUJ0YVc0Z1BEMGdlU0FtSmlCNUlEd2diV0Y0S1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdNZ1BTQk5ZWFJvTG1ac2IyOXlLQ0FvZUNBdElHMXBiaWtnTHlCalpXeHNVMmw2WlNrN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUhJZ1BTQk5ZWFJvTG1ac2IyOXlLQ0FvZVNBdElHMXBiaWtnTHlCalpXeHNVMmw2WlNrN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlGOTBhR2x6TG1selJHRnlheWh5TENCaktUOGdNQ0E2SURFN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlERTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnS1R0Y2JpQWdJQ0I5TzF4dVhHNGdJQ0FnY21WMGRYSnVJRjkwYUdsek8xeHVJQ0I5TzF4dVhHNGdJQzh2TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRYRzRnSUM4dklIRnlZMjlrWlM1emRISnBibWRVYjBKNWRHVnpYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc1Y2JpQWdjWEpqYjJSbExuTjBjbWx1WjFSdlFubDBaWE1nUFNCbWRXNWpkR2x2YmloektTQjdYRzRnSUNBZ2RtRnlJR0o1ZEdWeklEMGdibVYzSUVGeWNtRjVLQ2s3WEc0Z0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0IyWVhJZ1l5QTlJSE11WTJoaGNrTnZaR1ZCZENocEtUdGNiaUFnSUNBZ0lHSjVkR1Z6TG5CMWMyZ29ZeUFtSURCNFptWXBPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnWW5sMFpYTTdYRzRnSUgwN1hHNWNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmlBZ0x5OGdjWEpqYjJSbExtTnlaV0YwWlZOMGNtbHVaMVJ2UW5sMFpYTmNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dRSEJoY21GdElIVnVhV052WkdWRVlYUmhJR0poYzJVMk5DQnpkSEpwYm1jZ2IyWWdZbmwwWlNCaGNuSmhlUzVjYmlBZ0lDb2dXekUyWW1sMElGVnVhV052WkdWZExGc3hObUpwZENCQ2VYUmxjMTBzSUM0dUxseHVJQ0FnS2lCQWNHRnlZVzBnYm5WdFEyaGhjbk5jYmlBZ0lDb3ZYRzRnSUhGeVkyOWtaUzVqY21WaGRHVlRkSEpwYm1kVWIwSjVkR1Z6SUQwZ1puVnVZM1JwYjI0b2RXNXBZMjlrWlVSaGRHRXNJRzUxYlVOb1lYSnpLU0I3WEc1Y2JpQWdJQ0F2THlCamNtVmhkR1VnWTI5dWRtVnljMmx2YmlCdFlYQXVYRzVjYmlBZ0lDQjJZWElnZFc1cFkyOWtaVTFoY0NBOUlHWjFibU4wYVc5dUtDa2dlMXh1WEc0Z0lDQWdJQ0IyWVhJZ1ltbHVJRDBnWW1GelpUWTBSR1ZqYjJSbFNXNXdkWFJUZEhKbFlXMG9kVzVwWTI5a1pVUmhkR0VwTzF4dUlDQWdJQ0FnZG1GeUlISmxZV1FnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdJZ1BTQmlhVzR1Y21WaFpDZ3BPMXh1SUNBZ0lDQWdJQ0JwWmlBb1lpQTlQU0F0TVNrZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCaU8xeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdkbUZ5SUdOdmRXNTBJRDBnTUR0Y2JpQWdJQ0FnSUhaaGNpQjFibWxqYjJSbFRXRndJRDBnZTMwN1hHNGdJQ0FnSUNCM2FHbHNaU0FvZEhKMVpTa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1lqQWdQU0JpYVc0dWNtVmhaQ2dwTzF4dUlDQWdJQ0FnSUNCcFppQW9ZakFnUFQwZ0xURXBJR0p5WldGck8xeHVJQ0FnSUNBZ0lDQjJZWElnWWpFZ1BTQnlaV0ZrS0NrN1hHNGdJQ0FnSUNBZ0lIWmhjaUJpTWlBOUlISmxZV1FvS1R0Y2JpQWdJQ0FnSUNBZ2RtRnlJR0l6SUQwZ2NtVmhaQ2dwTzF4dUlDQWdJQ0FnSUNCMllYSWdheUE5SUZOMGNtbHVaeTVtY205dFEyaGhja052WkdVb0lDaGlNQ0E4UENBNEtTQjhJR0l4S1R0Y2JpQWdJQ0FnSUNBZ2RtRnlJSFlnUFNBb1lqSWdQRHdnT0NrZ2ZDQmlNenRjYmlBZ0lDQWdJQ0FnZFc1cFkyOWtaVTFoY0Z0clhTQTlJSFk3WEc0Z0lDQWdJQ0FnSUdOdmRXNTBJQ3M5SURFN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCcFppQW9ZMjkxYm5RZ0lUMGdiblZ0UTJoaGNuTXBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLR052ZFc1MElDc2dKeUFoUFNBbklDc2diblZ0UTJoaGNuTXBPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkVzVwWTI5a1pVMWhjRHRjYmlBZ0lDQjlLQ2s3WEc1Y2JpQWdJQ0IyWVhJZ2RXNXJibTkzYmtOb1lYSWdQU0FuUHljdVkyaGhja052WkdWQmRDZ3dLVHRjYmx4dUlDQWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpaHpLU0I3WEc0Z0lDQWdJQ0IyWVhJZ1lubDBaWE1nUFNCdVpYY2dRWEp5WVhrb0tUdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2djeTVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1l5QTlJSE11WTJoaGNrTnZaR1ZCZENocEtUdGNiaUFnSUNBZ0lDQWdhV1lnS0dNZ1BDQXhNamdwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmllWFJsY3k1d2RYTm9LR01wTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lIWmhjaUJpSUQwZ2RXNXBZMjlrWlUxaGNGdHpMbU5vWVhKQmRDaHBLVjA3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLSFI1Y0dWdlppQmlJRDA5SUNkdWRXMWlaWEluS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb0lDaGlJQ1lnTUhobVppa2dQVDBnWWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QXhZbmwwWlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JpZVhSbGN5NXdkWE5vS0dJcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnTW1KNWRHVnpYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHSjVkR1Z6TG5CMWMyZ29ZaUErUGo0Z09DazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHSjVkR1Z6TG5CMWMyZ29ZaUFtSURCNFptWXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaWVYUmxjeTV3ZFhOb0tIVnVhMjV2ZDI1RGFHRnlLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxkSFZ5YmlCaWVYUmxjenRjYmlBZ0lDQjlPMXh1SUNCOU8xeHVYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc0Z0lDOHZJRkZTVFc5a1pWeHVJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1WEc0Z0lIWmhjaUJSVWsxdlpHVWdQU0I3WEc0Z0lDQWdUVTlFUlY5T1ZVMUNSVklnT2lBZ0lDQXhJRHc4SURBc1hHNGdJQ0FnVFU5RVJWOUJURkJJUVY5T1ZVMGdPaUF4SUR3OElERXNYRzRnSUNBZ1RVOUVSVjg0UWtsVVgwSlpWRVVnT2lBeElEdzhJRElzWEc0Z0lDQWdUVTlFUlY5TFFVNUtTU0E2SUNBZ0lDQXhJRHc4SUROY2JpQWdmVHRjYmx4dUlDQXZMeTB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVJQ0F2THlCUlVrVnljbTl5UTI5eWNtVmpkR2x2Ymt4bGRtVnNYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc1Y2JpQWdkbUZ5SUZGU1JYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXd2dQU0I3WEc0Z0lDQWdUQ0E2SURFc1hHNGdJQ0FnVFNBNklEQXNYRzRnSUNBZ1VTQTZJRE1zWEc0Z0lDQWdTQ0E2SURKY2JpQWdmVHRjYmx4dUlDQXZMeTB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVJQ0F2THlCUlVrMWhjMnRRWVhSMFpYSnVYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc1Y2JpQWdkbUZ5SUZGU1RXRnphMUJoZEhSbGNtNGdQU0I3WEc0Z0lDQWdVRUZVVkVWU1RqQXdNQ0E2SURBc1hHNGdJQ0FnVUVGVVZFVlNUakF3TVNBNklERXNYRzRnSUNBZ1VFRlVWRVZTVGpBeE1DQTZJRElzWEc0Z0lDQWdVRUZVVkVWU1RqQXhNU0E2SURNc1hHNGdJQ0FnVUVGVVZFVlNUakV3TUNBNklEUXNYRzRnSUNBZ1VFRlVWRVZTVGpFd01TQTZJRFVzWEc0Z0lDQWdVRUZVVkVWU1RqRXhNQ0E2SURZc1hHNGdJQ0FnVUVGVVZFVlNUakV4TVNBNklEZGNiaUFnZlR0Y2JseHVJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBdkx5QlJVbFYwYVd4Y2JpQWdMeTh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMWNibHh1SUNCMllYSWdVVkpWZEdsc0lEMGdablZ1WTNScGIyNG9LU0I3WEc1Y2JpQWdJQ0IyWVhJZ1VFRlVWRVZTVGw5UVQxTkpWRWxQVGw5VVFVSk1SU0E5SUZ0Y2JpQWdJQ0FnSUZ0ZExGeHVJQ0FnSUNBZ1d6WXNJREU0WFN4Y2JpQWdJQ0FnSUZzMkxDQXlNbDBzWEc0Z0lDQWdJQ0JiTml3Z01qWmRMRnh1SUNBZ0lDQWdXellzSURNd1hTeGNiaUFnSUNBZ0lGczJMQ0F6TkYwc1hHNGdJQ0FnSUNCYk5pd2dNaklzSURNNFhTeGNiaUFnSUNBZ0lGczJMQ0F5TkN3Z05ESmRMRnh1SUNBZ0lDQWdXellzSURJMkxDQTBObDBzWEc0Z0lDQWdJQ0JiTml3Z01qZ3NJRFV3WFN4Y2JpQWdJQ0FnSUZzMkxDQXpNQ3dnTlRSZExGeHVJQ0FnSUNBZ1d6WXNJRE15TENBMU9GMHNYRzRnSUNBZ0lDQmJOaXdnTXpRc0lEWXlYU3hjYmlBZ0lDQWdJRnMyTENBeU5pd2dORFlzSURZMlhTeGNiaUFnSUNBZ0lGczJMQ0F5Tml3Z05EZ3NJRGN3WFN4Y2JpQWdJQ0FnSUZzMkxDQXlOaXdnTlRBc0lEYzBYU3hjYmlBZ0lDQWdJRnMyTENBek1Dd2dOVFFzSURjNFhTeGNiaUFnSUNBZ0lGczJMQ0F6TUN3Z05UWXNJRGd5WFN4Y2JpQWdJQ0FnSUZzMkxDQXpNQ3dnTlRnc0lEZzJYU3hjYmlBZ0lDQWdJRnMyTENBek5Dd2dOaklzSURrd1hTeGNiaUFnSUNBZ0lGczJMQ0F5T0N3Z05UQXNJRGN5TENBNU5GMHNYRzRnSUNBZ0lDQmJOaXdnTWpZc0lEVXdMQ0EzTkN3Z09UaGRMRnh1SUNBZ0lDQWdXellzSURNd0xDQTFOQ3dnTnpnc0lERXdNbDBzWEc0Z0lDQWdJQ0JiTml3Z01qZ3NJRFUwTENBNE1Dd2dNVEEyWFN4Y2JpQWdJQ0FnSUZzMkxDQXpNaXdnTlRnc0lEZzBMQ0F4TVRCZExGeHVJQ0FnSUNBZ1d6WXNJRE13TENBMU9Dd2dPRFlzSURFeE5GMHNYRzRnSUNBZ0lDQmJOaXdnTXpRc0lEWXlMQ0E1TUN3Z01URTRYU3hjYmlBZ0lDQWdJRnMyTENBeU5pd2dOVEFzSURjMExDQTVPQ3dnTVRJeVhTeGNiaUFnSUNBZ0lGczJMQ0F6TUN3Z05UUXNJRGM0TENBeE1ESXNJREV5Tmwwc1hHNGdJQ0FnSUNCYk5pd2dNallzSURVeUxDQTNPQ3dnTVRBMExDQXhNekJkTEZ4dUlDQWdJQ0FnV3pZc0lETXdMQ0ExTml3Z09ESXNJREV3T0N3Z01UTTBYU3hjYmlBZ0lDQWdJRnMyTENBek5Dd2dOakFzSURnMkxDQXhNVElzSURFek9GMHNYRzRnSUNBZ0lDQmJOaXdnTXpBc0lEVTRMQ0E0Tml3Z01URTBMQ0F4TkRKZExGeHVJQ0FnSUNBZ1d6WXNJRE0wTENBMk1pd2dPVEFzSURFeE9Dd2dNVFEyWFN4Y2JpQWdJQ0FnSUZzMkxDQXpNQ3dnTlRRc0lEYzRMQ0F4TURJc0lERXlOaXdnTVRVd1hTeGNiaUFnSUNBZ0lGczJMQ0F5TkN3Z05UQXNJRGMyTENBeE1ESXNJREV5T0N3Z01UVTBYU3hjYmlBZ0lDQWdJRnMyTENBeU9Dd2dOVFFzSURnd0xDQXhNRFlzSURFek1pd2dNVFU0WFN4Y2JpQWdJQ0FnSUZzMkxDQXpNaXdnTlRnc0lEZzBMQ0F4TVRBc0lERXpOaXdnTVRZeVhTeGNiaUFnSUNBZ0lGczJMQ0F5Tml3Z05UUXNJRGd5TENBeE1UQXNJREV6T0N3Z01UWTJYU3hjYmlBZ0lDQWdJRnMyTENBek1Dd2dOVGdzSURnMkxDQXhNVFFzSURFME1pd2dNVGN3WFZ4dUlDQWdJRjA3WEc0Z0lDQWdkbUZ5SUVjeE5TQTlJQ2d4SUR3OElERXdLU0I4SUNneElEdzhJRGdwSUh3Z0tERWdQRHdnTlNrZ2ZDQW9NU0E4UENBMEtTQjhJQ2d4SUR3OElESXBJSHdnS0RFZ1BEd2dNU2tnZkNBb01TQThQQ0F3S1R0Y2JpQWdJQ0IyWVhJZ1J6RTRJRDBnS0RFZ1BEd2dNVElwSUh3Z0tERWdQRHdnTVRFcElId2dLREVnUER3Z01UQXBJSHdnS0RFZ1BEd2dPU2tnZkNBb01TQThQQ0E0S1NCOElDZ3hJRHc4SURVcElId2dLREVnUER3Z01pa2dmQ0FvTVNBOFBDQXdLVHRjYmlBZ0lDQjJZWElnUnpFMVgwMUJVMHNnUFNBb01TQThQQ0F4TkNrZ2ZDQW9NU0E4UENBeE1pa2dmQ0FvTVNBOFBDQXhNQ2tnZkNBb01TQThQQ0EwS1NCOElDZ3hJRHc4SURFcE8xeHVYRzRnSUNBZ2RtRnlJRjkwYUdseklEMGdlMzA3WEc1Y2JpQWdJQ0IyWVhJZ1oyVjBRa05JUkdsbmFYUWdQU0JtZFc1amRHbHZiaWhrWVhSaEtTQjdYRzRnSUNBZ0lDQjJZWElnWkdsbmFYUWdQU0F3TzF4dUlDQWdJQ0FnZDJocGJHVWdLR1JoZEdFZ0lUMGdNQ2tnZTF4dUlDQWdJQ0FnSUNCa2FXZHBkQ0FyUFNBeE8xeHVJQ0FnSUNBZ0lDQmtZWFJoSUQ0K1BqMGdNVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJSEpsZEhWeWJpQmthV2RwZER0Y2JpQWdJQ0I5TzF4dVhHNGdJQ0FnWDNSb2FYTXVaMlYwUWtOSVZIbHdaVWx1Wm04Z1BTQm1kVzVqZEdsdmJpaGtZWFJoS1NCN1hHNGdJQ0FnSUNCMllYSWdaQ0E5SUdSaGRHRWdQRHdnTVRBN1hHNGdJQ0FnSUNCM2FHbHNaU0FvWjJWMFFrTklSR2xuYVhRb1pDa2dMU0JuWlhSQ1EwaEVhV2RwZENoSE1UVXBJRDQ5SURBcElIdGNiaUFnSUNBZ0lDQWdaQ0JlUFNBb1J6RTFJRHc4SUNoblpYUkNRMGhFYVdkcGRDaGtLU0F0SUdkbGRFSkRTRVJwWjJsMEtFY3hOU2tnS1NBcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBkWEp1SUNnZ0tHUmhkR0VnUER3Z01UQXBJSHdnWkNrZ1hpQkhNVFZmVFVGVFN6dGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11WjJWMFFrTklWSGx3WlU1MWJXSmxjaUE5SUdaMWJtTjBhVzl1S0dSaGRHRXBJSHRjYmlBZ0lDQWdJSFpoY2lCa0lEMGdaR0YwWVNBOFBDQXhNanRjYmlBZ0lDQWdJSGRvYVd4bElDaG5aWFJDUTBoRWFXZHBkQ2hrS1NBdElHZGxkRUpEU0VScFoybDBLRWN4T0NrZ1BqMGdNQ2tnZTF4dUlDQWdJQ0FnSUNCa0lGNDlJQ2hITVRnZ1BEd2dLR2RsZEVKRFNFUnBaMmwwS0dRcElDMGdaMlYwUWtOSVJHbG5hWFFvUnpFNEtTQXBJQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdLR1JoZEdFZ1BEd2dNVElwSUh3Z1pEdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11WjJWMFVHRjBkR1Z5YmxCdmMybDBhVzl1SUQwZ1puVnVZM1JwYjI0b2RIbHdaVTUxYldKbGNpa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlGQkJWRlJGVWs1ZlVFOVRTVlJKVDA1ZlZFRkNURVZiZEhsd1pVNTFiV0psY2lBdElERmRPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQmZkR2hwY3k1blpYUk5ZWE5yUm5WdVkzUnBiMjRnUFNCbWRXNWpkR2x2YmlodFlYTnJVR0YwZEdWeWJpa2dlMXh1WEc0Z0lDQWdJQ0J6ZDJsMFkyZ2dLRzFoYzJ0UVlYUjBaWEp1S1NCN1hHNWNiaUFnSUNBZ0lHTmhjMlVnVVZKTllYTnJVR0YwZEdWeWJpNVFRVlJVUlZKT01EQXdJRHBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVLR2tzSUdvcElIc2djbVYwZFhKdUlDaHBJQ3NnYWlrZ0pTQXlJRDA5SURBN0lIMDdYRzRnSUNBZ0lDQmpZWE5sSUZGU1RXRnphMUJoZEhSbGNtNHVVRUZVVkVWU1RqQXdNU0E2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaWhwTENCcUtTQjdJSEpsZEhWeWJpQnBJQ1VnTWlBOVBTQXdPeUI5TzF4dUlDQWdJQ0FnWTJGelpTQlJVazFoYzJ0UVlYUjBaWEp1TGxCQlZGUkZVazR3TVRBZ09seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1puVnVZM1JwYjI0b2FTd2dhaWtnZXlCeVpYUjFjbTRnYWlBbElETWdQVDBnTURzZ2ZUdGNiaUFnSUNBZ0lHTmhjMlVnVVZKTllYTnJVR0YwZEdWeWJpNVFRVlJVUlZKT01ERXhJRHBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVLR2tzSUdvcElIc2djbVYwZFhKdUlDaHBJQ3NnYWlrZ0pTQXpJRDA5SURBN0lIMDdYRzRnSUNBZ0lDQmpZWE5sSUZGU1RXRnphMUJoZEhSbGNtNHVVRUZVVkVWU1RqRXdNQ0E2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaWhwTENCcUtTQjdJSEpsZEhWeWJpQW9UV0YwYUM1bWJHOXZjaWhwSUM4Z01pa2dLeUJOWVhSb0xtWnNiMjl5S0dvZ0x5QXpLU0FwSUNVZ01pQTlQU0F3T3lCOU8xeHVJQ0FnSUNBZ1kyRnpaU0JSVWsxaGMydFFZWFIwWlhKdUxsQkJWRlJGVWs0eE1ERWdPbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdablZ1WTNScGIyNG9hU3dnYWlrZ2V5QnlaWFIxY200Z0tHa2dLaUJxS1NBbElESWdLeUFvYVNBcUlHb3BJQ1VnTXlBOVBTQXdPeUI5TzF4dUlDQWdJQ0FnWTJGelpTQlJVazFoYzJ0UVlYUjBaWEp1TGxCQlZGUkZVazR4TVRBZ09seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1puVnVZM1JwYjI0b2FTd2dhaWtnZXlCeVpYUjFjbTRnS0NBb2FTQXFJR29wSUNVZ01pQXJJQ2hwSUNvZ2Fpa2dKU0F6S1NBbElESWdQVDBnTURzZ2ZUdGNiaUFnSUNBZ0lHTmhjMlVnVVZKTllYTnJVR0YwZEdWeWJpNVFRVlJVUlZKT01URXhJRHBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVLR2tzSUdvcElIc2djbVYwZFhKdUlDZ2dLR2tnS2lCcUtTQWxJRE1nS3lBb2FTQXJJR29wSUNVZ01pa2dKU0F5SUQwOUlEQTdJSDA3WEc1Y2JpQWdJQ0FnSUdSbFptRjFiSFFnT2x4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJKaFpDQnRZWE5yVUdGMGRHVnliam9uSUNzZ2JXRnphMUJoZEhSbGNtNHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzVjYmlBZ0lDQmZkR2hwY3k1blpYUkZjbkp2Y2tOdmNuSmxZM1JRYjJ4NWJtOXRhV0ZzSUQwZ1puVnVZM1JwYjI0b1pYSnliM0pEYjNKeVpXTjBUR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQjJZWElnWVNBOUlIRnlVRzlzZVc1dmJXbGhiQ2hiTVYwc0lEQXBPMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JsY25KdmNrTnZjbkpsWTNSTVpXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dUlDQWdJQ0FnSUNCaElEMGdZUzV0ZFd4MGFYQnNlU2h4Y2xCdmJIbHViMjFwWVd3b1d6RXNJRkZTVFdGMGFDNW5aWGh3S0drcFhTd2dNQ2tnS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGRIVnliaUJoTzF4dUlDQWdJSDA3WEc1Y2JpQWdJQ0JmZEdocGN5NW5aWFJNWlc1bmRHaEpia0pwZEhNZ1BTQm1kVzVqZEdsdmJpaHRiMlJsTENCMGVYQmxLU0I3WEc1Y2JpQWdJQ0FnSUdsbUlDZ3hJRHc5SUhSNWNHVWdKaVlnZEhsd1pTQThJREV3S1NCN1hHNWNiaUFnSUNBZ0lDQWdMeThnTVNBdElEbGNibHh1SUNBZ0lDQWdJQ0J6ZDJsMFkyZ29iVzlrWlNrZ2UxeHVJQ0FnSUNBZ0lDQmpZWE5sSUZGU1RXOWtaUzVOVDBSRlgwNVZUVUpGVWlBZ0lDQTZJSEpsZEhWeWJpQXhNRHRjYmlBZ0lDQWdJQ0FnWTJGelpTQlJVazF2WkdVdVRVOUVSVjlCVEZCSVFWOU9WVTBnT2lCeVpYUjFjbTRnT1R0Y2JpQWdJQ0FnSUNBZ1kyRnpaU0JSVWsxdlpHVXVUVTlFUlY4NFFrbFVYMEpaVkVVZ09pQnlaWFIxY200Z09EdGNiaUFnSUNBZ0lDQWdZMkZ6WlNCUlVrMXZaR1V1VFU5RVJWOUxRVTVLU1NBZ0lDQWdPaUJ5WlhSMWNtNGdPRHRjYmlBZ0lDQWdJQ0FnWkdWbVlYVnNkQ0E2WEc0Z0lDQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkdGIyUmxPaWNnS3lCdGIyUmxLVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1VnUENBeU55a2dlMXh1WEc0Z0lDQWdJQ0FnSUM4dklERXdJQzBnTWpaY2JseHVJQ0FnSUNBZ0lDQnpkMmwwWTJnb2JXOWtaU2tnZTF4dUlDQWdJQ0FnSUNCallYTmxJRkZTVFc5a1pTNU5UMFJGWDA1VlRVSkZVaUFnSUNBNklISmxkSFZ5YmlBeE1qdGNiaUFnSUNBZ0lDQWdZMkZ6WlNCUlVrMXZaR1V1VFU5RVJWOUJURkJJUVY5T1ZVMGdPaUJ5WlhSMWNtNGdNVEU3WEc0Z0lDQWdJQ0FnSUdOaGMyVWdVVkpOYjJSbExrMVBSRVZmT0VKSlZGOUNXVlJGSURvZ2NtVjBkWEp1SURFMk8xeHVJQ0FnSUNBZ0lDQmpZWE5sSUZGU1RXOWtaUzVOVDBSRlgwdEJUa3BKSUNBZ0lDQTZJSEpsZEhWeWJpQXhNRHRjYmlBZ0lDQWdJQ0FnWkdWbVlYVnNkQ0E2WEc0Z0lDQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkdGIyUmxPaWNnS3lCdGIyUmxLVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1VnUENBME1Ta2dlMXh1WEc0Z0lDQWdJQ0FnSUM4dklESTNJQzBnTkRCY2JseHVJQ0FnSUNBZ0lDQnpkMmwwWTJnb2JXOWtaU2tnZTF4dUlDQWdJQ0FnSUNCallYTmxJRkZTVFc5a1pTNU5UMFJGWDA1VlRVSkZVaUFnSUNBNklISmxkSFZ5YmlBeE5EdGNiaUFnSUNBZ0lDQWdZMkZ6WlNCUlVrMXZaR1V1VFU5RVJWOUJURkJJUVY5T1ZVMGdPaUJ5WlhSMWNtNGdNVE03WEc0Z0lDQWdJQ0FnSUdOaGMyVWdVVkpOYjJSbExrMVBSRVZmT0VKSlZGOUNXVlJGSURvZ2NtVjBkWEp1SURFMk8xeHVJQ0FnSUNBZ0lDQmpZWE5sSUZGU1RXOWtaUzVOVDBSRlgwdEJUa3BKSUNBZ0lDQTZJSEpsZEhWeWJpQXhNanRjYmlBZ0lDQWdJQ0FnWkdWbVlYVnNkQ0E2WEc0Z0lDQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkdGIyUmxPaWNnS3lCdGIyUmxLVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjNSNWNHVTZKeUFySUhSNWNHVXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzVjYmlBZ0lDQmZkR2hwY3k1blpYUk1iM04wVUc5cGJuUWdQU0JtZFc1amRHbHZiaWh4Y21OdlpHVXBJSHRjYmx4dUlDQWdJQ0FnZG1GeUlHMXZaSFZzWlVOdmRXNTBJRDBnY1hKamIyUmxMbWRsZEUxdlpIVnNaVU52ZFc1MEtDazdYRzVjYmlBZ0lDQWdJSFpoY2lCc2IzTjBVRzlwYm5RZ1BTQXdPMXh1WEc0Z0lDQWdJQ0F2THlCTVJWWkZUREZjYmx4dUlDQWdJQ0FnWm05eUlDaDJZWElnY205M0lEMGdNRHNnY205M0lEd2diVzlrZFd4bFEyOTFiblE3SUhKdmR5QXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHTnZiQ0E5SURBN0lHTnZiQ0E4SUcxdlpIVnNaVU52ZFc1ME95QmpiMndnS3owZ01Ta2dlMXh1WEc0Z0lDQWdJQ0FnSUNBZ2RtRnlJSE5oYldWRGIzVnVkQ0E5SURBN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdSaGNtc2dQU0J4Y21OdlpHVXVhWE5FWVhKcktISnZkeXdnWTI5c0tUdGNibHh1SUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUhJZ1BTQXRNVHNnY2lBOFBTQXhPeUJ5SUNzOUlERXBJSHRjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hKdmR5QXJJSElnUENBd0lIeDhJRzF2WkhWc1pVTnZkVzUwSUR3OUlISnZkeUFySUhJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR01nUFNBdE1Uc2dZeUE4UFNBeE95QmpJQ3M5SURFcElIdGNibHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvWTI5c0lDc2dZeUE4SURBZ2ZId2diVzlrZFd4bFEyOTFiblFnUEQwZ1kyOXNJQ3NnWXlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZiblJwYm5WbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSElnUFQwZ01DQW1KaUJqSUQwOUlEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoa1lYSnJJRDA5SUhGeVkyOWtaUzVwYzBSaGNtc29jbTkzSUNzZ2Npd2dZMjlzSUNzZ1l5a2dLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJGdFpVTnZkVzUwSUNzOUlERTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9jMkZ0WlVOdmRXNTBJRDRnTlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYkc5emRGQnZhVzUwSUNzOUlDZ3pJQ3NnYzJGdFpVTnZkVzUwSUMwZ05TazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQXZMeUJNUlZaRlRESmNibHh1SUNBZ0lDQWdabTl5SUNoMllYSWdjbTkzSUQwZ01Ec2djbTkzSUR3Z2JXOWtkV3hsUTI5MWJuUWdMU0F4T3lCeWIzY2dLejBnTVNrZ2UxeHVJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQmpiMndnUFNBd095QmpiMndnUENCdGIyUjFiR1ZEYjNWdWRDQXRJREU3SUdOdmJDQXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdOdmRXNTBJRDBnTUR0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvY1hKamIyUmxMbWx6UkdGeWF5aHliM2NzSUdOdmJDa2dLU0JqYjNWdWRDQXJQU0F4TzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h4Y21OdlpHVXVhWE5FWVhKcktISnZkeUFySURFc0lHTnZiQ2tnS1NCamIzVnVkQ0FyUFNBeE8xeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoeGNtTnZaR1V1YVhORVlYSnJLSEp2ZHl3Z1kyOXNJQ3NnTVNrZ0tTQmpiM1Z1ZENBclBTQXhPMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHhjbU52WkdVdWFYTkVZWEpyS0hKdmR5QXJJREVzSUdOdmJDQXJJREVwSUNrZ1kyOTFiblFnS3owZ01UdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb1kyOTFiblFnUFQwZ01DQjhmQ0JqYjNWdWRDQTlQU0EwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JzYjNOMFVHOXBiblFnS3owZ016dGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdURVZXUlV3elhHNWNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlISnZkeUE5SURBN0lISnZkeUE4SUcxdlpIVnNaVU52ZFc1ME95QnliM2NnS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJqYjJ3Z1BTQXdPeUJqYjJ3Z1BDQnRiMlIxYkdWRGIzVnVkQ0F0SURZN0lHTnZiQ0FyUFNBeEtTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ1ltSUNGeGNtTnZaR1V1YVhORVlYSnJLSEp2ZHl3Z1kyOXNJQ3NnTVNsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSmlZZ0lIRnlZMjlrWlM1cGMwUmhjbXNvY205M0xDQmpiMndnS3lBeUtWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBbUppQWdjWEpqYjJSbExtbHpSR0Z5YXloeWIzY3NJR052YkNBcklETXBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDWW1JQ0J4Y21OdlpHVXVhWE5FWVhKcktISnZkeXdnWTI5c0lDc2dOQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdKaVlnSVhGeVkyOWtaUzVwYzBSaGNtc29jbTkzTENCamIyd2dLeUExS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FtSmlBZ2NYSmpiMlJsTG1selJHRnlheWh5YjNjc0lHTnZiQ0FySURZcElDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JHOXpkRkJ2YVc1MElDczlJRFF3TzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJqYjJ3Z1BTQXdPeUJqYjJ3Z1BDQnRiMlIxYkdWRGIzVnVkRHNnWTI5c0lDczlJREVwSUh0Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2NtOTNJRDBnTURzZ2NtOTNJRHdnYlc5a2RXeGxRMjkxYm5RZ0xTQTJPeUJ5YjNjZ0t6MGdNU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h4Y21OdlpHVXVhWE5FWVhKcktISnZkeXdnWTI5c0tWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBbUppQWhjWEpqYjJSbExtbHpSR0Z5YXloeWIzY2dLeUF4TENCamIyd3BYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDWW1JQ0J4Y21OdlpHVXVhWE5FWVhKcktISnZkeUFySURJc0lHTnZiQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdKaVlnSUhGeVkyOWtaUzVwYzBSaGNtc29jbTkzSUNzZ015d2dZMjlzS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FtSmlBZ2NYSmpiMlJsTG1selJHRnlheWh5YjNjZ0t5QTBMQ0JqYjJ3cFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNZbUlDRnhjbU52WkdVdWFYTkVZWEpyS0hKdmR5QXJJRFVzSUdOdmJDbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0ppWWdJSEZ5WTI5a1pTNXBjMFJoY21zb2NtOTNJQ3NnTml3Z1kyOXNLU0FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR3h2YzNSUWIybHVkQ0FyUFNBME1EdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdURVZXUlV3MFhHNWNiaUFnSUNBZ0lIWmhjaUJrWVhKclEyOTFiblFnUFNBd08xeHVYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQmpiMndnUFNBd095QmpiMndnUENCdGIyUjFiR1ZEYjNWdWREc2dZMjlzSUNzOUlERXBJSHRjYmlBZ0lDQWdJQ0FnWm05eUlDaDJZWElnY205M0lEMGdNRHNnY205M0lEd2diVzlrZFd4bFEyOTFiblE3SUhKdmR5QXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hGeVkyOWtaUzVwYzBSaGNtc29jbTkzTENCamIyd3BJQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdaR0Z5YTBOdmRXNTBJQ3M5SURFN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhaaGNpQnlZWFJwYnlBOUlFMWhkR2d1WVdKektERXdNQ0FxSUdSaGNtdERiM1Z1ZENBdklHMXZaSFZzWlVOdmRXNTBJQzhnYlc5a2RXeGxRMjkxYm5RZ0xTQTFNQ2tnTHlBMU8xeHVJQ0FnSUNBZ2JHOXpkRkJ2YVc1MElDczlJSEpoZEdsdklDb2dNVEE3WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJzYjNOMFVHOXBiblE3WEc0Z0lDQWdmVHRjYmx4dUlDQWdJSEpsZEhWeWJpQmZkR2hwY3p0Y2JpQWdmU2dwTzF4dVhHNGdJQzh2TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRYRzRnSUM4dklGRlNUV0YwYUZ4dUlDQXZMeTB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVYRzRnSUhaaGNpQlJVazFoZEdnZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmx4dUlDQWdJSFpoY2lCRldGQmZWRUZDVEVVZ1BTQnVaWGNnUVhKeVlYa29NalUyS1R0Y2JpQWdJQ0IyWVhJZ1RFOUhYMVJCUWt4RklEMGdibVYzSUVGeWNtRjVLREkxTmlrN1hHNWNiaUFnSUNBdkx5QnBibWwwYVdGc2FYcGxJSFJoWW14bGMxeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z09Ec2dhU0FyUFNBeEtTQjdYRzRnSUNBZ0lDQkZXRkJmVkVGQ1RFVmJhVjBnUFNBeElEdzhJR2s3WEc0Z0lDQWdmVnh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0E0T3lCcElEd2dNalUyT3lCcElDczlJREVwSUh0Y2JpQWdJQ0FnSUVWWVVGOVVRVUpNUlZ0cFhTQTlJRVZZVUY5VVFVSk1SVnRwSUMwZ05GMWNiaUFnSUNBZ0lDQWdYaUJGV0ZCZlZFRkNURVZiYVNBdElEVmRYRzRnSUNBZ0lDQWdJRjRnUlZoUVgxUkJRa3hGVzJrZ0xTQTJYVnh1SUNBZ0lDQWdJQ0JlSUVWWVVGOVVRVUpNUlZ0cElDMGdPRjA3WEc0Z0lDQWdmVnh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dNalUxT3lCcElDczlJREVwSUh0Y2JpQWdJQ0FnSUV4UFIxOVVRVUpNUlZ0RldGQmZWRUZDVEVWYmFWMGdYU0E5SUdrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnZG1GeUlGOTBhR2x6SUQwZ2UzMDdYRzVjYmlBZ0lDQmZkR2hwY3k1bmJHOW5JRDBnWm5WdVkzUnBiMjRvYmlrZ2UxeHVYRzRnSUNBZ0lDQnBaaUFvYmlBOElERXBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RuYkc5bktDY2dLeUJ1SUNzZ0p5a25LVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnY21WMGRYSnVJRXhQUjE5VVFVSk1SVnR1WFR0Y2JpQWdJQ0I5TzF4dVhHNGdJQ0FnWDNSb2FYTXVaMlY0Y0NBOUlHWjFibU4wYVc5dUtHNHBJSHRjYmx4dUlDQWdJQ0FnZDJocGJHVWdLRzRnUENBd0tTQjdYRzRnSUNBZ0lDQWdJRzRnS3owZ01qVTFPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0IzYUdsc1pTQW9iaUErUFNBeU5UWXBJSHRjYmlBZ0lDQWdJQ0FnYmlBdFBTQXlOVFU3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJGV0ZCZlZFRkNURVZiYmwwN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNiaUFnZlNncE8xeHVYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc0Z0lDOHZJSEZ5VUc5c2VXNXZiV2xoYkZ4dUlDQXZMeTB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVYRzRnSUdaMWJtTjBhVzl1SUhGeVVHOXNlVzV2YldsaGJDaHVkVzBzSUhOb2FXWjBLU0I3WEc1Y2JpQWdJQ0JwWmlBb2RIbHdaVzltSUc1MWJTNXNaVzVuZEdnZ1BUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWh1ZFcwdWJHVnVaM1JvSUNzZ0p5OG5JQ3NnYzJocFpuUXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIWmhjaUJmYm5WdElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0IyWVhJZ2IyWm1jMlYwSUQwZ01EdGNiaUFnSUNBZ0lIZG9hV3hsSUNodlptWnpaWFFnUENCdWRXMHViR1Z1WjNSb0lDWW1JRzUxYlZ0dlptWnpaWFJkSUQwOUlEQXBJSHRjYmlBZ0lDQWdJQ0FnYjJabWMyVjBJQ3M5SURFN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCMllYSWdYMjUxYlNBOUlHNWxkeUJCY25KaGVTaHVkVzB1YkdWdVozUm9JQzBnYjJabWMyVjBJQ3NnYzJocFpuUXBPMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J1ZFcwdWJHVnVaM1JvSUMwZ2IyWm1jMlYwT3lCcElDczlJREVwSUh0Y2JpQWdJQ0FnSUNBZ1gyNTFiVnRwWFNBOUlHNTFiVnRwSUNzZ2IyWm1jMlYwWFR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGRIVnliaUJmYm5WdE8xeHVJQ0FnSUgwb0tUdGNibHh1SUNBZ0lIWmhjaUJmZEdocGN5QTlJSHQ5TzF4dVhHNGdJQ0FnWDNSb2FYTXVaMlYwUVhRZ1BTQm1kVzVqZEdsdmJpaHBibVJsZUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUY5dWRXMWJhVzVrWlhoZE8xeHVJQ0FnSUgwN1hHNWNiaUFnSUNCZmRHaHBjeTVuWlhSTVpXNW5kR2dnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCZmJuVnRMbXhsYm1kMGFEdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11YlhWc2RHbHdiSGtnUFNCbWRXNWpkR2x2YmlobEtTQjdYRzVjYmlBZ0lDQWdJSFpoY2lCdWRXMGdQU0J1WlhjZ1FYSnlZWGtvWDNSb2FYTXVaMlYwVEdWdVozUm9LQ2tnS3lCbExtZGxkRXhsYm1kMGFDZ3BJQzBnTVNrN1hHNWNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dYM1JvYVhNdVoyVjBUR1Z1WjNSb0tDazdJR2tnS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJxSUQwZ01Ec2dhaUE4SUdVdVoyVjBUR1Z1WjNSb0tDazdJR29nS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUc1MWJWdHBJQ3NnYWwwZ1hqMGdVVkpOWVhSb0xtZGxlSEFvVVZKTllYUm9MbWRzYjJjb1gzUm9hWE11WjJWMFFYUW9hU2tnS1NBcklGRlNUV0YwYUM1bmJHOW5LR1V1WjJWMFFYUW9haWtnS1NBcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSEpsZEhWeWJpQnhjbEJ2YkhsdWIyMXBZV3dvYm5WdExDQXdLVHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdYM1JvYVhNdWJXOWtJRDBnWm5WdVkzUnBiMjRvWlNrZ2UxeHVYRzRnSUNBZ0lDQnBaaUFvWDNSb2FYTXVaMlYwVEdWdVozUm9LQ2tnTFNCbExtZGxkRXhsYm1kMGFDZ3BJRHdnTUNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhaaGNpQnlZWFJwYnlBOUlGRlNUV0YwYUM1bmJHOW5LRjkwYUdsekxtZGxkRUYwS0RBcElDa2dMU0JSVWsxaGRHZ3VaMnh2WnlobExtZGxkRUYwS0RBcElDazdYRzVjYmlBZ0lDQWdJSFpoY2lCdWRXMGdQU0J1WlhjZ1FYSnlZWGtvWDNSb2FYTXVaMlYwVEdWdVozUm9LQ2tnS1R0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1gzUm9hWE11WjJWMFRHVnVaM1JvS0NrN0lHa2dLejBnTVNrZ2UxeHVJQ0FnSUNBZ0lDQnVkVzFiYVYwZ1BTQmZkR2hwY3k1blpYUkJkQ2hwS1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmxMbWRsZEV4bGJtZDBhQ2dwT3lCcElDczlJREVwSUh0Y2JpQWdJQ0FnSUNBZ2JuVnRXMmxkSUY0OUlGRlNUV0YwYUM1blpYaHdLRkZTVFdGMGFDNW5iRzluS0dVdVoyVjBRWFFvYVNrZ0tTQXJJSEpoZEdsdktUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdMeThnY21WamRYSnphWFpsSUdOaGJHeGNiaUFnSUNBZ0lISmxkSFZ5YmlCeGNsQnZiSGx1YjIxcFlXd29iblZ0TENBd0tTNXRiMlFvWlNrN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNiaUFnZlR0Y2JseHVJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBdkx5QlJVbEpUUW14dlkydGNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmx4dUlDQjJZWElnVVZKU1UwSnNiMk5ySUQwZ1puVnVZM1JwYjI0b0tTQjdYRzVjYmlBZ0lDQjJZWElnVWxOZlFreFBRMHRmVkVGQ1RFVWdQU0JiWEc1Y2JpQWdJQ0FnSUM4dklFeGNiaUFnSUNBZ0lDOHZJRTFjYmlBZ0lDQWdJQzh2SUZGY2JpQWdJQ0FnSUM4dklFaGNibHh1SUNBZ0lDQWdMeThnTVZ4dUlDQWdJQ0FnV3pFc0lESTJMQ0F4T1Ywc1hHNGdJQ0FnSUNCYk1Td2dNallzSURFMlhTeGNiaUFnSUNBZ0lGc3hMQ0F5Tml3Z01UTmRMRnh1SUNBZ0lDQWdXekVzSURJMkxDQTVYU3hjYmx4dUlDQWdJQ0FnTHk4Z01seHVJQ0FnSUNBZ1d6RXNJRFEwTENBek5GMHNYRzRnSUNBZ0lDQmJNU3dnTkRRc0lESTRYU3hjYmlBZ0lDQWdJRnN4TENBME5Dd2dNakpkTEZ4dUlDQWdJQ0FnV3pFc0lEUTBMQ0F4Tmwwc1hHNWNiaUFnSUNBZ0lDOHZJRE5jYmlBZ0lDQWdJRnN4TENBM01Dd2dOVFZkTEZ4dUlDQWdJQ0FnV3pFc0lEY3dMQ0EwTkYwc1hHNGdJQ0FnSUNCYk1pd2dNelVzSURFM1hTeGNiaUFnSUNBZ0lGc3lMQ0F6TlN3Z01UTmRMRnh1WEc0Z0lDQWdJQ0F2THlBMFhHNGdJQ0FnSUNCYk1Td2dNVEF3TENBNE1GMHNYRzRnSUNBZ0lDQmJNaXdnTlRBc0lETXlYU3hjYmlBZ0lDQWdJRnN5TENBMU1Dd2dNalJkTEZ4dUlDQWdJQ0FnV3pRc0lESTFMQ0E1WFN4Y2JseHVJQ0FnSUNBZ0x5OGdOVnh1SUNBZ0lDQWdXekVzSURFek5Dd2dNVEE0WFN4Y2JpQWdJQ0FnSUZzeUxDQTJOeXdnTkROZExGeHVJQ0FnSUNBZ1d6SXNJRE16TENBeE5Td2dNaXdnTXpRc0lERTJYU3hjYmlBZ0lDQWdJRnN5TENBek15d2dNVEVzSURJc0lETTBMQ0F4TWwwc1hHNWNiaUFnSUNBZ0lDOHZJRFpjYmlBZ0lDQWdJRnN5TENBNE5pd2dOamhkTEZ4dUlDQWdJQ0FnV3pRc0lEUXpMQ0F5TjEwc1hHNGdJQ0FnSUNCYk5Dd2dORE1zSURFNVhTeGNiaUFnSUNBZ0lGczBMQ0EwTXl3Z01UVmRMRnh1WEc0Z0lDQWdJQ0F2THlBM1hHNGdJQ0FnSUNCYk1pd2dPVGdzSURjNFhTeGNiaUFnSUNBZ0lGczBMQ0EwT1N3Z016RmRMRnh1SUNBZ0lDQWdXeklzSURNeUxDQXhOQ3dnTkN3Z016TXNJREUxWFN4Y2JpQWdJQ0FnSUZzMExDQXpPU3dnTVRNc0lERXNJRFF3TENBeE5GMHNYRzVjYmlBZ0lDQWdJQzh2SURoY2JpQWdJQ0FnSUZzeUxDQXhNakVzSURrM1hTeGNiaUFnSUNBZ0lGc3lMQ0EyTUN3Z016Z3NJRElzSURZeExDQXpPVjBzWEc0Z0lDQWdJQ0JiTkN3Z05EQXNJREU0TENBeUxDQTBNU3dnTVRsZExGeHVJQ0FnSUNBZ1d6UXNJRFF3TENBeE5Dd2dNaXdnTkRFc0lERTFYU3hjYmx4dUlDQWdJQ0FnTHk4Z09WeHVJQ0FnSUNBZ1d6SXNJREUwTml3Z01URTJYU3hjYmlBZ0lDQWdJRnN6TENBMU9Dd2dNellzSURJc0lEVTVMQ0F6TjEwc1hHNGdJQ0FnSUNCYk5Dd2dNellzSURFMkxDQTBMQ0F6Tnl3Z01UZGRMRnh1SUNBZ0lDQWdXelFzSURNMkxDQXhNaXdnTkN3Z016Y3NJREV6WFN4Y2JseHVJQ0FnSUNBZ0x5OGdNVEJjYmlBZ0lDQWdJRnN5TENBNE5pd2dOamdzSURJc0lEZzNMQ0EyT1Ywc1hHNGdJQ0FnSUNCYk5Dd2dOamtzSURRekxDQXhMQ0EzTUN3Z05EUmRMRnh1SUNBZ0lDQWdXellzSURRekxDQXhPU3dnTWl3Z05EUXNJREl3WFN4Y2JpQWdJQ0FnSUZzMkxDQTBNeXdnTVRVc0lESXNJRFEwTENBeE5sMHNYRzVjYmlBZ0lDQWdJQzh2SURFeFhHNGdJQ0FnSUNCYk5Dd2dNVEF4TENBNE1WMHNYRzRnSUNBZ0lDQmJNU3dnT0RBc0lEVXdMQ0EwTENBNE1Td2dOVEZkTEZ4dUlDQWdJQ0FnV3pRc0lEVXdMQ0F5TWl3Z05Dd2dOVEVzSURJelhTeGNiaUFnSUNBZ0lGc3pMQ0F6Tml3Z01USXNJRGdzSURNM0xDQXhNMTBzWEc1Y2JpQWdJQ0FnSUM4dklERXlYRzRnSUNBZ0lDQmJNaXdnTVRFMkxDQTVNaXdnTWl3Z01URTNMQ0E1TTEwc1hHNGdJQ0FnSUNCYk5pd2dOVGdzSURNMkxDQXlMQ0ExT1N3Z016ZGRMRnh1SUNBZ0lDQWdXelFzSURRMkxDQXlNQ3dnTml3Z05EY3NJREl4WFN4Y2JpQWdJQ0FnSUZzM0xDQTBNaXdnTVRRc0lEUXNJRFF6TENBeE5WMHNYRzVjYmlBZ0lDQWdJQzh2SURFelhHNGdJQ0FnSUNCYk5Dd2dNVE16TENBeE1EZGRMRnh1SUNBZ0lDQWdXemdzSURVNUxDQXpOeXdnTVN3Z05qQXNJRE00WFN4Y2JpQWdJQ0FnSUZzNExDQTBOQ3dnTWpBc0lEUXNJRFExTENBeU1WMHNYRzRnSUNBZ0lDQmJNVElzSURNekxDQXhNU3dnTkN3Z016UXNJREV5WFN4Y2JseHVJQ0FnSUNBZ0x5OGdNVFJjYmlBZ0lDQWdJRnN6TENBeE5EVXNJREV4TlN3Z01Td2dNVFEyTENBeE1UWmRMRnh1SUNBZ0lDQWdXelFzSURZMExDQTBNQ3dnTlN3Z05qVXNJRFF4WFN4Y2JpQWdJQ0FnSUZzeE1Td2dNellzSURFMkxDQTFMQ0F6Tnl3Z01UZGRMRnh1SUNBZ0lDQWdXekV4TENBek5pd2dNVElzSURVc0lETTNMQ0F4TTEwc1hHNWNiaUFnSUNBZ0lDOHZJREUxWEc0Z0lDQWdJQ0JiTlN3Z01UQTVMQ0E0Tnl3Z01Td2dNVEV3TENBNE9GMHNYRzRnSUNBZ0lDQmJOU3dnTmpVc0lEUXhMQ0ExTENBMk5pd2dOREpkTEZ4dUlDQWdJQ0FnV3pVc0lEVTBMQ0F5TkN3Z055d2dOVFVzSURJMVhTeGNiaUFnSUNBZ0lGc3hNU3dnTXpZc0lERXlMQ0EzTENBek55d2dNVE5kTEZ4dVhHNGdJQ0FnSUNBdkx5QXhObHh1SUNBZ0lDQWdXelVzSURFeU1pd2dPVGdzSURFc0lERXlNeXdnT1RsZExGeHVJQ0FnSUNBZ1d6Y3NJRGN6TENBME5Td2dNeXdnTnpRc0lEUTJYU3hjYmlBZ0lDQWdJRnN4TlN3Z05ETXNJREU1TENBeUxDQTBOQ3dnTWpCZExGeHVJQ0FnSUNBZ1d6TXNJRFExTENBeE5Td2dNVE1zSURRMkxDQXhObDBzWEc1Y2JpQWdJQ0FnSUM4dklERTNYRzRnSUNBZ0lDQmJNU3dnTVRNMUxDQXhNRGNzSURVc0lERXpOaXdnTVRBNFhTeGNiaUFnSUNBZ0lGc3hNQ3dnTnpRc0lEUTJMQ0F4TENBM05Td2dORGRkTEZ4dUlDQWdJQ0FnV3pFc0lEVXdMQ0F5TWl3Z01UVXNJRFV4TENBeU0xMHNYRzRnSUNBZ0lDQmJNaXdnTkRJc0lERTBMQ0F4Tnl3Z05ETXNJREUxWFN4Y2JseHVJQ0FnSUNBZ0x5OGdNVGhjYmlBZ0lDQWdJRnMxTENBeE5UQXNJREV5TUN3Z01Td2dNVFV4TENBeE1qRmRMRnh1SUNBZ0lDQWdXemtzSURZNUxDQTBNeXdnTkN3Z056QXNJRFEwWFN4Y2JpQWdJQ0FnSUZzeE55d2dOVEFzSURJeUxDQXhMQ0ExTVN3Z01qTmRMRnh1SUNBZ0lDQWdXeklzSURReUxDQXhOQ3dnTVRrc0lEUXpMQ0F4TlYwc1hHNWNiaUFnSUNBZ0lDOHZJREU1WEc0Z0lDQWdJQ0JiTXl3Z01UUXhMQ0F4TVRNc0lEUXNJREUwTWl3Z01URTBYU3hjYmlBZ0lDQWdJRnN6TENBM01Dd2dORFFzSURFeExDQTNNU3dnTkRWZExGeHVJQ0FnSUNBZ1d6RTNMQ0EwTnl3Z01qRXNJRFFzSURRNExDQXlNbDBzWEc0Z0lDQWdJQ0JiT1N3Z016a3NJREV6TENBeE5pd2dOREFzSURFMFhTeGNibHh1SUNBZ0lDQWdMeThnTWpCY2JpQWdJQ0FnSUZzekxDQXhNelVzSURFd055d2dOU3dnTVRNMkxDQXhNRGhkTEZ4dUlDQWdJQ0FnV3pNc0lEWTNMQ0EwTVN3Z01UTXNJRFk0TENBME1sMHNYRzRnSUNBZ0lDQmJNVFVzSURVMExDQXlOQ3dnTlN3Z05UVXNJREkxWFN4Y2JpQWdJQ0FnSUZzeE5Td2dORE1zSURFMUxDQXhNQ3dnTkRRc0lERTJYU3hjYmx4dUlDQWdJQ0FnTHk4Z01qRmNiaUFnSUNBZ0lGczBMQ0F4TkRRc0lERXhOaXdnTkN3Z01UUTFMQ0F4TVRkZExGeHVJQ0FnSUNBZ1d6RTNMQ0EyT0N3Z05ESmRMRnh1SUNBZ0lDQWdXekUzTENBMU1Dd2dNaklzSURZc0lEVXhMQ0F5TTEwc1hHNGdJQ0FnSUNCYk1Ua3NJRFEyTENBeE5pd2dOaXdnTkRjc0lERTNYU3hjYmx4dUlDQWdJQ0FnTHk4Z01qSmNiaUFnSUNBZ0lGc3lMQ0F4TXprc0lERXhNU3dnTnl3Z01UUXdMQ0F4TVRKZExGeHVJQ0FnSUNBZ1d6RTNMQ0EzTkN3Z05EWmRMRnh1SUNBZ0lDQWdXemNzSURVMExDQXlOQ3dnTVRZc0lEVTFMQ0F5TlYwc1hHNGdJQ0FnSUNCYk16UXNJRE0zTENBeE0xMHNYRzVjYmlBZ0lDQWdJQzh2SURJelhHNGdJQ0FnSUNCYk5Dd2dNVFV4TENBeE1qRXNJRFVzSURFMU1pd2dNVEl5WFN4Y2JpQWdJQ0FnSUZzMExDQTNOU3dnTkRjc0lERTBMQ0EzTml3Z05EaGRMRnh1SUNBZ0lDQWdXekV4TENBMU5Dd2dNalFzSURFMExDQTFOU3dnTWpWZExGeHVJQ0FnSUNBZ1d6RTJMQ0EwTlN3Z01UVXNJREUwTENBME5pd2dNVFpkTEZ4dVhHNGdJQ0FnSUNBdkx5QXlORnh1SUNBZ0lDQWdXellzSURFME55d2dNVEUzTENBMExDQXhORGdzSURFeE9GMHNYRzRnSUNBZ0lDQmJOaXdnTnpNc0lEUTFMQ0F4TkN3Z056UXNJRFEyWFN4Y2JpQWdJQ0FnSUZzeE1Td2dOVFFzSURJMExDQXhOaXdnTlRVc0lESTFYU3hjYmlBZ0lDQWdJRnN6TUN3Z05EWXNJREUyTENBeUxDQTBOeXdnTVRkZExGeHVYRzRnSUNBZ0lDQXZMeUF5TlZ4dUlDQWdJQ0FnV3pnc0lERXpNaXdnTVRBMkxDQTBMQ0F4TXpNc0lERXdOMTBzWEc0Z0lDQWdJQ0JiT0N3Z056VXNJRFEzTENBeE15d2dOellzSURRNFhTeGNiaUFnSUNBZ0lGczNMQ0ExTkN3Z01qUXNJREl5TENBMU5Td2dNalZkTEZ4dUlDQWdJQ0FnV3pJeUxDQTBOU3dnTVRVc0lERXpMQ0EwTml3Z01UWmRMRnh1WEc0Z0lDQWdJQ0F2THlBeU5seHVJQ0FnSUNBZ1d6RXdMQ0F4TkRJc0lERXhOQ3dnTWl3Z01UUXpMQ0F4TVRWZExGeHVJQ0FnSUNBZ1d6RTVMQ0EzTkN3Z05EWXNJRFFzSURjMUxDQTBOMTBzWEc0Z0lDQWdJQ0JiTWpnc0lEVXdMQ0F5TWl3Z05pd2dOVEVzSURJelhTeGNiaUFnSUNBZ0lGc3pNeXdnTkRZc0lERTJMQ0EwTENBME55d2dNVGRkTEZ4dVhHNGdJQ0FnSUNBdkx5QXlOMXh1SUNBZ0lDQWdXemdzSURFMU1pd2dNVEl5TENBMExDQXhOVE1zSURFeU0xMHNYRzRnSUNBZ0lDQmJNaklzSURjekxDQTBOU3dnTXl3Z056UXNJRFEyWFN4Y2JpQWdJQ0FnSUZzNExDQTFNeXdnTWpNc0lESTJMQ0ExTkN3Z01qUmRMRnh1SUNBZ0lDQWdXekV5TENBME5Td2dNVFVzSURJNExDQTBOaXdnTVRaZExGeHVYRzRnSUNBZ0lDQXZMeUF5T0Z4dUlDQWdJQ0FnV3pNc0lERTBOeXdnTVRFM0xDQXhNQ3dnTVRRNExDQXhNVGhkTEZ4dUlDQWdJQ0FnV3pNc0lEY3pMQ0EwTlN3Z01qTXNJRGMwTENBME5sMHNYRzRnSUNBZ0lDQmJOQ3dnTlRRc0lESTBMQ0F6TVN3Z05UVXNJREkxWFN4Y2JpQWdJQ0FnSUZzeE1Td2dORFVzSURFMUxDQXpNU3dnTkRZc0lERTJYU3hjYmx4dUlDQWdJQ0FnTHk4Z01qbGNiaUFnSUNBZ0lGczNMQ0F4TkRZc0lERXhOaXdnTnl3Z01UUTNMQ0F4TVRkZExGeHVJQ0FnSUNBZ1d6SXhMQ0EzTXl3Z05EVXNJRGNzSURjMExDQTBObDBzWEc0Z0lDQWdJQ0JiTVN3Z05UTXNJREl6TENBek55d2dOVFFzSURJMFhTeGNiaUFnSUNBZ0lGc3hPU3dnTkRVc0lERTFMQ0F5Tml3Z05EWXNJREUyWFN4Y2JseHVJQ0FnSUNBZ0x5OGdNekJjYmlBZ0lDQWdJRnMxTENBeE5EVXNJREV4TlN3Z01UQXNJREUwTml3Z01URTJYU3hjYmlBZ0lDQWdJRnN4T1N3Z056VXNJRFEzTENBeE1Dd2dOellzSURRNFhTeGNiaUFnSUNBZ0lGc3hOU3dnTlRRc0lESTBMQ0F5TlN3Z05UVXNJREkxWFN4Y2JpQWdJQ0FnSUZzeU15d2dORFVzSURFMUxDQXlOU3dnTkRZc0lERTJYU3hjYmx4dUlDQWdJQ0FnTHk4Z016RmNiaUFnSUNBZ0lGc3hNeXdnTVRRMUxDQXhNVFVzSURNc0lERTBOaXdnTVRFMlhTeGNiaUFnSUNBZ0lGc3lMQ0EzTkN3Z05EWXNJREk1TENBM05Td2dORGRkTEZ4dUlDQWdJQ0FnV3pReUxDQTFOQ3dnTWpRc0lERXNJRFUxTENBeU5WMHNYRzRnSUNBZ0lDQmJNak1zSURRMUxDQXhOU3dnTWpnc0lEUTJMQ0F4Tmwwc1hHNWNiaUFnSUNBZ0lDOHZJRE15WEc0Z0lDQWdJQ0JiTVRjc0lERTBOU3dnTVRFMVhTeGNiaUFnSUNBZ0lGc3hNQ3dnTnpRc0lEUTJMQ0F5TXl3Z056VXNJRFEzWFN4Y2JpQWdJQ0FnSUZzeE1Dd2dOVFFzSURJMExDQXpOU3dnTlRVc0lESTFYU3hjYmlBZ0lDQWdJRnN4T1N3Z05EVXNJREUxTENBek5Td2dORFlzSURFMlhTeGNibHh1SUNBZ0lDQWdMeThnTXpOY2JpQWdJQ0FnSUZzeE55d2dNVFExTENBeE1UVXNJREVzSURFME5pd2dNVEUyWFN4Y2JpQWdJQ0FnSUZzeE5Dd2dOelFzSURRMkxDQXlNU3dnTnpVc0lEUTNYU3hjYmlBZ0lDQWdJRnN5T1N3Z05UUXNJREkwTENBeE9Td2dOVFVzSURJMVhTeGNiaUFnSUNBZ0lGc3hNU3dnTkRVc0lERTFMQ0EwTml3Z05EWXNJREUyWFN4Y2JseHVJQ0FnSUNBZ0x5OGdNelJjYmlBZ0lDQWdJRnN4TXl3Z01UUTFMQ0F4TVRVc0lEWXNJREUwTml3Z01URTJYU3hjYmlBZ0lDQWdJRnN4TkN3Z056UXNJRFEyTENBeU15d2dOelVzSURRM1hTeGNiaUFnSUNBZ0lGczBOQ3dnTlRRc0lESTBMQ0EzTENBMU5Td2dNalZkTEZ4dUlDQWdJQ0FnV3pVNUxDQTBOaXdnTVRZc0lERXNJRFEzTENBeE4xMHNYRzVjYmlBZ0lDQWdJQzh2SURNMVhHNGdJQ0FnSUNCYk1USXNJREUxTVN3Z01USXhMQ0EzTENBeE5USXNJREV5TWwwc1hHNGdJQ0FnSUNCYk1USXNJRGMxTENBME55d2dNallzSURjMkxDQTBPRjBzWEc0Z0lDQWdJQ0JiTXprc0lEVTBMQ0F5TkN3Z01UUXNJRFUxTENBeU5WMHNYRzRnSUNBZ0lDQmJNaklzSURRMUxDQXhOU3dnTkRFc0lEUTJMQ0F4Tmwwc1hHNWNiaUFnSUNBZ0lDOHZJRE0yWEc0Z0lDQWdJQ0JiTml3Z01UVXhMQ0F4TWpFc0lERTBMQ0F4TlRJc0lERXlNbDBzWEc0Z0lDQWdJQ0JiTml3Z056VXNJRFEzTENBek5Dd2dOellzSURRNFhTeGNiaUFnSUNBZ0lGczBOaXdnTlRRc0lESTBMQ0F4TUN3Z05UVXNJREkxWFN4Y2JpQWdJQ0FnSUZzeUxDQTBOU3dnTVRVc0lEWTBMQ0EwTml3Z01UWmRMRnh1WEc0Z0lDQWdJQ0F2THlBek4xeHVJQ0FnSUNBZ1d6RTNMQ0F4TlRJc0lERXlNaXdnTkN3Z01UVXpMQ0F4TWpOZExGeHVJQ0FnSUNBZ1d6STVMQ0EzTkN3Z05EWXNJREUwTENBM05Td2dORGRkTEZ4dUlDQWdJQ0FnV3pRNUxDQTFOQ3dnTWpRc0lERXdMQ0ExTlN3Z01qVmRMRnh1SUNBZ0lDQWdXekkwTENBME5Td2dNVFVzSURRMkxDQTBOaXdnTVRaZExGeHVYRzRnSUNBZ0lDQXZMeUF6T0Z4dUlDQWdJQ0FnV3pRc0lERTFNaXdnTVRJeUxDQXhPQ3dnTVRVekxDQXhNak5kTEZ4dUlDQWdJQ0FnV3pFekxDQTNOQ3dnTkRZc0lETXlMQ0EzTlN3Z05EZGRMRnh1SUNBZ0lDQWdXelE0TENBMU5Dd2dNalFzSURFMExDQTFOU3dnTWpWZExGeHVJQ0FnSUNBZ1d6UXlMQ0EwTlN3Z01UVXNJRE15TENBME5pd2dNVFpkTEZ4dVhHNGdJQ0FnSUNBdkx5QXpPVnh1SUNBZ0lDQWdXekl3TENBeE5EY3NJREV4Tnl3Z05Dd2dNVFE0TENBeE1UaGRMRnh1SUNBZ0lDQWdXelF3TENBM05Td2dORGNzSURjc0lEYzJMQ0EwT0Ywc1hHNGdJQ0FnSUNCYk5ETXNJRFUwTENBeU5Dd2dNaklzSURVMUxDQXlOVjBzWEc0Z0lDQWdJQ0JiTVRBc0lEUTFMQ0F4TlN3Z05qY3NJRFEyTENBeE5sMHNYRzVjYmlBZ0lDQWdJQzh2SURRd1hHNGdJQ0FnSUNCYk1Ua3NJREUwT0N3Z01URTRMQ0EyTENBeE5Ea3NJREV4T1Ywc1hHNGdJQ0FnSUNCYk1UZ3NJRGMxTENBME55d2dNekVzSURjMkxDQTBPRjBzWEc0Z0lDQWdJQ0JiTXpRc0lEVTBMQ0F5TkN3Z016UXNJRFUxTENBeU5WMHNYRzRnSUNBZ0lDQmJNakFzSURRMUxDQXhOU3dnTmpFc0lEUTJMQ0F4TmwxY2JpQWdJQ0JkTzF4dVhHNGdJQ0FnZG1GeUlIRnlVbE5DYkc5amF5QTlJR1oxYm1OMGFXOXVLSFJ2ZEdGc1EyOTFiblFzSUdSaGRHRkRiM1Z1ZENrZ2UxeHVJQ0FnSUNBZ2RtRnlJRjkwYUdseklEMGdlMzA3WEc0Z0lDQWdJQ0JmZEdocGN5NTBiM1JoYkVOdmRXNTBJRDBnZEc5MFlXeERiM1Z1ZER0Y2JpQWdJQ0FnSUY5MGFHbHpMbVJoZEdGRGIzVnVkQ0E5SUdSaGRHRkRiM1Z1ZER0Y2JpQWdJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNiaUFnSUNCOU8xeHVYRzRnSUNBZ2RtRnlJRjkwYUdseklEMGdlMzA3WEc1Y2JpQWdJQ0IyWVhJZ1oyVjBVbk5DYkc5amExUmhZbXhsSUQwZ1puVnVZM1JwYjI0b2RIbHdaVTUxYldKbGNpd2daWEp5YjNKRGIzSnlaV04wYVc5dVRHVjJaV3dwSUh0Y2JseHVJQ0FnSUNBZ2MzZHBkR05vS0dWeWNtOXlRMjl5Y21WamRHbHZia3hsZG1Wc0tTQjdYRzRnSUNBZ0lDQmpZWE5sSUZGU1JYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXd3VUQ0E2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJTVTE5Q1RFOURTMTlVUVVKTVJWc29kSGx3WlU1MWJXSmxjaUF0SURFcElDb2dOQ0FySURCZE8xeHVJQ0FnSUNBZ1kyRnpaU0JSVWtWeWNtOXlRMjl5Y21WamRHbHZia3hsZG1Wc0xrMGdPbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdVbE5mUWt4UFEwdGZWRUZDVEVWYktIUjVjR1ZPZFcxaVpYSWdMU0F4S1NBcUlEUWdLeUF4WFR0Y2JpQWdJQ0FnSUdOaGMyVWdVVkpGY25KdmNrTnZjbkpsWTNScGIyNU1aWFpsYkM1UklEcGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGSlRYMEpNVDBOTFgxUkJRa3hGV3loMGVYQmxUblZ0WW1WeUlDMGdNU2tnS2lBMElDc2dNbDA3WEc0Z0lDQWdJQ0JqWVhObElGRlNSWEp5YjNKRGIzSnlaV04wYVc5dVRHVjJaV3d1U0NBNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCU1UxOUNURTlEUzE5VVFVSk1SVnNvZEhsd1pVNTFiV0psY2lBdElERXBJQ29nTkNBcklETmRPMXh1SUNBZ0lDQWdaR1ZtWVhWc2RDQTZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjFibVJsWm1sdVpXUTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lGOTBhR2x6TG1kbGRGSlRRbXh2WTJ0eklEMGdablZ1WTNScGIyNG9kSGx3WlU1MWJXSmxjaXdnWlhKeWIzSkRiM0p5WldOMGFXOXVUR1YyWld3cElIdGNibHh1SUNBZ0lDQWdkbUZ5SUhKelFteHZZMnNnUFNCblpYUlNjMEpzYjJOclZHRmliR1VvZEhsd1pVNTFiV0psY2l3Z1pYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXd3BPMXh1WEc0Z0lDQWdJQ0JwWmlBb2RIbHdaVzltSUhKelFteHZZMnNnUFQwZ0ozVnVaR1ZtYVc1bFpDY3BJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RpWVdRZ2NuTWdZbXh2WTJzZ1FDQjBlWEJsVG5WdFltVnlPaWNnS3lCMGVYQmxUblZ0WW1WeUlDdGNiaUFnSUNBZ0lDQWdJQ0FnSUNjdlpYSnliM0pEYjNKeVpXTjBhVzl1VEdWMlpXdzZKeUFySUdWeWNtOXlRMjl5Y21WamRHbHZia3hsZG1Wc0tUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdkbUZ5SUd4bGJtZDBhQ0E5SUhKelFteHZZMnN1YkdWdVozUm9JQzhnTXp0Y2JseHVJQ0FnSUNBZ2RtRnlJR3hwYzNRZ1BTQnVaWGNnUVhKeVlYa29LVHRjYmx4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCc1pXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dVhHNGdJQ0FnSUNBZ0lIWmhjaUJqYjNWdWRDQTlJSEp6UW14dlkydGJhU0FxSURNZ0t5QXdYVHRjYmlBZ0lDQWdJQ0FnZG1GeUlIUnZkR0ZzUTI5MWJuUWdQU0J5YzBKc2IyTnJXMmtnS2lBeklDc2dNVjA3WEc0Z0lDQWdJQ0FnSUhaaGNpQmtZWFJoUTI5MWJuUWdQU0J5YzBKc2IyTnJXMmtnS2lBeklDc2dNbDA3WEc1Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FpQTlJREE3SUdvZ1BDQmpiM1Z1ZERzZ2FpQXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdiR2x6ZEM1d2RYTm9LSEZ5VWxOQ2JHOWpheWgwYjNSaGJFTnZkVzUwTENCa1lYUmhRMjkxYm5RcElDazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnY21WMGRYSnVJR3hwYzNRN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNiaUFnZlNncE8xeHVYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc0Z0lDOHZJSEZ5UW1sMFFuVm1abVZ5WEc0Z0lDOHZMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdFhHNWNiaUFnZG1GeUlIRnlRbWwwUW5WbVptVnlJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNWNiaUFnSUNCMllYSWdYMkoxWm1abGNpQTlJRzVsZHlCQmNuSmhlU2dwTzF4dUlDQWdJSFpoY2lCZmJHVnVaM1JvSUQwZ01EdGNibHh1SUNBZ0lIWmhjaUJmZEdocGN5QTlJSHQ5TzF4dVhHNGdJQ0FnWDNSb2FYTXVaMlYwUW5WbVptVnlJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWDJKMVptWmxjanRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdYM1JvYVhNdVoyVjBRWFFnUFNCbWRXNWpkR2x2YmlocGJtUmxlQ2tnZTF4dUlDQWdJQ0FnZG1GeUlHSjFaa2x1WkdWNElEMGdUV0YwYUM1bWJHOXZjaWhwYm1SbGVDQXZJRGdwTzF4dUlDQWdJQ0FnY21WMGRYSnVJQ2dnS0Y5aWRXWm1aWEpiWW5WbVNXNWtaWGhkSUQ0K1BpQW9OeUF0SUdsdVpHVjRJQ1VnT0NrZ0tTQW1JREVwSUQwOUlERTdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lGOTBhR2x6TG5CMWRDQTlJR1oxYm1OMGFXOXVLRzUxYlN3Z2JHVnVaM1JvS1NCN1hHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxibWQwYURzZ2FTQXJQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lGOTBhR2x6TG5CMWRFSnBkQ2dnS0NBb2JuVnRJRDQrUGlBb2JHVnVaM1JvSUMwZ2FTQXRJREVwSUNrZ0ppQXhLU0E5UFNBeEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11WjJWMFRHVnVaM1JvU1c1Q2FYUnpJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWDJ4bGJtZDBhRHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdYM1JvYVhNdWNIVjBRbWwwSUQwZ1puVnVZM1JwYjI0b1ltbDBLU0I3WEc1Y2JpQWdJQ0FnSUhaaGNpQmlkV1pKYm1SbGVDQTlJRTFoZEdndVpteHZiM0lvWDJ4bGJtZDBhQ0F2SURncE8xeHVJQ0FnSUNBZ2FXWWdLRjlpZFdabVpYSXViR1Z1WjNSb0lEdzlJR0oxWmtsdVpHVjRLU0I3WEc0Z0lDQWdJQ0FnSUY5aWRXWm1aWEl1Y0hWemFDZ3dLVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tHSnBkQ2tnZTF4dUlDQWdJQ0FnSUNCZlluVm1abVZ5VzJKMVprbHVaR1Y0WFNCOFBTQW9NSGc0TUNBK1BqNGdLRjlzWlc1bmRHZ2dKU0E0S1NBcE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQmZiR1Z1WjNSb0lDczlJREU3WEc0Z0lDQWdmVHRjYmx4dUlDQWdJSEpsZEhWeWJpQmZkR2hwY3p0Y2JpQWdmVHRjYmx4dUlDQXZMeTB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVJQ0F2THlCeGNrNTFiV0psY2x4dUlDQXZMeTB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVYRzRnSUhaaGNpQnhjazUxYldKbGNpQTlJR1oxYm1OMGFXOXVLR1JoZEdFcElIdGNibHh1SUNBZ0lIWmhjaUJmYlc5a1pTQTlJRkZTVFc5a1pTNU5UMFJGWDA1VlRVSkZVanRjYmlBZ0lDQjJZWElnWDJSaGRHRWdQU0JrWVhSaE8xeHVYRzRnSUNBZ2RtRnlJRjkwYUdseklEMGdlMzA3WEc1Y2JpQWdJQ0JmZEdocGN5NW5aWFJOYjJSbElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdYMjF2WkdVN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbWRsZEV4bGJtZDBhQ0E5SUdaMWJtTjBhVzl1S0dKMVptWmxjaWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRjlrWVhSaExteGxibWQwYUR0Y2JpQWdJQ0I5TzF4dVhHNGdJQ0FnWDNSb2FYTXVkM0pwZEdVZ1BTQm1kVzVqZEdsdmJpaGlkV1ptWlhJcElIdGNibHh1SUNBZ0lDQWdkbUZ5SUdSaGRHRWdQU0JmWkdGMFlUdGNibHh1SUNBZ0lDQWdkbUZ5SUdrZ1BTQXdPMXh1WEc0Z0lDQWdJQ0IzYUdsc1pTQW9hU0FySURJZ1BDQmtZWFJoTG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnSUNCaWRXWm1aWEl1Y0hWMEtITjBjbFJ2VG5WdEtHUmhkR0V1YzNWaWMzUnlhVzVuS0drc0lHa2dLeUF6S1NBcExDQXhNQ2s3WEc0Z0lDQWdJQ0FnSUdrZ0t6MGdNenRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tHa2dQQ0JrWVhSaExteGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWkdGMFlTNXNaVzVuZEdnZ0xTQnBJRDA5SURFcElIdGNiaUFnSUNBZ0lDQWdJQ0JpZFdabVpYSXVjSFYwS0hOMGNsUnZUblZ0S0dSaGRHRXVjM1ZpYzNSeWFXNW5LR2tzSUdrZ0t5QXhLU0FwTENBMEtUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hrWVhSaExteGxibWQwYUNBdElHa2dQVDBnTWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvYzNSeVZHOU9kVzBvWkdGMFlTNXpkV0p6ZEhKcGJtY29hU3dnYVNBcklESXBJQ2tzSURjcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lIWmhjaUJ6ZEhKVWIwNTFiU0E5SUdaMWJtTjBhVzl1S0hNcElIdGNiaUFnSUNBZ0lIWmhjaUJ1ZFcwZ1BTQXdPMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUc1MWJTQTlJRzUxYlNBcUlERXdJQ3NnWTJoaGRGUnZUblZ0S0hNdVkyaGhja0YwS0drcElDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnlaWFIxY200Z2JuVnRPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQjJZWElnWTJoaGRGUnZUblZ0SUQwZ1puVnVZM1JwYjI0b1l5a2dlMXh1SUNBZ0lDQWdhV1lnS0Njd0p5QThQU0JqSUNZbUlHTWdQRDBnSnprbktTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmpMbU5vWVhKRGIyUmxRWFFvTUNrZ0xTQW5NQ2N1WTJoaGNrTnZaR1ZCZENnd0tUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lIUm9jbTkzSUNkcGJHeGxaMkZzSUdOb1lYSWdPaWNnS3lCak8xeHVJQ0FnSUgwN1hHNWNiaUFnSUNCeVpYUjFjbTRnWDNSb2FYTTdYRzRnSUgwN1hHNWNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmlBZ0x5OGdjWEpCYkhCb1lVNTFiVnh1SUNBdkx5MHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFZ4dVhHNGdJSFpoY2lCeGNrRnNjR2hoVG5WdElEMGdablZ1WTNScGIyNG9aR0YwWVNrZ2UxeHVYRzRnSUNBZ2RtRnlJRjl0YjJSbElEMGdVVkpOYjJSbExrMVBSRVZmUVV4UVNFRmZUbFZOTzF4dUlDQWdJSFpoY2lCZlpHRjBZU0E5SUdSaGRHRTdYRzVjYmlBZ0lDQjJZWElnWDNSb2FYTWdQU0I3ZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbWRsZEUxdlpHVWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJmYlc5a1pUdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11WjJWMFRHVnVaM1JvSUQwZ1puVnVZM1JwYjI0b1luVm1abVZ5S1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWDJSaGRHRXViR1Z1WjNSb08xeHVJQ0FnSUgwN1hHNWNiaUFnSUNCZmRHaHBjeTUzY21sMFpTQTlJR1oxYm1OMGFXOXVLR0oxWm1abGNpa2dlMXh1WEc0Z0lDQWdJQ0IyWVhJZ2N5QTlJRjlrWVhSaE8xeHVYRzRnSUNBZ0lDQjJZWElnYVNBOUlEQTdYRzVjYmlBZ0lDQWdJSGRvYVd4bElDaHBJQ3NnTVNBOElITXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvWEc0Z0lDQWdJQ0FnSUNBZ1oyVjBRMjlrWlNoekxtTm9ZWEpCZENocEtTQXBJQ29nTkRVZ0sxeHVJQ0FnSUNBZ0lDQWdJR2RsZEVOdlpHVW9jeTVqYUdGeVFYUW9hU0FySURFcElDa3NJREV4S1R0Y2JpQWdJQ0FnSUNBZ2FTQXJQU0F5TzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCcFppQW9hU0E4SUhNdWJHVnVaM1JvS1NCN1hHNGdJQ0FnSUNBZ0lHSjFabVpsY2k1d2RYUW9aMlYwUTI5a1pTaHpMbU5vWVhKQmRDaHBLU0FwTENBMktUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOU8xeHVYRzRnSUNBZ2RtRnlJR2RsZEVOdlpHVWdQU0JtZFc1amRHbHZiaWhqS1NCN1hHNWNiaUFnSUNBZ0lHbG1JQ2duTUNjZ1BEMGdZeUFtSmlCaklEdzlJQ2M1SnlrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1l5NWphR0Z5UTI5a1pVRjBLREFwSUMwZ0p6QW5MbU5vWVhKRGIyUmxRWFFvTUNrN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tDZEJKeUE4UFNCaklDWW1JR01nUEQwZ0oxb25LU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJqTG1Ob1lYSkRiMlJsUVhRb01Da2dMU0FuUVNjdVkyaGhja052WkdWQmRDZ3dLU0FySURFd08xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2MzZHBkR05vSUNoaktTQjdYRzRnSUNBZ0lDQWdJR05oYzJVZ0p5QW5JRG9nY21WMGRYSnVJRE0yTzF4dUlDQWdJQ0FnSUNCallYTmxJQ2NrSnlBNklISmxkSFZ5YmlBek56dGNiaUFnSUNBZ0lDQWdZMkZ6WlNBbkpTY2dPaUJ5WlhSMWNtNGdNemc3WEc0Z0lDQWdJQ0FnSUdOaGMyVWdKeW9uSURvZ2NtVjBkWEp1SURNNU8xeHVJQ0FnSUNBZ0lDQmpZWE5sSUNjckp5QTZJSEpsZEhWeWJpQTBNRHRjYmlBZ0lDQWdJQ0FnWTJGelpTQW5MU2NnT2lCeVpYUjFjbTRnTkRFN1hHNGdJQ0FnSUNBZ0lHTmhjMlVnSnk0bklEb2djbVYwZFhKdUlEUXlPMXh1SUNBZ0lDQWdJQ0JqWVhObElDY3ZKeUE2SUhKbGRIVnliaUEwTXp0Y2JpQWdJQ0FnSUNBZ1kyRnpaU0FuT2ljZ09pQnlaWFIxY200Z05EUTdYRzRnSUNBZ0lDQWdJR1JsWm1GMWJIUWdPbHh1SUNBZ0lDQWdJQ0FnSUhSb2NtOTNJQ2RwYkd4bFoyRnNJR05vWVhJZ09pY2dLeUJqTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNiaUFnZlR0Y2JseHVJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBdkx5QnhjamhDYVhSQ2VYUmxYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc1Y2JpQWdkbUZ5SUhGeU9FSnBkRUo1ZEdVZ1BTQm1kVzVqZEdsdmJpaGtZWFJoS1NCN1hHNWNiaUFnSUNCMllYSWdYMjF2WkdVZ1BTQlJVazF2WkdVdVRVOUVSVjg0UWtsVVgwSlpWRVU3WEc0Z0lDQWdkbUZ5SUY5a1lYUmhJRDBnWkdGMFlUdGNiaUFnSUNCMllYSWdYMko1ZEdWeklEMGdjWEpqYjJSbExuTjBjbWx1WjFSdlFubDBaWE1vWkdGMFlTazdYRzVjYmlBZ0lDQjJZWElnWDNSb2FYTWdQU0I3ZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbWRsZEUxdlpHVWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJmYlc5a1pUdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11WjJWMFRHVnVaM1JvSUQwZ1puVnVZM1JwYjI0b1luVm1abVZ5S1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWDJKNWRHVnpMbXhsYm1kMGFEdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11ZDNKcGRHVWdQU0JtZFc1amRHbHZiaWhpZFdabVpYSXBJSHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWDJKNWRHVnpMbXhsYm1kMGFEc2dhU0FyUFNBeEtTQjdYRzRnSUNBZ0lDQWdJR0oxWm1abGNpNXdkWFFvWDJKNWRHVnpXMmxkTENBNEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOU8xeHVYRzRnSUNBZ2NtVjBkWEp1SUY5MGFHbHpPMXh1SUNCOU8xeHVYRzRnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc0Z0lDOHZJSEZ5UzJGdWFtbGNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmx4dUlDQjJZWElnY1hKTFlXNXFhU0E5SUdaMWJtTjBhVzl1S0dSaGRHRXBJSHRjYmx4dUlDQWdJSFpoY2lCZmJXOWtaU0E5SUZGU1RXOWtaUzVOVDBSRlgwdEJUa3BKTzF4dUlDQWdJSFpoY2lCZlpHRjBZU0E5SUdSaGRHRTdYRzRnSUNBZ2RtRnlJRjlpZVhSbGN5QTlJSEZ5WTI5a1pTNXpkSEpwYm1kVWIwSjVkR1Z6S0dSaGRHRXBPMXh1WEc0Z0lDQWdJV1oxYm1OMGFXOXVLR01zSUdOdlpHVXBJSHRjYmlBZ0lDQWdJQzh2SUhObGJHWWdkR1Z6ZENCbWIzSWdjMnBwY3lCemRYQndiM0owTGx4dUlDQWdJQ0FnZG1GeUlIUmxjM1FnUFNCeGNtTnZaR1V1YzNSeWFXNW5WRzlDZVhSbGN5aGpLVHRjYmlBZ0lDQWdJR2xtSUNoMFpYTjBMbXhsYm1kMGFDQWhQU0F5SUh4OElDZ2dLSFJsYzNSYk1GMGdQRHdnT0NrZ2ZDQjBaWE4wV3pGZEtTQWhQU0JqYjJSbEtTQjdYRzRnSUNBZ0lDQWdJSFJvY205M0lDZHphbWx6SUc1dmRDQnpkWEJ3YjNKMFpXUXVKenRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlLQ2RjWEhVMU0yTmlKeXdnTUhnNU56UTJLVHRjYmx4dUlDQWdJSFpoY2lCZmRHaHBjeUE5SUh0OU8xeHVYRzRnSUNBZ1gzUm9hWE11WjJWMFRXOWtaU0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUY5dGIyUmxPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQmZkR2hwY3k1blpYUk1aVzVuZEdnZ1BTQm1kVzVqZEdsdmJpaGlkV1ptWlhJcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCK2ZpaGZZbmwwWlhNdWJHVnVaM1JvSUM4Z01pazdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lGOTBhR2x6TG5keWFYUmxJRDBnWm5WdVkzUnBiMjRvWW5WbVptVnlLU0I3WEc1Y2JpQWdJQ0FnSUhaaGNpQmtZWFJoSUQwZ1gySjVkR1Z6TzF4dVhHNGdJQ0FnSUNCMllYSWdhU0E5SURBN1hHNWNiaUFnSUNBZ0lIZG9hV3hsSUNocElDc2dNU0E4SUdSaGRHRXViR1Z1WjNSb0tTQjdYRzVjYmlBZ0lDQWdJQ0FnZG1GeUlHTWdQU0FvSUNnd2VHWm1JQ1lnWkdGMFlWdHBYU2tnUER3Z09Da2dmQ0FvTUhobVppQW1JR1JoZEdGYmFTQXJJREZkS1R0Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvTUhnNE1UUXdJRHc5SUdNZ0ppWWdZeUE4UFNBd2VEbEdSa01wSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpJQzA5SURCNE9ERTBNRHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNnd2VFVXdOREFnUEQwZ1l5QW1KaUJqSUR3OUlEQjRSVUpDUmlrZ2UxeHVJQ0FnSUNBZ0lDQWdJR01nTFQwZ01IaERNVFF3TzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lIUm9jbTkzSUNkcGJHeGxaMkZzSUdOb1lYSWdZWFFnSnlBcklDaHBJQ3NnTVNrZ0t5QW5MeWNnS3lCak8xeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnWXlBOUlDZ2dLR01nUGo0K0lEZ3BJQ1lnTUhobVppa2dLaUF3ZUVNd0lDc2dLR01nSmlBd2VHWm1LVHRjYmx4dUlDQWdJQ0FnSUNCaWRXWm1aWEl1Y0hWMEtHTXNJREV6S1R0Y2JseHVJQ0FnSUNBZ0lDQnBJQ3M5SURJN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHbG1JQ2hwSUR3Z1pHRjBZUzVzWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dKMmxzYkdWbllXd2dZMmhoY2lCaGRDQW5JQ3NnS0drZ0t5QXhLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdjbVYwZFhKdUlGOTBhR2x6TzF4dUlDQjlPMXh1WEc0Z0lDOHZQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVhHNGdJQzh2SUVkSlJpQlRkWEJ3YjNKMElHVjBZeTVjYmlBZ0x5OWNibHh1SUNBdkx5MHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFZ4dUlDQXZMeUJpZVhSbFFYSnlZWGxQZFhSd2RYUlRkSEpsWVcxY2JpQWdMeTh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMWNibHh1SUNCMllYSWdZbmwwWlVGeWNtRjVUM1YwY0hWMFUzUnlaV0Z0SUQwZ1puVnVZM1JwYjI0b0tTQjdYRzVjYmlBZ0lDQjJZWElnWDJKNWRHVnpJRDBnYm1WM0lFRnljbUY1S0NrN1hHNWNiaUFnSUNCMllYSWdYM1JvYVhNZ1BTQjdmVHRjYmx4dUlDQWdJRjkwYUdsekxuZHlhWFJsUW5sMFpTQTlJR1oxYm1OMGFXOXVLR0lwSUh0Y2JpQWdJQ0FnSUY5aWVYUmxjeTV3ZFhOb0tHSWdKaUF3ZUdabUtUdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11ZDNKcGRHVlRhRzl5ZENBOUlHWjFibU4wYVc5dUtHa3BJSHRjYmlBZ0lDQWdJRjkwYUdsekxuZHlhWFJsUW5sMFpTaHBLVHRjYmlBZ0lDQWdJRjkwYUdsekxuZHlhWFJsUW5sMFpTaHBJRDQrUGlBNEtUdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ1gzUm9hWE11ZDNKcGRHVkNlWFJsY3lBOUlHWjFibU4wYVc5dUtHSXNJRzltWml3Z2JHVnVLU0I3WEc0Z0lDQWdJQ0J2Wm1ZZ1BTQnZabVlnZkh3Z01EdGNiaUFnSUNBZ0lHeGxiaUE5SUd4bGJpQjhmQ0JpTG14bGJtZDBhRHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYkdWdU95QnBJQ3M5SURFcElIdGNiaUFnSUNBZ0lDQWdYM1JvYVhNdWQzSnBkR1ZDZVhSbEtHSmJhU0FySUc5bVpsMHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzVjYmlBZ0lDQmZkR2hwY3k1M2NtbDBaVk4wY21sdVp5QTlJR1oxYm1OMGFXOXVLSE1wSUh0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2N5NXNaVzVuZEdnN0lHa2dLejBnTVNrZ2UxeHVJQ0FnSUNBZ0lDQmZkR2hwY3k1M2NtbDBaVUo1ZEdVb2N5NWphR0Z5UTI5a1pVRjBLR2twSUNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMblJ2UW5sMFpVRnljbUY1SUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1gySjVkR1Z6TzF4dUlDQWdJSDA3WEc1Y2JpQWdJQ0JmZEdocGN5NTBiMU4wY21sdVp5QTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnZG1GeUlITWdQU0FuSnp0Y2JpQWdJQ0FnSUhNZ0t6MGdKMXNuTzF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCZllubDBaWE11YkdWdVozUm9PeUJwSUNzOUlERXBJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHa2dQaUF3S1NCN1hHNGdJQ0FnSUNBZ0lDQWdjeUFyUFNBbkxDYzdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnY3lBclBTQmZZbmwwWlhOYmFWMDdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnpJQ3M5SUNkZEp6dGNiaUFnSUNBZ0lISmxkSFZ5YmlCek8xeHVJQ0FnSUgwN1hHNWNiaUFnSUNCeVpYUjFjbTRnWDNSb2FYTTdYRzRnSUgwN1hHNWNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmlBZ0x5OGdZbUZ6WlRZMFJXNWpiMlJsVDNWMGNIVjBVM1J5WldGdFhHNGdJQzh2TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRYRzVjYmlBZ2RtRnlJR0poYzJVMk5FVnVZMjlrWlU5MWRIQjFkRk4wY21WaGJTQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dVhHNGdJQ0FnZG1GeUlGOWlkV1ptWlhJZ1BTQXdPMXh1SUNBZ0lIWmhjaUJmWW5WbWJHVnVJRDBnTUR0Y2JpQWdJQ0IyWVhJZ1gyeGxibWQwYUNBOUlEQTdYRzRnSUNBZ2RtRnlJRjlpWVhObE5qUWdQU0FuSnp0Y2JseHVJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEc0Z0lDQWdkbUZ5SUhkeWFYUmxSVzVqYjJSbFpDQTlJR1oxYm1OMGFXOXVLR0lwSUh0Y2JpQWdJQ0FnSUY5aVlYTmxOalFnS3owZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTaGxibU52WkdVb1lpQW1JREI0TTJZcElDazdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lIWmhjaUJsYm1OdlpHVWdQU0JtZFc1amRHbHZiaWh1S1NCN1hHNGdJQ0FnSUNCcFppQW9iaUE4SURBcElIdGNiaUFnSUNBZ0lDQWdMeThnWlhKeWIzSXVYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLRzRnUENBeU5pa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdNSGcwTVNBcklHNDdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLRzRnUENBMU1pa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdNSGcyTVNBcklDaHVJQzBnTWpZcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHVJRHdnTmpJcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlEQjRNekFnS3lBb2JpQXRJRFV5S1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2JpQTlQU0EyTWlrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z01IZ3lZanRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvYmlBOVBTQTJNeWtnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnTUhneVpqdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnbmJqb25JQ3NnYmlrN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbmR5YVhSbFFubDBaU0E5SUdaMWJtTjBhVzl1S0c0cElIdGNibHh1SUNBZ0lDQWdYMkoxWm1abGNpQTlJQ2hmWW5WbVptVnlJRHc4SURncElId2dLRzRnSmlBd2VHWm1LVHRjYmlBZ0lDQWdJRjlpZFdac1pXNGdLejBnT0R0Y2JpQWdJQ0FnSUY5c1pXNW5kR2dnS3owZ01UdGNibHh1SUNBZ0lDQWdkMmhwYkdVZ0tGOWlkV1pzWlc0Z1BqMGdOaWtnZTF4dUlDQWdJQ0FnSUNCM2NtbDBaVVZ1WTI5a1pXUW9YMkoxWm1abGNpQStQajRnS0Y5aWRXWnNaVzRnTFNBMktTQXBPMXh1SUNBZ0lDQWdJQ0JmWW5WbWJHVnVJQzA5SURZN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbVpzZFhOb0lEMGdablZ1WTNScGIyNG9LU0I3WEc1Y2JpQWdJQ0FnSUdsbUlDaGZZblZtYkdWdUlENGdNQ2tnZTF4dUlDQWdJQ0FnSUNCM2NtbDBaVVZ1WTI5a1pXUW9YMkoxWm1abGNpQThQQ0FvTmlBdElGOWlkV1pzWlc0cElDazdYRzRnSUNBZ0lDQWdJRjlpZFdabVpYSWdQU0F3TzF4dUlDQWdJQ0FnSUNCZlluVm1iR1Z1SUQwZ01EdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdhV1lnS0Y5c1pXNW5kR2dnSlNBeklDRTlJREFwSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdjR0ZrWkdsdVoxeHVJQ0FnSUNBZ0lDQjJZWElnY0dGa2JHVnVJRDBnTXlBdElGOXNaVzVuZEdnZ0pTQXpPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUhCaFpHeGxianNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1gySmhjMlUyTkNBclBTQW5QU2M3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5TzF4dVhHNGdJQ0FnWDNSb2FYTXVkRzlUZEhKcGJtY2dQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJmWW1GelpUWTBPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc0Z0lIMDdYRzVjYmlBZ0x5OHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMxY2JpQWdMeThnWW1GelpUWTBSR1ZqYjJSbFNXNXdkWFJUZEhKbFlXMWNiaUFnTHk4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmx4dUlDQjJZWElnWW1GelpUWTBSR1ZqYjJSbFNXNXdkWFJUZEhKbFlXMGdQU0JtZFc1amRHbHZiaWh6ZEhJcElIdGNibHh1SUNBZ0lIWmhjaUJmYzNSeUlEMGdjM1J5TzF4dUlDQWdJSFpoY2lCZmNHOXpJRDBnTUR0Y2JpQWdJQ0IyWVhJZ1gySjFabVpsY2lBOUlEQTdYRzRnSUNBZ2RtRnlJRjlpZFdac1pXNGdQU0F3TzF4dVhHNGdJQ0FnZG1GeUlGOTBhR2x6SUQwZ2UzMDdYRzVjYmlBZ0lDQmZkR2hwY3k1eVpXRmtJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNWNiaUFnSUNBZ0lIZG9hV3hsSUNoZlluVm1iR1Z1SUR3Z09Da2dlMXh1WEc0Z0lDQWdJQ0FnSUdsbUlDaGZjRzl6SUQ0OUlGOXpkSEl1YkdWdVozUm9LU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRjlpZFdac1pXNGdQVDBnTUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQzB4TzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KM1Z1Wlhod1pXTjBaV1FnWlc1a0lHOW1JR1pwYkdVdUx5Y2dLeUJmWW5WbWJHVnVLVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lIWmhjaUJqSUQwZ1gzTjBjaTVqYUdGeVFYUW9YM0J2Y3lrN1hHNGdJQ0FnSUNBZ0lGOXdiM01nS3owZ01UdGNibHh1SUNBZ0lDQWdJQ0JwWmlBb1l5QTlQU0FuUFNjcElIdGNiaUFnSUNBZ0lDQWdJQ0JmWW5WbWJHVnVJRDBnTUR0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0xURTdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvWXk1dFlYUmphQ2d2WGx4Y2N5UXZLU0FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJwWjI1dmNtVWdhV1lnZDJocGRHVnpjR0ZqWlM1Y2JpQWdJQ0FnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUY5aWRXWm1aWElnUFNBb1gySjFabVpsY2lBOFBDQTJLU0I4SUdSbFkyOWtaU2hqTG1Ob1lYSkRiMlJsUVhRb01Da2dLVHRjYmlBZ0lDQWdJQ0FnWDJKMVpteGxiaUFyUFNBMk8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQjJZWElnYmlBOUlDaGZZblZtWm1WeUlENCtQaUFvWDJKMVpteGxiaUF0SURncElDa2dKaUF3ZUdabU8xeHVJQ0FnSUNBZ1gySjFabXhsYmlBdFBTQTRPMXh1SUNBZ0lDQWdjbVYwZFhKdUlHNDdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lIWmhjaUJrWldOdlpHVWdQU0JtZFc1amRHbHZiaWhqS1NCN1hHNGdJQ0FnSUNCcFppQW9NSGcwTVNBOFBTQmpJQ1ltSUdNZ1BEMGdNSGcxWVNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1l5QXRJREI0TkRFN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tEQjROakVnUEQwZ1l5QW1KaUJqSUR3OUlEQjROMkVwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdNZ0xTQXdlRFl4SUNzZ01qWTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLREI0TXpBZ1BEMGdZeUFtSmlCaklEdzlJREI0TXprcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHTWdMU0F3ZURNd0lDc2dOVEk3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dNZ1BUMGdNSGd5WWlrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z05qSTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR01nUFQwZ01IZ3laaWtnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnTmpNN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJNNkp5QXJJR01wTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDA3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdYM1JvYVhNN1hHNGdJSDA3WEc1Y2JpQWdMeTh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMWNiaUFnTHk4Z1oybG1TVzFoWjJVZ0tFSXZWeWxjYmlBZ0x5OHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMxY2JseHVJQ0IyWVhJZ1oybG1TVzFoWjJVZ1BTQm1kVzVqZEdsdmJpaDNhV1IwYUN3Z2FHVnBaMmgwS1NCN1hHNWNiaUFnSUNCMllYSWdYM2RwWkhSb0lEMGdkMmxrZEdnN1hHNGdJQ0FnZG1GeUlGOW9aV2xuYUhRZ1BTQm9aV2xuYUhRN1hHNGdJQ0FnZG1GeUlGOWtZWFJoSUQwZ2JtVjNJRUZ5Y21GNUtIZHBaSFJvSUNvZ2FHVnBaMmgwS1R0Y2JseHVJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEc0Z0lDQWdYM1JvYVhNdWMyVjBVR2w0Wld3Z1BTQm1kVzVqZEdsdmJpaDRMQ0I1TENCd2FYaGxiQ2tnZTF4dUlDQWdJQ0FnWDJSaGRHRmJlU0FxSUY5M2FXUjBhQ0FySUhoZElEMGdjR2w0Wld3N1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUY5MGFHbHpMbmR5YVhSbElEMGdablZ1WTNScGIyNG9iM1YwS1NCN1hHNWNiaUFnSUNBZ0lDOHZMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdFhHNGdJQ0FnSUNBdkx5QkhTVVlnVTJsbmJtRjBkWEpsWEc1Y2JpQWdJQ0FnSUc5MWRDNTNjbWwwWlZOMGNtbHVaeWduUjBsR09EZGhKeWs3WEc1Y2JpQWdJQ0FnSUM4dkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc0Z0lDQWdJQ0F2THlCVFkzSmxaVzRnUkdWelkzSnBjSFJ2Y2x4dVhHNGdJQ0FnSUNCdmRYUXVkM0pwZEdWVGFHOXlkQ2hmZDJsa2RHZ3BPMXh1SUNBZ0lDQWdiM1YwTG5keWFYUmxVMmh2Y25Rb1gyaGxhV2RvZENrN1hHNWNiaUFnSUNBZ0lHOTFkQzUzY21sMFpVSjVkR1VvTUhnNE1DazdJQzh2SURKaWFYUmNiaUFnSUNBZ0lHOTFkQzUzY21sMFpVSjVkR1VvTUNrN1hHNGdJQ0FnSUNCdmRYUXVkM0pwZEdWQ2VYUmxLREFwTzF4dVhHNGdJQ0FnSUNBdkx5MHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFZ4dUlDQWdJQ0FnTHk4Z1IyeHZZbUZzSUVOdmJHOXlJRTFoY0Z4dVhHNGdJQ0FnSUNBdkx5QmliR0ZqYTF4dUlDQWdJQ0FnYjNWMExuZHlhWFJsUW5sMFpTZ3dlREF3S1R0Y2JpQWdJQ0FnSUc5MWRDNTNjbWwwWlVKNWRHVW9NSGd3TUNrN1hHNGdJQ0FnSUNCdmRYUXVkM0pwZEdWQ2VYUmxLREI0TURBcE8xeHVYRzRnSUNBZ0lDQXZMeUIzYUdsMFpWeHVJQ0FnSUNBZ2IzVjBMbmR5YVhSbFFubDBaU2d3ZUdabUtUdGNiaUFnSUNBZ0lHOTFkQzUzY21sMFpVSjVkR1VvTUhobVppazdYRzRnSUNBZ0lDQnZkWFF1ZDNKcGRHVkNlWFJsS0RCNFptWXBPMXh1WEc0Z0lDQWdJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBZ0lDQWdMeThnU1cxaFoyVWdSR1Z6WTNKcGNIUnZjbHh1WEc0Z0lDQWdJQ0J2ZFhRdWQzSnBkR1ZUZEhKcGJtY29KeXduS1R0Y2JpQWdJQ0FnSUc5MWRDNTNjbWwwWlZOb2IzSjBLREFwTzF4dUlDQWdJQ0FnYjNWMExuZHlhWFJsVTJodmNuUW9NQ2s3WEc0Z0lDQWdJQ0J2ZFhRdWQzSnBkR1ZUYUc5eWRDaGZkMmxrZEdncE8xeHVJQ0FnSUNBZ2IzVjBMbmR5YVhSbFUyaHZjblFvWDJobGFXZG9kQ2s3WEc0Z0lDQWdJQ0J2ZFhRdWQzSnBkR1ZDZVhSbEtEQXBPMXh1WEc0Z0lDQWdJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBZ0lDQWdMeThnVEc5allXd2dRMjlzYjNJZ1RXRndYRzVjYmlBZ0lDQWdJQzh2TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRYRzRnSUNBZ0lDQXZMeUJTWVhOMFpYSWdSR0YwWVZ4dVhHNGdJQ0FnSUNCMllYSWdiSHAzVFdsdVEyOWtaVk5wZW1VZ1BTQXlPMXh1SUNBZ0lDQWdkbUZ5SUhKaGMzUmxjaUE5SUdkbGRFeGFWMUpoYzNSbGNpaHNlbmROYVc1RGIyUmxVMmw2WlNrN1hHNWNiaUFnSUNBZ0lHOTFkQzUzY21sMFpVSjVkR1VvYkhwM1RXbHVRMjlrWlZOcGVtVXBPMXh1WEc0Z0lDQWdJQ0IyWVhJZ2IyWm1jMlYwSUQwZ01EdGNibHh1SUNBZ0lDQWdkMmhwYkdVZ0tISmhjM1JsY2k1c1pXNW5kR2dnTFNCdlptWnpaWFFnUGlBeU5UVXBJSHRjYmlBZ0lDQWdJQ0FnYjNWMExuZHlhWFJsUW5sMFpTZ3lOVFVwTzF4dUlDQWdJQ0FnSUNCdmRYUXVkM0pwZEdWQ2VYUmxjeWh5WVhOMFpYSXNJRzltWm5ObGRDd2dNalUxS1R0Y2JpQWdJQ0FnSUNBZ2IyWm1jMlYwSUNzOUlESTFOVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYjNWMExuZHlhWFJsUW5sMFpTaHlZWE4wWlhJdWJHVnVaM1JvSUMwZ2IyWm1jMlYwS1R0Y2JpQWdJQ0FnSUc5MWRDNTNjbWwwWlVKNWRHVnpLSEpoYzNSbGNpd2diMlptYzJWMExDQnlZWE4wWlhJdWJHVnVaM1JvSUMwZ2IyWm1jMlYwS1R0Y2JpQWdJQ0FnSUc5MWRDNTNjbWwwWlVKNWRHVW9NSGd3TUNrN1hHNWNiaUFnSUNBZ0lDOHZMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdFhHNGdJQ0FnSUNBdkx5QkhTVVlnVkdWeWJXbHVZWFJ2Y2x4dUlDQWdJQ0FnYjNWMExuZHlhWFJsVTNSeWFXNW5LQ2M3SnlrN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUhaaGNpQmlhWFJQZFhSd2RYUlRkSEpsWVcwZ1BTQm1kVzVqZEdsdmJpaHZkWFFwSUh0Y2JseHVJQ0FnSUNBZ2RtRnlJRjl2ZFhRZ1BTQnZkWFE3WEc0Z0lDQWdJQ0IyWVhJZ1gySnBkRXhsYm1kMGFDQTlJREE3WEc0Z0lDQWdJQ0IyWVhJZ1gySnBkRUoxWm1abGNpQTlJREE3WEc1Y2JpQWdJQ0FnSUhaaGNpQmZkR2hwY3lBOUlIdDlPMXh1WEc0Z0lDQWdJQ0JmZEdocGN5NTNjbWwwWlNBOUlHWjFibU4wYVc5dUtHUmhkR0VzSUd4bGJtZDBhQ2tnZTF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2dnS0dSaGRHRWdQajQrSUd4bGJtZDBhQ2tnSVQwZ01Da2dlMXh1SUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduYkdWdVozUm9JRzkyWlhJbktUdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2hmWW1sMFRHVnVaM1JvSUNzZ2JHVnVaM1JvSUQ0OUlEZ3BJSHRjYmlBZ0lDQWdJQ0FnSUNCZmIzVjBMbmR5YVhSbFFubDBaU2d3ZUdabUlDWWdLQ0FvWkdGMFlTQThQQ0JmWW1sMFRHVnVaM1JvS1NCOElGOWlhWFJDZFdabVpYSXBJQ2s3WEc0Z0lDQWdJQ0FnSUNBZ2JHVnVaM1JvSUMwOUlDZzRJQzBnWDJKcGRFeGxibWQwYUNrN1hHNGdJQ0FnSUNBZ0lDQWdaR0YwWVNBK1BqNDlJQ2c0SUMwZ1gySnBkRXhsYm1kMGFDazdYRzRnSUNBZ0lDQWdJQ0FnWDJKcGRFSjFabVpsY2lBOUlEQTdYRzRnSUNBZ0lDQWdJQ0FnWDJKcGRFeGxibWQwYUNBOUlEQTdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCZlltbDBRblZtWm1WeUlEMGdLR1JoZEdFZ1BEd2dYMkpwZEV4bGJtZDBhQ2tnZkNCZlltbDBRblZtWm1WeU8xeHVJQ0FnSUNBZ0lDQmZZbWwwVEdWdVozUm9JRDBnWDJKcGRFeGxibWQwYUNBcklHeGxibWQwYUR0Y2JpQWdJQ0FnSUgwN1hHNWNiaUFnSUNBZ0lGOTBhR2x6TG1ac2RYTm9JRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hmWW1sMFRHVnVaM1JvSUQ0Z01Da2dlMXh1SUNBZ0lDQWdJQ0FnSUY5dmRYUXVkM0pwZEdWQ2VYUmxLRjlpYVhSQ2RXWm1aWElwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc0Z0lDQWdmVHRjYmx4dUlDQWdJSFpoY2lCblpYUk1XbGRTWVhOMFpYSWdQU0JtZFc1amRHbHZiaWhzZW5kTmFXNURiMlJsVTJsNlpTa2dlMXh1WEc0Z0lDQWdJQ0IyWVhJZ1kyeGxZWEpEYjJSbElEMGdNU0E4UENCc2VuZE5hVzVEYjJSbFUybDZaVHRjYmlBZ0lDQWdJSFpoY2lCbGJtUkRiMlJsSUQwZ0tERWdQRHdnYkhwM1RXbHVRMjlrWlZOcGVtVXBJQ3NnTVR0Y2JpQWdJQ0FnSUhaaGNpQmlhWFJNWlc1bmRHZ2dQU0JzZW5kTmFXNURiMlJsVTJsNlpTQXJJREU3WEc1Y2JpQWdJQ0FnSUM4dklGTmxkSFZ3SUV4YVYxUmhZbXhsWEc0Z0lDQWdJQ0IyWVhJZ2RHRmliR1VnUFNCc2VuZFVZV0pzWlNncE8xeHVYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05zWldGeVEyOWtaVHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUhSaFlteGxMbUZrWkNoVGRISnBibWN1Wm5KdmJVTm9ZWEpEYjJSbEtHa3BJQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0IwWVdKc1pTNWhaR1FvVTNSeWFXNW5MbVp5YjIxRGFHRnlRMjlrWlNoamJHVmhja052WkdVcElDazdYRzRnSUNBZ0lDQjBZV0pzWlM1aFpHUW9VM1J5YVc1bkxtWnliMjFEYUdGeVEyOWtaU2hsYm1SRGIyUmxLU0FwTzF4dVhHNGdJQ0FnSUNCMllYSWdZbmwwWlU5MWRDQTlJR0o1ZEdWQmNuSmhlVTkxZEhCMWRGTjBjbVZoYlNncE8xeHVJQ0FnSUNBZ2RtRnlJR0pwZEU5MWRDQTlJR0pwZEU5MWRIQjFkRk4wY21WaGJTaGllWFJsVDNWMEtUdGNibHh1SUNBZ0lDQWdMeThnWTJ4bFlYSWdZMjlrWlZ4dUlDQWdJQ0FnWW1sMFQzVjBMbmR5YVhSbEtHTnNaV0Z5UTI5a1pTd2dZbWwwVEdWdVozUm9LVHRjYmx4dUlDQWdJQ0FnZG1GeUlHUmhkR0ZKYm1SbGVDQTlJREE3WEc1Y2JpQWdJQ0FnSUhaaGNpQnpJRDBnVTNSeWFXNW5MbVp5YjIxRGFHRnlRMjlrWlNoZlpHRjBZVnRrWVhSaFNXNWtaWGhkS1R0Y2JpQWdJQ0FnSUdSaGRHRkpibVJsZUNBclBTQXhPMXh1WEc0Z0lDQWdJQ0IzYUdsc1pTQW9aR0YwWVVsdVpHVjRJRHdnWDJSaGRHRXViR1Z1WjNSb0tTQjdYRzVjYmlBZ0lDQWdJQ0FnZG1GeUlHTWdQU0JUZEhKcGJtY3Vabkp2YlVOb1lYSkRiMlJsS0Y5a1lYUmhXMlJoZEdGSmJtUmxlRjBwTzF4dUlDQWdJQ0FnSUNCa1lYUmhTVzVrWlhnZ0t6MGdNVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9kR0ZpYkdVdVkyOXVkR0ZwYm5Nb2N5QXJJR01wSUNrZ2UxeHVYRzRnSUNBZ0lDQWdJQ0FnY3lBOUlITWdLeUJqTzF4dVhHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNWNiaUFnSUNBZ0lDQWdJQ0JpYVhSUGRYUXVkM0pwZEdVb2RHRmliR1V1YVc1a1pYaFBaaWh6S1N3Z1ltbDBUR1Z1WjNSb0tUdGNibHh1SUNBZ0lDQWdJQ0FnSUdsbUlDaDBZV0pzWlM1emFYcGxLQ2tnUENBd2VHWm1aaWtnZTF4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2RHRmliR1V1YzJsNlpTZ3BJRDA5SUNneElEdzhJR0pwZEV4bGJtZDBhQ2tnS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdKcGRFeGxibWQwYUNBclBTQXhPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCMFlXSnNaUzVoWkdRb2N5QXJJR01wTzF4dUlDQWdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0FnSUhNZ1BTQmpPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdKcGRFOTFkQzUzY21sMFpTaDBZV0pzWlM1cGJtUmxlRTltS0hNcExDQmlhWFJNWlc1bmRHZ3BPMXh1WEc0Z0lDQWdJQ0F2THlCbGJtUWdZMjlrWlZ4dUlDQWdJQ0FnWW1sMFQzVjBMbmR5YVhSbEtHVnVaRU52WkdVc0lHSnBkRXhsYm1kMGFDazdYRzVjYmlBZ0lDQWdJR0pwZEU5MWRDNW1iSFZ6YUNncE8xeHVYRzRnSUNBZ0lDQnlaWFIxY200Z1lubDBaVTkxZEM1MGIwSjVkR1ZCY25KaGVTZ3BPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQjJZWElnYkhwM1ZHRmliR1VnUFNCbWRXNWpkR2x2YmlncElIdGNibHh1SUNBZ0lDQWdkbUZ5SUY5dFlYQWdQU0I3ZlR0Y2JpQWdJQ0FnSUhaaGNpQmZjMmw2WlNBOUlEQTdYRzVjYmlBZ0lDQWdJSFpoY2lCZmRHaHBjeUE5SUh0OU8xeHVYRzRnSUNBZ0lDQmZkR2hwY3k1aFpHUWdQU0JtZFc1amRHbHZiaWhyWlhrcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0Y5MGFHbHpMbU52Ym5SaGFXNXpLR3RsZVNrZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RrZFhBZ2EyVjVPaWNnS3lCclpYa3BPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUY5dFlYQmJhMlY1WFNBOUlGOXphWHBsTzF4dUlDQWdJQ0FnSUNCZmMybDZaU0FyUFNBeE8xeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdYM1JvYVhNdWMybDZaU0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1gzTnBlbVU3WEc0Z0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNCZmRHaHBjeTVwYm1SbGVFOW1JRDBnWm5WdVkzUnBiMjRvYTJWNUtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmZiV0Z3VzJ0bGVWMDdYRzRnSUNBZ0lDQjlPMXh1WEc0Z0lDQWdJQ0JmZEdocGN5NWpiMjUwWVdsdWN5QTlJR1oxYm1OMGFXOXVLR3RsZVNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RIbHdaVzltSUY5dFlYQmJhMlY1WFNBaFBTQW5kVzVrWldacGJtVmtKenRjYmlBZ0lDQWdJSDA3WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJmZEdocGN6dGNiaUFnSUNCOU8xeHVYRzRnSUNBZ2NtVjBkWEp1SUY5MGFHbHpPMXh1SUNCOU8xeHVYRzRnSUhaaGNpQmpjbVZoZEdWSmJXZFVZV2NnUFNCbWRXNWpkR2x2YmloM2FXUjBhQ3dnYUdWcFoyaDBMQ0JuWlhSUWFYaGxiQ3dnWVd4MEtTQjdYRzVjYmlBZ0lDQjJZWElnWjJsbUlEMGdaMmxtU1cxaFoyVW9kMmxrZEdnc0lHaGxhV2RvZENrN1hHNGdJQ0FnWm05eUlDaDJZWElnZVNBOUlEQTdJSGtnUENCb1pXbG5hSFE3SUhrZ0t6MGdNU2tnZTF4dUlDQWdJQ0FnWm05eUlDaDJZWElnZUNBOUlEQTdJSGdnUENCM2FXUjBhRHNnZUNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUdkcFppNXpaWFJRYVhobGJDaDRMQ0I1TENCblpYUlFhWGhsYkNoNExDQjVLU0FwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCaUlEMGdZbmwwWlVGeWNtRjVUM1YwY0hWMFUzUnlaV0Z0S0NrN1hHNGdJQ0FnWjJsbUxuZHlhWFJsS0dJcE8xeHVYRzRnSUNBZ2RtRnlJR0poYzJVMk5DQTlJR0poYzJVMk5FVnVZMjlrWlU5MWRIQjFkRk4wY21WaGJTZ3BPMXh1SUNBZ0lIWmhjaUJpZVhSbGN5QTlJR0l1ZEc5Q2VYUmxRWEp5WVhrb0tUdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHSjVkR1Z6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0JpWVhObE5qUXVkM0pwZEdWQ2VYUmxLR0o1ZEdWelcybGRLVHRjYmlBZ0lDQjlYRzRnSUNBZ1ltRnpaVFkwTG1ac2RYTm9LQ2s3WEc1Y2JpQWdJQ0IyWVhJZ2FXMW5JRDBnSnljN1hHNGdJQ0FnYVcxbklDczlJQ2M4YVcxbkp6dGNiaUFnSUNCcGJXY2dLejBnSjF4Y2RUQXdNakJ6Y21NOVhDSW5PMXh1SUNBZ0lHbHRaeUFyUFNBblpHRjBZVHBwYldGblpTOW5hV1k3WW1GelpUWTBMQ2M3WEc0Z0lDQWdhVzFuSUNzOUlHSmhjMlUyTkR0Y2JpQWdJQ0JwYldjZ0t6MGdKMXdpSnp0Y2JpQWdJQ0JwYldjZ0t6MGdKMXhjZFRBd01qQjNhV1IwYUQxY0lpYzdYRzRnSUNBZ2FXMW5JQ3M5SUhkcFpIUm9PMXh1SUNBZ0lHbHRaeUFyUFNBblhDSW5PMXh1SUNBZ0lHbHRaeUFyUFNBblhGeDFNREF5TUdobGFXZG9kRDFjSWljN1hHNGdJQ0FnYVcxbklDczlJR2hsYVdkb2REdGNiaUFnSUNCcGJXY2dLejBnSjF3aUp6dGNiaUFnSUNCcFppQW9ZV3gwS1NCN1hHNGdJQ0FnSUNCcGJXY2dLejBnSjF4Y2RUQXdNakJoYkhROVhDSW5PMXh1SUNBZ0lDQWdhVzFuSUNzOUlHRnNkRHRjYmlBZ0lDQWdJR2x0WnlBclBTQW5YQ0luTzF4dUlDQWdJSDFjYmlBZ0lDQnBiV2NnS3owZ0p5OCtKenRjYmx4dUlDQWdJSEpsZEhWeWJpQnBiV2M3WEc0Z0lIMDdYRzVjYmlBZ2RtRnlJR055WldGMFpVbHRaMDlpYW1WamRDQTlJR1oxYm1OMGFXOXVLSGRwWkhSb0xDQm9aV2xuYUhRc0lHZGxkRkJwZUdWc0tTQjdYRzVjYmlBZ0lDQjJZWElnWjJsbUlEMGdaMmxtU1cxaFoyVW9kMmxrZEdnc0lHaGxhV2RvZENrN1hHNGdJQ0FnWm05eUlDaDJZWElnZVNBOUlEQTdJSGtnUENCb1pXbG5hSFE3SUhrZ0t6MGdNU2tnZTF4dUlDQWdJQ0FnWm05eUlDaDJZWElnZUNBOUlEQTdJSGdnUENCM2FXUjBhRHNnZUNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUdkcFppNXpaWFJRYVhobGJDaDRMQ0I1TENCblpYUlFhWGhsYkNoNExDQjVLU0FwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCaUlEMGdZbmwwWlVGeWNtRjVUM1YwY0hWMFUzUnlaV0Z0S0NrN1hHNGdJQ0FnWjJsbUxuZHlhWFJsS0dJcE8xeHVYRzRnSUNBZ2RtRnlJR0poYzJVMk5DQTlJR0poYzJVMk5FVnVZMjlrWlU5MWRIQjFkRk4wY21WaGJTZ3BPMXh1SUNBZ0lIWmhjaUJpZVhSbGN5QTlJR0l1ZEc5Q2VYUmxRWEp5WVhrb0tUdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHSjVkR1Z6TG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0JpWVhObE5qUXVkM0pwZEdWQ2VYUmxLR0o1ZEdWelcybGRLVHRjYmlBZ0lDQjlYRzRnSUNBZ1ltRnpaVFkwTG1ac2RYTm9LQ2s3WEc1Y2JpQWdJQ0IyWVhJZ2FXMW5JRDBnYm1WM0lFbHRZV2RsS0NrN1hHNGdJQ0FnYVcxbkxuTnlZeUE5SUNka1lYUmhPbWx0WVdkbEwyZHBaanRpWVhObE5qUXNKeUFySUdKaGMyVTJORHRjYmlBZ0lDQnBiV2N1ZDJsa2RHZ2dQU0IzYVdSMGFEdGNiaUFnSUNCcGJXY3VhR1ZwWjJoMElEMGdhR1ZwWjJoME8xeHVYRzRnSUNBZ2NtVjBkWEp1SUdsdFp6dGNiaUFnZlR0Y2JseHVJQ0F2THkwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBdkx5QnlaWFIxY201eklIRnlZMjlrWlNCbWRXNWpkR2x2Ymk1Y2JseHVJQ0J5WlhSMWNtNGdlMXh1SUNBZ0lGRlNRMjlrWlRvZ2NYSmpiMlJsTEZ4dUlDQWdJRkZTVlhScGJEb2dVVkpWZEdsc1hHNGdJSDA3WEc1OUtDazdYRzVjYmlobWRXNWpkR2x2YmlBb1ptRmpkRzl5ZVNrZ2UxeHVJQ0JwWmlBb2RIbHdaVzltSUdSbFptbHVaU0E5UFQwZ0oyWjFibU4wYVc5dUp5QW1KaUJrWldacGJtVXVZVzFrS1NCN1hHNGdJQ0FnSUNCa1pXWnBibVVvVzEwc0lHWmhZM1J2Y25rcE8xeHVJQ0I5SUdWc2MyVWdhV1lnS0hSNWNHVnZaaUJsZUhCdmNuUnpJRDA5UFNBbmIySnFaV04wSnlrZ2UxeHVJQ0FnSUNBZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbVlXTjBiM0o1S0NrN1hHNGdJSDFjYm4wb1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNCUlVrTnZaR1U2SUhGeVkyOWtaUzVSVWtOdlpHVXNYRzRnSUNBZ0lDQlJVbFYwYVd3NklIRnlZMjlrWlM1UlVsVjBhV3hjYmlBZ0lDQjlPMXh1ZlNrcE8xeHVYRzVjYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTSUM4dlhHNHZMeUF1TDNOeVl5OXhjbU52WkdVdWFuTWlMQ0pjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1Wlhod2IzSjBjeTVmWDJWelRXOWtkV3hsSUQwZ2RISjFaVHRjYmx4dWRtRnlJRjlwZEdWeVlYUnZjaUE5SUhKbGNYVnBjbVVvWENJdUxpOWpiM0psTFdwekwzTjViV0p2YkM5cGRHVnlZWFJ2Y2x3aUtUdGNibHh1ZG1GeUlGOXBkR1Z5WVhSdmNqSWdQU0JmYVc1MFpYSnZjRkpsY1hWcGNtVkVaV1poZFd4MEtGOXBkR1Z5WVhSdmNpazdYRzVjYm5aaGNpQmZjM2x0WW05c0lEMGdjbVZ4ZFdseVpTaGNJaTR1TDJOdmNtVXRhbk12YzNsdFltOXNYQ0lwTzF4dVhHNTJZWElnWDNONWJXSnZiRElnUFNCZmFXNTBaWEp2Y0ZKbGNYVnBjbVZFWldaaGRXeDBLRjl6ZVcxaWIyd3BPMXh1WEc1MllYSWdYM1I1Y0dWdlppQTlJSFI1Y0dWdlppQmZjM2x0WW05c01pNWtaV1poZFd4MElEMDlQU0JjSW1aMWJtTjBhVzl1WENJZ0ppWWdkSGx3Wlc5bUlGOXBkR1Z5WVhSdmNqSXVaR1ZtWVhWc2RDQTlQVDBnWENKemVXMWliMnhjSWlBL0lHWjFibU4wYVc5dUlDaHZZbW9wSUhzZ2NtVjBkWEp1SUhSNWNHVnZaaUJ2WW1vN0lIMGdPaUJtZFc1amRHbHZiaUFvYjJKcUtTQjdJSEpsZEhWeWJpQnZZbW9nSmlZZ2RIbHdaVzltSUY5emVXMWliMnd5TG1SbFptRjFiSFFnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCdlltb3VZMjl1YzNSeWRXTjBiM0lnUFQwOUlGOXplVzFpYjJ3eUxtUmxabUYxYkhRZ0ppWWdiMkpxSUNFOVBTQmZjM2x0WW05c01pNWtaV1poZFd4MExuQnliM1J2ZEhsd1pTQS9JRndpYzNsdFltOXNYQ0lnT2lCMGVYQmxiMllnYjJKcU95QjlPMXh1WEc1bWRXNWpkR2x2YmlCZmFXNTBaWEp2Y0ZKbGNYVnBjbVZFWldaaGRXeDBLRzlpYWlrZ2V5QnlaWFIxY200Z2IySnFJQ1ltSUc5aWFpNWZYMlZ6VFc5a2RXeGxJRDhnYjJKcUlEb2dleUJrWldaaGRXeDBPaUJ2WW1vZ2ZUc2dmVnh1WEc1bGVIQnZjblJ6TG1SbFptRjFiSFFnUFNCMGVYQmxiMllnWDNONWJXSnZiREl1WkdWbVlYVnNkQ0E5UFQwZ1hDSm1kVzVqZEdsdmJsd2lJQ1ltSUY5MGVYQmxiMllvWDJsMFpYSmhkRzl5TWk1a1pXWmhkV3gwS1NBOVBUMGdYQ0p6ZVcxaWIyeGNJaUEvSUdaMWJtTjBhVzl1SUNodlltb3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJ2WW1vZ1BUMDlJRndpZFc1a1pXWnBibVZrWENJZ1B5QmNJblZ1WkdWbWFXNWxaRndpSURvZ1gzUjVjR1Z2Wmlodlltb3BPMXh1ZlNBNklHWjFibU4wYVc5dUlDaHZZbW9wSUh0Y2JpQWdjbVYwZFhKdUlHOWlhaUFtSmlCMGVYQmxiMllnWDNONWJXSnZiREl1WkdWbVlYVnNkQ0E5UFQwZ1hDSm1kVzVqZEdsdmJsd2lJQ1ltSUc5aWFpNWpiMjV6ZEhKMVkzUnZjaUE5UFQwZ1gzTjViV0p2YkRJdVpHVm1ZWFZzZENBbUppQnZZbW9nSVQwOUlGOXplVzFpYjJ3eUxtUmxabUYxYkhRdWNISnZkRzkwZVhCbElEOGdYQ0p6ZVcxaWIyeGNJaUE2SUhSNWNHVnZaaUJ2WW1vZ1BUMDlJRndpZFc1a1pXWnBibVZrWENJZ1B5QmNJblZ1WkdWbWFXNWxaRndpSURvZ1gzUjVjR1Z2Wmlodlltb3BPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WW1GaVpXd3RjblZ1ZEdsdFpTOW9aV3h3WlhKekwzUjVjR1Z2Wmk1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01qSmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN0lGd2laR1ZtWVhWc2RGd2lPaUJ5WlhGMWFYSmxLRndpWTI5eVpTMXFjeTlzYVdKeVlYSjVMMlp1TDNONWJXSnZiQzlwZEdWeVlYUnZjbHdpS1N3Z1gxOWxjMDF2WkhWc1pUb2dkSEoxWlNCOU8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5aVlXSmxiQzF5ZFc1MGFXMWxMMk52Y21VdGFuTXZjM2x0WW05c0wybDBaWEpoZEc5eUxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXlNMXh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSnlaWEYxYVhKbEtDY3VMaTh1TGk5dGIyUjFiR1Z6TDJWek5pNXpkSEpwYm1jdWFYUmxjbUYwYjNJbktUdGNibkpsY1hWcGNtVW9KeTR1THk0dUwyMXZaSFZzWlhNdmQyVmlMbVJ2YlM1cGRHVnlZV0pzWlNjcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQnlaWEYxYVhKbEtDY3VMaTh1TGk5dGIyUjFiR1Z6TDE5M2EzTXRaWGgwSnlrdVppZ25hWFJsY21GMGIzSW5LVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyWnVMM041YldKdmJDOXBkR1Z5WVhSdmNpNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNalJjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lKM1Z6WlNCemRISnBZM1FuTzF4dWRtRnlJQ1JoZENBZ1BTQnlaWEYxYVhKbEtDY3VMMTl6ZEhKcGJtY3RZWFFuS1NoMGNuVmxLVHRjYmx4dUx5OGdNakV1TVM0ekxqSTNJRk4wY21sdVp5NXdjbTkwYjNSNWNHVmJRRUJwZEdWeVlYUnZjbDBvS1Z4dWNtVnhkV2x5WlNnbkxpOWZhWFJsY2kxa1pXWnBibVVuS1NoVGRISnBibWNzSUNkVGRISnBibWNuTENCbWRXNWpkR2x2YmlocGRHVnlZWFJsWkNsN1hHNGdJSFJvYVhNdVgzUWdQU0JUZEhKcGJtY29hWFJsY21GMFpXUXBPeUF2THlCMFlYSm5aWFJjYmlBZ2RHaHBjeTVmYVNBOUlEQTdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDOHZJRzVsZUhRZ2FXNWtaWGhjYmk4dklESXhMakV1TlM0eUxqRWdKVk4wY21sdVowbDBaWEpoZEc5eVVISnZkRzkwZVhCbEpTNXVaWGgwS0NsY2JuMHNJR1oxYm1OMGFXOXVLQ2w3WEc0Z0lIWmhjaUJQSUNBZ0lDQTlJSFJvYVhNdVgzUmNiaUFnSUNBc0lHbHVaR1Y0SUQwZ2RHaHBjeTVmYVZ4dUlDQWdJQ3dnY0c5cGJuUTdYRzRnSUdsbUtHbHVaR1Y0SUQ0OUlFOHViR1Z1WjNSb0tYSmxkSFZ5YmlCN2RtRnNkV1U2SUhWdVpHVm1hVzVsWkN3Z1pHOXVaVG9nZEhKMVpYMDdYRzRnSUhCdmFXNTBJRDBnSkdGMEtFOHNJR2x1WkdWNEtUdGNiaUFnZEdocGN5NWZhU0FyUFNCd2IybHVkQzVzWlc1bmRHZzdYRzRnSUhKbGRIVnliaUI3ZG1Gc2RXVTZJSEJ2YVc1MExDQmtiMjVsT2lCbVlXeHpaWDA3WEc1OUtUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WlhNMkxuTjBjbWx1Wnk1cGRHVnlZWFJ2Y2k1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01qVmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWRtRnlJSFJ2U1c1MFpXZGxjaUE5SUhKbGNYVnBjbVVvSnk0dlgzUnZMV2x1ZEdWblpYSW5LVnh1SUNBc0lHUmxabWx1WldRZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJSbFptbHVaV1FuS1R0Y2JpOHZJSFJ5ZFdVZ0lDMCtJRk4wY21sdVp5TmhkRnh1THk4Z1ptRnNjMlVnTFQ0Z1UzUnlhVzVuSTJOdlpHVlFiMmx1ZEVGMFhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtGUlBYMU5VVWtsT1J5bDdYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaWgwYUdGMExDQndiM01wZTF4dUlDQWdJSFpoY2lCeklEMGdVM1J5YVc1bktHUmxabWx1WldRb2RHaGhkQ2twWEc0Z0lDQWdJQ0FzSUdrZ1BTQjBiMGx1ZEdWblpYSW9jRzl6S1Z4dUlDQWdJQ0FnTENCc0lEMGdjeTVzWlc1bmRHaGNiaUFnSUNBZ0lDd2dZU3dnWWp0Y2JpQWdJQ0JwWmlocElEd2dNQ0I4ZkNCcElENDlJR3dwY21WMGRYSnVJRlJQWDFOVVVrbE9SeUEvSUNjbklEb2dkVzVrWldacGJtVmtPMXh1SUNBZ0lHRWdQU0J6TG1Ob1lYSkRiMlJsUVhRb2FTazdYRzRnSUNBZ2NtVjBkWEp1SUdFZ1BDQXdlR1E0TURBZ2ZId2dZU0ErSURCNFpHSm1aaUI4ZkNCcElDc2dNU0E5UFQwZ2JDQjhmQ0FvWWlBOUlITXVZMmhoY2tOdlpHVkJkQ2hwSUNzZ01Ta3BJRHdnTUhoa1l6QXdJSHg4SUdJZ1BpQXdlR1JtWm1aY2JpQWdJQ0FnSUQ4Z1ZFOWZVMVJTU1U1SElEOGdjeTVqYUdGeVFYUW9hU2tnT2lCaFhHNGdJQ0FnSUNBNklGUlBYMU5VVWtsT1J5QS9JSE11YzJ4cFkyVW9hU3dnYVNBcklESXBJRG9nS0dFZ0xTQXdlR1E0TURBZ1BEd2dNVEFwSUNzZ0tHSWdMU0F3ZUdSak1EQXBJQ3NnTUhneE1EQXdNRHRjYmlBZ2ZUdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXpkSEpwYm1jdFlYUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREkyWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJaTh2SURjdU1TNDBJRlJ2U1c1MFpXZGxjbHh1ZG1GeUlHTmxhV3dnSUQwZ1RXRjBhQzVqWldsc1hHNGdJQ3dnWm14dmIzSWdQU0JOWVhSb0xtWnNiMjl5TzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlocGRDbDdYRzRnSUhKbGRIVnliaUJwYzA1aFRpaHBkQ0E5SUN0cGRDa2dQeUF3SURvZ0tHbDBJRDRnTUNBL0lHWnNiMjl5SURvZ1kyVnBiQ2tvYVhRcE8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgzUnZMV2x1ZEdWblpYSXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREkzWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJaTh2SURjdU1pNHhJRkpsY1hWcGNtVlBZbXBsWTNSRGIyVnlZMmxpYkdVb1lYSm5kVzFsYm5RcFhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHbDBLWHRjYmlBZ2FXWW9hWFFnUFQwZ2RXNWtaV1pwYm1Wa0tYUm9jbTkzSUZSNWNHVkZjbkp2Y2loY0lrTmhiaWQwSUdOaGJHd2diV1YwYUc5a0lHOXVJQ0JjSWlBcklHbDBLVHRjYmlBZ2NtVjBkWEp1SUdsME8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyUmxabWx1WldRdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlESTRYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0lpZDFjMlVnYzNSeWFXTjBKenRjYm5aaGNpQk1TVUpTUVZKWklDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMnhwWW5KaGNua25LVnh1SUNBc0lDUmxlSEJ2Y25RZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZaWGh3YjNKMEp5bGNiaUFnTENCeVpXUmxabWx1WlNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzSmxaR1ZtYVc1bEp5bGNiaUFnTENCb2FXUmxJQ0FnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyaHBaR1VuS1Z4dUlDQXNJR2hoY3lBZ0lDQWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYUdGekp5bGNiaUFnTENCSmRHVnlZWFJ2Y25NZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgybDBaWEpoZEc5eWN5Y3BYRzRnSUN3Z0pHbDBaWEpEY21WaGRHVWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOXBkR1Z5TFdOeVpXRjBaU2NwWEc0Z0lDd2djMlYwVkc5VGRISnBibWRVWVdjZ1BTQnlaWEYxYVhKbEtDY3VMMTl6WlhRdGRHOHRjM1J5YVc1bkxYUmhaeWNwWEc0Z0lDd2daMlYwVUhKdmRHOTBlWEJsVDJZZ1BTQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRaM0J2SnlsY2JpQWdMQ0JKVkVWU1FWUlBVaUFnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNkcmN5Y3BLQ2RwZEdWeVlYUnZjaWNwWEc0Z0lDd2dRbFZIUjFrZ0lDQWdJQ0FnSUNBZ1BTQWhLRnRkTG10bGVYTWdKaVlnSjI1bGVIUW5JR2x1SUZ0ZExtdGxlWE1vS1NrZ0x5OGdVMkZtWVhKcElHaGhjeUJpZFdkbmVTQnBkR1Z5WVhSdmNuTWdkeTl2SUdCdVpYaDBZRnh1SUNBc0lFWkdYMGxVUlZKQlZFOVNJQ0FnSUQwZ0owQkFhWFJsY21GMGIzSW5YRzRnSUN3Z1MwVlpVeUFnSUNBZ0lDQWdJQ0FnUFNBbmEyVjVjeWRjYmlBZ0xDQldRVXhWUlZNZ0lDQWdJQ0FnSUNBOUlDZDJZV3gxWlhNbk8xeHVYRzUyWVhJZ2NtVjBkWEp1VkdocGN5QTlJR1oxYm1OMGFXOXVLQ2w3SUhKbGRIVnliaUIwYUdsek95QjlPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0VKaGMyVXNJRTVCVFVVc0lFTnZibk4wY25WamRHOXlMQ0J1WlhoMExDQkVSVVpCVlV4VUxDQkpVMTlUUlZRc0lFWlBVa05GUkNsN1hHNGdJQ1JwZEdWeVEzSmxZWFJsS0VOdmJuTjBjblZqZEc5eUxDQk9RVTFGTENCdVpYaDBLVHRjYmlBZ2RtRnlJR2RsZEUxbGRHaHZaQ0E5SUdaMWJtTjBhVzl1S0d0cGJtUXBlMXh1SUNBZ0lHbG1LQ0ZDVlVkSFdTQW1KaUJyYVc1a0lHbHVJSEJ5YjNSdktYSmxkSFZ5YmlCd2NtOTBiMXRyYVc1a1hUdGNiaUFnSUNCemQybDBZMmdvYTJsdVpDbDdYRzRnSUNBZ0lDQmpZWE5sSUV0RldWTTZJSEpsZEhWeWJpQm1kVzVqZEdsdmJpQnJaWGx6S0NsN0lISmxkSFZ5YmlCdVpYY2dRMjl1YzNSeWRXTjBiM0lvZEdocGN5d2dhMmx1WkNrN0lIMDdYRzRnSUNBZ0lDQmpZWE5sSUZaQlRGVkZVem9nY21WMGRYSnVJR1oxYm1OMGFXOXVJSFpoYkhWbGN5Z3BleUJ5WlhSMWNtNGdibVYzSUVOdmJuTjBjblZqZEc5eUtIUm9hWE1zSUd0cGJtUXBPeUI5TzF4dUlDQWdJSDBnY21WMGRYSnVJR1oxYm1OMGFXOXVJR1Z1ZEhKcFpYTW9LWHNnY21WMGRYSnVJRzVsZHlCRGIyNXpkSEoxWTNSdmNpaDBhR2x6TENCcmFXNWtLVHNnZlR0Y2JpQWdmVHRjYmlBZ2RtRnlJRlJCUnlBZ0lDQWdJQ0FnUFNCT1FVMUZJQ3NnSnlCSmRHVnlZWFJ2Y2lkY2JpQWdJQ0FzSUVSRlJsOVdRVXhWUlZNZ1BTQkVSVVpCVlV4VUlEMDlJRlpCVEZWRlUxeHVJQ0FnSUN3Z1ZrRk1WVVZUWDBKVlJ5QTlJR1poYkhObFhHNGdJQ0FnTENCd2NtOTBieUFnSUNBZ0lEMGdRbUZ6WlM1d2NtOTBiM1I1Y0dWY2JpQWdJQ0FzSUNSdVlYUnBkbVVnSUNBZ1BTQndjbTkwYjF0SlZFVlNRVlJQVWwwZ2ZId2djSEp2ZEc5YlJrWmZTVlJGVWtGVVQxSmRJSHg4SUVSRlJrRlZURlFnSmlZZ2NISnZkRzliUkVWR1FWVk1WRjFjYmlBZ0lDQXNJQ1JrWldaaGRXeDBJQ0FnUFNBa2JtRjBhWFpsSUh4OElHZGxkRTFsZEdodlpDaEVSVVpCVlV4VUtWeHVJQ0FnSUN3Z0pHVnVkSEpwWlhNZ0lDQTlJRVJGUmtGVlRGUWdQeUFoUkVWR1gxWkJURlZGVXlBL0lDUmtaV1poZFd4MElEb2daMlYwVFdWMGFHOWtLQ2RsYm5SeWFXVnpKeWtnT2lCMWJtUmxabWx1WldSY2JpQWdJQ0FzSUNSaGJubE9ZWFJwZG1VZ1BTQk9RVTFGSUQwOUlDZEJjbkpoZVNjZ1B5QndjbTkwYnk1bGJuUnlhV1Z6SUh4OElDUnVZWFJwZG1VZ09pQWtibUYwYVhabFhHNGdJQ0FnTENCdFpYUm9iMlJ6TENCclpYa3NJRWwwWlhKaGRHOXlVSEp2ZEc5MGVYQmxPMXh1SUNBdkx5QkdhWGdnYm1GMGFYWmxYRzRnSUdsbUtDUmhibmxPWVhScGRtVXBlMXh1SUNBZ0lFbDBaWEpoZEc5eVVISnZkRzkwZVhCbElEMGdaMlYwVUhKdmRHOTBlWEJsVDJZb0pHRnVlVTVoZEdsMlpTNWpZV3hzS0c1bGR5QkNZWE5sS1NrN1hHNGdJQ0FnYVdZb1NYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVZ0lUMDlJRTlpYW1WamRDNXdjbTkwYjNSNWNHVXBlMXh1SUNBZ0lDQWdMeThnVTJWMElFQkFkRzlUZEhKcGJtZFVZV2NnZEc4Z2JtRjBhWFpsSUdsMFpYSmhkRzl5YzF4dUlDQWdJQ0FnYzJWMFZHOVRkSEpwYm1kVVlXY29TWFJsY21GMGIzSlFjbTkwYjNSNWNHVXNJRlJCUnl3Z2RISjFaU2s3WEc0Z0lDQWdJQ0F2THlCbWFYZ2dabTl5SUhOdmJXVWdiMnhrSUdWdVoybHVaWE5jYmlBZ0lDQWdJR2xtS0NGTVNVSlNRVkpaSUNZbUlDRm9ZWE1vU1hSbGNtRjBiM0pRY205MGIzUjVjR1VzSUVsVVJWSkJWRTlTS1Nsb2FXUmxLRWwwWlhKaGRHOXlVSEp2ZEc5MGVYQmxMQ0JKVkVWU1FWUlBVaXdnY21WMGRYSnVWR2hwY3lrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUM4dklHWnBlQ0JCY25KaGVTTjdkbUZzZFdWekxDQkFRR2wwWlhKaGRHOXlmUzV1WVcxbElHbHVJRlk0SUM4Z1JrWmNiaUFnYVdZb1JFVkdYMVpCVEZWRlV5QW1KaUFrYm1GMGFYWmxJQ1ltSUNSdVlYUnBkbVV1Ym1GdFpTQWhQVDBnVmtGTVZVVlRLWHRjYmlBZ0lDQldRVXhWUlZOZlFsVkhJRDBnZEhKMVpUdGNiaUFnSUNBa1pHVm1ZWFZzZENBOUlHWjFibU4wYVc5dUlIWmhiSFZsY3lncGV5QnlaWFIxY200Z0pHNWhkR2wyWlM1allXeHNLSFJvYVhNcE95QjlPMXh1SUNCOVhHNGdJQzh2SUVSbFptbHVaU0JwZEdWeVlYUnZjbHh1SUNCcFppZ29JVXhKUWxKQlVsa2dmSHdnUms5U1EwVkVLU0FtSmlBb1FsVkhSMWtnZkh3Z1ZrRk1WVVZUWDBKVlJ5QjhmQ0FoY0hKdmRHOWJTVlJGVWtGVVQxSmRLU2w3WEc0Z0lDQWdhR2xrWlNod2NtOTBieXdnU1ZSRlVrRlVUMUlzSUNSa1pXWmhkV3gwS1R0Y2JpQWdmVnh1SUNBdkx5QlFiSFZuSUdadmNpQnNhV0p5WVhKNVhHNGdJRWwwWlhKaGRHOXljMXRPUVUxRlhTQTlJQ1JrWldaaGRXeDBPMXh1SUNCSmRHVnlZWFJ2Y25OYlZFRkhYU0FnUFNCeVpYUjFjbTVVYUdsek8xeHVJQ0JwWmloRVJVWkJWVXhVS1h0Y2JpQWdJQ0J0WlhSb2IyUnpJRDBnZTF4dUlDQWdJQ0FnZG1Gc2RXVnpPaUFnUkVWR1gxWkJURlZGVXlBL0lDUmtaV1poZFd4MElEb2daMlYwVFdWMGFHOWtLRlpCVEZWRlV5a3NYRzRnSUNBZ0lDQnJaWGx6T2lBZ0lDQkpVMTlUUlZRZ0lDQWdJRDhnSkdSbFptRjFiSFFnT2lCblpYUk5aWFJvYjJRb1MwVlpVeWtzWEc0Z0lDQWdJQ0JsYm5SeWFXVnpPaUFrWlc1MGNtbGxjMXh1SUNBZ0lIMDdYRzRnSUNBZ2FXWW9SazlTUTBWRUtXWnZjaWhyWlhrZ2FXNGdiV1YwYUc5a2N5bDdYRzRnSUNBZ0lDQnBaaWdoS0d0bGVTQnBiaUJ3Y205MGJ5a3BjbVZrWldacGJtVW9jSEp2ZEc4c0lHdGxlU3dnYldWMGFHOWtjMXRyWlhsZEtUdGNiaUFnSUNCOUlHVnNjMlVnSkdWNGNHOXlkQ2drWlhod2IzSjBMbEFnS3lBa1pYaHdiM0owTGtZZ0tpQW9RbFZIUjFrZ2ZId2dWa0ZNVlVWVFgwSlZSeWtzSUU1QlRVVXNJRzFsZEdodlpITXBPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnRaWFJvYjJSek8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgybDBaWEl0WkdWbWFXNWxMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F5T1Z4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0p0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSFJ5ZFdVN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlzYVdKeVlYSjVMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F6TUZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0p0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEpsY1hWcGNtVW9KeTR2WDJocFpHVW5LVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgzSmxaR1ZtYVc1bExtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXpNVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSjJZWElnYUdGelQzZHVVSEp2Y0dWeWRIa2dQU0I3ZlM1b1lYTlBkMjVRY205d1pYSjBlVHRjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvYVhRc0lHdGxlU2w3WEc0Z0lISmxkSFZ5YmlCb1lYTlBkMjVRY205d1pYSjBlUzVqWVd4c0tHbDBMQ0JyWlhrcE8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyaGhjeTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTXpKY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0I3ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMmwwWlhKaGRHOXljeTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTXpOY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVkbUZ5SUdOeVpXRjBaU0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmIySnFaV04wTFdOeVpXRjBaU2NwWEc0Z0lDd2daR1Z6WTNKcGNIUnZjaUFnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl3Y205d1pYSjBlUzFrWlhOakp5bGNiaUFnTENCelpYUlViMU4wY21sdVoxUmhaeUE5SUhKbGNYVnBjbVVvSnk0dlgzTmxkQzEwYnkxemRISnBibWN0ZEdGbkp5bGNiaUFnTENCSmRHVnlZWFJ2Y2xCeWIzUnZkSGx3WlNBOUlIdDlPMXh1WEc0dkx5QXlOUzR4TGpJdU1TNHhJQ1ZKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU1ZiUUVCcGRHVnlZWFJ2Y2wwb0tWeHVjbVZ4ZFdseVpTZ25MaTlmYUdsa1pTY3BLRWwwWlhKaGRHOXlVSEp2ZEc5MGVYQmxMQ0J5WlhGMWFYSmxLQ2N1TDE5M2EzTW5LU2duYVhSbGNtRjBiM0luS1N3Z1puVnVZM1JwYjI0b0tYc2djbVYwZFhKdUlIUm9hWE03SUgwcE8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLRU52Ym5OMGNuVmpkRzl5TENCT1FVMUZMQ0J1WlhoMEtYdGNiaUFnUTI5dWMzUnlkV04wYjNJdWNISnZkRzkwZVhCbElEMGdZM0psWVhSbEtFbDBaWEpoZEc5eVVISnZkRzkwZVhCbExDQjdibVY0ZERvZ1pHVnpZM0pwY0hSdmNpZ3hMQ0J1WlhoMEtYMHBPMXh1SUNCelpYUlViMU4wY21sdVoxUmhaeWhEYjI1emRISjFZM1J2Y2l3Z1RrRk5SU0FySUNjZ1NYUmxjbUYwYjNJbktUdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXBkR1Z5TFdOeVpXRjBaUzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTXpSY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpTHk4Z01Ua3VNUzR5TGpJZ0x5QXhOUzR5TGpNdU5TQlBZbXBsWTNRdVkzSmxZWFJsS0U4Z1d5d2dVSEp2Y0dWeWRHbGxjMTBwWEc1MllYSWdZVzVQWW1wbFkzUWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOWhiaTF2WW1wbFkzUW5LVnh1SUNBc0lHUlFjeUFnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmIySnFaV04wTFdSd2N5Y3BYRzRnSUN3Z1pXNTFiVUoxWjB0bGVYTWdQU0J5WlhGMWFYSmxLQ2N1TDE5bGJuVnRMV0oxWnkxclpYbHpKeWxjYmlBZ0xDQkpSVjlRVWs5VVR5QWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzTm9ZWEpsWkMxclpYa25LU2duU1VWZlVGSlBWRThuS1Z4dUlDQXNJRVZ0Y0hSNUlDQWdJQ0FnSUQwZ1puVnVZM1JwYjI0b0tYc2dMeW9nWlcxd2RIa2dLaThnZlZ4dUlDQXNJRkJTVDFSUFZGbFFSU0FnSUQwZ0ozQnliM1J2ZEhsd1pTYzdYRzVjYmk4dklFTnlaV0YwWlNCdlltcGxZM1FnZDJsMGFDQm1ZV3RsSUdCdWRXeHNZQ0J3Y205MGIzUjVjR1U2SUhWelpTQnBabkpoYldVZ1QySnFaV04wSUhkcGRHZ2dZMnhsWVhKbFpDQndjbTkwYjNSNWNHVmNiblpoY2lCamNtVmhkR1ZFYVdOMElEMGdablZ1WTNScGIyNG9LWHRjYmlBZ0x5OGdWR2h5WVhOb0xDQjNZWE4wWlNCaGJtUWdjMjlrYjIxNU9pQkpSU0JIUXlCaWRXZGNiaUFnZG1GeUlHbG1jbUZ0WlNBOUlISmxjWFZwY21Vb0p5NHZYMlJ2YlMxamNtVmhkR1VuS1NnbmFXWnlZVzFsSnlsY2JpQWdJQ0FzSUdrZ0lDQWdJQ0E5SUdWdWRXMUNkV2RMWlhsekxteGxibWQwYUZ4dUlDQWdJQ3dnYkhRZ0lDQWdJRDBnSnp3blhHNGdJQ0FnTENCbmRDQWdJQ0FnUFNBblBpZGNiaUFnSUNBc0lHbG1jbUZ0WlVSdlkzVnRaVzUwTzF4dUlDQnBabkpoYldVdWMzUjViR1V1WkdsemNHeGhlU0E5SUNkdWIyNWxKenRjYmlBZ2NtVnhkV2x5WlNnbkxpOWZhSFJ0YkNjcExtRndjR1Z1WkVOb2FXeGtLR2xtY21GdFpTazdYRzRnSUdsbWNtRnRaUzV6Y21NZ1BTQW5hbUYyWVhOamNtbHdkRG9uT3lBdkx5QmxjMnhwYm5RdFpHbHpZV0pzWlMxc2FXNWxJRzV2TFhOamNtbHdkQzExY214Y2JpQWdMeThnWTNKbFlYUmxSR2xqZENBOUlHbG1jbUZ0WlM1amIyNTBaVzUwVjJsdVpHOTNMazlpYW1WamREdGNiaUFnTHk4Z2FIUnRiQzV5WlcxdmRtVkRhR2xzWkNocFpuSmhiV1VwTzF4dUlDQnBabkpoYldWRWIyTjFiV1Z1ZENBOUlHbG1jbUZ0WlM1amIyNTBaVzUwVjJsdVpHOTNMbVJ2WTNWdFpXNTBPMXh1SUNCcFpuSmhiV1ZFYjJOMWJXVnVkQzV2Y0dWdUtDazdYRzRnSUdsbWNtRnRaVVJ2WTNWdFpXNTBMbmR5YVhSbEtHeDBJQ3NnSjNOamNtbHdkQ2NnS3lCbmRDQXJJQ2RrYjJOMWJXVnVkQzVHUFU5aWFtVmpkQ2NnS3lCc2RDQXJJQ2N2YzJOeWFYQjBKeUFySUdkMEtUdGNiaUFnYVdaeVlXMWxSRzlqZFcxbGJuUXVZMnh2YzJVb0tUdGNiaUFnWTNKbFlYUmxSR2xqZENBOUlHbG1jbUZ0WlVSdlkzVnRaVzUwTGtZN1hHNGdJSGRvYVd4bEtHa3RMU2xrWld4bGRHVWdZM0psWVhSbFJHbGpkRnRRVWs5VVQxUlpVRVZkVzJWdWRXMUNkV2RMWlhselcybGRYVHRjYmlBZ2NtVjBkWEp1SUdOeVpXRjBaVVJwWTNRb0tUdGNibjA3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1QySnFaV04wTG1OeVpXRjBaU0I4ZkNCbWRXNWpkR2x2YmlCamNtVmhkR1VvVHl3Z1VISnZjR1Z5ZEdsbGN5bDdYRzRnSUhaaGNpQnlaWE4xYkhRN1hHNGdJR2xtS0U4Z0lUMDlJRzUxYkd3cGUxeHVJQ0FnSUVWdGNIUjVXMUJTVDFSUFZGbFFSVjBnUFNCaGJrOWlhbVZqZENoUEtUdGNiaUFnSUNCeVpYTjFiSFFnUFNCdVpYY2dSVzF3ZEhrN1hHNGdJQ0FnUlcxd2RIbGJVRkpQVkU5VVdWQkZYU0E5SUc1MWJHdzdYRzRnSUNBZ0x5OGdZV1JrSUZ3aVgxOXdjbTkwYjE5ZlhDSWdabTl5SUU5aWFtVmpkQzVuWlhSUWNtOTBiM1I1Y0dWUFppQndiMng1Wm1sc2JGeHVJQ0FnSUhKbGMzVnNkRnRKUlY5UVVrOVVUMTBnUFNCUE8xeHVJQ0I5SUdWc2MyVWdjbVZ6ZFd4MElEMGdZM0psWVhSbFJHbGpkQ2dwTzF4dUlDQnlaWFIxY200Z1VISnZjR1Z5ZEdsbGN5QTlQVDBnZFc1a1pXWnBibVZrSUQ4Z2NtVnpkV3gwSURvZ1pGQnpLSEpsYzNWc2RDd2dVSEp2Y0dWeWRHbGxjeWs3WEc1OU8xeHVYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dlltcGxZM1F0WTNKbFlYUmxMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F6TlZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0oyWVhJZ1pGQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRaSEFuS1Z4dUlDQXNJR0Z1VDJKcVpXTjBJRDBnY21WeGRXbHlaU2duTGk5ZllXNHRiMkpxWldOMEp5bGNiaUFnTENCblpYUkxaWGx6SUNBOUlISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMXJaWGx6SnlrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdjbVZ4ZFdseVpTZ25MaTlmWkdWelkzSnBjSFJ2Y25NbktTQS9JRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowYVdWeklEb2dablZ1WTNScGIyNGdaR1ZtYVc1bFVISnZjR1Z5ZEdsbGN5aFBMQ0JRY205d1pYSjBhV1Z6S1h0Y2JpQWdZVzVQWW1wbFkzUW9UeWs3WEc0Z0lIWmhjaUJyWlhseklDQWdQU0JuWlhSTFpYbHpLRkJ5YjNCbGNuUnBaWE1wWEc0Z0lDQWdMQ0JzWlc1bmRHZ2dQU0JyWlhsekxteGxibWQwYUZ4dUlDQWdJQ3dnYVNBOUlEQmNiaUFnSUNBc0lGQTdYRzRnSUhkb2FXeGxLR3hsYm1kMGFDQStJR2twWkZBdVppaFBMQ0JRSUQwZ2EyVjVjMXRwS3l0ZExDQlFjbTl3WlhKMGFXVnpXMUJkS1R0Y2JpQWdjbVYwZFhKdUlFODdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXUndjeTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTXpaY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpTHk4Z01Ua3VNUzR5TGpFMElDOGdNVFV1TWk0ekxqRTBJRTlpYW1WamRDNXJaWGx6S0U4cFhHNTJZWElnSkd0bGVYTWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRhMlY1Y3kxcGJuUmxjbTVoYkNjcFhHNGdJQ3dnWlc1MWJVSjFaMHRsZVhNZ1BTQnlaWEYxYVhKbEtDY3VMMTlsYm5WdExXSjFaeTFyWlhsekp5azdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnVDJKcVpXTjBMbXRsZVhNZ2ZId2dablZ1WTNScGIyNGdhMlY1Y3loUEtYdGNiaUFnY21WMGRYSnVJQ1JyWlhsektFOHNJR1Z1ZFcxQ2RXZExaWGx6S1R0Y2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dlltcGxZM1F0YTJWNWN5NXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNemRjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lkbUZ5SUdoaGN5QWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJoaGN5Y3BYRzRnSUN3Z2RHOUpUMkpxWldOMElDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmRHOHRhVzlpYW1WamRDY3BYRzRnSUN3Z1lYSnlZWGxKYm1SbGVFOW1JRDBnY21WeGRXbHlaU2duTGk5ZllYSnlZWGt0YVc1amJIVmtaWE1uS1NobVlXeHpaU2xjYmlBZ0xDQkpSVjlRVWs5VVR5QWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOXphR0Z5WldRdGEyVjVKeWtvSjBsRlgxQlNUMVJQSnlrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9iMkpxWldOMExDQnVZVzFsY3lsN1hHNGdJSFpoY2lCUElDQWdJQ0FnUFNCMGIwbFBZbXBsWTNRb2IySnFaV04wS1Z4dUlDQWdJQ3dnYVNBZ0lDQWdJRDBnTUZ4dUlDQWdJQ3dnY21WemRXeDBJRDBnVzExY2JpQWdJQ0FzSUd0bGVUdGNiaUFnWm05eUtHdGxlU0JwYmlCUEtXbG1LR3RsZVNBaFBTQkpSVjlRVWs5VVR5bG9ZWE1vVHl3Z2EyVjVLU0FtSmlCeVpYTjFiSFF1Y0hWemFDaHJaWGtwTzF4dUlDQXZMeUJFYjI0bmRDQmxiblZ0SUdKMVp5QW1JR2hwWkdSbGJpQnJaWGx6WEc0Z0lIZG9hV3hsS0c1aGJXVnpMbXhsYm1kMGFDQStJR2twYVdZb2FHRnpLRThzSUd0bGVTQTlJRzVoYldWelcya3JLMTBwS1h0Y2JpQWdJQ0IrWVhKeVlYbEpibVJsZUU5bUtISmxjM1ZzZEN3Z2EyVjVLU0I4ZkNCeVpYTjFiSFF1Y0hWemFDaHJaWGtwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhOMWJIUTdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXdGxlWE10YVc1MFpYSnVZV3d1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURNNFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWk4dklIUnZJR2x1WkdWNFpXUWdiMkpxWldOMExDQjBiMDlpYW1WamRDQjNhWFJvSUdaaGJHeGlZV05ySUdadmNpQnViMjR0WVhKeVlYa3RiR2xyWlNCRlV6TWdjM1J5YVc1bmMxeHVkbUZ5SUVsUFltcGxZM1FnUFNCeVpYRjFhWEpsS0NjdUwxOXBiMkpxWldOMEp5bGNiaUFnTENCa1pXWnBibVZrSUQwZ2NtVnhkV2x5WlNnbkxpOWZaR1ZtYVc1bFpDY3BPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhwZENsN1hHNGdJSEpsZEhWeWJpQkpUMkpxWldOMEtHUmxabWx1WldRb2FYUXBLVHRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTkwYnkxcGIySnFaV04wTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBek9WeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENJdkx5Qm1ZV3hzWW1GamF5Qm1iM0lnYm05dUxXRnljbUY1TFd4cGEyVWdSVk16SUdGdVpDQnViMjR0Wlc1MWJXVnlZV0pzWlNCdmJHUWdWamdnYzNSeWFXNW5jMXh1ZG1GeUlHTnZaaUE5SUhKbGNYVnBjbVVvSnk0dlgyTnZaaWNwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCUFltcGxZM1FvSjNvbktTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaU2d3S1NBL0lFOWlhbVZqZENBNklHWjFibU4wYVc5dUtHbDBLWHRjYmlBZ2NtVjBkWEp1SUdOdlppaHBkQ2tnUFQwZ0oxTjBjbWx1WnljZ1B5QnBkQzV6Y0d4cGRDZ25KeWtnT2lCUFltcGxZM1FvYVhRcE8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgybHZZbXBsWTNRdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEUXdYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0luWmhjaUIwYjFOMGNtbHVaeUE5SUh0OUxuUnZVM1J5YVc1bk8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwS1h0Y2JpQWdjbVYwZFhKdUlIUnZVM1J5YVc1bkxtTmhiR3dvYVhRcExuTnNhV05sS0Rnc0lDMHhLVHRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlqYjJZdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEUXhYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0lpOHZJR1poYkhObElDMCtJRUZ5Y21GNUkybHVaR1Y0VDJaY2JpOHZJSFJ5ZFdVZ0lDMCtJRUZ5Y21GNUkybHVZMngxWkdWelhHNTJZWElnZEc5SlQySnFaV04wSUQwZ2NtVnhkV2x5WlNnbkxpOWZkRzh0YVc5aWFtVmpkQ2NwWEc0Z0lDd2dkRzlNWlc1bmRHZ2dJRDBnY21WeGRXbHlaU2duTGk5ZmRHOHRiR1Z1WjNSb0p5bGNiaUFnTENCMGIwbHVaR1Y0SUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTkwYnkxcGJtUmxlQ2NwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmloSlUxOUpUa05NVlVSRlV5bDdYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaWdrZEdocGN5d2daV3dzSUdaeWIyMUpibVJsZUNsN1hHNGdJQ0FnZG1GeUlFOGdJQ0FnSUNBOUlIUnZTVTlpYW1WamRDZ2tkR2hwY3lsY2JpQWdJQ0FnSUN3Z2JHVnVaM1JvSUQwZ2RHOU1aVzVuZEdnb1R5NXNaVzVuZEdncFhHNGdJQ0FnSUNBc0lHbHVaR1Y0SUNBOUlIUnZTVzVrWlhnb1puSnZiVWx1WkdWNExDQnNaVzVuZEdncFhHNGdJQ0FnSUNBc0lIWmhiSFZsTzF4dUlDQWdJQzh2SUVGeWNtRjVJMmx1WTJ4MVpHVnpJSFZ6WlhNZ1UyRnRaVlpoYkhWbFdtVnlieUJsY1hWaGJHbDBlU0JoYkdkdmNtbDBhRzFjYmlBZ0lDQnBaaWhKVTE5SlRrTk1WVVJGVXlBbUppQmxiQ0FoUFNCbGJDbDNhR2xzWlNoc1pXNW5kR2dnUGlCcGJtUmxlQ2w3WEc0Z0lDQWdJQ0IyWVd4MVpTQTlJRTliYVc1a1pYZ3JLMTA3WEc0Z0lDQWdJQ0JwWmloMllXeDFaU0FoUFNCMllXeDFaU2x5WlhSMWNtNGdkSEoxWlR0Y2JpQWdJQ0F2THlCQmNuSmhlU04wYjBsdVpHVjRJR2xuYm05eVpYTWdhRzlzWlhNc0lFRnljbUY1STJsdVkyeDFaR1Z6SUMwZ2JtOTBYRzRnSUNBZ2ZTQmxiSE5sSUdadmNpZzdiR1Z1WjNSb0lENGdhVzVrWlhnN0lHbHVaR1Y0S3lzcGFXWW9TVk5mU1U1RFRGVkVSVk1nZkh3Z2FXNWtaWGdnYVc0Z1R5bDdYRzRnSUNBZ0lDQnBaaWhQVzJsdVpHVjRYU0E5UFQwZ1pXd3BjbVYwZFhKdUlFbFRYMGxPUTB4VlJFVlRJSHg4SUdsdVpHVjRJSHg4SURBN1hHNGdJQ0FnZlNCeVpYUjFjbTRnSVVsVFgwbE9RMHhWUkVWVElDWW1JQzB4TzF4dUlDQjlPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMkZ5Y21GNUxXbHVZMngxWkdWekxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTBNbHh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUEzTGpFdU1UVWdWRzlNWlc1bmRHaGNiblpoY2lCMGIwbHVkR1ZuWlhJZ1BTQnlaWEYxYVhKbEtDY3VMMTkwYnkxcGJuUmxaMlZ5SnlsY2JpQWdMQ0J0YVc0Z0lDQWdJQ0FnUFNCTllYUm9MbTFwYmp0Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1SUNCeVpYUjFjbTRnYVhRZ1BpQXdJRDhnYldsdUtIUnZTVzUwWldkbGNpaHBkQ2tzSURCNE1XWm1abVptWm1abVptWm1abVlwSURvZ01Ec2dMeThnY0c5M0tESXNJRFV6S1NBdElERWdQVDBnT1RBd056RTVPVEkxTkRjME1EazVNVnh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM1J2TFd4bGJtZDBhQzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTkROY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpZG1GeUlIUnZTVzUwWldkbGNpQTlJSEpsY1hWcGNtVW9KeTR2WDNSdkxXbHVkR1ZuWlhJbktWeHVJQ0FzSUcxaGVDQWdJQ0FnSUNBOUlFMWhkR2d1YldGNFhHNGdJQ3dnYldsdUlDQWdJQ0FnSUQwZ1RXRjBhQzV0YVc0N1hHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHbHVaR1Y0TENCc1pXNW5kR2dwZTF4dUlDQnBibVJsZUNBOUlIUnZTVzUwWldkbGNpaHBibVJsZUNrN1hHNGdJSEpsZEhWeWJpQnBibVJsZUNBOElEQWdQeUJ0WVhnb2FXNWtaWGdnS3lCc1pXNW5kR2dzSURBcElEb2diV2x1S0dsdVpHVjRMQ0JzWlc1bmRHZ3BPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM1J2TFdsdVpHVjRMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EwTkZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0oyWVhJZ2MyaGhjbVZrSUQwZ2NtVnhkV2x5WlNnbkxpOWZjMmhoY21Wa0p5a29KMnRsZVhNbktWeHVJQ0FzSUhWcFpDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzVnBaQ2NwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmloclpYa3BlMXh1SUNCeVpYUjFjbTRnYzJoaGNtVmtXMnRsZVYwZ2ZId2dLSE5vWVhKbFpGdHJaWGxkSUQwZ2RXbGtLR3RsZVNrcE8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgzTm9ZWEpsWkMxclpYa3Vhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFExWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCbmJHOWlZV3dnUFNCeVpYRjFhWEpsS0NjdUwxOW5iRzlpWVd3bktWeHVJQ0FzSUZOSVFWSkZSQ0E5SUNkZlgyTnZjbVV0YW5OZmMyaGhjbVZrWDE4blhHNGdJQ3dnYzNSdmNtVWdJRDBnWjJ4dlltRnNXMU5JUVZKRlJGMGdmSHdnS0dkc2IySmhiRnRUU0VGU1JVUmRJRDBnZTMwcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHJaWGtwZTF4dUlDQnlaWFIxY200Z2MzUnZjbVZiYTJWNVhTQjhmQ0FvYzNSdmNtVmJhMlY1WFNBOUlIdDlLVHRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTl6YUdGeVpXUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFEyWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCcFpDQTlJREJjYmlBZ0xDQndlQ0E5SUUxaGRHZ3VjbUZ1Wkc5dEtDazdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR3RsZVNsN1hHNGdJSEpsZEhWeWJpQW5VM2x0WW05c0tDY3VZMjl1WTJGMEtHdGxlU0E5UFQwZ2RXNWtaV1pwYm1Wa0lEOGdKeWNnT2lCclpYa3NJQ2NwWHljc0lDZ3JLMmxrSUNzZ2NIZ3BMblJ2VTNSeWFXNW5LRE0yS1NrN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmRXbGtMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EwTjF4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0l2THlCSlJTQTRMU0JrYjI0bmRDQmxiblZ0SUdKMVp5QnJaWGx6WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUNoY2JpQWdKMk52Ym5OMGNuVmpkRzl5TEdoaGMwOTNibEJ5YjNCbGNuUjVMR2x6VUhKdmRHOTBlWEJsVDJZc2NISnZjR1Z5ZEhsSmMwVnVkVzFsY21GaWJHVXNkRzlNYjJOaGJHVlRkSEpwYm1jc2RHOVRkSEpwYm1jc2RtRnNkV1ZQWmlkY2Jpa3VjM0JzYVhRb0p5d25LVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyVnVkVzB0WW5WbkxXdGxlWE11YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURRNFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnY21WeGRXbHlaU2duTGk5ZloyeHZZbUZzSnlrdVpHOWpkVzFsYm5RZ0ppWWdaRzlqZFcxbGJuUXVaRzlqZFcxbGJuUkZiR1Z0Wlc1ME8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYUhSdGJDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdORGxjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lkbUZ5SUdSbFppQTlJSEpsY1hWcGNtVW9KeTR2WDI5aWFtVmpkQzFrY0NjcExtWmNiaUFnTENCb1lYTWdQU0J5WlhGMWFYSmxLQ2N1TDE5b1lYTW5LVnh1SUNBc0lGUkJSeUE5SUhKbGNYVnBjbVVvSnk0dlgzZHJjeWNwS0NkMGIxTjBjbWx1WjFSaFp5Y3BPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dsMExDQjBZV2NzSUhOMFlYUXBlMXh1SUNCcFppaHBkQ0FtSmlBaGFHRnpLR2wwSUQwZ2MzUmhkQ0EvSUdsMElEb2dhWFF1Y0hKdmRHOTBlWEJsTENCVVFVY3BLV1JsWmlocGRDd2dWRUZITENCN1kyOXVabWxuZFhKaFlteGxPaUIwY25WbExDQjJZV3gxWlRvZ2RHRm5mU2s3WEc1OU8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYzJWMExYUnZMWE4wY21sdVp5MTBZV2N1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURVd1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQnpkRzl5WlNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmMyaGhjbVZrSnlrb0ozZHJjeWNwWEc0Z0lDd2dkV2xrSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzVnBaQ2NwWEc0Z0lDd2dVM2x0WW05c0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyZHNiMkpoYkNjcExsTjViV0p2YkZ4dUlDQXNJRlZUUlY5VFdVMUNUMHdnUFNCMGVYQmxiMllnVTNsdFltOXNJRDA5SUNkbWRXNWpkR2x2YmljN1hHNWNiblpoY2lBa1pYaHdiM0owY3lBOUlHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2JtRnRaU2w3WEc0Z0lISmxkSFZ5YmlCemRHOXlaVnR1WVcxbFhTQjhmQ0FvYzNSdmNtVmJibUZ0WlYwZ1BWeHVJQ0FnSUZWVFJWOVRXVTFDVDB3Z0ppWWdVM2x0WW05c1cyNWhiV1ZkSUh4OElDaFZVMFZmVTFsTlFrOU1JRDhnVTNsdFltOXNJRG9nZFdsa0tTZ25VM2x0WW05c0xpY2dLeUJ1WVcxbEtTazdYRzU5TzF4dVhHNGtaWGh3YjNKMGN5NXpkRzl5WlNBOUlITjBiM0psTzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkMnR6TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBMU1WeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENJdkx5QXhPUzR4TGpJdU9TQXZJREUxTGpJdU15NHlJRTlpYW1WamRDNW5aWFJRY205MGIzUjVjR1ZQWmloUEtWeHVkbUZ5SUdoaGN5QWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYUdGekp5bGNiaUFnTENCMGIwOWlhbVZqZENBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNSdkxXOWlhbVZqZENjcFhHNGdJQ3dnU1VWZlVGSlBWRThnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl6YUdGeVpXUXRhMlY1Snlrb0owbEZYMUJTVDFSUEp5bGNiaUFnTENCUFltcGxZM1JRY205MGJ5QTlJRTlpYW1WamRDNXdjbTkwYjNSNWNHVTdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUlIeDhJR1oxYm1OMGFXOXVLRThwZTF4dUlDQlBJRDBnZEc5UFltcGxZM1FvVHlrN1hHNGdJR2xtS0doaGN5aFBMQ0JKUlY5UVVrOVVUeWtwY21WMGRYSnVJRTliU1VWZlVGSlBWRTlkTzF4dUlDQnBaaWgwZVhCbGIyWWdUeTVqYjI1emRISjFZM1J2Y2lBOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUU4Z2FXNXpkR0Z1WTJWdlppQlBMbU52Ym5OMGNuVmpkRzl5S1h0Y2JpQWdJQ0J5WlhSMWNtNGdUeTVqYjI1emRISjFZM1J2Y2k1d2NtOTBiM1I1Y0dVN1hHNGdJSDBnY21WMGRYSnVJRThnYVc1emRHRnVZMlZ2WmlCUFltcGxZM1FnUHlCUFltcGxZM1JRY205MGJ5QTZJRzUxYkd3N1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmIySnFaV04wTFdkd2J5NXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdOVEpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lMeThnTnk0eExqRXpJRlJ2VDJKcVpXTjBLR0Z5WjNWdFpXNTBLVnh1ZG1GeUlHUmxabWx1WldRZ1BTQnlaWEYxYVhKbEtDY3VMMTlrWldacGJtVmtKeWs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dsMEtYdGNiaUFnY21WMGRYSnVJRTlpYW1WamRDaGtaV1pwYm1Wa0tHbDBLU2s3WEc1OU8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmZEc4dGIySnFaV04wTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBMU0xeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKeVpYRjFhWEpsS0NjdUwyVnpOaTVoY25KaGVTNXBkR1Z5WVhSdmNpY3BPMXh1ZG1GeUlHZHNiMkpoYkNBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOW5iRzlpWVd3bktWeHVJQ0FzSUdocFpHVWdJQ0FnSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5b2FXUmxKeWxjYmlBZ0xDQkpkR1Z5WVhSdmNuTWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZhWFJsY21GMGIzSnpKeWxjYmlBZ0xDQlVUMTlUVkZKSlRrZGZWRUZISUQwZ2NtVnhkV2x5WlNnbkxpOWZkMnR6Snlrb0ozUnZVM1J5YVc1blZHRm5KeWs3WEc1Y2JtWnZjaWgyWVhJZ1kyOXNiR1ZqZEdsdmJuTWdQU0JiSjA1dlpHVk1hWE4wSnl3Z0owUlBUVlJ2YTJWdVRHbHpkQ2NzSUNkTlpXUnBZVXhwYzNRbkxDQW5VM1I1YkdWVGFHVmxkRXhwYzNRbkxDQW5RMU5UVW5Wc1pVeHBjM1FuWFN3Z2FTQTlJREE3SUdrZ1BDQTFPeUJwS3lzcGUxeHVJQ0IyWVhJZ1RrRk5SU0FnSUNBZ0lDQTlJR052Ykd4bFkzUnBiMjV6VzJsZFhHNGdJQ0FnTENCRGIyeHNaV04wYVc5dUlEMGdaMnh2WW1Gc1cwNUJUVVZkWEc0Z0lDQWdMQ0J3Y205MGJ5QWdJQ0FnSUQwZ1EyOXNiR1ZqZEdsdmJpQW1KaUJEYjJ4c1pXTjBhVzl1TG5CeWIzUnZkSGx3WlR0Y2JpQWdhV1lvY0hKdmRHOGdKaVlnSVhCeWIzUnZXMVJQWDFOVVVrbE9SMTlVUVVkZEtXaHBaR1VvY0hKdmRHOHNJRlJQWDFOVVVrbE9SMTlVUVVjc0lFNUJUVVVwTzF4dUlDQkpkR1Z5WVhSdmNuTmJUa0ZOUlYwZ1BTQkpkR1Z5WVhSdmNuTXVRWEp5WVhrN1hHNTlYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDNkbFlpNWtiMjB1YVhSbGNtRmliR1V1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURVMFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWlkMWMyVWdjM1J5YVdOMEp6dGNiblpoY2lCaFpHUlViMVZ1YzJOdmNHRmliR1Z6SUQwZ2NtVnhkV2x5WlNnbkxpOWZZV1JrTFhSdkxYVnVjMk52Y0dGaWJHVnpKeWxjYmlBZ0xDQnpkR1Z3SUNBZ0lDQWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYVhSbGNpMXpkR1Z3SnlsY2JpQWdMQ0JKZEdWeVlYUnZjbk1nSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmFYUmxjbUYwYjNKekp5bGNiaUFnTENCMGIwbFBZbXBsWTNRZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZkRzh0YVc5aWFtVmpkQ2NwTzF4dVhHNHZMeUF5TWk0eExqTXVOQ0JCY25KaGVTNXdjbTkwYjNSNWNHVXVaVzUwY21sbGN5Z3BYRzR2THlBeU1pNHhMak11TVRNZ1FYSnlZWGt1Y0hKdmRHOTBlWEJsTG10bGVYTW9LVnh1THk4Z01qSXVNUzR6TGpJNUlFRnljbUY1TG5CeWIzUnZkSGx3WlM1MllXeDFaWE1vS1Z4dUx5OGdNakl1TVM0ekxqTXdJRUZ5Y21GNUxuQnliM1J2ZEhsd1pWdEFRR2wwWlhKaGRHOXlYU2dwWEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhKbGNYVnBjbVVvSnk0dlgybDBaWEl0WkdWbWFXNWxKeWtvUVhKeVlYa3NJQ2RCY25KaGVTY3NJR1oxYm1OMGFXOXVLR2wwWlhKaGRHVmtMQ0JyYVc1a0tYdGNiaUFnZEdocGN5NWZkQ0E5SUhSdlNVOWlhbVZqZENocGRHVnlZWFJsWkNrN0lDOHZJSFJoY21kbGRGeHVJQ0IwYUdsekxsOXBJRDBnTURzZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0x5OGdibVY0ZENCcGJtUmxlRnh1SUNCMGFHbHpMbDlySUQwZ2EybHVaRHNnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnYTJsdVpGeHVMeThnTWpJdU1TNDFMakl1TVNBbFFYSnlZWGxKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU1V1Ym1WNGRDZ3BYRzU5TENCbWRXNWpkR2x2YmlncGUxeHVJQ0IyWVhJZ1R5QWdJQ0FnUFNCMGFHbHpMbDkwWEc0Z0lDQWdMQ0JyYVc1a0lDQTlJSFJvYVhNdVgydGNiaUFnSUNBc0lHbHVaR1Y0SUQwZ2RHaHBjeTVmYVNzck8xeHVJQ0JwWmlnaFR5QjhmQ0JwYm1SbGVDQStQU0JQTG14bGJtZDBhQ2w3WEc0Z0lDQWdkR2hwY3k1ZmRDQTlJSFZ1WkdWbWFXNWxaRHRjYmlBZ0lDQnlaWFIxY200Z2MzUmxjQ2d4S1R0Y2JpQWdmVnh1SUNCcFppaHJhVzVrSUQwOUlDZHJaWGx6SnlBZ0tYSmxkSFZ5YmlCemRHVndLREFzSUdsdVpHVjRLVHRjYmlBZ2FXWW9hMmx1WkNBOVBTQW5kbUZzZFdWekp5bHlaWFIxY200Z2MzUmxjQ2d3TENCUFcybHVaR1Y0WFNrN1hHNGdJSEpsZEhWeWJpQnpkR1Z3S0RBc0lGdHBibVJsZUN3Z1QxdHBibVJsZUYxZEtUdGNibjBzSUNkMllXeDFaWE1uS1R0Y2JseHVMeThnWVhKbmRXMWxiblJ6VEdsemRGdEFRR2wwWlhKaGRHOXlYU0JwY3lBbFFYSnlZWGxRY205MGIxOTJZV3gxWlhNbElDZzVMalF1TkM0MkxDQTVMalF1TkM0M0tWeHVTWFJsY21GMGIzSnpMa0Z5WjNWdFpXNTBjeUE5SUVsMFpYSmhkRzl5Y3k1QmNuSmhlVHRjYmx4dVlXUmtWRzlWYm5OamIzQmhZbXhsY3lnbmEyVjVjeWNwTzF4dVlXUmtWRzlWYm5OamIzQmhZbXhsY3lnbmRtRnNkV1Z6SnlrN1hHNWhaR1JVYjFWdWMyTnZjR0ZpYkdWektDZGxiblJ5YVdWekp5azdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDJWek5pNWhjbkpoZVM1cGRHVnlZWFJ2Y2k1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ05UVmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlncGV5QXZLaUJsYlhCMGVTQXFMeUI5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZZV1JrTFhSdkxYVnVjMk52Y0dGaWJHVnpMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0ExTmx4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0p0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR1J2Ym1Vc0lIWmhiSFZsS1h0Y2JpQWdjbVYwZFhKdUlIdDJZV3gxWlRvZ2RtRnNkV1VzSUdSdmJtVTZJQ0VoWkc5dVpYMDdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZhWFJsY2kxemRHVndMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0ExTjF4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0psZUhCdmNuUnpMbVlnUFNCeVpYRjFhWEpsS0NjdUwxOTNhM01uS1R0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM2RyY3kxbGVIUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFU0WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJbTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdleUJjSW1SbFptRjFiSFJjSWpvZ2NtVnhkV2x5WlNoY0ltTnZjbVV0YW5NdmJHbGljbUZ5ZVM5bWJpOXplVzFpYjJ4Y0lpa3NJRjlmWlhOTmIyUjFiR1U2SUhSeWRXVWdmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZbUZpWld3dGNuVnVkR2x0WlM5amIzSmxMV3B6TDNONWJXSnZiQzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTlRsY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpY21WeGRXbHlaU2duTGk0dkxpNHZiVzlrZFd4bGN5OWxjell1YzNsdFltOXNKeWs3WEc1eVpYRjFhWEpsS0NjdUxpOHVMaTl0YjJSMWJHVnpMMlZ6Tmk1dlltcGxZM1F1ZEc4dGMzUnlhVzVuSnlrN1hHNXlaWEYxYVhKbEtDY3VMaTh1TGk5dGIyUjFiR1Z6TDJWek55NXplVzFpYjJ3dVlYTjVibU10YVhSbGNtRjBiM0luS1R0Y2JuSmxjWFZwY21Vb0p5NHVMeTR1TDIxdlpIVnNaWE12WlhNM0xuTjViV0p2YkM1dlluTmxjblpoWW14bEp5azdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEpsY1hWcGNtVW9KeTR1THk0dUwyMXZaSFZzWlhNdlgyTnZjbVVuS1M1VGVXMWliMnc3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOW1iaTl6ZVcxaWIyd3ZhVzVrWlhndWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEWXdYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmk4dklFVkRUVUZUWTNKcGNIUWdOaUJ6ZVcxaWIyeHpJSE5vYVcxY2JuWmhjaUJuYkc5aVlXd2dJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJkc2IySmhiQ2NwWEc0Z0lDd2dhR0Z6SUNBZ0lDQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTlvWVhNbktWeHVJQ0FzSUVSRlUwTlNTVkJVVDFKVElDQWdJRDBnY21WeGRXbHlaU2duTGk5ZlpHVnpZM0pwY0hSdmNuTW5LVnh1SUNBc0lDUmxlSEJ2Y25RZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZaWGh3YjNKMEp5bGNiaUFnTENCeVpXUmxabWx1WlNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzSmxaR1ZtYVc1bEp5bGNiaUFnTENCTlJWUkJJQ0FnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyMWxkR0VuS1M1TFJWbGNiaUFnTENBa1ptRnBiSE1nSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyWmhhV3h6SnlsY2JpQWdMQ0J6YUdGeVpXUWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNOb1lYSmxaQ2NwWEc0Z0lDd2djMlYwVkc5VGRISnBibWRVWVdjZ1BTQnlaWEYxYVhKbEtDY3VMMTl6WlhRdGRHOHRjM1J5YVc1bkxYUmhaeWNwWEc0Z0lDd2dkV2xrSUNBZ0lDQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTkxYVdRbktWeHVJQ0FzSUhkcmN5QWdJQ0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmQydHpKeWxjYmlBZ0xDQjNhM05GZUhRZ0lDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYM2RyY3kxbGVIUW5LVnh1SUNBc0lIZHJjMFJsWm1sdVpTQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZkMnR6TFdSbFptbHVaU2NwWEc0Z0lDd2dhMlY1VDJZZ0lDQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTlyWlhsdlppY3BYRzRnSUN3Z1pXNTFiVXRsZVhNZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOWxiblZ0TFd0bGVYTW5LVnh1SUNBc0lHbHpRWEp5WVhrZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZhWE10WVhKeVlYa25LVnh1SUNBc0lHRnVUMkpxWldOMElDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZZVzR0YjJKcVpXTjBKeWxjYmlBZ0xDQjBiMGxQWW1wbFkzUWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYM1J2TFdsdlltcGxZM1FuS1Z4dUlDQXNJSFJ2VUhKcGJXbDBhWFpsSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmZEc4dGNISnBiV2wwYVhabEp5bGNiaUFnTENCamNtVmhkR1ZFWlhOaklDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzQnliM0JsY25SNUxXUmxjMk1uS1Z4dUlDQXNJRjlqY21WaGRHVWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYjJKcVpXTjBMV055WldGMFpTY3BYRzRnSUN3Z1owOVFUa1Y0ZENBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOXZZbXBsWTNRdFoyOXdiaTFsZUhRbktWeHVJQ0FzSUNSSFQxQkVJQ0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmIySnFaV04wTFdkdmNHUW5LVnh1SUNBc0lDUkVVQ0FnSUNBZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZiMkpxWldOMExXUndKeWxjYmlBZ0xDQWthMlY1Y3lBZ0lDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMXJaWGx6SnlsY2JpQWdMQ0JuVDFCRUlDQWdJQ0FnSUNBZ0lDQTlJQ1JIVDFCRUxtWmNiaUFnTENCa1VDQWdJQ0FnSUNBZ0lDQWdJQ0E5SUNSRVVDNW1YRzRnSUN3Z1owOVFUaUFnSUNBZ0lDQWdJQ0FnUFNCblQxQk9SWGgwTG1aY2JpQWdMQ0FrVTNsdFltOXNJQ0FnSUNBZ0lDQTlJR2RzYjJKaGJDNVRlVzFpYjJ4Y2JpQWdMQ0FrU2xOUFRpQWdJQ0FnSUNBZ0lDQTlJR2RzYjJKaGJDNUtVMDlPWEc0Z0lDd2dYM04wY21sdVoybG1lU0FnSUNBZ1BTQWtTbE5QVGlBbUppQWtTbE5QVGk1emRISnBibWRwWm5sY2JpQWdMQ0JRVWs5VVQxUlpVRVVnSUNBZ0lDQTlJQ2R3Y205MGIzUjVjR1VuWEc0Z0lDd2dTRWxFUkVWT0lDQWdJQ0FnSUNBZ1BTQjNhM01vSjE5b2FXUmtaVzRuS1Z4dUlDQXNJRlJQWDFCU1NVMUpWRWxXUlNBZ0lEMGdkMnR6S0NkMGIxQnlhVzFwZEdsMlpTY3BYRzRnSUN3Z2FYTkZiblZ0SUNBZ0lDQWdJQ0FnUFNCN2ZTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaVnh1SUNBc0lGTjViV0p2YkZKbFoybHpkSEo1SUQwZ2MyaGhjbVZrS0NkemVXMWliMnd0Y21WbmFYTjBjbmtuS1Z4dUlDQXNJRUZzYkZONWJXSnZiSE1nSUNBZ0lEMGdjMmhoY21Wa0tDZHplVzFpYjJ4ekp5bGNiaUFnTENCUFVGTjViV0p2YkhNZ0lDQWdJQ0E5SUhOb1lYSmxaQ2duYjNBdGMzbHRZbTlzY3ljcFhHNGdJQ3dnVDJKcVpXTjBVSEp2ZEc4Z0lDQWdQU0JQWW1wbFkzUmJVRkpQVkU5VVdWQkZYVnh1SUNBc0lGVlRSVjlPUVZSSlZrVWdJQ0FnSUQwZ2RIbHdaVzltSUNSVGVXMWliMndnUFQwZ0oyWjFibU4wYVc5dUoxeHVJQ0FzSUZGUFltcGxZM1FnSUNBZ0lDQWdJRDBnWjJ4dlltRnNMbEZQWW1wbFkzUTdYRzR2THlCRWIyNG5kQ0IxYzJVZ2MyVjBkR1Z5Y3lCcGJpQlJkQ0JUWTNKcGNIUXNJR2gwZEhCek9pOHZaMmwwYUhWaUxtTnZiUzk2Ykc5cGNtOWpheTlqYjNKbExXcHpMMmx6YzNWbGN5OHhOek5jYm5aaGNpQnpaWFIwWlhJZ1BTQWhVVTlpYW1WamRDQjhmQ0FoVVU5aWFtVmpkRnRRVWs5VVQxUlpVRVZkSUh4OElDRlJUMkpxWldOMFcxQlNUMVJQVkZsUVJWMHVabWx1WkVOb2FXeGtPMXh1WEc0dkx5Qm1ZV3hzWW1GamF5Qm1iM0lnYjJ4a0lFRnVaSEp2YVdRc0lHaDBkSEJ6T2k4dlkyOWtaUzVuYjI5bmJHVXVZMjl0TDNBdmRqZ3ZhWE56ZFdWekwyUmxkR0ZwYkQ5cFpEMDJPRGRjYm5aaGNpQnpaWFJUZVcxaWIyeEVaWE5qSUQwZ1JFVlRRMUpKVUZSUFVsTWdKaVlnSkdaaGFXeHpLR1oxYm1OMGFXOXVLQ2w3WEc0Z0lISmxkSFZ5YmlCZlkzSmxZWFJsS0dSUUtIdDlMQ0FuWVNjc0lIdGNiaUFnSUNCblpYUTZJR1oxYm1OMGFXOXVLQ2w3SUhKbGRIVnliaUJrVUNoMGFHbHpMQ0FuWVNjc0lIdDJZV3gxWlRvZ04zMHBMbUU3SUgxY2JpQWdmU2twTG1FZ0lUMGdOenRjYm4wcElEOGdablZ1WTNScGIyNG9hWFFzSUd0bGVTd2dSQ2w3WEc0Z0lIWmhjaUJ3Y205MGIwUmxjMk1nUFNCblQxQkVLRTlpYW1WamRGQnliM1J2TENCclpYa3BPMXh1SUNCcFppaHdjbTkwYjBSbGMyTXBaR1ZzWlhSbElFOWlhbVZqZEZCeWIzUnZXMnRsZVYwN1hHNGdJR1JRS0dsMExDQnJaWGtzSUVRcE8xeHVJQ0JwWmlod2NtOTBiMFJsYzJNZ0ppWWdhWFFnSVQwOUlFOWlhbVZqZEZCeWIzUnZLV1JRS0U5aWFtVmpkRkJ5YjNSdkxDQnJaWGtzSUhCeWIzUnZSR1Z6WXlrN1hHNTlJRG9nWkZBN1hHNWNiblpoY2lCM2NtRndJRDBnWm5WdVkzUnBiMjRvZEdGbktYdGNiaUFnZG1GeUlITjViU0E5SUVGc2JGTjViV0p2YkhOYmRHRm5YU0E5SUY5amNtVmhkR1VvSkZONWJXSnZiRnRRVWs5VVQxUlpVRVZkS1R0Y2JpQWdjM2x0TGw5cklEMGdkR0ZuTzF4dUlDQnlaWFIxY200Z2MzbHRPMXh1ZlR0Y2JseHVkbUZ5SUdselUzbHRZbTlzSUQwZ1ZWTkZYMDVCVkVsV1JTQW1KaUIwZVhCbGIyWWdKRk41YldKdmJDNXBkR1Z5WVhSdmNpQTlQU0FuYzNsdFltOXNKeUEvSUdaMWJtTjBhVzl1S0dsMEtYdGNiaUFnY21WMGRYSnVJSFI1Y0dWdlppQnBkQ0E5UFNBbmMzbHRZbTlzSnp0Y2JuMGdPaUJtZFc1amRHbHZiaWhwZENsN1hHNGdJSEpsZEhWeWJpQnBkQ0JwYm5OMFlXNWpaVzltSUNSVGVXMWliMnc3WEc1OU8xeHVYRzUyWVhJZ0pHUmxabWx1WlZCeWIzQmxjblI1SUQwZ1puVnVZM1JwYjI0Z1pHVm1hVzVsVUhKdmNHVnlkSGtvYVhRc0lHdGxlU3dnUkNsN1hHNGdJR2xtS0dsMElEMDlQU0JQWW1wbFkzUlFjbTkwYnlra1pHVm1hVzVsVUhKdmNHVnlkSGtvVDFCVGVXMWliMnh6TENCclpYa3NJRVFwTzF4dUlDQmhiazlpYW1WamRDaHBkQ2s3WEc0Z0lHdGxlU0E5SUhSdlVISnBiV2wwYVhabEtHdGxlU3dnZEhKMVpTazdYRzRnSUdGdVQySnFaV04wS0VRcE8xeHVJQ0JwWmlob1lYTW9RV3hzVTNsdFltOXNjeXdnYTJWNUtTbDdYRzRnSUNBZ2FXWW9JVVF1Wlc1MWJXVnlZV0pzWlNsN1hHNGdJQ0FnSUNCcFppZ2hhR0Z6S0dsMExDQklTVVJFUlU0cEtXUlFLR2wwTENCSVNVUkVSVTRzSUdOeVpXRjBaVVJsYzJNb01Td2dlMzBwS1R0Y2JpQWdJQ0FnSUdsMFcwaEpSRVJGVGwxYmEyVjVYU0E5SUhSeWRXVTdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdsbUtHaGhjeWhwZEN3Z1NFbEVSRVZPS1NBbUppQnBkRnRJU1VSRVJVNWRXMnRsZVYwcGFYUmJTRWxFUkVWT1hWdHJaWGxkSUQwZ1ptRnNjMlU3WEc0Z0lDQWdJQ0JFSUQwZ1gyTnlaV0YwWlNoRUxDQjdaVzUxYldWeVlXSnNaVG9nWTNKbFlYUmxSR1Z6WXlnd0xDQm1ZV3h6WlNsOUtUdGNiaUFnSUNCOUlISmxkSFZ5YmlCelpYUlRlVzFpYjJ4RVpYTmpLR2wwTENCclpYa3NJRVFwTzF4dUlDQjlJSEpsZEhWeWJpQmtVQ2hwZEN3Z2EyVjVMQ0JFS1R0Y2JuMDdYRzUyWVhJZ0pHUmxabWx1WlZCeWIzQmxjblJwWlhNZ1BTQm1kVzVqZEdsdmJpQmtaV1pwYm1WUWNtOXdaWEowYVdWektHbDBMQ0JRS1h0Y2JpQWdZVzVQWW1wbFkzUW9hWFFwTzF4dUlDQjJZWElnYTJWNWN5QTlJR1Z1ZFcxTFpYbHpLRkFnUFNCMGIwbFBZbXBsWTNRb1VDa3BYRzRnSUNBZ0xDQnBJQ0FnSUQwZ01GeHVJQ0FnSUN3Z2JDQTlJR3RsZVhNdWJHVnVaM1JvWEc0Z0lDQWdMQ0JyWlhrN1hHNGdJSGRvYVd4bEtHd2dQaUJwS1NSa1pXWnBibVZRY205d1pYSjBlU2hwZEN3Z2EyVjVJRDBnYTJWNWMxdHBLeXRkTENCUVcydGxlVjBwTzF4dUlDQnlaWFIxY200Z2FYUTdYRzU5TzF4dWRtRnlJQ1JqY21WaGRHVWdQU0JtZFc1amRHbHZiaUJqY21WaGRHVW9hWFFzSUZBcGUxeHVJQ0J5WlhSMWNtNGdVQ0E5UFQwZ2RXNWtaV1pwYm1Wa0lEOGdYMk55WldGMFpTaHBkQ2tnT2lBa1pHVm1hVzVsVUhKdmNHVnlkR2xsY3loZlkzSmxZWFJsS0dsMEtTd2dVQ2s3WEc1OU8xeHVkbUZ5SUNSd2NtOXdaWEowZVVselJXNTFiV1Z5WVdKc1pTQTlJR1oxYm1OMGFXOXVJSEJ5YjNCbGNuUjVTWE5GYm5WdFpYSmhZbXhsS0d0bGVTbDdYRzRnSUhaaGNpQkZJRDBnYVhORmJuVnRMbU5oYkd3b2RHaHBjeXdnYTJWNUlEMGdkRzlRY21sdGFYUnBkbVVvYTJWNUxDQjBjblZsS1NrN1hHNGdJR2xtS0hSb2FYTWdQVDA5SUU5aWFtVmpkRkJ5YjNSdklDWW1JR2hoY3loQmJHeFRlVzFpYjJ4ekxDQnJaWGtwSUNZbUlDRm9ZWE1vVDFCVGVXMWliMnh6TENCclpYa3BLWEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdjbVYwZFhKdUlFVWdmSHdnSVdoaGN5aDBhR2x6TENCclpYa3BJSHg4SUNGb1lYTW9RV3hzVTNsdFltOXNjeXdnYTJWNUtTQjhmQ0JvWVhNb2RHaHBjeXdnU0VsRVJFVk9LU0FtSmlCMGFHbHpXMGhKUkVSRlRsMWJhMlY1WFNBL0lFVWdPaUIwY25WbE8xeHVmVHRjYm5aaGNpQWtaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUlEMGdablZ1WTNScGIyNGdaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUtHbDBMQ0JyWlhrcGUxeHVJQ0JwZENBZ1BTQjBiMGxQWW1wbFkzUW9hWFFwTzF4dUlDQnJaWGtnUFNCMGIxQnlhVzFwZEdsMlpTaHJaWGtzSUhSeWRXVXBPMXh1SUNCcFppaHBkQ0E5UFQwZ1QySnFaV04wVUhKdmRHOGdKaVlnYUdGektFRnNiRk41YldKdmJITXNJR3RsZVNrZ0ppWWdJV2hoY3loUFVGTjViV0p2YkhNc0lHdGxlU2twY21WMGRYSnVPMXh1SUNCMllYSWdSQ0E5SUdkUFVFUW9hWFFzSUd0bGVTazdYRzRnSUdsbUtFUWdKaVlnYUdGektFRnNiRk41YldKdmJITXNJR3RsZVNrZ0ppWWdJU2hvWVhNb2FYUXNJRWhKUkVSRlRpa2dKaVlnYVhSYlNFbEVSRVZPWFZ0clpYbGRLU2xFTG1WdWRXMWxjbUZpYkdVZ1BTQjBjblZsTzF4dUlDQnlaWFIxY200Z1JEdGNibjA3WEc1MllYSWdKR2RsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1nUFNCbWRXNWpkR2x2YmlCblpYUlBkMjVRY205d1pYSjBlVTVoYldWektHbDBLWHRjYmlBZ2RtRnlJRzVoYldWeklDQTlJR2RQVUU0b2RHOUpUMkpxWldOMEtHbDBLU2xjYmlBZ0lDQXNJSEpsYzNWc2RDQTlJRnRkWEc0Z0lDQWdMQ0JwSUNBZ0lDQWdQU0F3WEc0Z0lDQWdMQ0JyWlhrN1hHNGdJSGRvYVd4bEtHNWhiV1Z6TG14bGJtZDBhQ0ErSUdrcGUxeHVJQ0FnSUdsbUtDRm9ZWE1vUVd4c1UzbHRZbTlzY3l3Z2EyVjVJRDBnYm1GdFpYTmJhU3NyWFNrZ0ppWWdhMlY1SUNFOUlFaEpSRVJGVGlBbUppQnJaWGtnSVQwZ1RVVlVRU2x5WlhOMWJIUXVjSFZ6YUNoclpYa3BPMXh1SUNCOUlISmxkSFZ5YmlCeVpYTjFiSFE3WEc1OU8xeHVkbUZ5SUNSblpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITWdQU0JtZFc1amRHbHZiaUJuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNb2FYUXBlMXh1SUNCMllYSWdTVk5mVDFBZ0lEMGdhWFFnUFQwOUlFOWlhbVZqZEZCeWIzUnZYRzRnSUNBZ0xDQnVZVzFsY3lBZ1BTQm5UMUJPS0VsVFgwOVFJRDhnVDFCVGVXMWliMnh6SURvZ2RHOUpUMkpxWldOMEtHbDBLU2xjYmlBZ0lDQXNJSEpsYzNWc2RDQTlJRnRkWEc0Z0lDQWdMQ0JwSUNBZ0lDQWdQU0F3WEc0Z0lDQWdMQ0JyWlhrN1hHNGdJSGRvYVd4bEtHNWhiV1Z6TG14bGJtZDBhQ0ErSUdrcGUxeHVJQ0FnSUdsbUtHaGhjeWhCYkd4VGVXMWliMnh6TENCclpYa2dQU0J1WVcxbGMxdHBLeXRkS1NBbUppQW9TVk5mVDFBZ1B5Qm9ZWE1vVDJKcVpXTjBVSEp2ZEc4c0lHdGxlU2tnT2lCMGNuVmxLU2x5WlhOMWJIUXVjSFZ6YUNoQmJHeFRlVzFpYjJ4elcydGxlVjBwTzF4dUlDQjlJSEpsZEhWeWJpQnlaWE4xYkhRN1hHNTlPMXh1WEc0dkx5QXhPUzQwTGpFdU1TQlRlVzFpYjJ3b1cyUmxjMk55YVhCMGFXOXVYU2xjYm1sbUtDRlZVMFZmVGtGVVNWWkZLWHRjYmlBZ0pGTjViV0p2YkNBOUlHWjFibU4wYVc5dUlGTjViV0p2YkNncGUxeHVJQ0FnSUdsbUtIUm9hWE1nYVc1emRHRnVZMlZ2WmlBa1UzbHRZbTlzS1hSb2NtOTNJRlI1Y0dWRmNuSnZjaWduVTNsdFltOXNJR2x6SUc1dmRDQmhJR052Ym5OMGNuVmpkRzl5SVNjcE8xeHVJQ0FnSUhaaGNpQjBZV2NnUFNCMWFXUW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQStJREFnUHlCaGNtZDFiV1Z1ZEhOYk1GMGdPaUIxYm1SbFptbHVaV1FwTzF4dUlDQWdJSFpoY2lBa2MyVjBJRDBnWm5WdVkzUnBiMjRvZG1Gc2RXVXBlMXh1SUNBZ0lDQWdhV1lvZEdocGN5QTlQVDBnVDJKcVpXTjBVSEp2ZEc4cEpITmxkQzVqWVd4c0tFOVFVM2x0WW05c2N5d2dkbUZzZFdVcE8xeHVJQ0FnSUNBZ2FXWW9hR0Z6S0hSb2FYTXNJRWhKUkVSRlRpa2dKaVlnYUdGektIUm9hWE5iU0VsRVJFVk9YU3dnZEdGbktTbDBhR2x6VzBoSlJFUkZUbDFiZEdGblhTQTlJR1poYkhObE8xeHVJQ0FnSUNBZ2MyVjBVM2x0WW05c1JHVnpZeWgwYUdsekxDQjBZV2NzSUdOeVpXRjBaVVJsYzJNb01Td2dkbUZzZFdVcEtUdGNiaUFnSUNCOU8xeHVJQ0FnSUdsbUtFUkZVME5TU1ZCVVQxSlRJQ1ltSUhObGRIUmxjaWx6WlhSVGVXMWliMnhFWlhOaktFOWlhbVZqZEZCeWIzUnZMQ0IwWVdjc0lIdGpiMjVtYVdkMWNtRmliR1U2SUhSeWRXVXNJSE5sZERvZ0pITmxkSDBwTzF4dUlDQWdJSEpsZEhWeWJpQjNjbUZ3S0hSaFp5azdYRzRnSUgwN1hHNGdJSEpsWkdWbWFXNWxLQ1JUZVcxaWIyeGJVRkpQVkU5VVdWQkZYU3dnSjNSdlUzUnlhVzVuSnl3Z1puVnVZM1JwYjI0Z2RHOVRkSEpwYm1jb0tYdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NWZhenRjYmlBZ2ZTazdYRzVjYmlBZ0pFZFBVRVF1WmlBOUlDUm5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNJN1hHNGdJQ1JFVUM1bUlDQWdQU0FrWkdWbWFXNWxVSEp2Y0dWeWRIazdYRzRnSUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxbmIzQnVKeWt1WmlBOUlHZFBVRTVGZUhRdVppQTlJQ1JuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6TzF4dUlDQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRjR2xsSnlrdVppQWdQU0FrY0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVN1hHNGdJSEpsY1hWcGNtVW9KeTR2WDI5aWFtVmpkQzFuYjNCekp5a3VaaUE5SUNSblpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITTdYRzVjYmlBZ2FXWW9SRVZUUTFKSlVGUlBVbE1nSmlZZ0lYSmxjWFZwY21Vb0p5NHZYMnhwWW5KaGNua25LU2w3WEc0Z0lDQWdjbVZrWldacGJtVW9UMkpxWldOMFVISnZkRzhzSUNkd2NtOXdaWEowZVVselJXNTFiV1Z5WVdKc1pTY3NJQ1J3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlN3Z2RISjFaU2s3WEc0Z0lIMWNibHh1SUNCM2EzTkZlSFF1WmlBOUlHWjFibU4wYVc5dUtHNWhiV1VwZTF4dUlDQWdJSEpsZEhWeWJpQjNjbUZ3S0hkcmN5aHVZVzFsS1NrN1hHNGdJSDFjYm4xY2JseHVKR1Y0Y0c5eWRDZ2taWGh3YjNKMExrY2dLeUFrWlhod2IzSjBMbGNnS3lBa1pYaHdiM0owTGtZZ0tpQWhWVk5GWDA1QlZFbFdSU3dnZTFONWJXSnZiRG9nSkZONWJXSnZiSDBwTzF4dVhHNW1iM0lvZG1GeUlITjViV0p2YkhNZ1BTQW9YRzRnSUM4dklERTVMalF1TWk0eUxDQXhPUzQwTGpJdU15d2dNVGt1TkM0eUxqUXNJREU1TGpRdU1pNDJMQ0F4T1M0MExqSXVPQ3dnTVRrdU5DNHlMamtzSURFNUxqUXVNaTR4TUN3Z01Ua3VOQzR5TGpFeExDQXhPUzQwTGpJdU1USXNJREU1TGpRdU1pNHhNeXdnTVRrdU5DNHlMakUwWEc0Z0lDZG9ZWE5KYm5OMFlXNWpaU3hwYzBOdmJtTmhkRk53Y21WaFpHRmliR1VzYVhSbGNtRjBiM0lzYldGMFkyZ3NjbVZ3YkdGalpTeHpaV0Z5WTJnc2MzQmxZMmxsY3l4emNHeHBkQ3gwYjFCeWFXMXBkR2wyWlN4MGIxTjBjbWx1WjFSaFp5eDFibk5qYjNCaFlteGxjeWRjYmlrdWMzQnNhWFFvSnl3bktTd2dhU0E5SURBN0lITjViV0p2YkhNdWJHVnVaM1JvSUQ0Z2FUc2dLWGRyY3loemVXMWliMnh6VzJrcksxMHBPMXh1WEc1bWIzSW9kbUZ5SUhONWJXSnZiSE1nUFNBa2EyVjVjeWgzYTNNdWMzUnZjbVVwTENCcElEMGdNRHNnYzNsdFltOXNjeTVzWlc1bmRHZ2dQaUJwT3lBcGQydHpSR1ZtYVc1bEtITjViV0p2YkhOYmFTc3JYU2s3WEc1Y2JpUmxlSEJ2Y25Rb0pHVjRjRzl5ZEM1VElDc2dKR1Y0Y0c5eWRDNUdJQ29nSVZWVFJWOU9RVlJKVmtVc0lDZFRlVzFpYjJ3bkxDQjdYRzRnSUM4dklERTVMalF1TWk0eElGTjViV0p2YkM1bWIzSW9hMlY1S1Z4dUlDQW5abTl5SnpvZ1puVnVZM1JwYjI0b2EyVjVLWHRjYmlBZ0lDQnlaWFIxY200Z2FHRnpLRk41YldKdmJGSmxaMmx6ZEhKNUxDQnJaWGtnS3owZ0p5Y3BYRzRnSUNBZ0lDQS9JRk41YldKdmJGSmxaMmx6ZEhKNVcydGxlVjFjYmlBZ0lDQWdJRG9nVTNsdFltOXNVbVZuYVhOMGNubGJhMlY1WFNBOUlDUlRlVzFpYjJ3b2EyVjVLVHRjYmlBZ2ZTeGNiaUFnTHk4Z01Ua3VOQzR5TGpVZ1UzbHRZbTlzTG10bGVVWnZjaWh6ZVcwcFhHNGdJR3RsZVVadmNqb2dablZ1WTNScGIyNGdhMlY1Um05eUtHdGxlU2w3WEc0Z0lDQWdhV1lvYVhOVGVXMWliMndvYTJWNUtTbHlaWFIxY200Z2EyVjVUMllvVTNsdFltOXNVbVZuYVhOMGNua3NJR3RsZVNrN1hHNGdJQ0FnZEdoeWIzY2dWSGx3WlVWeWNtOXlLR3RsZVNBcklDY2dhWE1nYm05MElHRWdjM2x0WW05c0lTY3BPMXh1SUNCOUxGeHVJQ0IxYzJWVFpYUjBaWEk2SUdaMWJtTjBhVzl1S0NsN0lITmxkSFJsY2lBOUlIUnlkV1U3SUgwc1hHNGdJSFZ6WlZOcGJYQnNaVG9nWm5WdVkzUnBiMjRvS1hzZ2MyVjBkR1Z5SUQwZ1ptRnNjMlU3SUgxY2JuMHBPMXh1WEc0a1pYaHdiM0owS0NSbGVIQnZjblF1VXlBcklDUmxlSEJ2Y25RdVJpQXFJQ0ZWVTBWZlRrRlVTVlpGTENBblQySnFaV04wSnl3Z2UxeHVJQ0F2THlBeE9TNHhMakl1TWlCUFltcGxZM1F1WTNKbFlYUmxLRThnV3l3Z1VISnZjR1Z5ZEdsbGMxMHBYRzRnSUdOeVpXRjBaVG9nSkdOeVpXRjBaU3hjYmlBZ0x5OGdNVGt1TVM0eUxqUWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0U4c0lGQXNJRUYwZEhKcFluVjBaWE1wWEc0Z0lHUmxabWx1WlZCeWIzQmxjblI1T2lBa1pHVm1hVzVsVUhKdmNHVnlkSGtzWEc0Z0lDOHZJREU1TGpFdU1pNHpJRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowYVdWektFOHNJRkJ5YjNCbGNuUnBaWE1wWEc0Z0lHUmxabWx1WlZCeWIzQmxjblJwWlhNNklDUmtaV1pwYm1WUWNtOXdaWEowYVdWekxGeHVJQ0F2THlBeE9TNHhMakl1TmlCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXlLRThzSUZBcFhHNGdJR2RsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNqb2dKR2RsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpeGNiaUFnTHk4Z01Ua3VNUzR5TGpjZ1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVUbUZ0WlhNb1R5bGNiaUFnWjJWMFQzZHVVSEp2Y0dWeWRIbE9ZVzFsY3pvZ0pHZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTXNYRzRnSUM4dklERTVMakV1TWk0NElFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITW9UeWxjYmlBZ1oyVjBUM2R1VUhKdmNHVnlkSGxUZVcxaWIyeHpPaUFrWjJWMFQzZHVVSEp2Y0dWeWRIbFRlVzFpYjJ4elhHNTlLVHRjYmx4dUx5OGdNalF1TXk0eUlFcFRUMDR1YzNSeWFXNW5hV1o1S0haaGJIVmxJRnNzSUhKbGNHeGhZMlZ5SUZzc0lITndZV05sWFYwcFhHNGtTbE5QVGlBbUppQWtaWGh3YjNKMEtDUmxlSEJ2Y25RdVV5QXJJQ1JsZUhCdmNuUXVSaUFxSUNnaFZWTkZYMDVCVkVsV1JTQjhmQ0FrWm1GcGJITW9ablZ1WTNScGIyNG9LWHRjYmlBZ2RtRnlJRk1nUFNBa1UzbHRZbTlzS0NrN1hHNGdJQzh2SUUxVElFVmtaMlVnWTI5dWRtVnlkSE1nYzNsdFltOXNJSFpoYkhWbGN5QjBieUJLVTA5T0lHRnpJSHQ5WEc0Z0lDOHZJRmRsWWt0cGRDQmpiMjUyWlhKMGN5QnplVzFpYjJ3Z2RtRnNkV1Z6SUhSdklFcFRUMDRnWVhNZ2JuVnNiRnh1SUNBdkx5QldPQ0IwYUhKdmQzTWdiMjRnWW05NFpXUWdjM2x0WW05c2MxeHVJQ0J5WlhSMWNtNGdYM04wY21sdVoybG1lU2hiVTEwcElDRTlJQ2RiYm5Wc2JGMG5JSHg4SUY5emRISnBibWRwWm5rb2UyRTZJRk45S1NBaFBTQW5lMzBuSUh4OElGOXpkSEpwYm1kcFpua29UMkpxWldOMEtGTXBLU0FoUFNBbmUzMG5PMXh1ZlNrcExDQW5TbE5QVGljc0lIdGNiaUFnYzNSeWFXNW5hV1o1T2lCbWRXNWpkR2x2YmlCemRISnBibWRwWm5rb2FYUXBlMXh1SUNBZ0lHbG1LR2wwSUQwOVBTQjFibVJsWm1sdVpXUWdmSHdnYVhOVGVXMWliMndvYVhRcEtYSmxkSFZ5YmpzZ0x5OGdTVVU0SUhKbGRIVnlibk1nYzNSeWFXNW5JRzl1SUhWdVpHVm1hVzVsWkZ4dUlDQWdJSFpoY2lCaGNtZHpJRDBnVzJsMFhWeHVJQ0FnSUNBZ0xDQnBJQ0FnSUQwZ01WeHVJQ0FnSUNBZ0xDQnlaWEJzWVdObGNpd2dKSEpsY0d4aFkyVnlPMXh1SUNBZ0lIZG9hV3hsS0dGeVozVnRaVzUwY3k1c1pXNW5kR2dnUGlCcEtXRnlaM011Y0hWemFDaGhjbWQxYldWdWRITmJhU3NyWFNrN1hHNGdJQ0FnY21Wd2JHRmpaWElnUFNCaGNtZHpXekZkTzF4dUlDQWdJR2xtS0hSNWNHVnZaaUJ5WlhCc1lXTmxjaUE5UFNBblpuVnVZM1JwYjI0bktTUnlaWEJzWVdObGNpQTlJSEpsY0d4aFkyVnlPMXh1SUNBZ0lHbG1LQ1J5WlhCc1lXTmxjaUI4ZkNBaGFYTkJjbkpoZVNoeVpYQnNZV05sY2lrcGNtVndiR0ZqWlhJZ1BTQm1kVzVqZEdsdmJpaHJaWGtzSUhaaGJIVmxLWHRjYmlBZ0lDQWdJR2xtS0NSeVpYQnNZV05sY2lsMllXeDFaU0E5SUNSeVpYQnNZV05sY2k1allXeHNLSFJvYVhNc0lHdGxlU3dnZG1Gc2RXVXBPMXh1SUNBZ0lDQWdhV1lvSVdselUzbHRZbTlzS0haaGJIVmxLU2x5WlhSMWNtNGdkbUZzZFdVN1hHNGdJQ0FnZlR0Y2JpQWdJQ0JoY21keld6RmRJRDBnY21Wd2JHRmpaWEk3WEc0Z0lDQWdjbVYwZFhKdUlGOXpkSEpwYm1kcFpua3VZWEJ3Ykhrb0pFcFRUMDRzSUdGeVozTXBPMXh1SUNCOVhHNTlLVHRjYmx4dUx5OGdNVGt1TkM0ekxqUWdVM2x0WW05c0xuQnliM1J2ZEhsd1pWdEFRSFJ2VUhKcGJXbDBhWFpsWFNob2FXNTBLVnh1SkZONWJXSnZiRnRRVWs5VVQxUlpVRVZkVzFSUFgxQlNTVTFKVkVsV1JWMGdmSHdnY21WeGRXbHlaU2duTGk5ZmFHbGtaU2NwS0NSVGVXMWliMnhiVUZKUFZFOVVXVkJGWFN3Z1ZFOWZVRkpKVFVsVVNWWkZMQ0FrVTNsdFltOXNXMUJTVDFSUFZGbFFSVjB1ZG1Gc2RXVlBaaWs3WEc0dkx5QXhPUzQwTGpNdU5TQlRlVzFpYjJ3dWNISnZkRzkwZVhCbFcwQkFkRzlUZEhKcGJtZFVZV2RkWEc1elpYUlViMU4wY21sdVoxUmhaeWdrVTNsdFltOXNMQ0FuVTNsdFltOXNKeWs3WEc0dkx5QXlNQzR5TGpFdU9TQk5ZWFJvVzBCQWRHOVRkSEpwYm1kVVlXZGRYRzV6WlhSVWIxTjBjbWx1WjFSaFp5aE5ZWFJvTENBblRXRjBhQ2NzSUhSeWRXVXBPMXh1THk4Z01qUXVNeTR6SUVwVFQwNWJRRUIwYjFOMGNtbHVaMVJoWjExY2JuTmxkRlJ2VTNSeWFXNW5WR0ZuS0dkc2IySmhiQzVLVTA5T0xDQW5TbE5QVGljc0lIUnlkV1VwTzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWxjell1YzNsdFltOXNMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EyTVZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0oyWVhJZ1RVVlVRU0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTkxYVdRbktTZ25iV1YwWVNjcFhHNGdJQ3dnYVhOUFltcGxZM1FnUFNCeVpYRjFhWEpsS0NjdUwxOXBjeTF2WW1wbFkzUW5LVnh1SUNBc0lHaGhjeUFnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYUdGekp5bGNiaUFnTENCelpYUkVaWE5qSUNBOUlISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMWtjQ2NwTG1aY2JpQWdMQ0JwWkNBZ0lDQWdJQ0E5SURBN1hHNTJZWElnYVhORmVIUmxibk5wWW14bElEMGdUMkpxWldOMExtbHpSWGgwWlc1emFXSnNaU0I4ZkNCbWRXNWpkR2x2YmlncGUxeHVJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JuMDdYRzUyWVhJZ1JsSkZSVnBGSUQwZ0lYSmxjWFZwY21Vb0p5NHZYMlpoYVd4ekp5a29ablZ1WTNScGIyNG9LWHRjYmlBZ2NtVjBkWEp1SUdselJYaDBaVzV6YVdKc1pTaFBZbXBsWTNRdWNISmxkbVZ1ZEVWNGRHVnVjMmx2Ym5Nb2UzMHBLVHRjYm4wcE8xeHVkbUZ5SUhObGRFMWxkR0VnUFNCbWRXNWpkR2x2YmlocGRDbDdYRzRnSUhObGRFUmxjMk1vYVhRc0lFMUZWRUVzSUh0MllXeDFaVG9nZTF4dUlDQWdJR2s2SUNkUEp5QXJJQ3NyYVdRc0lDOHZJRzlpYW1WamRDQkpSRnh1SUNBZ0lIYzZJSHQ5SUNBZ0lDQWdJQ0FnSUM4dklIZGxZV3NnWTI5c2JHVmpkR2x2Ym5NZ1NVUnpYRzRnSUgxOUtUdGNibjA3WEc1MllYSWdabUZ6ZEV0bGVTQTlJR1oxYm1OMGFXOXVLR2wwTENCamNtVmhkR1VwZTF4dUlDQXZMeUJ5WlhSMWNtNGdjSEpwYldsMGFYWmxJSGRwZEdnZ2NISmxabWw0WEc0Z0lHbG1LQ0ZwYzA5aWFtVmpkQ2hwZENrcGNtVjBkWEp1SUhSNWNHVnZaaUJwZENBOVBTQW5jM2x0WW05c0p5QS9JR2wwSURvZ0tIUjVjR1Z2WmlCcGRDQTlQU0FuYzNSeWFXNW5KeUEvSUNkVEp5QTZJQ2RRSnlrZ0t5QnBkRHRjYmlBZ2FXWW9JV2hoY3locGRDd2dUVVZVUVNrcGUxeHVJQ0FnSUM4dklHTmhiaWQwSUhObGRDQnRaWFJoWkdGMFlTQjBieUIxYm1OaGRXZG9kQ0JtY205NlpXNGdiMkpxWldOMFhHNGdJQ0FnYVdZb0lXbHpSWGgwWlc1emFXSnNaU2hwZENrcGNtVjBkWEp1SUNkR0p6dGNiaUFnSUNBdkx5QnViM1FnYm1WalpYTnpZWEo1SUhSdklHRmtaQ0J0WlhSaFpHRjBZVnh1SUNBZ0lHbG1LQ0ZqY21WaGRHVXBjbVYwZFhKdUlDZEZKenRjYmlBZ0lDQXZMeUJoWkdRZ2JXbHpjMmx1WnlCdFpYUmhaR0YwWVZ4dUlDQWdJSE5sZEUxbGRHRW9hWFFwTzF4dUlDQXZMeUJ5WlhSMWNtNGdiMkpxWldOMElFbEVYRzRnSUgwZ2NtVjBkWEp1SUdsMFcwMUZWRUZkTG1rN1hHNTlPMXh1ZG1GeUlHZGxkRmRsWVdzZ1BTQm1kVzVqZEdsdmJpaHBkQ3dnWTNKbFlYUmxLWHRjYmlBZ2FXWW9JV2hoY3locGRDd2dUVVZVUVNrcGUxeHVJQ0FnSUM4dklHTmhiaWQwSUhObGRDQnRaWFJoWkdGMFlTQjBieUIxYm1OaGRXZG9kQ0JtY205NlpXNGdiMkpxWldOMFhHNGdJQ0FnYVdZb0lXbHpSWGgwWlc1emFXSnNaU2hwZENrcGNtVjBkWEp1SUhSeWRXVTdYRzRnSUNBZ0x5OGdibTkwSUc1bFkyVnpjMkZ5ZVNCMGJ5QmhaR1FnYldWMFlXUmhkR0ZjYmlBZ0lDQnBaaWdoWTNKbFlYUmxLWEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0F2THlCaFpHUWdiV2x6YzJsdVp5QnRaWFJoWkdGMFlWeHVJQ0FnSUhObGRFMWxkR0VvYVhRcE8xeHVJQ0F2THlCeVpYUjFjbTRnYUdGemFDQjNaV0ZySUdOdmJHeGxZM1JwYjI1eklFbEVjMXh1SUNCOUlISmxkSFZ5YmlCcGRGdE5SVlJCWFM1M08xeHVmVHRjYmk4dklHRmtaQ0J0WlhSaFpHRjBZU0J2YmlCbWNtVmxlbVV0Wm1GdGFXeDVJRzFsZEdodlpITWdZMkZzYkdsdVoxeHVkbUZ5SUc5dVJuSmxaWHBsSUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1SUNCcFppaEdVa1ZGV2tVZ0ppWWdiV1YwWVM1T1JVVkVJQ1ltSUdselJYaDBaVzV6YVdKc1pTaHBkQ2tnSmlZZ0lXaGhjeWhwZEN3Z1RVVlVRU2twYzJWMFRXVjBZU2hwZENrN1hHNGdJSEpsZEhWeWJpQnBkRHRjYm4wN1hHNTJZWElnYldWMFlTQTlJRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdlMXh1SUNCTFJWazZJQ0FnSUNBZ1RVVlVRU3hjYmlBZ1RrVkZSRG9nSUNBZ0lHWmhiSE5sTEZ4dUlDQm1ZWE4wUzJWNU9pQWdabUZ6ZEV0bGVTeGNiaUFnWjJWMFYyVmhhem9nSUdkbGRGZGxZV3NzWEc0Z0lHOXVSbkpsWlhwbE9pQnZia1p5WldWNlpWeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyMWxkR0V1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURZeVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQm5iRzlpWVd3Z0lDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMmRzYjJKaGJDY3BYRzRnSUN3Z1kyOXlaU0FnSUNBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOWpiM0psSnlsY2JpQWdMQ0JNU1VKU1FWSlpJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJ4cFluSmhjbmtuS1Z4dUlDQXNJSGRyYzBWNGRDQWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmZDJ0ekxXVjRkQ2NwWEc0Z0lDd2daR1ZtYVc1bFVISnZjR1Z5ZEhrZ1BTQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRaSEFuS1M1bU8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHVZVzFsS1h0Y2JpQWdkbUZ5SUNSVGVXMWliMndnUFNCamIzSmxMbE41YldKdmJDQjhmQ0FvWTI5eVpTNVRlVzFpYjJ3Z1BTQk1TVUpTUVZKWklEOGdlMzBnT2lCbmJHOWlZV3d1VTNsdFltOXNJSHg4SUh0OUtUdGNiaUFnYVdZb2JtRnRaUzVqYUdGeVFYUW9NQ2tnSVQwZ0oxOG5JQ1ltSUNFb2JtRnRaU0JwYmlBa1UzbHRZbTlzS1Nsa1pXWnBibVZRY205d1pYSjBlU2drVTNsdFltOXNMQ0J1WVcxbExDQjdkbUZzZFdVNklIZHJjMFY0ZEM1bUtHNWhiV1VwZlNrN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmQydHpMV1JsWm1sdVpTNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdOak5jYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lkbUZ5SUdkbGRFdGxlWE1nSUNBOUlISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMXJaWGx6SnlsY2JpQWdMQ0IwYjBsUFltcGxZM1FnUFNCeVpYRjFhWEpsS0NjdUwxOTBieTFwYjJKcVpXTjBKeWs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0c5aWFtVmpkQ3dnWld3cGUxeHVJQ0IyWVhJZ1R5QWdJQ0FnSUQwZ2RHOUpUMkpxWldOMEtHOWlhbVZqZENsY2JpQWdJQ0FzSUd0bGVYTWdJQ0E5SUdkbGRFdGxlWE1vVHlsY2JpQWdJQ0FzSUd4bGJtZDBhQ0E5SUd0bGVYTXViR1Z1WjNSb1hHNGdJQ0FnTENCcGJtUmxlQ0FnUFNBd1hHNGdJQ0FnTENCclpYazdYRzRnSUhkb2FXeGxLR3hsYm1kMGFDQStJR2x1WkdWNEtXbG1LRTliYTJWNUlEMGdhMlY1YzF0cGJtUmxlQ3NyWFYwZ1BUMDlJR1ZzS1hKbGRIVnliaUJyWlhrN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmEyVjViMll1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURZMFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWk4dklHRnNiQ0JsYm5WdFpYSmhZbXhsSUc5aWFtVmpkQ0JyWlhsekxDQnBibU5zZFdSbGN5QnplVzFpYjJ4elhHNTJZWElnWjJWMFMyVjVjeUE5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxclpYbHpKeWxjYmlBZ0xDQm5UMUJUSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYjJKcVpXTjBMV2R2Y0hNbktWeHVJQ0FzSUhCSlJTQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOXZZbXBsWTNRdGNHbGxKeWs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dsMEtYdGNiaUFnZG1GeUlISmxjM1ZzZENBZ0lDQWdQU0JuWlhSTFpYbHpLR2wwS1Z4dUlDQWdJQ3dnWjJWMFUzbHRZbTlzY3lBOUlHZFBVRk11Wmp0Y2JpQWdhV1lvWjJWMFUzbHRZbTlzY3lsN1hHNGdJQ0FnZG1GeUlITjViV0p2YkhNZ1BTQm5aWFJUZVcxaWIyeHpLR2wwS1Z4dUlDQWdJQ0FnTENCcGMwVnVkVzBnSUQwZ2NFbEZMbVpjYmlBZ0lDQWdJQ3dnYVNBZ0lDQWdJQ0E5SURCY2JpQWdJQ0FnSUN3Z2EyVjVPMXh1SUNBZ0lIZG9hV3hsS0hONWJXSnZiSE11YkdWdVozUm9JRDRnYVNscFppaHBjMFZ1ZFcwdVkyRnNiQ2hwZEN3Z2EyVjVJRDBnYzNsdFltOXNjMXRwS3l0ZEtTbHlaWE4xYkhRdWNIVnphQ2hyWlhrcE8xeHVJQ0I5SUhKbGRIVnliaUJ5WlhOMWJIUTdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZaVzUxYlMxclpYbHpMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EyTlZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0psZUhCdmNuUnpMbVlnUFNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbFRlVzFpYjJ4ek8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV2R2Y0hNdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEWTJYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0ltVjRjRzl5ZEhNdVppQTlJSHQ5TG5CeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bE8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMWEJwWlM1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ05qZGNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aUx5OGdOeTR5TGpJZ1NYTkJjbkpoZVNoaGNtZDFiV1Z1ZENsY2JuWmhjaUJqYjJZZ1BTQnlaWEYxYVhKbEtDY3VMMTlqYjJZbktUdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdRWEp5WVhrdWFYTkJjbkpoZVNCOGZDQm1kVzVqZEdsdmJpQnBjMEZ5Y21GNUtHRnlaeWw3WEc0Z0lISmxkSFZ5YmlCamIyWW9ZWEpuS1NBOVBTQW5RWEp5WVhrbk8xeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgybHpMV0Z5Y21GNUxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTJPRnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUJtWVd4c1ltRmpheUJtYjNJZ1NVVXhNU0JpZFdkbmVTQlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxPWVcxbGN5QjNhWFJvSUdsbWNtRnRaU0JoYm1RZ2QybHVaRzkzWEc1MllYSWdkRzlKVDJKcVpXTjBJRDBnY21WeGRXbHlaU2duTGk5ZmRHOHRhVzlpYW1WamRDY3BYRzRnSUN3Z1owOVFUaUFnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYjJKcVpXTjBMV2R2Y0c0bktTNW1YRzRnSUN3Z2RHOVRkSEpwYm1jZ0lEMGdlMzB1ZEc5VGRISnBibWM3WEc1Y2JuWmhjaUIzYVc1a2IzZE9ZVzFsY3lBOUlIUjVjR1Z2WmlCM2FXNWtiM2NnUFQwZ0oyOWlhbVZqZENjZ0ppWWdkMmx1Wkc5M0lDWW1JRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpYRzRnSUQ4Z1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVUbUZ0WlhNb2QybHVaRzkzS1NBNklGdGRPMXh1WEc1MllYSWdaMlYwVjJsdVpHOTNUbUZ0WlhNZ1BTQm1kVzVqZEdsdmJpaHBkQ2w3WEc0Z0lIUnllU0I3WEc0Z0lDQWdjbVYwZFhKdUlHZFBVRTRvYVhRcE8xeHVJQ0I5SUdOaGRHTm9LR1VwZTF4dUlDQWdJSEpsZEhWeWJpQjNhVzVrYjNkT1lXMWxjeTV6YkdsalpTZ3BPMXh1SUNCOVhHNTlPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeTVtSUQwZ1puVnVZM1JwYjI0Z1oyVjBUM2R1VUhKdmNHVnlkSGxPWVcxbGN5aHBkQ2w3WEc0Z0lISmxkSFZ5YmlCM2FXNWtiM2RPWVcxbGN5QW1KaUIwYjFOMGNtbHVaeTVqWVd4c0tHbDBLU0E5UFNBblcyOWlhbVZqZENCWGFXNWtiM2RkSnlBL0lHZGxkRmRwYm1SdmQwNWhiV1Z6S0dsMEtTQTZJR2RQVUU0b2RHOUpUMkpxWldOMEtHbDBLU2s3WEc1OU8xeHVYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dlltcGxZM1F0WjI5d2JpMWxlSFF1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURZNVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWk4dklERTVMakV1TWk0M0lDOGdNVFV1TWk0ekxqUWdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTW9UeWxjYm5aaGNpQWthMlY1Y3lBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmIySnFaV04wTFd0bGVYTXRhVzUwWlhKdVlXd25LVnh1SUNBc0lHaHBaR1JsYmt0bGVYTWdQU0J5WlhGMWFYSmxLQ2N1TDE5bGJuVnRMV0oxWnkxclpYbHpKeWt1WTI5dVkyRjBLQ2RzWlc1bmRHZ25MQ0FuY0hKdmRHOTBlWEJsSnlrN1hHNWNibVY0Y0c5eWRITXVaaUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6SUh4OElHWjFibU4wYVc5dUlHZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTW9UeWw3WEc0Z0lISmxkSFZ5YmlBa2EyVjVjeWhQTENCb2FXUmtaVzVMWlhsektUdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXZZbXBsWTNRdFoyOXdiaTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTnpCY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpZG1GeUlIQkpSU0FnSUNBZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZiMkpxWldOMExYQnBaU2NwWEc0Z0lDd2dZM0psWVhSbFJHVnpZeUFnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl3Y205d1pYSjBlUzFrWlhOakp5bGNiaUFnTENCMGIwbFBZbXBsWTNRZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzUnZMV2x2WW1wbFkzUW5LVnh1SUNBc0lIUnZVSEpwYldsMGFYWmxJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZkRzh0Y0hKcGJXbDBhWFpsSnlsY2JpQWdMQ0JvWVhNZ0lDQWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJoaGN5Y3BYRzRnSUN3Z1NVVTRYMFJQVFY5RVJVWkpUa1VnUFNCeVpYRjFhWEpsS0NjdUwxOXBaVGd0Wkc5dExXUmxabWx1WlNjcFhHNGdJQ3dnWjA5UVJDQWdJQ0FnSUNBZ0lDQWdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eU8xeHVYRzVsZUhCdmNuUnpMbVlnUFNCeVpYRjFhWEpsS0NjdUwxOWtaWE5qY21sd2RHOXljeWNwSUQ4Z1owOVFSQ0E2SUdaMWJtTjBhVzl1SUdkbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaWhQTENCUUtYdGNiaUFnVHlBOUlIUnZTVTlpYW1WamRDaFBLVHRjYmlBZ1VDQTlJSFJ2VUhKcGJXbDBhWFpsS0ZBc0lIUnlkV1VwTzF4dUlDQnBaaWhKUlRoZlJFOU5YMFJGUmtsT1JTbDBjbmtnZTF4dUlDQWdJSEpsZEhWeWJpQm5UMUJFS0U4c0lGQXBPMXh1SUNCOUlHTmhkR05vS0dVcGV5QXZLaUJsYlhCMGVTQXFMeUI5WEc0Z0lHbG1LR2hoY3loUExDQlFLU2x5WlhSMWNtNGdZM0psWVhSbFJHVnpZeWdoY0VsRkxtWXVZMkZzYkNoUExDQlFLU3dnVDF0UVhTazdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXZHZjR1F1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURjeFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5KbGNYVnBjbVVvSnk0dlgzZHJjeTFrWldacGJtVW5LU2duWVhONWJtTkpkR1Z5WVhSdmNpY3BPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5bGN6Y3VjM2x0WW05c0xtRnplVzVqTFdsMFpYSmhkRzl5TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBM00xeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKeVpYRjFhWEpsS0NjdUwxOTNhM010WkdWbWFXNWxKeWtvSjI5aWMyVnlkbUZpYkdVbktUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WlhNM0xuTjViV0p2YkM1dlluTmxjblpoWW14bExtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTNORnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSmpiR0Z6Y3lCVmRHbHNJSHRjYmlBZ2MzUmhkR2xqSUdOeVpXRjBaVU5oYm5aaGN5aHphWHBsTENCcGJXRm5aU2tnZTF4dUlDQWdJSFpoY2lCallXNTJZWE1nUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLQ2RqWVc1MllYTW5LVHRjYmlBZ0lDQmpZVzUyWVhNdWQybGtkR2dnUFNCemFYcGxPMXh1SUNBZ0lHTmhiblpoY3k1b1pXbG5hSFFnUFNCemFYcGxPMXh1SUNBZ0lHTmhiblpoY3k1blpYUkRiMjUwWlhoMEtDY3laQ2NwTG1SeVlYZEpiV0ZuWlNocGJXRm5aU3dnTUN3Z01Dd2djMmw2WlN3Z2MybDZaU2s3WEc0Z0lDQWdjbVYwZFhKdUlHTmhiblpoY3p0Y2JpQWdmVnh1WEc0Z0lITjBZWFJwWXlCMGFISmxjMmh2YkdRb2Npd2daeXdnWWl3Z2RtRnNkV1VwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdLREF1TWpFeU5pcHlJQ3NnTUM0M01UVXlLbWNnS3lBd0xqQTNNaklxWWlBK1BTQjJZV3gxWlNrZ1B5QXlOVFVnT2lBd08xeHVJQ0I5WEc1OVhHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElGVjBhV3c3WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDNWMGFXd3Vhbk1pWFN3aWMyOTFjbU5sVW05dmRDSTZJaUo5XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3FhcnRqcy9kaXN0L3FhcnQubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=');
},function(module,exports){eval("module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQgfHwgKG9wdGlvbnMuY29tcHV0ZWQgPSB7fSlcbiAgICBPYmplY3Qua2V5cyhjc3NNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBjc3NNb2R1bGVzW2tleV1cbiAgICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', [_c(\'div\', {\n    ref: "qart"\n  }), _vm._v(" "), (_vm.downloadButton) ? _c(\'button\', {\n    on: {\n      "click": _vm.convertToImage\n    }\n  }, [_vm._v("download t2o image")]) : _vm._e()])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlLXFhcnQudnVlPzZlMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnZGl2Jywge1xuICAgIHJlZjogXCJxYXJ0XCJcbiAgfSksIF92bS5fdihcIiBcIiksIChfdm0uZG93bmxvYWRCdXR0b24pID8gX2MoJ2J1dHRvbicsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uY29udmVydFRvSW1hZ2VcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJkb3dubG9hZCB0Mm8gaW1hZ2VcIildKSA6IF92bS5fZSgpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/aWQ9ZGF0YS12LTU2M2E2NDdjIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvdnVlLXFhcnQudnVlXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _vueQart = __webpack_require__(0);\n\nvar _vueQart2 = _interopRequireDefault(_vueQart);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _vueQart2.default; /**\n                                      * Created by superman on 17/2/6.\n                                      */\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFHQTs7Ozs7O3FDQUhBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgc3VwZXJtYW4gb24gMTcvMi82LlxuICovXG5pbXBvcnQgVnVlUUFydCBmcm9tICcuL3Z1ZS1xYXJ0LnZ1ZSc7XG5leHBvcnQgZGVmYXVsdCBWdWVRQXJ0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=')}])});

/***/ }),

/***/ "4YfN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__("aA9S");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "5YsT":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__("xB8i");

var ENUM = 'enum';

/**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function enumerable(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (enumerable);

/***/ }),

/***/ "5di0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var aria = aria || {};

aria.Utils = aria.Utils || {};

/**
 * @desc Set focus on descendant nodes until the first focusable element is
 *       found.
 * @param element
 *          DOM node for which to find the first focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */
aria.Utils.focusFirstDescendant = function (element) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (aria.Utils.attemptFocus(child) || aria.Utils.focusFirstDescendant(child)) {
      return true;
    }
  }
  return false;
};

/**
 * @desc Find the last descendant node that is focusable.
 * @param element
 *          DOM node for which to find the last focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */

aria.Utils.focusLastDescendant = function (element) {
  for (var i = element.childNodes.length - 1; i >= 0; i--) {
    var child = element.childNodes[i];
    if (aria.Utils.attemptFocus(child) || aria.Utils.focusLastDescendant(child)) {
      return true;
    }
  }
  return false;
};

/**
 * @desc Set Attempt to set focus on the current node.
 * @param element
 *          The node to attempt to focus on.
 * @returns
 *  true if element is focused.
 */
aria.Utils.attemptFocus = function (element) {
  if (!aria.Utils.isFocusable(element)) {
    return false;
  }
  aria.Utils.IgnoreUtilFocusChanges = true;
  try {
    element.focus();
  } catch (e) {}
  aria.Utils.IgnoreUtilFocusChanges = false;
  return document.activeElement === element;
};

aria.Utils.isFocusable = function (element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {
    return true;
  }

  if (element.disabled) {
    return false;
  }

  switch (element.nodeName) {
    case 'A':
      return !!element.href && element.rel !== 'ignore';
    case 'INPUT':
      return element.type !== 'hidden' && element.type !== 'file';
    case 'BUTTON':
    case 'SELECT':
    case 'TEXTAREA':
      return true;
    default:
      return false;
  }
};

/**
 * 触发一个事件
 * mouseenter, mouseleave, mouseover, keyup, change, click 等
 * @param  {Element} elm
 * @param  {String} name
 * @param  {*} opts
 */
aria.Utils.triggerEvent = function (elm, name) {
  var eventName = void 0;

  if (/^mouse|click/.test(name)) {
    eventName = 'MouseEvents';
  } else if (/^key/.test(name)) {
    eventName = 'KeyboardEvent';
  } else {
    eventName = 'HTMLEvents';
  }
  var evt = document.createEvent(eventName);

  for (var _len = arguments.length, opts = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    opts[_key - 2] = arguments[_key];
  }

  evt.initEvent.apply(evt, [name].concat(opts));
  elm.dispatchEvent ? elm.dispatchEvent(evt) : elm.fireEvent('on' + name, evt);

  return elm;
};

aria.Utils.keys = {
  tab: 9,
  enter: 13,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40
};

exports.default = aria.Utils;

/***/ }),

/***/ "5tK0":
/***/ (function(module, exports) {



/***/ }),

/***/ "5vqR":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.5.3
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (false) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.functionalOptions = undefined;
  this.functionalScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode, deep) {
  var componentOptions = vnode.componentOptions;
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  if (deep) {
    if (vnode.children) {
      cloned.children = cloneVNodes(vnode.children, true);
    }
    if (componentOptions && componentOptions.children) {
      componentOptions.children = cloneVNodes(componentOptions.children, true);
    }
  }
  return cloned
}

function cloneVNodes (vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "production" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (false) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (false) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (false) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (false) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (false) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (false) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if (inBrowser && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (false) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "production" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                 false
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      data && data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (false) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (false) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (false) {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (false) {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject).filter(function (key) {
          /* istanbul ignore next */
          return Object.getOwnPropertyDescriptor(inject, key).enumerable
        })
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (false) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (false) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if (false) {
        warn(
          "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
          "- this will likely cause render errors.",
          this
        );
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias,
  eventKeyName
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1
    } else {
      return keyCodes !== eventKeyCode
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  // static trees can be rendered once and cached on the contructor options
  // so every instance shares the same cached trees
  var options = this.$options;
  var cached = options.cached || (options.cached = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = options.staticRenderFns[index].call(this._renderProxy, null, this);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.functionalScopeId = options._scopeId;
        vnode.functionalContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.functionalContext = contextVm;
    vnode.functionalOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "production" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (false) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid$1 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (false) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (false
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (false) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && cached$$1 !== current) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.exclude && matches(this.exclude, name)) ||
        (this.include && !matches(this.include, name))
      )) {
        return vnode
      }

      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (false) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.5.3';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "production" !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(
            config.ignoredElements.length &&
            config.ignoredElements.some(function (ignore) {
              return isRegExp(ignore)
                ? ignore.test(tag)
                : ignore === tag
            })
          ) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.functionalScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.functionalContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (false) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    if (false) {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false
              ) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false
              ) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (false) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE9 || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

function baseWarn (msg) {
  console.error(("[Vue compiler]: " + msg));
}

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr (el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    false
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    );
  }
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers && modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
        "? " + baseValueExpression + ".trim()" +
        ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: ("\"" + value + "\""),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;



function parseModel (val) {
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (false) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead."
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (false) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
      "?_i(" + value + "," + valueBinding + ")>-1" + (
        trueValueBinding === 'true'
          ? (":(" + value + ")")
          : (":_q(" + value + "," + trueValueBinding + ")")
      )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" +
      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal)
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (false) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (false) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "production" !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (false) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (false
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (false) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (false
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});

function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+')
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (false) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (false) {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!--([\s\S]*?)-->/g, '$1')
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (false) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3]; }
        if (args[4] === '') { delete args[4]; }
        if (args[5] === '') { delete args[5]; }
      }
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (false
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;



function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre (element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "production" !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.'
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints (el) {
        if (false) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              "Cannot use <" + (el.tag) + "> as component root element because it may " +
              'contain multiple nodes.'
            );
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            );
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (false) {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead."
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {
        postTransforms[i$1](element, options);
      }
    },

    end: function end () {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars (text) {
      if (!currentParent) {
        if (false) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored.")
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment (text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (false) {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      "production" !== 'production' && warn$2(
        ("Invalid v-for expression: " + exp)
      );
      return
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (false) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if."
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if (false) {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored."
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (false) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead."
      );
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if (false) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(
              el,
              ("update:" + (camelize(name))),
              genAssignmentCode(value, "$event")
            );
          }
        }
        if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (false) {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (false) {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          );
        }
      }
      addAttr(el, name, JSON.stringify(value));
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true');
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      false
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead."
      );
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
      var typeBinding = getBindingAttr(el, 'type');
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

function addRawAttr (el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

var model$2 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$2
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative,
  warn
) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    var handler = events[name];
    // #5330: warn click.right, since right clicks do not actually fire click events.
    if (false
    ) {
      warn(
        "Use \"contextmenu\" instead of \"click.right\" since right clicks " +
        "do not actually fire \"click\" events."
      );
    }
    res += "\"" + name + "\":" + (genHandler(name, handler)) + ",";
  }
  return res.slice(0, -1) + '}'
}

function genHandler (
  name,
  handler
) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression
      ? handler.value
      : ("function($event){" + (handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? handler.value + '($event)'
      : isFunctionExpression
        ? ("(" + (handler.value) + ")($event)")
        : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var code = keyCodes[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(code)) + "," +
    "$event.key)"
  )
}

/*  */

function on (el, dir) {
  if (false) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      "production" !== 'production' && state.warn(
        "v-once can only be used inside v-for that is keyed. "
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if (false
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + (genProps(el.attrs)) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + (genProps(el.props)) + "},";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false, state.warn)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true, state.warn)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if (false) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  slots,
  state
) {
  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state)
    }).join(',')) + "])")
}

function genScopedSlot (
  key,
  el,
  state
) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state)
  }
  var fn = "function(" + (String(el.slotScope)) + "){" +
    "return " + (el.tag === 'template'
      ? el.if
        ? ((el.if) + "?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  return ("{key:" + key + ",fn:" + fn + "}")
}

function genForScopedSlot (
  key,
  el,
  state
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + (genScopedSlot(key, el, state)) +
    '})'
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el$1, state)
    }
    var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
  }
  return res.slice(0, -1)
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors
}

function checkNode (node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), errors);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), errors);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent (exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
    );
  }
  checkExpression(exp, text, errors);
}

function checkFor (node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier (ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
  }
}

function checkExpression (exp, text, errors) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim())
      );
    } else {
      errors.push(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n"
      );
    }
  }
}

/*  */

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (false) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (false) {
      if (compiled.errors && compiled.errors.length) {
        warn$$1(
          "Error compiling template:\n\n" + template + "\n\n" +
          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
          vm
        );
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (false) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (false) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "production" !== 'production' && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (false) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (false) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (false) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (false) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue$3.compile = compileToFunctions;

/* harmony default export */ __webpack_exports__["default"] = (Vue$3);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("QYmj"), __webpack_require__("nARF").setImmediate))

/***/ }),

/***/ "6EQH":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Vue-awesome-swiper
 * @author Surmon.me
 */

var Swiper = __webpack_require__("Bnvi")
var SwiperComponent = __webpack_require__("r4/i")
var SlideComponent = __webpack_require__("2DCh")
SwiperComponent = SwiperComponent.default || SwiperComponent
SlideComponent = SlideComponent.default || SlideComponent
if (typeof window !== 'undefined') {
	window.Swiper = Swiper
}

var swiper = {
  swiperSlide: SlideComponent,
  swiper: SwiperComponent,
  swiperPlugins: Swiper.prototype.plugins,
  install: function(Vue) {
    Vue.component(SwiperComponent.name, SwiperComponent)
    Vue.component(SlideComponent.name, SlideComponent)
  }
}

module.exports = swiper


/***/ }),

/***/ "6d3N":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getStyle = exports.once = exports.off = exports.on = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* istanbul ignore next */

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setStyle = setStyle;

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isServer = _vue2.default.prototype.$isServer;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var ieVersion = isServer ? 0 : Number(document.documentMode);

/* istanbul ignore next */
var trim = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */
var camelCase = function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};

/* istanbul ignore next */
var on = exports.on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var off = exports.off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var once = exports.once = function once(el, event, fn) {
  var listener = function listener() {
    if (fn) {
      fn.apply(this, arguments);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

/* istanbul ignore next */
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
};

/* istanbul ignore next */
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
};

/* istanbul ignore next */
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }
  if (!el.classList) {
    el.className = trim(curClass);
  }
};

/* istanbul ignore next */
var getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'styleFloat';
  }
  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }
      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'cssFloat';
  }
  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};

/* istanbul ignore next */
function setStyle(element, styleName, value) {
  if (!element || !styleName) return;

  if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {
    for (var prop in styleName) {
      if (styleName.hasOwnProperty(prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);
    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
};

/***/ }),

/***/ "7qHl":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("X609");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "8bSs":
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__("gLa1")

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "9Poz":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("Lohu").f;
var has = __webpack_require__("AsM0");
var TAG = __webpack_require__("IFGh")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "9goP":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("WoFR");
var enumBugKeys = __webpack_require__("M8Yd");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "9lqe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.PopupManager = undefined;

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

var _merge = __webpack_require__("UGrZ");

var _merge2 = _interopRequireDefault(_merge);

var _popupManager = __webpack_require__("FRKS");

var _popupManager2 = _interopRequireDefault(_popupManager);

var _scrollbarWidth = __webpack_require__("wDOA");

var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

var _dom = __webpack_require__("6d3N");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var idSeed = 1;
var transitions = [];

var hookTransition = function hookTransition(transition) {
  if (transitions.indexOf(transition) !== -1) return;

  var getVueInstance = function getVueInstance(element) {
    var instance = element.__vue__;
    if (!instance) {
      var textNode = element.previousSibling;
      if (textNode.__vue__) {
        instance = textNode.__vue__;
      }
    }
    return instance;
  };

  _vue2.default.transition(transition, {
    afterEnter: function afterEnter(el) {
      var instance = getVueInstance(el);

      if (instance) {
        instance.doAfterOpen && instance.doAfterOpen();
      }
    },
    afterLeave: function afterLeave(el) {
      var instance = getVueInstance(el);

      if (instance) {
        instance.doAfterClose && instance.doAfterClose();
      }
    }
  });
};

var scrollBarWidth = void 0;

var getDOM = function getDOM(dom) {
  if (dom.nodeType === 3) {
    dom = dom.nextElementSibling || dom.nextSibling;
    getDOM(dom);
  }
  return dom;
};

exports.default = {
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    transition: {
      type: String,
      default: ''
    },
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    modal: {
      type: Boolean,
      default: false
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {},
    modalAppendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    }
  },

  created: function created() {
    if (this.transition) {
      hookTransition(this.transition);
    }
  },
  beforeMount: function beforeMount() {
    this._popupId = 'popup-' + idSeed++;
    _popupManager2.default.register(this._popupId, this);
  },
  beforeDestroy: function beforeDestroy() {
    _popupManager2.default.deregister(this._popupId);
    _popupManager2.default.closeModal(this._popupId);
    if (this.modal && this.bodyOverflow !== null && this.bodyOverflow !== 'hidden') {
      document.body.style.overflow = this.bodyOverflow;
      document.body.style.paddingRight = this.bodyPaddingRight;
    }
    this.bodyOverflow = null;
    this.bodyPaddingRight = null;
  },
  data: function data() {
    return {
      opened: false,
      bodyOverflow: null,
      bodyPaddingRight: null,
      rendered: false
    };
  },


  watch: {
    visible: function visible(val) {
      var _this = this;

      if (val) {
        if (this._opening) return;
        if (!this.rendered) {
          this.rendered = true;
          _vue2.default.nextTick(function () {
            _this.open();
          });
        } else {
          this.open();
        }
      } else {
        this.close();
      }
    }
  },

  methods: {
    open: function open(options) {
      var _this2 = this;

      if (!this.rendered) {
        this.rendered = true;
      }

      var props = (0, _merge2.default)({}, this.$props || this, options);

      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
      clearTimeout(this._openTimer);

      var openDelay = Number(props.openDelay);
      if (openDelay > 0) {
        this._openTimer = setTimeout(function () {
          _this2._openTimer = null;
          _this2.doOpen(props);
        }, openDelay);
      } else {
        this.doOpen(props);
      }
    },
    doOpen: function doOpen(props) {
      if (this.$isServer) return;
      if (this.willOpen && !this.willOpen()) return;
      if (this.opened) return;

      this._opening = true;

      var dom = getDOM(this.$el);

      var modal = props.modal;

      var zIndex = props.zIndex;
      if (zIndex) {
        _popupManager2.default.zIndex = zIndex;
      }

      if (modal) {
        if (this._closing) {
          _popupManager2.default.closeModal(this._popupId);
          this._closing = false;
        }
        _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);
        if (props.lockScroll) {
          if (!this.bodyOverflow) {
            this.bodyPaddingRight = document.body.style.paddingRight;
            this.bodyOverflow = document.body.style.overflow;
          }
          scrollBarWidth = (0, _scrollbarWidth2.default)();
          var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          var bodyOverflowY = (0, _dom.getStyle)(document.body, 'overflowY');
          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll')) {
            document.body.style.paddingRight = scrollBarWidth + 'px';
          }
          document.body.style.overflow = 'hidden';
        }
      }

      if (getComputedStyle(dom).position === 'static') {
        dom.style.position = 'absolute';
      }

      dom.style.zIndex = _popupManager2.default.nextZIndex();
      this.opened = true;

      this.onOpen && this.onOpen();

      if (!this.transition) {
        this.doAfterOpen();
      }
    },
    doAfterOpen: function doAfterOpen() {
      this._opening = false;
    },
    close: function close() {
      var _this3 = this;

      if (this.willClose && !this.willClose()) return;

      if (this._openTimer !== null) {
        clearTimeout(this._openTimer);
        this._openTimer = null;
      }
      clearTimeout(this._closeTimer);

      var closeDelay = Number(this.closeDelay);

      if (closeDelay > 0) {
        this._closeTimer = setTimeout(function () {
          _this3._closeTimer = null;
          _this3.doClose();
        }, closeDelay);
      } else {
        this.doClose();
      }
    },
    doClose: function doClose() {
      var _this4 = this;

      this._closing = true;

      this.onClose && this.onClose();

      if (this.lockScroll) {
        setTimeout(function () {
          if (_this4.modal && _this4.bodyOverflow !== 'hidden') {
            document.body.style.overflow = _this4.bodyOverflow;
            document.body.style.paddingRight = _this4.bodyPaddingRight;
          }
          _this4.bodyOverflow = null;
          _this4.bodyPaddingRight = null;
        }, 200);
      }

      this.opened = false;

      if (!this.transition) {
        this.doAfterClose();
      }
    },
    doAfterClose: function doAfterClose() {
      _popupManager2.default.closeModal(this._popupId);
      this._closing = false;
    }
  }
};
exports.PopupManager = _popupManager2.default;

/***/ }),

/***/ "AYvJ":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("QYmj"), __webpack_require__("V0EG")))

/***/ }),

/***/ "AsM0":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "BWjf":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "BbKf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function _broadcast(componentName, eventName, params) {
  this.$children.forEach(function (child) {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      _broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
exports.default = {
  methods: {
    dispatch: function dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }
      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast: function broadcast(componentName, eventName, params) {
      _broadcast.call(this, componentName, eventName, params);
    }
  }
};

/***/ }),

/***/ "BkJT":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "Bnvi":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Swiper 3.4.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2017, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: March 10, 2017
 */
(function () {
    'use strict';
    var $;

    /*===========================
    Swiper
    ===========================*/
    var Swiper = function (container, params) {
        if (!(this instanceof Swiper)) return new Swiper(container, params);
    

        var defaults = {
            direction: 'horizontal',
            touchEventsTarget: 'container',
            initialSlide: 0,
            speed: 300,
            // autoplay
            autoplay: false,
            autoplayDisableOnInteraction: true,
            autoplayStopOnLast: false,
            // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
            iOSEdgeSwipeDetection: false,
            iOSEdgeSwipeThreshold: 20,
            // Free mode
            freeMode: false,
            freeModeMomentum: true,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: true,
            freeModeMomentumBounceRatio: 1,
            freeModeMomentumVelocityRatio: 1,
            freeModeSticky: false,
            freeModeMinimumVelocity: 0.02,
            // Autoheight
            autoHeight: false,
            // Set wrapper width
            setWrapperSize: false,
            // Virtual Translate
            virtualTranslate: false,
            // Effects
            effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
            coverflow: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows : true
            },
            flip: {
                slideShadows : true,
                limitRotation: true
            },
            cube: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            },
            fade: {
                crossFade: false
            },
            // Parallax
            parallax: false,
            // Zoom
            zoom: false,
            zoomMax: 3,
            zoomMin: 1,
            zoomToggle: true,
            // Scrollbar
            scrollbar: null,
            scrollbarHide: true,
            scrollbarDraggable: false,
            scrollbarSnapOnRelease: false,
            // Keyboard Mousewheel
            keyboardControl: false,
            mousewheelControl: false,
            mousewheelReleaseOnEdges: false,
            mousewheelInvert: false,
            mousewheelForceToAxis: false,
            mousewheelSensitivity: 1,
            mousewheelEventsTarged: 'container',
            // Hash Navigation
            hashnav: false,
            hashnavWatchState: false,
            // History
            history: false,
            // Commong Nav State
            replaceState: false,
            // Breakpoints
            breakpoints: undefined,
            // Slides grid
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerColumnFill: 'column',
            slidesPerGroup: 1,
            centeredSlides: false,
            slidesOffsetBefore: 0, // in px
            slidesOffsetAfter: 0, // in px
            // Round length
            roundLengths: false,
            // Touches
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: true,
            onlyExternal: false,
            threshold: 0,
            touchMoveStopPropagation: true,
            touchReleaseOnEdges: false,
            // Unique Navigation Elements
            uniqueNavElements: true,
            // Pagination
            pagination: null,
            paginationElement: 'span',
            paginationClickable: false,
            paginationHide: false,
            paginationBulletRender: null,
            paginationProgressRender: null,
            paginationFractionRender: null,
            paginationCustomRender: null,
            paginationType: 'bullets', // 'bullets' or 'progress' or 'fraction' or 'custom'
            // Resistance
            resistance: true,
            resistanceRatio: 0.85,
            // Next/prev buttons
            nextButton: null,
            prevButton: null,
            // Progress
            watchSlidesProgress: false,
            watchSlidesVisibility: false,
            // Cursor
            grabCursor: false,
            // Clicks
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            // Lazy Loading
            lazyLoading: false,
            lazyLoadingInPrevNext: false,
            lazyLoadingInPrevNextAmount: 1,
            lazyLoadingOnTransitionStart: false,
            // Images
            preloadImages: true,
            updateOnImagesReady: true,
            // loop
            loop: false,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            // Control
            control: undefined,
            controlInverse: false,
            controlBy: 'slide', //or 'container'
            normalizeSlideIndex: true,
            // Swiping/no swiping
            allowSwipeToPrev: true,
            allowSwipeToNext: true,
            swipeHandler: null, //'.swipe-handler',
            noSwiping: true,
            noSwipingClass: 'swiper-no-swiping',
            // Passive Listeners
            passiveListeners: true,
            // NS
            containerModifierClass: 'swiper-container-', // NEW
            slideClass: 'swiper-slide',
            slideActiveClass: 'swiper-slide-active',
            slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
            slideVisibleClass: 'swiper-slide-visible',
            slideDuplicateClass: 'swiper-slide-duplicate',
            slideNextClass: 'swiper-slide-next',
            slideDuplicateNextClass: 'swiper-slide-duplicate-next',
            slidePrevClass: 'swiper-slide-prev',
            slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
            wrapperClass: 'swiper-wrapper',
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            buttonDisabledClass: 'swiper-button-disabled',
            paginationCurrentClass: 'swiper-pagination-current',
            paginationTotalClass: 'swiper-pagination-total',
            paginationHiddenClass: 'swiper-pagination-hidden',
            paginationProgressbarClass: 'swiper-pagination-progressbar',
            paginationClickableClass: 'swiper-pagination-clickable', // NEW
            paginationModifierClass: 'swiper-pagination-', // NEW
            lazyLoadingClass: 'swiper-lazy',
            lazyStatusLoadingClass: 'swiper-lazy-loading',
            lazyStatusLoadedClass: 'swiper-lazy-loaded',
            lazyPreloaderClass: 'swiper-lazy-preloader',
            notificationClass: 'swiper-notification',
            preloaderClass: 'preloader',
            zoomContainerClass: 'swiper-zoom-container',
        
            // Observer
            observer: false,
            observeParents: false,
            // Accessibility
            a11y: false,
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
            paginationBulletMessage: 'Go to slide {{index}}',
            // Callbacks
            runCallbacksOnInit: true
            /*
            Callbacks:
            onInit: function (swiper)
            onDestroy: function (swiper)
            onBeforeResize: function (swiper)
            onAfterResize: function (swiper)
            onClick: function (swiper, e)
            onTap: function (swiper, e)
            onDoubleTap: function (swiper, e)
            onSliderMove: function (swiper, e)
            onSlideChangeStart: function (swiper)
            onSlideChangeEnd: function (swiper)
            onTransitionStart: function (swiper)
            onTransitionEnd: function (swiper)
            onImagesReady: function (swiper)
            onProgress: function (swiper, progress)
            onTouchStart: function (swiper, e)
            onTouchMove: function (swiper, e)
            onTouchMoveOpposite: function (swiper, e)
            onTouchEnd: function (swiper, e)
            onReachBeginning: function (swiper)
            onReachEnd: function (swiper)
            onSetTransition: function (swiper, duration)
            onSetTranslate: function (swiper, translate)
            onAutoplayStart: function (swiper)
            onAutoplayStop: function (swiper),
            onLazyImageLoad: function (swiper, slide, image)
            onLazyImageReady: function (swiper, slide, image)
            onKeyPress: function (swiper, keyCode)
            */
        
        };
        var initialVirtualTranslate = params && params.virtualTranslate;
        
        params = params || {};
        var originalParams = {};
        for (var param in params) {
            if (typeof params[param] === 'object' && params[param] !== null && !(params[param].nodeType || params[param] === window || params[param] === document || (typeof Dom7 !== 'undefined' && params[param] instanceof Dom7) || (typeof jQuery !== 'undefined' && params[param] instanceof jQuery))) {
                originalParams[param] = {};
                for (var deepParam in params[param]) {
                    originalParams[param][deepParam] = params[param][deepParam];
                }
            }
            else {
                originalParams[param] = params[param];
            }
        }
        for (var def in defaults) {
            if (typeof params[def] === 'undefined') {
                params[def] = defaults[def];
            }
            else if (typeof params[def] === 'object') {
                for (var deepDef in defaults[def]) {
                    if (typeof params[def][deepDef] === 'undefined') {
                        params[def][deepDef] = defaults[def][deepDef];
                    }
                }
            }
        }
        
        // Swiper
        var s = this;
        
        // Params
        s.params = params;
        s.originalParams = originalParams;
        
        // Classname
        s.classNames = [];
        /*=========================
          Dom Library and plugins
          ===========================*/
        if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){
            $ = Dom7;
        }
        if (typeof $ === 'undefined') {
            if (typeof Dom7 === 'undefined') {
                $ = window.Dom7 || window.Zepto || window.jQuery;
            }
            else {
                $ = Dom7;
            }
            if (!$) return;
        }
        // Export it to Swiper instance
        s.$ = $;
        
        /*=========================
          Breakpoints
          ===========================*/
        s.currentBreakpoint = undefined;
        s.getActiveBreakpoint = function () {
            //Get breakpoint for window width
            if (!s.params.breakpoints) return false;
            var breakpoint = false;
            var points = [], point;
            for ( point in s.params.breakpoints ) {
                if (s.params.breakpoints.hasOwnProperty(point)) {
                    points.push(point);
                }
            }
            points.sort(function (a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                if (point >= window.innerWidth && !breakpoint) {
                    breakpoint = point;
                }
            }
            return breakpoint || 'max';
        };
        s.setBreakpoint = function () {
            //Set breakpoint for window width and update parameters
            var breakpoint = s.getActiveBreakpoint();
            if (breakpoint && s.currentBreakpoint !== breakpoint) {
                var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
                var needsReLoop = s.params.loop && (breakPointsParams.slidesPerView !== s.params.slidesPerView);
                for ( var param in breakPointsParams ) {
                    s.params[param] = breakPointsParams[param];
                }
                s.currentBreakpoint = breakpoint;
                if(needsReLoop && s.destroyLoop) {
                    s.reLoop(true);
                }
            }
        };
        // Set breakpoint on load
        if (s.params.breakpoints) {
            s.setBreakpoint();
        }
        
        /*=========================
          Preparation - Define Container, Wrapper and Pagination
          ===========================*/
        s.container = $(container);
        if (s.container.length === 0) return;
        if (s.container.length > 1) {
            var swipers = [];
            s.container.each(function () {
                var container = this;
                swipers.push(new Swiper(this, params));
            });
            return swipers;
        }
        
        // Save instance in container HTML Element and in data
        s.container[0].swiper = s;
        s.container.data('swiper', s);
        
        s.classNames.push(s.params.containerModifierClass + s.params.direction);
        
        if (s.params.freeMode) {
            s.classNames.push(s.params.containerModifierClass + 'free-mode');
        }
        if (!s.support.flexbox) {
            s.classNames.push(s.params.containerModifierClass + 'no-flexbox');
            s.params.slidesPerColumn = 1;
        }
        if (s.params.autoHeight) {
            s.classNames.push(s.params.containerModifierClass + 'autoheight');
        }
        // Enable slides progress when required
        if (s.params.parallax || s.params.watchSlidesVisibility) {
            s.params.watchSlidesProgress = true;
        }
        // Max resistance when touchReleaseOnEdges
        if (s.params.touchReleaseOnEdges) {
            s.params.resistanceRatio = 0;
        }
        // Coverflow / 3D
        if (['cube', 'coverflow', 'flip'].indexOf(s.params.effect) >= 0) {
            if (s.support.transforms3d) {
                s.params.watchSlidesProgress = true;
                s.classNames.push(s.params.containerModifierClass + '3d');
            }
            else {
                s.params.effect = 'slide';
            }
        }
        if (s.params.effect !== 'slide') {
            s.classNames.push(s.params.containerModifierClass + s.params.effect);
        }
        if (s.params.effect === 'cube') {
            s.params.resistanceRatio = 0;
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.centeredSlides = false;
            s.params.spaceBetween = 0;
            s.params.virtualTranslate = true;
        }
        if (s.params.effect === 'fade' || s.params.effect === 'flip') {
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.watchSlidesProgress = true;
            s.params.spaceBetween = 0;
            if (typeof initialVirtualTranslate === 'undefined') {
                s.params.virtualTranslate = true;
            }
        }
        
        // Grab Cursor
        if (s.params.grabCursor && s.support.touch) {
            s.params.grabCursor = false;
        }
        
        // Wrapper
        s.wrapper = s.container.children('.' + s.params.wrapperClass);
        
        // Pagination
        if (s.params.pagination) {
            s.paginationContainer = $(s.params.pagination);
            if (s.params.uniqueNavElements && typeof s.params.pagination === 'string' && s.paginationContainer.length > 1 && s.container.find(s.params.pagination).length === 1) {
                s.paginationContainer = s.container.find(s.params.pagination);
            }
        
            if (s.params.paginationType === 'bullets' && s.params.paginationClickable) {
                s.paginationContainer.addClass(s.params.paginationModifierClass + 'clickable');
            }
            else {
                s.params.paginationClickable = false;
            }
            s.paginationContainer.addClass(s.params.paginationModifierClass + s.params.paginationType);
        }
        // Next/Prev Buttons
        if (s.params.nextButton || s.params.prevButton) {
            if (s.params.nextButton) {
                s.nextButton = $(s.params.nextButton);
                if (s.params.uniqueNavElements && typeof s.params.nextButton === 'string' && s.nextButton.length > 1 && s.container.find(s.params.nextButton).length === 1) {
                    s.nextButton = s.container.find(s.params.nextButton);
                }
            }
            if (s.params.prevButton) {
                s.prevButton = $(s.params.prevButton);
                if (s.params.uniqueNavElements && typeof s.params.prevButton === 'string' && s.prevButton.length > 1 && s.container.find(s.params.prevButton).length === 1) {
                    s.prevButton = s.container.find(s.params.prevButton);
                }
            }
        }
        
        // Is Horizontal
        s.isHorizontal = function () {
            return s.params.direction === 'horizontal';
        };
        // s.isH = isH;
        
        // RTL
        s.rtl = s.isHorizontal() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
        if (s.rtl) {
            s.classNames.push(s.params.containerModifierClass + 'rtl');
        }
        
        // Wrong RTL support
        if (s.rtl) {
            s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
        }
        
        // Columns
        if (s.params.slidesPerColumn > 1) {
            s.classNames.push(s.params.containerModifierClass + 'multirow');
        }
        
        // Check for Android
        if (s.device.android) {
            s.classNames.push(s.params.containerModifierClass + 'android');
        }
        
        // Add classes
        s.container.addClass(s.classNames.join(' '));
        
        // Translate
        s.translate = 0;
        
        // Progress
        s.progress = 0;
        
        // Velocity
        s.velocity = 0;
        
        /*=========================
          Locks, unlocks
          ===========================*/
        s.lockSwipeToNext = function () {
            s.params.allowSwipeToNext = false;
            if (s.params.allowSwipeToPrev === false && s.params.grabCursor) {
                s.unsetGrabCursor();
            }
        };
        s.lockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = false;
            if (s.params.allowSwipeToNext === false && s.params.grabCursor) {
                s.unsetGrabCursor();
            }
        };
        s.lockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
            if (s.params.grabCursor) s.unsetGrabCursor();
        };
        s.unlockSwipeToNext = function () {
            s.params.allowSwipeToNext = true;
            if (s.params.allowSwipeToPrev === true && s.params.grabCursor) {
                s.setGrabCursor();
            }
        };
        s.unlockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = true;
            if (s.params.allowSwipeToNext === true && s.params.grabCursor) {
                s.setGrabCursor();
            }
        };
        s.unlockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
            if (s.params.grabCursor) s.setGrabCursor();
        };
        
        /*=========================
          Round helper
          ===========================*/
        function round(a) {
            return Math.floor(a);
        }
        /*=========================
          Set grab cursor
          ===========================*/
        s.setGrabCursor = function(moving) {
            s.container[0].style.cursor = 'move';
            s.container[0].style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
            s.container[0].style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
            s.container[0].style.cursor = moving ? 'grabbing': 'grab';
        };
        s.unsetGrabCursor = function () {
            s.container[0].style.cursor = '';
        };
        if (s.params.grabCursor) {
            s.setGrabCursor();
        }
        /*=========================
          Update on Images Ready
          ===========================*/
        s.imagesToLoad = [];
        s.imagesLoaded = 0;
        
        s.loadImage = function (imgElement, src, srcset, sizes, checkForComplete, callback) {
            var image;
            function onReady () {
                if (callback) callback();
            }
            if (!imgElement.complete || !checkForComplete) {
                if (src) {
                    image = new window.Image();
                    image.onload = onReady;
                    image.onerror = onReady;
                    if (sizes) {
                        image.sizes = sizes;
                    }
                    if (srcset) {
                        image.srcset = srcset;
                    }
                    if (src) {
                        image.src = src;
                    }
                } else {
                    onReady();
                }
        
            } else {//image already loaded...
                onReady();
            }
        };
        s.preloadImages = function () {
            s.imagesToLoad = s.container.find('img');
            function _onReady() {
                if (typeof s === 'undefined' || s === null || !s) return;
                if (s.imagesLoaded !== undefined) s.imagesLoaded++;
                if (s.imagesLoaded === s.imagesToLoad.length) {
                    if (s.params.updateOnImagesReady) s.update();
                    s.emit('onImagesReady', s);
                }
            }
            for (var i = 0; i < s.imagesToLoad.length; i++) {
                s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), (s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset')), s.imagesToLoad[i].sizes || s.imagesToLoad[i].getAttribute('sizes'), true, _onReady);
            }
        };
        
        /*=========================
          Autoplay
          ===========================*/
        s.autoplayTimeoutId = undefined;
        s.autoplaying = false;
        s.autoplayPaused = false;
        function autoplay() {
            var autoplayDelay = s.params.autoplay;
            var activeSlide = s.slides.eq(s.activeIndex);
            if (activeSlide.attr('data-swiper-autoplay')) {
                autoplayDelay = activeSlide.attr('data-swiper-autoplay') || s.params.autoplay;
            }
            s.autoplayTimeoutId = setTimeout(function () {
                if (s.params.loop) {
                    s.fixLoop();
                    s._slideNext();
                    s.emit('onAutoplay', s);
                }
                else {
                    if (!s.isEnd) {
                        s._slideNext();
                        s.emit('onAutoplay', s);
                    }
                    else {
                        if (!params.autoplayStopOnLast) {
                            s._slideTo(0);
                            s.emit('onAutoplay', s);
                        }
                        else {
                            s.stopAutoplay();
                        }
                    }
                }
            }, autoplayDelay);
        }
        s.startAutoplay = function () {
            if (typeof s.autoplayTimeoutId !== 'undefined') return false;
            if (!s.params.autoplay) return false;
            if (s.autoplaying) return false;
            s.autoplaying = true;
            s.emit('onAutoplayStart', s);
            autoplay();
        };
        s.stopAutoplay = function (internal) {
            if (!s.autoplayTimeoutId) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplaying = false;
            s.autoplayTimeoutId = undefined;
            s.emit('onAutoplayStop', s);
        };
        s.pauseAutoplay = function (speed) {
            if (s.autoplayPaused) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplayPaused = true;
            if (speed === 0) {
                s.autoplayPaused = false;
                autoplay();
            }
            else {
                s.wrapper.transitionEnd(function () {
                    if (!s) return;
                    s.autoplayPaused = false;
                    if (!s.autoplaying) {
                        s.stopAutoplay();
                    }
                    else {
                        autoplay();
                    }
                });
            }
        };
        /*=========================
          Min/Max Translate
          ===========================*/
        s.minTranslate = function () {
            return (-s.snapGrid[0]);
        };
        s.maxTranslate = function () {
            return (-s.snapGrid[s.snapGrid.length - 1]);
        };
        /*=========================
          Slider/slides sizes
          ===========================*/
        s.updateAutoHeight = function () {
            var activeSlides = [];
            var newHeight = 0;
            var i;
        
            // Find slides currently in view
            if(s.params.slidesPerView !== 'auto' && s.params.slidesPerView > 1) {
                for (i = 0; i < Math.ceil(s.params.slidesPerView); i++) {
                    var index = s.activeIndex + i;
                    if(index > s.slides.length) break;
                    activeSlides.push(s.slides.eq(index)[0]);
                }
            } else {
                activeSlides.push(s.slides.eq(s.activeIndex)[0]);
            }
        
            // Find new height from heighest slide in view
            for (i = 0; i < activeSlides.length; i++) {
                if (typeof activeSlides[i] !== 'undefined') {
                    var height = activeSlides[i].offsetHeight;
                    newHeight = height > newHeight ? height : newHeight;
                }
            }
        
            // Update Height
            if (newHeight) s.wrapper.css('height', newHeight + 'px');
        };
        s.updateContainerSize = function () {
            var width, height;
            if (typeof s.params.width !== 'undefined') {
                width = s.params.width;
            }
            else {
                width = s.container[0].clientWidth;
            }
            if (typeof s.params.height !== 'undefined') {
                height = s.params.height;
            }
            else {
                height = s.container[0].clientHeight;
            }
            if (width === 0 && s.isHorizontal() || height === 0 && !s.isHorizontal()) {
                return;
            }
        
            //Subtract paddings
            width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
            height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
        
            // Store values
            s.width = width;
            s.height = height;
            s.size = s.isHorizontal() ? s.width : s.height;
        };
        
        s.updateSlidesSize = function () {
            s.slides = s.wrapper.children('.' + s.params.slideClass);
            s.snapGrid = [];
            s.slidesGrid = [];
            s.slidesSizesGrid = [];
        
            var spaceBetween = s.params.spaceBetween,
                slidePosition = -s.params.slidesOffsetBefore,
                i,
                prevSlideSize = 0,
                index = 0;
            if (typeof s.size === 'undefined') return;
            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
            }
        
            s.virtualSize = -spaceBetween;
            // reset margins
            if (s.rtl) s.slides.css({marginLeft: '', marginTop: ''});
            else s.slides.css({marginRight: '', marginBottom: ''});
        
            var slidesNumberEvenToRows;
            if (s.params.slidesPerColumn > 1) {
                if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
                    slidesNumberEvenToRows = s.slides.length;
                }
                else {
                    slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
                }
                if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
                    slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
                }
            }
        
            // Calc slides
            var slideSize;
            var slidesPerColumn = s.params.slidesPerColumn;
            var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
            var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
            for (i = 0; i < s.slides.length; i++) {
                slideSize = 0;
                var slide = s.slides.eq(i);
                if (s.params.slidesPerColumn > 1) {
                    // Set slides order
                    var newSlideOrderIndex;
                    var column, row;
                    if (s.params.slidesPerColumnFill === 'column') {
                        column = Math.floor(i / slidesPerColumn);
                        row = i - column * slidesPerColumn;
                        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn-1)) {
                            if (++row >= slidesPerColumn) {
                                row = 0;
                                column++;
                            }
                        }
                        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                        slide
                            .css({
                                '-webkit-box-ordinal-group': newSlideOrderIndex,
                                '-moz-box-ordinal-group': newSlideOrderIndex,
                                '-ms-flex-order': newSlideOrderIndex,
                                '-webkit-order': newSlideOrderIndex,
                                'order': newSlideOrderIndex
                            });
                    }
                    else {
                        row = Math.floor(i / slidesPerRow);
                        column = i - row * slidesPerRow;
                    }
                    slide
                        .css(
                            'margin-' + (s.isHorizontal() ? 'top' : 'left'),
                            (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')
                        )
                        .attr('data-swiper-column', column)
                        .attr('data-swiper-row', row);
        
                }
                if (slide.css('display') === 'none') continue;
                if (s.params.slidesPerView === 'auto') {
                    slideSize = s.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                    if (s.params.roundLengths) slideSize = round(slideSize);
                }
                else {
                    slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
                    if (s.params.roundLengths) slideSize = round(slideSize);
        
                    if (s.isHorizontal()) {
                        s.slides[i].style.width = slideSize + 'px';
                    }
                    else {
                        s.slides[i].style.height = slideSize + 'px';
                    }
                }
                s.slides[i].swiperSlideSize = slideSize;
                s.slidesSizesGrid.push(slideSize);
        
        
                if (s.params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if(prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                    if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                }
                else {
                    if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
        
                s.virtualSize += slideSize + spaceBetween;
        
                prevSlideSize = slideSize;
        
                index ++;
            }
            s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
            var newSlidesGrid;
        
            if (
                s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
                s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
            }
            if (!s.support.flexbox || s.params.setWrapperSize) {
                if (s.isHorizontal()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
                else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
            }
        
            if (s.params.slidesPerColumn > 1) {
                s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
                s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
                if (s.isHorizontal()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
                else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
                if (s.params.centeredSlides) {
                    newSlidesGrid = [];
                    for (i = 0; i < s.snapGrid.length; i++) {
                        if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
                    }
                    s.snapGrid = newSlidesGrid;
                }
            }
        
            // Remove last grid elements depending on width
            if (!s.params.centeredSlides) {
                newSlidesGrid = [];
                for (i = 0; i < s.snapGrid.length; i++) {
                    if (s.snapGrid[i] <= s.virtualSize - s.size) {
                        newSlidesGrid.push(s.snapGrid[i]);
                    }
                }
                s.snapGrid = newSlidesGrid;
                if (Math.floor(s.virtualSize - s.size) - Math.floor(s.snapGrid[s.snapGrid.length - 1]) > 1) {
                    s.snapGrid.push(s.virtualSize - s.size);
                }
            }
            if (s.snapGrid.length === 0) s.snapGrid = [0];
        
            if (s.params.spaceBetween !== 0) {
                if (s.isHorizontal()) {
                    if (s.rtl) s.slides.css({marginLeft: spaceBetween + 'px'});
                    else s.slides.css({marginRight: spaceBetween + 'px'});
                }
                else s.slides.css({marginBottom: spaceBetween + 'px'});
            }
            if (s.params.watchSlidesProgress) {
                s.updateSlidesOffset();
            }
        };
        s.updateSlidesOffset = function () {
            for (var i = 0; i < s.slides.length; i++) {
                s.slides[i].swiperSlideOffset = s.isHorizontal() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
            }
        };
        
        /*=========================
          Dynamic Slides Per View
          ===========================*/
        s.currentSlidesPerView = function () {
            var spv = 1, i, j;
            if (s.params.centeredSlides) {
                var size = s.slides[s.activeIndex].swiperSlideSize;
                var breakLoop;
                for (i = s.activeIndex + 1; i < s.slides.length; i++) {
                    if (s.slides[i] && !breakLoop) {
                        size += s.slides[i].swiperSlideSize;
                        spv ++;
                        if (size > s.size) breakLoop = true;
                    }
                }
                for (j = s.activeIndex - 1; j >= 0; j--) {
                    if (s.slides[j] && !breakLoop) {
                        size += s.slides[j].swiperSlideSize;
                        spv ++;
                        if (size > s.size) breakLoop = true;
                    }
                }
            }
            else {
                for (i = s.activeIndex + 1; i < s.slides.length; i++) {
                    if (s.slidesGrid[i] - s.slidesGrid[s.activeIndex] < s.size) {
                        spv++;
                    }
                }
            }
            return spv;
        };
        /*=========================
          Slider/slides progress
          ===========================*/
        s.updateSlidesProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            if (s.slides.length === 0) return;
            if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();
        
            var offsetCenter = -translate;
            if (s.rtl) offsetCenter = translate;
        
            // Visible Slides
            s.slides.removeClass(s.params.slideVisibleClass);
            for (var i = 0; i < s.slides.length; i++) {
                var slide = s.slides[i];
                var slideProgress = (offsetCenter + (s.params.centeredSlides ? s.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
                if (s.params.watchSlidesVisibility) {
                    var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                    var slideAfter = slideBefore + s.slidesSizesGrid[i];
                    var isVisible =
                        (slideBefore >= 0 && slideBefore < s.size) ||
                        (slideAfter > 0 && slideAfter <= s.size) ||
                        (slideBefore <= 0 && slideAfter >= s.size);
                    if (isVisible) {
                        s.slides.eq(i).addClass(s.params.slideVisibleClass);
                    }
                }
                slide.progress = s.rtl ? -slideProgress : slideProgress;
            }
        };
        s.updateProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            var wasBeginning = s.isBeginning;
            var wasEnd = s.isEnd;
            if (translatesDiff === 0) {
                s.progress = 0;
                s.isBeginning = s.isEnd = true;
            }
            else {
                s.progress = (translate - s.minTranslate()) / (translatesDiff);
                s.isBeginning = s.progress <= 0;
                s.isEnd = s.progress >= 1;
            }
            if (s.isBeginning && !wasBeginning) s.emit('onReachBeginning', s);
            if (s.isEnd && !wasEnd) s.emit('onReachEnd', s);
        
            if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
            s.emit('onProgress', s, s.progress);
        };
        s.updateActiveIndex = function () {
            var translate = s.rtl ? s.translate : -s.translate;
            var newActiveIndex, i, snapIndex;
            for (i = 0; i < s.slidesGrid.length; i ++) {
                if (typeof s.slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
                        newActiveIndex = i;
                    }
                    else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
                        newActiveIndex = i + 1;
                    }
                }
                else {
                    if (translate >= s.slidesGrid[i]) {
                        newActiveIndex = i;
                    }
                }
            }
            // Normalize slideIndex
            if(s.params.normalizeSlideIndex){
                if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
            }
            // for (i = 0; i < s.slidesGrid.length; i++) {
                // if (- translate >= s.slidesGrid[i]) {
                    // newActiveIndex = i;
                // }
            // }
            snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
            if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;
        
            if (newActiveIndex === s.activeIndex) {
                return;
            }
            s.snapIndex = snapIndex;
            s.previousIndex = s.activeIndex;
            s.activeIndex = newActiveIndex;
            s.updateClasses();
            s.updateRealIndex();
        };
        s.updateRealIndex = function(){
            s.realIndex = parseInt(s.slides.eq(s.activeIndex).attr('data-swiper-slide-index') || s.activeIndex, 10);
        };
        
        /*=========================
          Classes
          ===========================*/
        s.updateClasses = function () {
            s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass + ' ' + s.params.slideDuplicateActiveClass + ' ' + s.params.slideDuplicateNextClass + ' ' + s.params.slideDuplicatePrevClass);
            var activeSlide = s.slides.eq(s.activeIndex);
            // Active classes
            activeSlide.addClass(s.params.slideActiveClass);
            if (params.loop) {
                // Duplicate to all looped slides
                if (activeSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
                }
                else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
                }
            }
            // Next Slide
            var nextSlide = activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
            if (s.params.loop && nextSlide.length === 0) {
                nextSlide = s.slides.eq(0);
                nextSlide.addClass(s.params.slideNextClass);
            }
            // Prev Slide
            var prevSlide = activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
            if (s.params.loop && prevSlide.length === 0) {
                prevSlide = s.slides.eq(-1);
                prevSlide.addClass(s.params.slidePrevClass);
            }
            if (params.loop) {
                // Duplicate to all looped slides
                if (nextSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
                }
                else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
                }
                if (prevSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
                }
                else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
                }
            }
        
            // Pagination
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                // Current/Total
                var current,
                    total = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                if (s.params.loop) {
                    current = Math.ceil((s.activeIndex - s.loopedSlides)/s.params.slidesPerGroup);
                    if (current > s.slides.length - 1 - s.loopedSlides * 2) {
                        current = current - (s.slides.length - s.loopedSlides * 2);
                    }
                    if (current > total - 1) current = current - total;
                    if (current < 0 && s.params.paginationType !== 'bullets') current = total + current;
                }
                else {
                    if (typeof s.snapIndex !== 'undefined') {
                        current = s.snapIndex;
                    }
                    else {
                        current = s.activeIndex || 0;
                    }
                }
                // Types
                if (s.params.paginationType === 'bullets' && s.bullets && s.bullets.length > 0) {
                    s.bullets.removeClass(s.params.bulletActiveClass);
                    if (s.paginationContainer.length > 1) {
                        s.bullets.each(function () {
                            if ($(this).index() === current) $(this).addClass(s.params.bulletActiveClass);
                        });
                    }
                    else {
                        s.bullets.eq(current).addClass(s.params.bulletActiveClass);
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    s.paginationContainer.find('.' + s.params.paginationCurrentClass).text(current + 1);
                    s.paginationContainer.find('.' + s.params.paginationTotalClass).text(total);
                }
                if (s.params.paginationType === 'progress') {
                    var scale = (current + 1) / total,
                        scaleX = scale,
                        scaleY = 1;
                    if (!s.isHorizontal()) {
                        scaleY = scale;
                        scaleX = 1;
                    }
                    s.paginationContainer.find('.' + s.params.paginationProgressbarClass).transform('translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')').transition(s.params.speed);
                }
                if (s.params.paginationType === 'custom' && s.params.paginationCustomRender) {
                    s.paginationContainer.html(s.params.paginationCustomRender(s, current + 1, total));
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        
            // Next/active buttons
            if (!s.params.loop) {
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    if (s.isBeginning) {
                        s.prevButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.prevButton);
                    }
                    else {
                        s.prevButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.prevButton);
                    }
                }
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    if (s.isEnd) {
                        s.nextButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.nextButton);
                    }
                    else {
                        s.nextButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.nextButton);
                    }
                }
            }
        };
        
        /*=========================
          Pagination
          ===========================*/
        s.updatePagination = function () {
            if (!s.params.pagination) return;
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                var paginationHTML = '';
                if (s.params.paginationType === 'bullets') {
                    var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                    for (var i = 0; i < numberOfBullets; i++) {
                        if (s.params.paginationBulletRender) {
                            paginationHTML += s.params.paginationBulletRender(s, i, s.params.bulletClass);
                        }
                        else {
                            paginationHTML += '<' + s.params.paginationElement+' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
                        }
                    }
                    s.paginationContainer.html(paginationHTML);
                    s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
                    if (s.params.paginationClickable && s.params.a11y && s.a11y) {
                        s.a11y.initPagination();
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    if (s.params.paginationFractionRender) {
                        paginationHTML = s.params.paginationFractionRender(s, s.params.paginationCurrentClass, s.params.paginationTotalClass);
                    }
                    else {
                        paginationHTML =
                            '<span class="' + s.params.paginationCurrentClass + '"></span>' +
                            ' / ' +
                            '<span class="' + s.params.paginationTotalClass+'"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType === 'progress') {
                    if (s.params.paginationProgressRender) {
                        paginationHTML = s.params.paginationProgressRender(s, s.params.paginationProgressbarClass);
                    }
                    else {
                        paginationHTML = '<span class="' + s.params.paginationProgressbarClass + '"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType !== 'custom') {
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        };
        /*=========================
          Common update method
          ===========================*/
        s.update = function (updateTranslate) {
            if (!s) return;
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updateProgress();
            s.updatePagination();
            s.updateClasses();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            var newTranslate;
            function forceSetTranslate() {
                var translate = s.rtl ? -s.translate : s.translate;
                newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
            }
            if (updateTranslate) {
                var translated;
                if (s.controller && s.controller.spline) {
                    s.controller.spline = undefined;
                }
                if (s.params.freeMode) {
                    forceSetTranslate();
                    if (s.params.autoHeight) {
                        s.updateAutoHeight();
                    }
                }
                else {
                    if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                        translated = s.slideTo(s.slides.length - 1, 0, false, true);
                    }
                    else {
                        translated = s.slideTo(s.activeIndex, 0, false, true);
                    }
                    if (!translated) {
                        forceSetTranslate();
                    }
                }
            }
            else if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
        };
        
        /*=========================
          Resize Handler
          ===========================*/
        s.onResize = function (forceUpdatePagination) {
            if (s.params.onBeforeResize) s.params.onBeforeResize(s);
            //Breakpoints
            if (s.params.breakpoints) {
                s.setBreakpoint();
            }
        
            // Disable locks on resize
            var allowSwipeToPrev = s.params.allowSwipeToPrev;
            var allowSwipeToNext = s.params.allowSwipeToNext;
            s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
        
            s.updateContainerSize();
            s.updateSlidesSize();
            if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            if (s.controller && s.controller.spline) {
                s.controller.spline = undefined;
            }
            var slideChangedBySlideTo = false;
            if (s.params.freeMode) {
                var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
        
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
            }
            else {
                s.updateClasses();
                if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                    slideChangedBySlideTo = s.slideTo(s.slides.length - 1, 0, false, true);
                }
                else {
                    slideChangedBySlideTo = s.slideTo(s.activeIndex, 0, false, true);
                }
            }
            if (s.params.lazyLoading && !slideChangedBySlideTo && s.lazy) {
                s.lazy.load();
            }
            // Return locks after resize
            s.params.allowSwipeToPrev = allowSwipeToPrev;
            s.params.allowSwipeToNext = allowSwipeToNext;
            if (s.params.onAfterResize) s.params.onAfterResize(s);
        };
        
        /*=========================
          Events
          ===========================*/
        
        //Define Touch Events
        s.touchEventsDesktop = {start: 'mousedown', move: 'mousemove', end: 'mouseup'};
        if (window.navigator.pointerEnabled) s.touchEventsDesktop = {start: 'pointerdown', move: 'pointermove', end: 'pointerup'};
        else if (window.navigator.msPointerEnabled) s.touchEventsDesktop = {start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp'};
        s.touchEvents = {
            start : s.support.touch || !s.params.simulateTouch  ? 'touchstart' : s.touchEventsDesktop.start,
            move : s.support.touch || !s.params.simulateTouch ? 'touchmove' : s.touchEventsDesktop.move,
            end : s.support.touch || !s.params.simulateTouch ? 'touchend' : s.touchEventsDesktop.end
        };
        
        
        // WP8 Touch Events Fix
        if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
            (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
        }
        
        // Attach/detach events
        s.initEvents = function (detach) {
            var actionDom = detach ? 'off' : 'on';
            var action = detach ? 'removeEventListener' : 'addEventListener';
            var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
            var target = s.support.touch ? touchEventsTarget : document;
        
            var moveCapture = s.params.nested ? true : false;
        
            //Touch Events
            if (s.browser.ie) {
                touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
                target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                target[action](s.touchEvents.end, s.onTouchEnd, false);
            }
            else {
                if (s.support.touch) {
                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? {passive: true, capture: false} : false;
                    touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, passiveListener);
                    touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                    touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, passiveListener);
                }
                if ((params.simulateTouch && !s.device.ios && !s.device.android) || (params.simulateTouch && !s.support.touch && s.device.ios)) {
                    touchEventsTarget[action]('mousedown', s.onTouchStart, false);
                    document[action]('mousemove', s.onTouchMove, moveCapture);
                    document[action]('mouseup', s.onTouchEnd, false);
                }
            }
            window[action]('resize', s.onResize);
        
            // Next, Prev, Index
            if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                s.nextButton[actionDom]('click', s.onClickNext);
                if (s.params.a11y && s.a11y) s.nextButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                s.prevButton[actionDom]('click', s.onClickPrev);
                if (s.params.a11y && s.a11y) s.prevButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.pagination && s.params.paginationClickable) {
                s.paginationContainer[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
                if (s.params.a11y && s.a11y) s.paginationContainer[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
            }
        
            // Prevent Links Clicks
            if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
        };
        s.attachEvents = function () {
            s.initEvents();
        };
        s.detachEvents = function () {
            s.initEvents(true);
        };
        
        /*=========================
          Handle Clicks
          ===========================*/
        // Prevent Clicks
        s.allowClick = true;
        s.preventClicks = function (e) {
            if (!s.allowClick) {
                if (s.params.preventClicks) e.preventDefault();
                if (s.params.preventClicksPropagation && s.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        };
        // Clicks
        s.onClickNext = function (e) {
            e.preventDefault();
            if (s.isEnd && !s.params.loop) return;
            s.slideNext();
        };
        s.onClickPrev = function (e) {
            e.preventDefault();
            if (s.isBeginning && !s.params.loop) return;
            s.slidePrev();
        };
        s.onClickIndex = function (e) {
            e.preventDefault();
            var index = $(this).index() * s.params.slidesPerGroup;
            if (s.params.loop) index = index + s.loopedSlides;
            s.slideTo(index);
        };
        
        /*=========================
          Handle Touches
          ===========================*/
        function findElementInEvent(e, selector) {
            var el = $(e.target);
            if (!el.is(selector)) {
                if (typeof selector === 'string') {
                    el = el.parents(selector);
                }
                else if (selector.nodeType) {
                    var found;
                    el.parents().each(function (index, _el) {
                        if (_el === selector) found = selector;
                    });
                    if (!found) return undefined;
                    else return selector;
                }
            }
            if (el.length === 0) {
                return undefined;
            }
            return el[0];
        }
        s.updateClickedSlide = function (e) {
            var slide = findElementInEvent(e, '.' + s.params.slideClass);
            var slideFound = false;
            if (slide) {
                for (var i = 0; i < s.slides.length; i++) {
                    if (s.slides[i] === slide) slideFound = true;
                }
            }
        
            if (slide && slideFound) {
                s.clickedSlide = slide;
                s.clickedIndex = $(slide).index();
            }
            else {
                s.clickedSlide = undefined;
                s.clickedIndex = undefined;
                return;
            }
            if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
                var slideToIndex = s.clickedIndex,
                    realIndex,
                    duplicatedSlides,
                    slidesPerView = s.params.slidesPerView === 'auto' ? s.currentSlidesPerView() : s.params.slidesPerView;
                if (s.params.loop) {
                    if (s.animating) return;
                    realIndex = parseInt($(s.clickedSlide).attr('data-swiper-slide-index'), 10);
                    if (s.params.centeredSlides) {
                        if ((slideToIndex < s.loopedSlides - slidesPerView/2) || (slideToIndex > s.slides.length - s.loopedSlides + slidesPerView/2)) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        }
                        else {
                            s.slideTo(slideToIndex);
                        }
                    }
                    else {
                        if (slideToIndex > s.slides.length - slidesPerView) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        }
                        else {
                            s.slideTo(slideToIndex);
                        }
                    }
                }
                else {
                    s.slideTo(slideToIndex);
                }
            }
        };
        
        var isTouched,
            isMoved,
            allowTouchCallbacks,
            touchStartTime,
            isScrolling,
            currentTranslate,
            startTranslate,
            allowThresholdMove,
            // Form elements to match
            formElements = 'input, select, textarea, button, video',
            // Last click time
            lastClickTime = Date.now(), clickTimeout,
            //Velocities
            velocities = [],
            allowMomentumBounce;
        
        // Animating Flag
        s.animating = false;
        
        // Touches information
        s.touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
        };
        
        // Touch handlers
        var isTouchEvent, startMoving;
        s.onTouchStart = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            isTouchEvent = e.type === 'touchstart';
            if (!isTouchEvent && 'which' in e && e.which === 3) return;
            if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
                s.allowClick = true;
                return;
            }
            if (s.params.swipeHandler) {
                if (!findElementInEvent(e, s.params.swipeHandler)) return;
            }
        
            var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        
            // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
            if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
                return;
            }
        
            isTouched = true;
            isMoved = false;
            allowTouchCallbacks = true;
            isScrolling = undefined;
            startMoving = undefined;
            s.touches.startX = startX;
            s.touches.startY = startY;
            touchStartTime = Date.now();
            s.allowClick = true;
            s.updateContainerSize();
            s.swipeDirection = undefined;
            if (s.params.threshold > 0) allowThresholdMove = false;
            if (e.type !== 'touchstart') {
                var preventDefault = true;
                if ($(e.target).is(formElements)) preventDefault = false;
                if (document.activeElement && $(document.activeElement).is(formElements)) {
                    document.activeElement.blur();
                }
                if (preventDefault) {
                    e.preventDefault();
                }
            }
            s.emit('onTouchStart', s, e);
        };
        
        s.onTouchMove = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (isTouchEvent && e.type === 'mousemove') return;
            if (e.preventedByNestedSwiper) {
                s.touches.startX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                s.touches.startY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                return;
            }
            if (s.params.onlyExternal) {
                // isMoved = true;
                s.allowClick = false;
                if (isTouched) {
                    s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                    s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                    touchStartTime = Date.now();
                }
                return;
            }
            if (isTouchEvent && s.params.touchReleaseOnEdges && !s.params.loop) {
                if (!s.isHorizontal()) {
                    // Vertical
                    if (
                        (s.touches.currentY < s.touches.startY && s.translate <= s.maxTranslate()) ||
                        (s.touches.currentY > s.touches.startY && s.translate >= s.minTranslate())
                        ) {
                        return;
                    }
                }
                else {
                    if (
                        (s.touches.currentX < s.touches.startX && s.translate <= s.maxTranslate()) ||
                        (s.touches.currentX > s.touches.startX && s.translate >= s.minTranslate())
                        ) {
                        return;
                    }
                }
            }
            if (isTouchEvent && document.activeElement) {
                if (e.target === document.activeElement && $(e.target).is(formElements)) {
                    isMoved = true;
                    s.allowClick = false;
                    return;
                }
            }
            if (allowTouchCallbacks) {
                s.emit('onTouchMove', s, e);
            }
            if (e.targetTouches && e.targetTouches.length > 1) return;
        
            s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        
            if (typeof isScrolling === 'undefined') {
                var touchAngle;
                if (s.isHorizontal() && s.touches.currentY === s.touches.startY || !s.isHorizontal() && s.touches.currentX === s.touches.startX) {
                    isScrolling = false;
                }
                else {
                    touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
                    isScrolling = s.isHorizontal() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
                }
            }
            if (isScrolling) {
                s.emit('onTouchMoveOpposite', s, e);
            }
            if (typeof startMoving === 'undefined') {
                if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
                    startMoving = true;
                }
            }
            if (!isTouched) return;
            if (isScrolling)  {
                isTouched = false;
                return;
            }
            if (!startMoving) {
                return;
            }
            s.allowClick = false;
            s.emit('onSliderMove', s, e);
            e.preventDefault();
            if (s.params.touchMoveStopPropagation && !s.params.nested) {
                e.stopPropagation();
            }
        
            if (!isMoved) {
                if (params.loop) {
                    s.fixLoop();
                }
                startTranslate = s.getWrapperTranslate();
                s.setWrapperTransition(0);
                if (s.animating) {
                    s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
                }
                if (s.params.autoplay && s.autoplaying) {
                    if (s.params.autoplayDisableOnInteraction) {
                        s.stopAutoplay();
                    }
                    else {
                        s.pauseAutoplay();
                    }
                }
                allowMomentumBounce = false;
                //Grab Cursor
                if (s.params.grabCursor && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
                    s.setGrabCursor(true);
                }
            }
            isMoved = true;
        
            var diff = s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
        
            diff = diff * s.params.touchRatio;
            if (s.rtl) diff = -diff;
        
            s.swipeDirection = diff > 0 ? 'prev' : 'next';
            currentTranslate = diff + startTranslate;
        
            var disableParentSwiper = true;
            if ((diff > 0 && currentTranslate > s.minTranslate())) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
            }
            else if (diff < 0 && currentTranslate < s.maxTranslate()) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
            }
        
            if (disableParentSwiper) {
                e.preventedByNestedSwiper = true;
            }
        
            // Directions locks
            if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
                currentTranslate = startTranslate;
            }
            if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
                currentTranslate = startTranslate;
            }
        
        
            // Threshold
            if (s.params.threshold > 0) {
                if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
                    if (!allowThresholdMove) {
                        allowThresholdMove = true;
                        s.touches.startX = s.touches.currentX;
                        s.touches.startY = s.touches.currentY;
                        currentTranslate = startTranslate;
                        s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                        return;
                    }
                }
                else {
                    currentTranslate = startTranslate;
                    return;
                }
            }
        
            if (!s.params.followFinger) return;
        
            // Update active index in free mode
            if (s.params.freeMode || s.params.watchSlidesProgress) {
                s.updateActiveIndex();
            }
            if (s.params.freeMode) {
                //Velocity
                if (velocities.length === 0) {
                    velocities.push({
                        position: s.touches[s.isHorizontal() ? 'startX' : 'startY'],
                        time: touchStartTime
                    });
                }
                velocities.push({
                    position: s.touches[s.isHorizontal() ? 'currentX' : 'currentY'],
                    time: (new window.Date()).getTime()
                });
            }
            // Update progress
            s.updateProgress(currentTranslate);
            // Update translate
            s.setWrapperTranslate(currentTranslate);
        };
        s.onTouchEnd = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (allowTouchCallbacks) {
                s.emit('onTouchEnd', s, e);
            }
            allowTouchCallbacks = false;
            if (!isTouched) return;
            //Return Grab Cursor
            if (s.params.grabCursor && isMoved && isTouched  && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
                s.setGrabCursor(false);
            }
        
            // Time diff
            var touchEndTime = Date.now();
            var timeDiff = touchEndTime - touchStartTime;
        
            // Tap, doubleTap, Click
            if (s.allowClick) {
                s.updateClickedSlide(e);
                s.emit('onTap', s, e);
                if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    clickTimeout = setTimeout(function () {
                        if (!s) return;
                        if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
                            s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
                        }
                        s.emit('onClick', s, e);
                    }, 300);
        
                }
                if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    s.emit('onDoubleTap', s, e);
                }
            }
        
            lastClickTime = Date.now();
            setTimeout(function () {
                if (s) s.allowClick = true;
            }, 0);
        
            if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
                isTouched = isMoved = false;
                return;
            }
            isTouched = isMoved = false;
        
            var currentPos;
            if (s.params.followFinger) {
                currentPos = s.rtl ? s.translate : -s.translate;
            }
            else {
                currentPos = -currentTranslate;
            }
            if (s.params.freeMode) {
                if (currentPos < -s.minTranslate()) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                else if (currentPos > -s.maxTranslate()) {
                    if (s.slides.length < s.snapGrid.length) {
                        s.slideTo(s.snapGrid.length - 1);
                    }
                    else {
                        s.slideTo(s.slides.length - 1);
                    }
                    return;
                }
        
                if (s.params.freeModeMomentum) {
                    if (velocities.length > 1) {
                        var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop();
        
                        var distance = lastMoveEvent.position - velocityEvent.position;
                        var time = lastMoveEvent.time - velocityEvent.time;
                        s.velocity = distance / time;
                        s.velocity = s.velocity / 2;
                        if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
                            s.velocity = 0;
                        }
                        // this implies that the user stopped moving a finger then released.
                        // There would be no events with distance zero, so the last event is stale.
                        if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
                            s.velocity = 0;
                        }
                    } else {
                        s.velocity = 0;
                    }
                    s.velocity = s.velocity * s.params.freeModeMomentumVelocityRatio;
        
                    velocities.length = 0;
                    var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
                    var momentumDistance = s.velocity * momentumDuration;
        
                    var newPosition = s.translate + momentumDistance;
                    if (s.rtl) newPosition = - newPosition;
                    var doBounce = false;
                    var afterBouncePosition;
                    var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
                    if (newPosition < s.maxTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition + s.maxTranslate() < -bounceAmount) {
                                newPosition = s.maxTranslate() - bounceAmount;
                            }
                            afterBouncePosition = s.maxTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        }
                        else {
                            newPosition = s.maxTranslate();
                        }
                    }
                    else if (newPosition > s.minTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition - s.minTranslate() > bounceAmount) {
                                newPosition = s.minTranslate() + bounceAmount;
                            }
                            afterBouncePosition = s.minTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        }
                        else {
                            newPosition = s.minTranslate();
                        }
                    }
                    else if (s.params.freeModeSticky) {
                        var j = 0,
                            nextSlide;
                        for (j = 0; j < s.snapGrid.length; j += 1) {
                            if (s.snapGrid[j] > -newPosition) {
                                nextSlide = j;
                                break;
                            }
        
                        }
                        if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                            newPosition = s.snapGrid[nextSlide];
                        } else {
                            newPosition = s.snapGrid[nextSlide - 1];
                        }
                        if (!s.rtl) newPosition = - newPosition;
                    }
                    //Fix duration
                    if (s.velocity !== 0) {
                        if (s.rtl) {
                            momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
                        }
                        else {
                            momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
                        }
                    }
                    else if (s.params.freeModeSticky) {
                        s.slideReset();
                        return;
                    }
        
                    if (s.params.freeModeMomentumBounce && doBounce) {
                        s.updateProgress(afterBouncePosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        s.animating = true;
                        s.wrapper.transitionEnd(function () {
                            if (!s || !allowMomentumBounce) return;
                            s.emit('onMomentumBounce', s);
        
                            s.setWrapperTransition(s.params.speed);
                            s.setWrapperTranslate(afterBouncePosition);
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        });
                    } else if (s.velocity) {
                        s.updateProgress(newPosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        if (!s.animating) {
                            s.animating = true;
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        }
        
                    } else {
                        s.updateProgress(newPosition);
                    }
        
                    s.updateActiveIndex();
                }
                if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
                    s.updateProgress();
                    s.updateActiveIndex();
                }
                return;
            }
        
            // Find current slide
            var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
            for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
                if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
                    if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
                    }
                }
                else {
                    if (currentPos >= s.slidesGrid[i]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
                    }
                }
            }
        
            // Find current slide size
            var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
        
            if (timeDiff > s.params.longSwipesMs) {
                // Long touches
                if (!s.params.longSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);
                    else s.slideTo(stopIndex);
        
                }
                if (s.swipeDirection === 'prev') {
                    if (ratio > (1 - s.params.longSwipesRatio)) s.slideTo(stopIndex + s.params.slidesPerGroup);
                    else s.slideTo(stopIndex);
                }
            }
            else {
                // Short swipes
                if (!s.params.shortSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    s.slideTo(stopIndex + s.params.slidesPerGroup);
        
                }
                if (s.swipeDirection === 'prev') {
                    s.slideTo(stopIndex);
                }
            }
        };
        /*=========================
          Transitions
          ===========================*/
        s._slideTo = function (slideIndex, speed) {
            return s.slideTo(slideIndex, speed, true, true);
        };
        s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (typeof slideIndex === 'undefined') slideIndex = 0;
            if (slideIndex < 0) slideIndex = 0;
            s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
            if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;
        
            var translate = - s.snapGrid[s.snapIndex];
            // Stop autoplay
            if (s.params.autoplay && s.autoplaying) {
                if (internal || !s.params.autoplayDisableOnInteraction) {
                    s.pauseAutoplay(speed);
                }
                else {
                    s.stopAutoplay();
                }
            }
            // Update progress
            s.updateProgress(translate);
        
            // Normalize slideIndex
            if(s.params.normalizeSlideIndex){
                for (var i = 0; i < s.slidesGrid.length; i++) {
                    if (- Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
                        slideIndex = i;
                    }
                }
            }
        
            // Directions locks
            if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
                if ((s.activeIndex || 0) !== slideIndex ) return false;
            }
        
            // Update Index
            if (typeof speed === 'undefined') speed = s.params.speed;
            s.previousIndex = s.activeIndex || 0;
            s.activeIndex = slideIndex;
            s.updateRealIndex();
            if ((s.rtl && -translate === s.translate) || (!s.rtl && translate === s.translate)) {
                // Update Height
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
                s.updateClasses();
                if (s.params.effect !== 'slide') {
                    s.setWrapperTranslate(translate);
                }
                return false;
            }
            s.updateClasses();
            s.onTransitionStart(runCallbacks);
        
            if (speed === 0 || s.browser.lteIE9) {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(0);
                s.onTransitionEnd(runCallbacks);
            }
            else {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(speed);
                if (!s.animating) {
                    s.animating = true;
                    s.wrapper.transitionEnd(function () {
                        if (!s) return;
                        s.onTransitionEnd(runCallbacks);
                    });
                }
        
            }
        
            return true;
        };
        
        s.onTransitionStart = function (runCallbacks) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
            if (s.lazy) s.lazy.onTransitionStart();
            if (runCallbacks) {
                s.emit('onTransitionStart', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeStart', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextStart', s);
                    }
                    else {
                        s.emit('onSlidePrevStart', s);
                    }
                }
        
            }
        };
        s.onTransitionEnd = function (runCallbacks) {
            s.animating = false;
            s.setWrapperTransition(0);
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.lazy) s.lazy.onTransitionEnd();
            if (runCallbacks) {
                s.emit('onTransitionEnd', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeEnd', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextEnd', s);
                    }
                    else {
                        s.emit('onSlidePrevEnd', s);
                    }
                }
            }
            if (s.params.history && s.history) {
                s.history.setHistory(s.params.history, s.activeIndex);
            }
            if (s.params.hashnav && s.hashnav) {
                s.hashnav.setHash();
            }
        
        };
        s.slideNext = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
            }
            else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
        };
        s._slideNext = function (speed) {
            return s.slideNext(true, speed, true);
        };
        s.slidePrev = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
            }
            else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
        };
        s._slidePrev = function (speed) {
            return s.slidePrev(true, speed, true);
        };
        s.slideReset = function (runCallbacks, speed, internal) {
            return s.slideTo(s.activeIndex, speed, runCallbacks);
        };
        
        s.disableTouchControl = function () {
            s.params.onlyExternal = true;
            return true;
        };
        s.enableTouchControl = function () {
            s.params.onlyExternal = false;
            return true;
        };
        
        /*=========================
          Translate/transition helpers
          ===========================*/
        s.setWrapperTransition = function (duration, byController) {
            s.wrapper.transition(duration);
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTransition(duration);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTransition(duration);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTransition(duration);
            }
            if (s.params.control && s.controller) {
                s.controller.setTransition(duration, byController);
            }
            s.emit('onSetTransition', s, duration);
        };
        s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
            var x = 0, y = 0, z = 0;
            if (s.isHorizontal()) {
                x = s.rtl ? -translate : translate;
            }
            else {
                y = translate;
            }
        
            if (s.params.roundLengths) {
                x = round(x);
                y = round(y);
            }
        
            if (!s.params.virtualTranslate) {
                if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
                else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
            }
        
            s.translate = s.isHorizontal() ? x : y;
        
            // Check if we need to update progress
            var progress;
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            if (translatesDiff === 0) {
                progress = 0;
            }
            else {
                progress = (translate - s.minTranslate()) / (translatesDiff);
            }
            if (progress !== s.progress) {
                s.updateProgress(translate);
            }
        
            if (updateActiveIndex) s.updateActiveIndex();
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTranslate(s.translate);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTranslate(s.translate);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTranslate(s.translate);
            }
            if (s.params.control && s.controller) {
                s.controller.setTranslate(s.translate, byController);
            }
            s.emit('onSetTranslate', s, s.translate);
        };
        
        s.getTranslate = function (el, axis) {
            var matrix, curTransform, curStyle, transformMatrix;
        
            // automatic axis detection
            if (typeof axis === 'undefined') {
                axis = 'x';
            }
        
            if (s.params.virtualTranslate) {
                return s.rtl ? -s.translate : s.translate;
            }
        
            curStyle = window.getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(',').length > 6) {
                    curTransform = curTransform.split(', ').map(function(a){
                        return a.replace(',','.');
                    }).join(', ');
                }
                // Some old versions of Webkit choke when 'none' is passed; pass
                // empty string instead in this case
                transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            }
            else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform  || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }
        
            if (axis === 'x') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m41;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[12]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m42;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[13]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[5]);
            }
            if (s.rtl && curTransform) curTransform = -curTransform;
            return curTransform || 0;
        };
        s.getWrapperTranslate = function (axis) {
            if (typeof axis === 'undefined') {
                axis = s.isHorizontal() ? 'x' : 'y';
            }
            return s.getTranslate(s.wrapper[0], axis);
        };
        
        /*=========================
          Observer
          ===========================*/
        s.observers = [];
        function initObserver(target, options) {
            options = options || {};
            // create an observer instance
            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            var observer = new ObserverFunc(function (mutations) {
                mutations.forEach(function (mutation) {
                    s.onResize(true);
                    s.emit('onObserverUpdate', s, mutation);
                });
            });
        
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
        
            s.observers.push(observer);
        }
        s.initObservers = function () {
            if (s.params.observeParents) {
                var containerParents = s.container.parents();
                for (var i = 0; i < containerParents.length; i++) {
                    initObserver(containerParents[i]);
                }
            }
        
            // Observe container
            initObserver(s.container[0], {childList: false});
        
            // Observe wrapper
            initObserver(s.wrapper[0], {attributes: false});
        };
        s.disconnectObservers = function () {
            for (var i = 0; i < s.observers.length; i++) {
                s.observers[i].disconnect();
            }
            s.observers = [];
        };
        /*=========================
          Loop
          ===========================*/
        // Create looped slides
        s.createLoop = function () {
            // Remove duplicated slides
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
        
            var slides = s.wrapper.children('.' + s.params.slideClass);
        
            if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;
        
            s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
            s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
            if (s.loopedSlides > slides.length) {
                s.loopedSlides = slides.length;
            }
        
            var prependSlides = [], appendSlides = [], i;
            slides.each(function (index, el) {
                var slide = $(this);
                if (index < s.loopedSlides) appendSlides.push(el);
                if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
                slide.attr('data-swiper-slide-index', index);
            });
            for (i = 0; i < appendSlides.length; i++) {
                s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
            for (i = prependSlides.length - 1; i >= 0; i--) {
                s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
        };
        s.destroyLoop = function () {
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
            s.slides.removeAttr('data-swiper-slide-index');
        };
        s.reLoop = function (updatePosition) {
            var oldIndex = s.activeIndex - s.loopedSlides;
            s.destroyLoop();
            s.createLoop();
            s.updateSlidesSize();
            if (updatePosition) {
                s.slideTo(oldIndex + s.loopedSlides, 0, false);
            }
        
        };
        s.fixLoop = function () {
            var newIndex;
            //Fix For Negative Oversliding
            if (s.activeIndex < s.loopedSlides) {
                newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
            //Fix For Positive Oversliding
            else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
                newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
        };
        /*=========================
          Append/Prepend/Remove Slides
          ===========================*/
        s.appendSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.append(slides[i]);
                }
            }
            else {
                s.wrapper.append(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
        };
        s.prependSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            var newActiveIndex = s.activeIndex + 1;
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.prepend(slides[i]);
                }
                newActiveIndex = s.activeIndex + slides.length;
            }
            else {
                s.wrapper.prepend(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            s.slideTo(newActiveIndex, 0, false);
        };
        s.removeSlide = function (slidesIndexes) {
            if (s.params.loop) {
                s.destroyLoop();
                s.slides = s.wrapper.children('.' + s.params.slideClass);
            }
            var newActiveIndex = s.activeIndex,
                indexToRemove;
            if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
                for (var i = 0; i < slidesIndexes.length; i++) {
                    indexToRemove = slidesIndexes[i];
                    if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                    if (indexToRemove < newActiveIndex) newActiveIndex--;
                }
                newActiveIndex = Math.max(newActiveIndex, 0);
            }
            else {
                indexToRemove = slidesIndexes;
                if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex--;
                newActiveIndex = Math.max(newActiveIndex, 0);
            }
        
            if (s.params.loop) {
                s.createLoop();
            }
        
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            if (s.params.loop) {
                s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
            }
            else {
                s.slideTo(newActiveIndex, 0, false);
            }
        
        };
        s.removeAllSlides = function () {
            var slidesIndexes = [];
            for (var i = 0; i < s.slides.length; i++) {
                slidesIndexes.push(i);
            }
            s.removeSlide(slidesIndexes);
        };
        

        /*=========================
          Effects
          ===========================*/
        s.effects = {
            fade: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var offset = slide[0].swiperSlideOffset;
                        var tx = -offset;
                        if (!s.params.virtualTranslate) tx = tx - s.translate;
                        var ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
                        var slideOpacity = s.params.fade.crossFade ?
                                Math.max(1 - Math.abs(slide[0].progress), 0) :
                                1 + Math.min(Math.max(slide[0].progress, -1), 0);
                        slide
                            .css({
                                opacity: slideOpacity
                            })
                            .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
        
                    }
        
                },
                setTransition: function (duration) {
                    s.slides.transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            flip: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var progress = slide[0].progress;
                        if (s.params.flip.limitRotation) {
                            progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        }
                        var offset = slide[0].swiperSlideOffset;
                        var rotate = -180 * progress,
                            rotateY = rotate,
                            rotateX = 0,
                            tx = -offset,
                            ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                            rotateX = -rotateY;
                            rotateY = 0;
                        }
                        else if (s.rtl) {
                            rotateY = -rotateY;
                        }
        
                        slide[0].style.zIndex = -Math.abs(Math.round(progress)) + s.slides.length;
        
                        if (s.params.flip.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
        
                        slide
                            .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px) rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)');
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.eq(s.activeIndex).transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            if (!$(this).hasClass(s.params.slideActiveClass)) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            cube: {
                setTranslate: function () {
                    var wrapperRotate = 0, cubeShadow;
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow = s.wrapper.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.wrapper.append(cubeShadow);
                            }
                            cubeShadow.css({height: s.width + 'px'});
                        }
                        else {
                            cubeShadow = s.container.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.container.append(cubeShadow);
                            }
                        }
                    }
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var slideAngle = i * 90;
                        var round = Math.floor(slideAngle / 360);
                        if (s.rtl) {
                            slideAngle = -slideAngle;
                            round = Math.floor(-slideAngle / 360);
                        }
                        var progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        var tx = 0, ty = 0, tz = 0;
                        if (i % 4 === 0) {
                            tx = - round * 4 * s.size;
                            tz = 0;
                        }
                        else if ((i - 1) % 4 === 0) {
                            tx = 0;
                            tz = - round * 4 * s.size;
                        }
                        else if ((i - 2) % 4 === 0) {
                            tx = s.size + round * 4 * s.size;
                            tz = s.size;
                        }
                        else if ((i - 3) % 4 === 0) {
                            tx = - s.size;
                            tz = 3 * s.size + s.size * 4 * round;
                        }
                        if (s.rtl) {
                            tx = -tx;
                        }
        
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
        
                        var transform = 'rotateX(' + (s.isHorizontal() ? 0 : -slideAngle) + 'deg) rotateY(' + (s.isHorizontal() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                        if (progress <= 1 && progress > -1) {
                            wrapperRotate = i * 90 + progress * 90;
                            if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
                        }
                        slide.transform(transform);
                        if (s.params.cube.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
                    }
                    s.wrapper.css({
                        '-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        '-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        '-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
                    });
        
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
                        }
                        else {
                            var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                            var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                            var scale1 = s.params.cube.shadowScale,
                                scale2 = s.params.cube.shadowScale / multiplier,
                                offset = s.params.cube.shadowOffset;
                            cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
                        }
                    }
                    var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
                    s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (s.isHorizontal() ? 0 : wrapperRotate) + 'deg) rotateY(' + (s.isHorizontal() ? -wrapperRotate : 0) + 'deg)');
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.cube.shadow && !s.isHorizontal()) {
                        s.container.find('.swiper-cube-shadow').transition(duration);
                    }
                }
            },
            coverflow: {
                setTranslate: function () {
                    var transform = s.translate;
                    var center = s.isHorizontal() ? -transform + s.width / 2 : -transform + s.height / 2;
                    var rotate = s.isHorizontal() ? s.params.coverflow.rotate: -s.params.coverflow.rotate;
                    var translate = s.params.coverflow.depth;
                    //Each slide offset from center
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideSize = s.slidesSizesGrid[i];
                        var slideOffset = slide[0].swiperSlideOffset;
                        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
        
                        var rotateY = s.isHorizontal() ? rotate * offsetMultiplier : 0;
                        var rotateX = s.isHorizontal() ? 0 : rotate * offsetMultiplier;
                        // var rotateZ = 0
                        var translateZ = -translate * Math.abs(offsetMultiplier);
        
                        var translateY = s.isHorizontal() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
                        var translateX = s.isHorizontal() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;
        
                        //Fix for ultra small values
                        if (Math.abs(translateX) < 0.001) translateX = 0;
                        if (Math.abs(translateY) < 0.001) translateY = 0;
                        if (Math.abs(translateZ) < 0.001) translateZ = 0;
                        if (Math.abs(rotateY) < 0.001) rotateY = 0;
                        if (Math.abs(rotateX) < 0.001) rotateX = 0;
        
                        var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
        
                        slide.transform(slideTransform);
                        slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                        if (s.params.coverflow.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                            if (shadowAfter.length) shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                        }
                    }
        
                    //Set correct perspective for IE10
                    if (s.browser.ie) {
                        var ws = s.wrapper[0].style;
                        ws.perspectiveOrigin = center + 'px 50%';
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                }
            }
        };
        

        /*=========================
          Images Lazy Loading
          ===========================*/
        s.lazy = {
            initialImageLoaded: false,
            loadImageInSlide: function (index, loadInDuplicate) {
                if (typeof index === 'undefined') return;
                if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
                if (s.slides.length === 0) return;
        
                var slide = s.slides.eq(index);
                var img = slide.find('.' + s.params.lazyLoadingClass + ':not(.' + s.params.lazyStatusLoadedClass + '):not(.' + s.params.lazyStatusLoadingClass + ')');
                if (slide.hasClass(s.params.lazyLoadingClass) && !slide.hasClass(s.params.lazyStatusLoadedClass) && !slide.hasClass(s.params.lazyStatusLoadingClass)) {
                    img = img.add(slide[0]);
                }
                if (img.length === 0) return;
        
                img.each(function () {
                    var _img = $(this);
                    _img.addClass(s.params.lazyStatusLoadingClass);
                    var background = _img.attr('data-background');
                    var src = _img.attr('data-src'),
                        srcset = _img.attr('data-srcset'),
                        sizes = _img.attr('data-sizes');
                    s.loadImage(_img[0], (src || background), srcset, sizes, false, function () {
                        if (typeof s === 'undefined' || s === null || !s) return;
                        if (background) {
                            _img.css('background-image', 'url("' + background + '")');
                            _img.removeAttr('data-background');
                        }
                        else {
                            if (srcset) {
                                _img.attr('srcset', srcset);
                                _img.removeAttr('data-srcset');
                            }
                            if (sizes) {
                                _img.attr('sizes', sizes);
                                _img.removeAttr('data-sizes');
                            }
                            if (src) {
                                _img.attr('src', src);
                                _img.removeAttr('data-src');
                            }
        
                        }
        
                        _img.addClass(s.params.lazyStatusLoadedClass).removeClass(s.params.lazyStatusLoadingClass);
                        slide.find('.' + s.params.lazyPreloaderClass + ', .' + s.params.preloaderClass).remove();
                        if (s.params.loop && loadInDuplicate) {
                            var slideOriginalIndex = slide.attr('data-swiper-slide-index');
                            if (slide.hasClass(s.params.slideDuplicateClass)) {
                                var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
                                s.lazy.loadImageInSlide(originalSlide.index(), false);
                            }
                            else {
                                var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                                s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
                            }
                        }
                        s.emit('onLazyImageReady', s, slide[0], _img[0]);
                    });
        
                    s.emit('onLazyImageLoad', s, slide[0], _img[0]);
                });
        
            },
            load: function () {
                var i;
                var slidesPerView = s.params.slidesPerView;
                if (slidesPerView === 'auto') {
                    slidesPerView = 0;
                }
                if (!s.lazy.initialImageLoaded) s.lazy.initialImageLoaded = true;
                if (s.params.watchSlidesVisibility) {
                    s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
                        s.lazy.loadImageInSlide($(this).index());
                    });
                }
                else {
                    if (slidesPerView > 1) {
                        for (i = s.activeIndex; i < s.activeIndex + slidesPerView ; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    }
                    else {
                        s.lazy.loadImageInSlide(s.activeIndex);
                    }
                }
                if (s.params.lazyLoadingInPrevNext) {
                    if (slidesPerView > 1 || (s.params.lazyLoadingInPrevNextAmount && s.params.lazyLoadingInPrevNextAmount > 1)) {
                        var amount = s.params.lazyLoadingInPrevNextAmount;
                        var spv = slidesPerView;
                        var maxIndex = Math.min(s.activeIndex + spv + Math.max(amount, spv), s.slides.length);
                        var minIndex = Math.max(s.activeIndex - Math.max(spv, amount), 0);
                        // Next Slides
                        for (i = s.activeIndex + slidesPerView; i < maxIndex; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                        // Prev Slides
                        for (i = minIndex; i < s.activeIndex ; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    }
                    else {
                        var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
                        if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());
        
                        var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
                        if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
                    }
                }
            },
            onTransitionStart: function () {
                if (s.params.lazyLoading) {
                    if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
                        s.lazy.load();
                    }
                }
            },
            onTransitionEnd: function () {
                if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
                    s.lazy.load();
                }
            }
        };
        

        /*=========================
          Scrollbar
          ===========================*/
        s.scrollbar = {
            isTouched: false,
            setDragPosition: function (e) {
                var sb = s.scrollbar;
                var x = 0, y = 0;
                var translate;
                var pointerPosition = s.isHorizontal() ?
                    ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX) :
                    ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY) ;
                var position = (pointerPosition) - sb.track.offset()[s.isHorizontal() ? 'left' : 'top'] - sb.dragSize / 2;
                var positionMin = -s.minTranslate() * sb.moveDivider;
                var positionMax = -s.maxTranslate() * sb.moveDivider;
                if (position < positionMin) {
                    position = positionMin;
                }
                else if (position > positionMax) {
                    position = positionMax;
                }
                position = -position / sb.moveDivider;
                s.updateProgress(position);
                s.setWrapperTranslate(position, true);
            },
            dragStart: function (e) {
                var sb = s.scrollbar;
                sb.isTouched = true;
                e.preventDefault();
                e.stopPropagation();
        
                sb.setDragPosition(e);
                clearTimeout(sb.dragTimeout);
        
                sb.track.transition(0);
                if (s.params.scrollbarHide) {
                    sb.track.css('opacity', 1);
                }
                s.wrapper.transition(100);
                sb.drag.transition(100);
                s.emit('onScrollbarDragStart', s);
            },
            dragMove: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
                sb.setDragPosition(e);
                s.wrapper.transition(0);
                sb.track.transition(0);
                sb.drag.transition(0);
                s.emit('onScrollbarDragMove', s);
            },
            dragEnd: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                sb.isTouched = false;
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.dragTimeout);
                    sb.dragTimeout = setTimeout(function () {
                        sb.track.css('opacity', 0);
                        sb.track.transition(400);
                    }, 1000);
        
                }
                s.emit('onScrollbarDragEnd', s);
                if (s.params.scrollbarSnapOnRelease) {
                    s.slideReset();
                }
            },
            draggableEvents: (function () {
                if ((s.params.simulateTouch === false && !s.support.touch)) return s.touchEventsDesktop;
                else return s.touchEvents;
            })(),
            enableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).on(sb.draggableEvents.start, sb.dragStart);
                $(target).on(sb.draggableEvents.move, sb.dragMove);
                $(target).on(sb.draggableEvents.end, sb.dragEnd);
            },
            disableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).off(sb.draggableEvents.start, sb.dragStart);
                $(target).off(sb.draggableEvents.move, sb.dragMove);
                $(target).off(sb.draggableEvents.end, sb.dragEnd);
            },
            set: function () {
                if (!s.params.scrollbar) return;
                var sb = s.scrollbar;
                sb.track = $(s.params.scrollbar);
                if (s.params.uniqueNavElements && typeof s.params.scrollbar === 'string' && sb.track.length > 1 && s.container.find(s.params.scrollbar).length === 1) {
                    sb.track = s.container.find(s.params.scrollbar);
                }
                sb.drag = sb.track.find('.swiper-scrollbar-drag');
                if (sb.drag.length === 0) {
                    sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
                    sb.track.append(sb.drag);
                }
                sb.drag[0].style.width = '';
                sb.drag[0].style.height = '';
                sb.trackSize = s.isHorizontal() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
        
                sb.divider = s.size / s.virtualSize;
                sb.moveDivider = sb.divider * (sb.trackSize / s.size);
                sb.dragSize = sb.trackSize * sb.divider;
        
                if (s.isHorizontal()) {
                    sb.drag[0].style.width = sb.dragSize + 'px';
                }
                else {
                    sb.drag[0].style.height = sb.dragSize + 'px';
                }
        
                if (sb.divider >= 1) {
                    sb.track[0].style.display = 'none';
                }
                else {
                    sb.track[0].style.display = '';
                }
                if (s.params.scrollbarHide) {
                    sb.track[0].style.opacity = 0;
                }
            },
            setTranslate: function () {
                if (!s.params.scrollbar) return;
                var diff;
                var sb = s.scrollbar;
                var translate = s.translate || 0;
                var newPos;
        
                var newSize = sb.dragSize;
                newPos = (sb.trackSize - sb.dragSize) * s.progress;
                if (s.rtl && s.isHorizontal()) {
                    newPos = -newPos;
                    if (newPos > 0) {
                        newSize = sb.dragSize - newPos;
                        newPos = 0;
                    }
                    else if (-newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize + newPos;
                    }
                }
                else {
                    if (newPos < 0) {
                        newSize = sb.dragSize + newPos;
                        newPos = 0;
                    }
                    else if (newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize - newPos;
                    }
                }
                if (s.isHorizontal()) {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
                    }
                    else {
                        sb.drag.transform('translateX(' + (newPos) + 'px)');
                    }
                    sb.drag[0].style.width = newSize + 'px';
                }
                else {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
                    }
                    else {
                        sb.drag.transform('translateY(' + (newPos) + 'px)');
                    }
                    sb.drag[0].style.height = newSize + 'px';
                }
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.timeout);
                    sb.track[0].style.opacity = 1;
                    sb.timeout = setTimeout(function () {
                        sb.track[0].style.opacity = 0;
                        sb.track.transition(400);
                    }, 1000);
                }
            },
            setTransition: function (duration) {
                if (!s.params.scrollbar) return;
                s.scrollbar.drag.transition(duration);
            }
        };
        

        /*=========================
          Controller
          ===========================*/
        s.controller = {
            LinearSpline: function (x, y) {
                var binarySearch = (function() {
                    var maxIndex, minIndex, guess;
                    return function(array, val) {
                        minIndex = -1;
                        maxIndex = array.length;
                        while (maxIndex - minIndex > 1)
                            if (array[guess = maxIndex + minIndex >> 1] <= val) {
                                minIndex = guess;
                            } else {
                                maxIndex = guess;
                            }
                        return maxIndex;
                    };
                })();
                this.x = x;
                this.y = y;
                this.lastIndex = x.length - 1;
                // Given an x value (x2), return the expected y2 value:
                // (x1,y1) is the known point before given value,
                // (x3,y3) is the known point after given value.
                var i1, i3;
                var l = this.x.length;
        
                this.interpolate = function (x2) {
                    if (!x2) return 0;
        
                    // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                    i3 = binarySearch(this.x, x2);
                    i1 = i3 - 1;
        
                    // We have our indexes i1 & i3, so we can calculate already:
                    // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
                    return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
                };
            },
            //xxx: for now i will just save one spline function to to
            getInterpolateFunction: function(c){
                if(!s.controller.spline) s.controller.spline = s.params.loop ?
                    new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) :
                    new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
            },
            setTranslate: function (translate, byController) {
               var controlled = s.params.control;
               var multiplier, controlledTranslate;
               function setControlledTranslate(c) {
                    // this will create an Interpolate function based on the snapGrids
                    // x is the Grid of the scrolled scroller and y will be the controlled scroller
                    // it makes sense to create this only once and recall it for the interpolation
                    // the function does a lot of value caching for performance
                    translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
                    if (s.params.controlBy === 'slide') {
                        s.controller.getInterpolateFunction(c);
                        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                        // but it did not work out
                        controlledTranslate = -s.controller.spline.interpolate(-translate);
                    }
        
                    if(!controlledTranslate || s.params.controlBy === 'container'){
                        multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
                        controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
                    }
        
                    if (s.params.controlInverse) {
                        controlledTranslate = c.maxTranslate() - controlledTranslate;
                    }
                    c.updateProgress(controlledTranslate);
                    c.setWrapperTranslate(controlledTranslate, false, s);
                    c.updateActiveIndex();
               }
               if (Array.isArray(controlled)) {
                   for (var i = 0; i < controlled.length; i++) {
                       if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                           setControlledTranslate(controlled[i]);
                       }
                   }
               }
               else if (controlled instanceof Swiper && byController !== controlled) {
        
                   setControlledTranslate(controlled);
               }
            },
            setTransition: function (duration, byController) {
                var controlled = s.params.control;
                var i;
                function setControlledTransition(c) {
                    c.setWrapperTransition(duration, s);
                    if (duration !== 0) {
                        c.onTransitionStart();
                        c.wrapper.transitionEnd(function(){
                            if (!controlled) return;
                            if (c.params.loop && s.params.controlBy === 'slide') {
                                c.fixLoop();
                            }
                            c.onTransitionEnd();
        
                        });
                    }
                }
                if (Array.isArray(controlled)) {
                    for (i = 0; i < controlled.length; i++) {
                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                            setControlledTransition(controlled[i]);
                        }
                    }
                }
                else if (controlled instanceof Swiper && byController !== controlled) {
                    setControlledTransition(controlled);
                }
            }
        };
        

        /*=========================
          Hash Navigation
          ===========================*/
        s.hashnav = {
            onHashCange: function (e, a) {
                var newHash = document.location.hash.replace('#', '');
                var activeSlideHash = s.slides.eq(s.activeIndex).attr('data-hash');
                if (newHash !== activeSlideHash) {
                    s.slideTo(s.wrapper.children('.' + s.params.slideClass + '[data-hash="' + (newHash) + '"]').index());
                }
            },
            attachEvents: function (detach) {
                var action = detach ? 'off' : 'on';
                $(window)[action]('hashchange', s.hashnav.onHashCange);
            },
            setHash: function () {
                if (!s.hashnav.initialized || !s.params.hashnav) return;
                if (s.params.replaceState && window.history && window.history.replaceState) {
                    window.history.replaceState(null, null, ('#' + s.slides.eq(s.activeIndex).attr('data-hash') || ''));
                } else {
                    var slide = s.slides.eq(s.activeIndex);
                    var hash = slide.attr('data-hash') || slide.attr('data-history');
                    document.location.hash = hash || '';
                }
            },
            init: function () {
                if (!s.params.hashnav || s.params.history) return;
                s.hashnav.initialized = true;
                var hash = document.location.hash.replace('#', '');
                if (hash) {
                    var speed = 0;
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideHash = slide.attr('data-hash') || slide.attr('data-history');
                        if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                            var index = slide.index();
                            s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
                        }
                    }
                }
                if (s.params.hashnavWatchState) s.hashnav.attachEvents();
            },
            destroy: function () {
                if (s.params.hashnavWatchState) s.hashnav.attachEvents(true);
            }
        };
        

        /*=========================
          History Api with fallback to Hashnav
          ===========================*/
        s.history = {
            init: function () {
                if (!s.params.history) return;
                if (!window.history || !window.history.pushState) {
                    s.params.history = false;
                    s.params.hashnav = true;
                    return;
                }
                s.history.initialized = true;
                this.paths = this.getPathValues();
                if (!this.paths.key && !this.paths.value) return;
                this.scrollToSlide(0, this.paths.value, s.params.runCallbacksOnInit);
                if (!s.params.replaceState) {
                    window.addEventListener('popstate', this.setHistoryPopState);
                }
            },
            setHistoryPopState: function() {
                s.history.paths = s.history.getPathValues();
                s.history.scrollToSlide(s.params.speed, s.history.paths.value, false);
            },
            getPathValues: function() {
                var pathArray = window.location.pathname.slice(1).split('/');
                var total = pathArray.length;
                var key = pathArray[total - 2];
                var value = pathArray[total - 1];
                return { key: key, value: value };
            },
            setHistory: function (key, index) {
                if (!s.history.initialized || !s.params.history) return;
                var slide = s.slides.eq(index);
                var value = this.slugify(slide.attr('data-history'));
                if (!window.location.pathname.includes(key)) {
                    value = key + '/' + value;
                }
                if (s.params.replaceState) {
                    window.history.replaceState(null, null, value);
                } else {
                    window.history.pushState(null, null, value);
                }
            },
            slugify: function(text) {
                return text.toString().toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-')
                    .replace(/^-+/, '')
                    .replace(/-+$/, '');
            },
            scrollToSlide: function(speed, value, runCallbacks) {
                if (value) {
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideHistory = this.slugify(slide.attr('data-history'));
                        if (slideHistory === value && !slide.hasClass(s.params.slideDuplicateClass)) {
                            var index = slide.index();
                            s.slideTo(index, speed, runCallbacks);
                        }
                    }
                } else {
                    s.slideTo(0, speed, runCallbacks);
                }
            }
        };
        

        /*=========================
          Keyboard Control
          ===========================*/
        function handleKeyboard(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var kc = e.keyCode || e.charCode;
            // Directions locks
            if (!s.params.allowSwipeToNext && (s.isHorizontal() && kc === 39 || !s.isHorizontal() && kc === 40)) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && (s.isHorizontal() && kc === 37 || !s.isHorizontal() && kc === 38)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return;
            }
            if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
                var inView = false;
                //Check that swiper should be inside of visible area of window
                if (s.container.parents('.' + s.params.slideClass).length > 0 && s.container.parents('.' + s.params.slideActiveClass).length === 0) {
                    return;
                }
                var windowScroll = {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                };
                var windowWidth = window.innerWidth;
                var windowHeight = window.innerHeight;
                var swiperOffset = s.container.offset();
                if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
                var swiperCoord = [
                    [swiperOffset.left, swiperOffset.top],
                    [swiperOffset.left + s.width, swiperOffset.top],
                    [swiperOffset.left, swiperOffset.top + s.height],
                    [swiperOffset.left + s.width, swiperOffset.top + s.height]
                ];
                for (var i = 0; i < swiperCoord.length; i++) {
                    var point = swiperCoord[i];
                    if (
                        point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
                        point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight
                    ) {
                        inView = true;
                    }
        
                }
                if (!inView) return;
            }
            if (s.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl)) s.slideNext();
                if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl)) s.slidePrev();
            }
            else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if (kc === 40) s.slideNext();
                if (kc === 38) s.slidePrev();
            }
            s.emit('onKeyPress', s, kc);
        }
        s.disableKeyboardControl = function () {
            s.params.keyboardControl = false;
            $(document).off('keydown', handleKeyboard);
        };
        s.enableKeyboardControl = function () {
            s.params.keyboardControl = true;
            $(document).on('keydown', handleKeyboard);
        };
        

        /*=========================
          Mousewheel Control
          ===========================*/
        s.mousewheel = {
            event: false,
            lastScrollTime: (new window.Date()).getTime()
        };
        function isEventSupported() {
            var eventName = 'onwheel';
            var isSupported = eventName in document;
        
            if (!isSupported) {
                var element = document.createElement('div');
                element.setAttribute(eventName, 'return;');
                isSupported = typeof element[eventName] === 'function';
            }
        
            if (!isSupported &&
                document.implementation &&
                document.implementation.hasFeature &&
                    // always returns true in newer browsers as per the standard.
                    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
                document.implementation.hasFeature('', '') !== true ) {
                // This is the only way to test support for the `wheel` event in IE9+.
                isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
            }
        
            return isSupported;
        }
        /**
         * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
         * complicated, thus this doc is long and (hopefully) detailed enough to answer
         * your questions.
         *
         * If you need to react to the mouse wheel in a predictable way, this code is
         * like your bestest friend. * hugs *
         *
         * As of today, there are 4 DOM event types you can listen to:
         *
         *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
         *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
         *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
         *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
         *
         * So what to do?  The is the best:
         *
         *   normalizeWheel.getEventType();
         *
         * In your event callback, use this code to get sane interpretation of the
         * deltas.  This code will return an object with properties:
         *
         *   spinX   -- normalized spin speed (use for zoom) - x plane
         *   spinY   -- " - y plane
         *   pixelX  -- normalized distance (to pixels) - x plane
         *   pixelY  -- " - y plane
         *
         * Wheel values are provided by the browser assuming you are using the wheel to
         * scroll a web page by a number of lines or pixels (or pages).  Values can vary
         * significantly on different platforms and browsers, forgetting that you can
         * scroll at different speeds.  Some devices (like trackpads) emit more events
         * at smaller increments with fine granularity, and some emit massive jumps with
         * linear speed or acceleration.
         *
         * This code does its best to normalize the deltas for you:
         *
         *   - spin is trying to normalize how far the wheel was spun (or trackpad
         *     dragged).  This is super useful for zoom support where you want to
         *     throw away the chunky scroll steps on the PC and make those equal to
         *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
         *     resolve a single slow step on a wheel to 1.
         *
         *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
         *     get the crazy differences between browsers, but at least it'll be in
         *     pixels!
         *
         *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
         *     should translate to positive value zooming IN, negative zooming OUT.
         *     This matches the newer 'wheel' event.
         *
         * Why are there spinX, spinY (or pixels)?
         *
         *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
         *     with a mouse.  It results in side-scrolling in the browser by default.
         *
         *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
         *
         *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
         *     probably is by browsers in conjunction with fancy 3D controllers .. but
         *     you know.
         *
         * Implementation info:
         *
         * Examples of 'wheel' event if you scroll slowly (down) by one step with an
         * average mouse:
         *
         *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
         *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
         *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
         *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
         *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
         *
         * On the trackpad:
         *
         *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
         *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
         *
         * On other/older browsers.. it's more complicated as there can be multiple and
         * also missing delta values.
         *
         * The 'wheel' event is more standard:
         *
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
         *
         * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
         * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
         * backward compatibility with older events.  Those other values help us
         * better normalize spin speed.  Example of what the browsers provide:
         *
         *                          | event.wheelDelta | event.detail
         *        ------------------+------------------+--------------
         *          Safari v5/OS X  |       -120       |       0
         *          Safari v5/Win7  |       -120       |       0
         *         Chrome v17/OS X  |       -120       |       0
         *         Chrome v17/Win7  |       -120       |       0
         *                IE9/Win7  |       -120       |   undefined
         *         Firefox v4/OS X  |     undefined    |       1
         *         Firefox v4/Win7  |     undefined    |       3
         *
         */
        function normalizeWheel( /*object*/ event ) /*object*/ {
            // Reasonable defaults
            var PIXEL_STEP = 10;
            var LINE_HEIGHT = 40;
            var PAGE_HEIGHT = 800;
        
            var sX = 0, sY = 0,       // spinX, spinY
                pX = 0, pY = 0;       // pixelX, pixelY
        
            // Legacy
            if( 'detail' in event ) {
                sY = event.detail;
            }
            if( 'wheelDelta' in event ) {
                sY = -event.wheelDelta / 120;
            }
            if( 'wheelDeltaY' in event ) {
                sY = -event.wheelDeltaY / 120;
            }
            if( 'wheelDeltaX' in event ) {
                sX = -event.wheelDeltaX / 120;
            }
        
            // side scrolling on FF with DOMMouseScroll
            if( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
                sX = sY;
                sY = 0;
            }
        
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
        
            if( 'deltaY' in event ) {
                pY = event.deltaY;
            }
            if( 'deltaX' in event ) {
                pX = event.deltaX;
            }
        
            if( (pX || pY) && event.deltaMode ) {
                if( event.deltaMode === 1 ) {          // delta in LINE units
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {                             // delta in PAGE units
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }
        
            // Fall-back if spin cannot be determined
            if( pX && !sX ) {
                sX = (pX < 1) ? -1 : 1;
            }
            if( pY && !sY ) {
                sY = (pY < 1) ? -1 : 1;
            }
        
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }
        if (s.params.mousewheelControl) {
            /**
             * The best combination if you prefer spinX + spinY normalization.  It favors
             * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
             * 'wheel' event, making spin speed determination impossible.
             */
            s.mousewheel.event = (navigator.userAgent.indexOf('firefox') > -1) ?
                'DOMMouseScroll' :
                isEventSupported() ?
                    'wheel' : 'mousewheel';
        }
        function handleMousewheel(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var delta = 0;
            var rtlFactor = s.rtl ? -1 : 1;
        
            var data = normalizeWheel( e );
        
            if (s.params.mousewheelForceToAxis) {
                if (s.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
                    else return;
                }
                else {
                    if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
                    else return;
                }
            }
            else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? - data.pixelX * rtlFactor : - data.pixelY;
            }
        
            if (delta === 0) return;
        
            if (s.params.mousewheelInvert) delta = -delta;
        
            if (!s.params.freeMode) {
                if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!s.isEnd || s.params.loop) && !s.animating) {
                            s.slideNext();
                            s.emit('onScroll', s, e);
                        }
                        else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                    else {
                        if ((!s.isBeginning || s.params.loop) && !s.animating) {
                            s.slidePrev();
                            s.emit('onScroll', s, e);
                        }
                        else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                }
                s.mousewheel.lastScrollTime = (new window.Date()).getTime();
        
            }
            else {
                //Freemode or scrollContainer:
                var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
                var wasBeginning = s.isBeginning,
                    wasEnd = s.isEnd;
        
                if (position >= s.minTranslate()) position = s.minTranslate();
                if (position <= s.maxTranslate()) position = s.maxTranslate();
        
                s.setWrapperTransition(0);
                s.setWrapperTranslate(position);
                s.updateProgress();
                s.updateActiveIndex();
        
                if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
                    s.updateClasses();
                }
        
                if (s.params.freeModeSticky) {
                    clearTimeout(s.mousewheel.timeout);
                    s.mousewheel.timeout = setTimeout(function () {
                        s.slideReset();
                    }, 300);
                }
                else {
                    if (s.params.lazyLoading && s.lazy) {
                        s.lazy.load();
                    }
                }
                // Emit event
                s.emit('onScroll', s, e);
        
                // Stop autoplay
                if (s.params.autoplay && s.params.autoplayDisableOnInteraction) s.stopAutoplay();
        
                // Return page scroll on edge positions
                if (position === 0 || position === s.maxTranslate()) return;
            }
        
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            return false;
        }
        s.disableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            var target = s.container;
            if (s.params.mousewheelEventsTarged !== 'container') {
                target = $(s.params.mousewheelEventsTarged);
            }
            target.off(s.mousewheel.event, handleMousewheel);
            s.params.mousewheelControl = false;
            return true;
        };
        
        s.enableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            var target = s.container;
            if (s.params.mousewheelEventsTarged !== 'container') {
                target = $(s.params.mousewheelEventsTarged);
            }
            target.on(s.mousewheel.event, handleMousewheel);
            s.params.mousewheelControl = true;
            return true;
        };
        

        /*=========================
          Parallax
          ===========================*/
        function setParallaxTransform(el, progress) {
            el = $(el);
            var p, pX, pY;
            var rtlFactor = s.rtl ? -1 : 1;
        
            p = el.attr('data-swiper-parallax') || '0';
            pX = el.attr('data-swiper-parallax-x');
            pY = el.attr('data-swiper-parallax-y');
            if (pX || pY) {
                pX = pX || '0';
                pY = pY || '0';
            }
            else {
                if (s.isHorizontal()) {
                    pX = p;
                    pY = '0';
                }
                else {
                    pY = p;
                    pX = '0';
                }
            }
        
            if ((pX).indexOf('%') >= 0) {
                pX = parseInt(pX, 10) * progress * rtlFactor + '%';
            }
            else {
                pX = pX * progress * rtlFactor + 'px' ;
            }
            if ((pY).indexOf('%') >= 0) {
                pY = parseInt(pY, 10) * progress + '%';
            }
            else {
                pY = pY * progress + 'px' ;
            }
        
            el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
        }
        s.parallax = {
            setTranslate: function () {
                s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
                    setParallaxTransform(this, s.progress);
        
                });
                s.slides.each(function () {
                    var slide = $(this);
                    slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
                        var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                        setParallaxTransform(this, progress);
                    });
                });
            },
            setTransition: function (duration) {
                if (typeof duration === 'undefined') duration = s.params.speed;
                s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
                    var el = $(this);
                    var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
                    if (duration === 0) parallaxDuration = 0;
                    el.transition(parallaxDuration);
                });
            }
        };
        

        /*=========================
          Zoom
          ===========================*/
        s.zoom = {
            // "Global" Props
            scale: 1,
            currentScale: 1,
            isScaling: false,
            gesture: {
                slide: undefined,
                slideWidth: undefined,
                slideHeight: undefined,
                image: undefined,
                imageWrap: undefined,
                zoomMax: s.params.zoomMax
            },
            image: {
                isTouched: undefined,
                isMoved: undefined,
                currentX: undefined,
                currentY: undefined,
                minX: undefined,
                minY: undefined,
                maxX: undefined,
                maxY: undefined,
                width: undefined,
                height: undefined,
                startX: undefined,
                startY: undefined,
                touchesStart: {},
                touchesCurrent: {}
            },
            velocity: {
                x: undefined,
                y: undefined,
                prevPositionX: undefined,
                prevPositionY: undefined,
                prevTime: undefined
            },
            // Calc Scale From Multi-touches
            getDistanceBetweenTouches: function (e) {
                if (e.targetTouches.length < 2) return 1;
                var x1 = e.targetTouches[0].pageX,
                    y1 = e.targetTouches[0].pageY,
                    x2 = e.targetTouches[1].pageX,
                    y2 = e.targetTouches[1].pageY;
                var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                return distance;
            },
            // Events
            onGestureStart: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
                        return;
                    }
                    z.gesture.scaleStart = z.getDistanceBetweenTouches(e);
                }
                if (!z.gesture.slide || !z.gesture.slide.length) {
                    z.gesture.slide = $(this);
                    if (z.gesture.slide.length === 0) z.gesture.slide = s.slides.eq(s.activeIndex);
                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
                    z.gesture.zoomMax = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax ;
                    if (z.gesture.imageWrap.length === 0) {
                        z.gesture.image = undefined;
                        return;
                    }
                }
                z.gesture.image.transition(0);
                z.isScaling = true;
            },
            onGestureChange: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
                        return;
                    }
                    z.gesture.scaleMove = z.getDistanceBetweenTouches(e);
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (s.support.gestures) {
                    z.scale = e.scale * z.currentScale;
                }
                else {
                    z.scale = (z.gesture.scaleMove / z.gesture.scaleStart) * z.currentScale;
                }
                if (z.scale > z.gesture.zoomMax) {
                    z.scale = z.gesture.zoomMax - 1 + Math.pow((z.scale - z.gesture.zoomMax + 1), 0.5);
                }
                if (z.scale < s.params.zoomMin) {
                    z.scale =  s.params.zoomMin + 1 - Math.pow((s.params.zoomMin - z.scale + 1), 0.5);
                }
                z.gesture.image.transform('translate3d(0,0,0) scale(' + z.scale + ')');
            },
            onGestureEnd: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2) {
                        return;
                    }
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                z.scale = Math.max(Math.min(z.scale, z.gesture.zoomMax), s.params.zoomMin);
                z.gesture.image.transition(s.params.speed).transform('translate3d(0,0,0) scale(' + z.scale + ')');
                z.currentScale = z.scale;
                z.isScaling = false;
                if (z.scale === 1) z.gesture.slide = undefined;
            },
            onTouchStart: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (z.image.isTouched) return;
                if (s.device.os === 'android') e.preventDefault();
                z.image.isTouched = true;
                z.image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
                z.image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
            },
            onTouchMove: function (e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                s.allowClick = false;
                if (!z.image.isTouched || !z.gesture.slide) return;
        
                if (!z.image.isMoved) {
                    z.image.width = z.gesture.image[0].offsetWidth;
                    z.image.height = z.gesture.image[0].offsetHeight;
                    z.image.startX = s.getTranslate(z.gesture.imageWrap[0], 'x') || 0;
                    z.image.startY = s.getTranslate(z.gesture.imageWrap[0], 'y') || 0;
                    z.gesture.slideWidth = z.gesture.slide[0].offsetWidth;
                    z.gesture.slideHeight = z.gesture.slide[0].offsetHeight;
                    z.gesture.imageWrap.transition(0);
                    if (s.rtl) z.image.startX = -z.image.startX;
                    if (s.rtl) z.image.startY = -z.image.startY;
                }
                // Define if we need image drag
                var scaledWidth = z.image.width * z.scale;
                var scaledHeight = z.image.height * z.scale;
        
                if (scaledWidth < z.gesture.slideWidth && scaledHeight < z.gesture.slideHeight) return;
        
                z.image.minX = Math.min((z.gesture.slideWidth / 2 - scaledWidth / 2), 0);
                z.image.maxX = -z.image.minX;
                z.image.minY = Math.min((z.gesture.slideHeight / 2 - scaledHeight / 2), 0);
                z.image.maxY = -z.image.minY;
        
                z.image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                z.image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        
                if (!z.image.isMoved && !z.isScaling) {
                    if (s.isHorizontal() &&
                        (Math.floor(z.image.minX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x < z.image.touchesStart.x) ||
                        (Math.floor(z.image.maxX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x > z.image.touchesStart.x)
                        ) {
                        z.image.isTouched = false;
                        return;
                    }
                    else if (!s.isHorizontal() &&
                        (Math.floor(z.image.minY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y < z.image.touchesStart.y) ||
                        (Math.floor(z.image.maxY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y > z.image.touchesStart.y)
                        ) {
                        z.image.isTouched = false;
                        return;
                    }
                }
                e.preventDefault();
                e.stopPropagation();
        
                z.image.isMoved = true;
                z.image.currentX = z.image.touchesCurrent.x - z.image.touchesStart.x + z.image.startX;
                z.image.currentY = z.image.touchesCurrent.y - z.image.touchesStart.y + z.image.startY;
        
                if (z.image.currentX < z.image.minX) {
                    z.image.currentX =  z.image.minX + 1 - Math.pow((z.image.minX - z.image.currentX + 1), 0.8);
                }
                if (z.image.currentX > z.image.maxX) {
                    z.image.currentX = z.image.maxX - 1 + Math.pow((z.image.currentX - z.image.maxX + 1), 0.8);
                }
        
                if (z.image.currentY < z.image.minY) {
                    z.image.currentY =  z.image.minY + 1 - Math.pow((z.image.minY - z.image.currentY + 1), 0.8);
                }
                if (z.image.currentY > z.image.maxY) {
                    z.image.currentY = z.image.maxY - 1 + Math.pow((z.image.currentY - z.image.maxY + 1), 0.8);
                }
        
                //Velocity
                if (!z.velocity.prevPositionX) z.velocity.prevPositionX = z.image.touchesCurrent.x;
                if (!z.velocity.prevPositionY) z.velocity.prevPositionY = z.image.touchesCurrent.y;
                if (!z.velocity.prevTime) z.velocity.prevTime = Date.now();
                z.velocity.x = (z.image.touchesCurrent.x - z.velocity.prevPositionX) / (Date.now() - z.velocity.prevTime) / 2;
                z.velocity.y = (z.image.touchesCurrent.y - z.velocity.prevPositionY) / (Date.now() - z.velocity.prevTime) / 2;
                if (Math.abs(z.image.touchesCurrent.x - z.velocity.prevPositionX) < 2) z.velocity.x = 0;
                if (Math.abs(z.image.touchesCurrent.y - z.velocity.prevPositionY) < 2) z.velocity.y = 0;
                z.velocity.prevPositionX = z.image.touchesCurrent.x;
                z.velocity.prevPositionY = z.image.touchesCurrent.y;
                z.velocity.prevTime = Date.now();
        
                z.gesture.imageWrap.transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
            },
            onTouchEnd: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (!z.image.isTouched || !z.image.isMoved) {
                    z.image.isTouched = false;
                    z.image.isMoved = false;
                    return;
                }
                z.image.isTouched = false;
                z.image.isMoved = false;
                var momentumDurationX = 300;
                var momentumDurationY = 300;
                var momentumDistanceX = z.velocity.x * momentumDurationX;
                var newPositionX = z.image.currentX + momentumDistanceX;
                var momentumDistanceY = z.velocity.y * momentumDurationY;
                var newPositionY = z.image.currentY + momentumDistanceY;
        
                //Fix duration
                if (z.velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - z.image.currentX) / z.velocity.x);
                if (z.velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - z.image.currentY) / z.velocity.y);
                var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        
                z.image.currentX = newPositionX;
                z.image.currentY = newPositionY;
        
                // Define if we need image drag
                var scaledWidth = z.image.width * z.scale;
                var scaledHeight = z.image.height * z.scale;
                z.image.minX = Math.min((z.gesture.slideWidth / 2 - scaledWidth / 2), 0);
                z.image.maxX = -z.image.minX;
                z.image.minY = Math.min((z.gesture.slideHeight / 2 - scaledHeight / 2), 0);
                z.image.maxY = -z.image.minY;
                z.image.currentX = Math.max(Math.min(z.image.currentX, z.image.maxX), z.image.minX);
                z.image.currentY = Math.max(Math.min(z.image.currentY, z.image.maxY), z.image.minY);
        
                z.gesture.imageWrap.transition(momentumDuration).transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
            },
            onTransitionEnd: function (s) {
                var z = s.zoom;
                if (z.gesture.slide && s.previousIndex !== s.activeIndex) {
                    z.gesture.image.transform('translate3d(0,0,0) scale(1)');
                    z.gesture.imageWrap.transform('translate3d(0,0,0)');
                    z.gesture.slide = z.gesture.image = z.gesture.imageWrap = undefined;
                    z.scale = z.currentScale = 1;
                }
            },
            // Toggle Zoom
            toggleZoom: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.slide) {
                    z.gesture.slide = s.clickedSlide ? $(s.clickedSlide) : s.slides.eq(s.activeIndex);
                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
        
                var touchX, touchY, offsetX, offsetY, diffX, diffY, translateX, translateY, imageWidth, imageHeight, scaledWidth, scaledHeight, translateMinX, translateMinY, translateMaxX, translateMaxY, slideWidth, slideHeight;
        
                if (typeof z.image.touchesStart.x === 'undefined' && e) {
                    touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                    touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
                }
                else {
                    touchX = z.image.touchesStart.x;
                    touchY = z.image.touchesStart.y;
                }
        
                if (z.scale && z.scale !== 1) {
                    // Zoom Out
                    z.scale = z.currentScale = 1;
                    z.gesture.imageWrap.transition(300).transform('translate3d(0,0,0)');
                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(1)');
                    z.gesture.slide = undefined;
                }
                else {
                    // Zoom In
                    z.scale = z.currentScale = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax;
                    if (e) {
                        slideWidth = z.gesture.slide[0].offsetWidth;
                        slideHeight = z.gesture.slide[0].offsetHeight;
                        offsetX = z.gesture.slide.offset().left;
                        offsetY = z.gesture.slide.offset().top;
                        diffX = offsetX + slideWidth/2 - touchX;
                        diffY = offsetY + slideHeight/2 - touchY;
        
                        imageWidth = z.gesture.image[0].offsetWidth;
                        imageHeight = z.gesture.image[0].offsetHeight;
                        scaledWidth = imageWidth * z.scale;
                        scaledHeight = imageHeight * z.scale;
        
                        translateMinX = Math.min((slideWidth / 2 - scaledWidth / 2), 0);
                        translateMinY = Math.min((slideHeight / 2 - scaledHeight / 2), 0);
                        translateMaxX = -translateMinX;
                        translateMaxY = -translateMinY;
        
                        translateX = diffX * z.scale;
                        translateY = diffY * z.scale;
        
                        if (translateX < translateMinX) {
                            translateX =  translateMinX;
                        }
                        if (translateX > translateMaxX) {
                            translateX = translateMaxX;
                        }
        
                        if (translateY < translateMinY) {
                            translateY =  translateMinY;
                        }
                        if (translateY > translateMaxY) {
                            translateY = translateMaxY;
                        }
                    }
                    else {
                        translateX = 0;
                        translateY = 0;
                    }
                    z.gesture.imageWrap.transition(300).transform('translate3d(' + translateX + 'px, ' + translateY + 'px,0)');
                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(' + z.scale + ')');
                }
            },
            // Attach/Detach Events
            attachEvents: function (detach) {
                var action = detach ? 'off' : 'on';
        
                if (s.params.zoom) {
                    var target = s.slides;
                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? {passive: true, capture: false} : false;
                    // Scale image
                    if (s.support.gestures) {
                        s.slides[action]('gesturestart', s.zoom.onGestureStart, passiveListener);
                        s.slides[action]('gesturechange', s.zoom.onGestureChange, passiveListener);
                        s.slides[action]('gestureend', s.zoom.onGestureEnd, passiveListener);
                    }
                    else if (s.touchEvents.start === 'touchstart') {
                        s.slides[action](s.touchEvents.start, s.zoom.onGestureStart, passiveListener);
                        s.slides[action](s.touchEvents.move, s.zoom.onGestureChange, passiveListener);
                        s.slides[action](s.touchEvents.end, s.zoom.onGestureEnd, passiveListener);
                    }
        
                    // Move image
                    s[action]('touchStart', s.zoom.onTouchStart);
                    s.slides.each(function (index, slide){
                        if ($(slide).find('.' + s.params.zoomContainerClass).length > 0) {
                            $(slide)[action](s.touchEvents.move, s.zoom.onTouchMove);
                        }
                    });
                    s[action]('touchEnd', s.zoom.onTouchEnd);
        
                    // Scale Out
                    s[action]('transitionEnd', s.zoom.onTransitionEnd);
                    if (s.params.zoomToggle) {
                        s.on('doubleTap', s.zoom.toggleZoom);
                    }
                }
            },
            init: function () {
                s.zoom.attachEvents();
            },
            destroy: function () {
                s.zoom.attachEvents(true);
            }
        };
        

        /*=========================
          Plugins API. Collect all and init all plugins
          ===========================*/
        s._plugins = [];
        for (var plugin in s.plugins) {
            var p = s.plugins[plugin](s, s.params[plugin]);
            if (p) s._plugins.push(p);
        }
        // Method to call all plugins event/method
        s.callPlugins = function (eventName) {
            for (var i = 0; i < s._plugins.length; i++) {
                if (eventName in s._plugins[i]) {
                    s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
        };
        

        /*=========================
          Events/Callbacks/Plugins Emitter
          ===========================*/
        function normalizeEventName (eventName) {
            if (eventName.indexOf('on') !== 0) {
                if (eventName[0] !== eventName[0].toUpperCase()) {
                    eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
                }
                else {
                    eventName = 'on' + eventName;
                }
            }
            return eventName;
        }
        s.emitterEventListeners = {
        
        };
        s.emit = function (eventName) {
            // Trigger callbacks
            if (s.params[eventName]) {
                s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
            var i;
            // Trigger events
            if (s.emitterEventListeners[eventName]) {
                for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                    s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
            // Trigger plugins
            if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        };
        s.on = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
            s.emitterEventListeners[eventName].push(handler);
            return s;
        };
        s.off = function (eventName, handler) {
            var i;
            eventName = normalizeEventName(eventName);
            if (typeof handler === 'undefined') {
                // Remove all handlers for such event
                s.emitterEventListeners[eventName] = [];
                return s;
            }
            if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                if(s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
            }
            return s;
        };
        s.once = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            var _handler = function () {
                handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                s.off(eventName, _handler);
            };
            s.on(eventName, _handler);
            return s;
        };
        

        // Accessibility tools
        s.a11y = {
            makeFocusable: function ($el) {
                $el.attr('tabIndex', '0');
                return $el;
            },
            addRole: function ($el, role) {
                $el.attr('role', role);
                return $el;
            },
        
            addLabel: function ($el, label) {
                $el.attr('aria-label', label);
                return $el;
            },
        
            disable: function ($el) {
                $el.attr('aria-disabled', true);
                return $el;
            },
        
            enable: function ($el) {
                $el.attr('aria-disabled', false);
                return $el;
            },
        
            onEnterKey: function (event) {
                if (event.keyCode !== 13) return;
                if ($(event.target).is(s.params.nextButton)) {
                    s.onClickNext(event);
                    if (s.isEnd) {
                        s.a11y.notify(s.params.lastSlideMessage);
                    }
                    else {
                        s.a11y.notify(s.params.nextSlideMessage);
                    }
                }
                else if ($(event.target).is(s.params.prevButton)) {
                    s.onClickPrev(event);
                    if (s.isBeginning) {
                        s.a11y.notify(s.params.firstSlideMessage);
                    }
                    else {
                        s.a11y.notify(s.params.prevSlideMessage);
                    }
                }
                if ($(event.target).is('.' + s.params.bulletClass)) {
                    $(event.target)[0].click();
                }
            },
        
            liveRegion: $('<span class="' + s.params.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>'),
        
            notify: function (message) {
                var notification = s.a11y.liveRegion;
                if (notification.length === 0) return;
                notification.html('');
                notification.html(message);
            },
            init: function () {
                // Setup accessibility
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    s.a11y.makeFocusable(s.nextButton);
                    s.a11y.addRole(s.nextButton, 'button');
                    s.a11y.addLabel(s.nextButton, s.params.nextSlideMessage);
                }
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    s.a11y.makeFocusable(s.prevButton);
                    s.a11y.addRole(s.prevButton, 'button');
                    s.a11y.addLabel(s.prevButton, s.params.prevSlideMessage);
                }
        
                $(s.container).append(s.a11y.liveRegion);
            },
            initPagination: function () {
                if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
                    s.bullets.each(function () {
                        var bullet = $(this);
                        s.a11y.makeFocusable(bullet);
                        s.a11y.addRole(bullet, 'button');
                        s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
                    });
                }
            },
            destroy: function () {
                if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
            }
        };
        

        /*=========================
          Init/Destroy
          ===========================*/
        s.init = function () {
            if (s.params.loop) s.createLoop();
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.enableDraggable();
                }
            }
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                if (!s.params.loop) s.updateProgress();
                s.effects[s.params.effect].setTranslate();
            }
            if (s.params.loop) {
                s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
            }
            else {
                s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
                if (s.params.initialSlide === 0) {
                    if (s.parallax && s.params.parallax) s.parallax.setTranslate();
                    if (s.lazy && s.params.lazyLoading) {
                        s.lazy.load();
                        s.lazy.initialImageLoaded = true;
                    }
                }
            }
            s.attachEvents();
            if (s.params.observer && s.support.observer) {
                s.initObservers();
            }
            if (s.params.preloadImages && !s.params.lazyLoading) {
                s.preloadImages();
            }
            if (s.params.zoom && s.zoom) {
                s.zoom.init();
            }
            if (s.params.autoplay) {
                s.startAutoplay();
            }
            if (s.params.keyboardControl) {
                if (s.enableKeyboardControl) s.enableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.enableMousewheelControl) s.enableMousewheelControl();
            }
            // Deprecated hashnavReplaceState changed to replaceState for use in hashnav and history
            if (s.params.hashnavReplaceState) {
                s.params.replaceState = s.params.hashnavReplaceState;
            }
            if (s.params.history) {
                if (s.history) s.history.init();
            }
            if (s.params.hashnav) {
                if (s.hashnav) s.hashnav.init();
            }
            if (s.params.a11y && s.a11y) s.a11y.init();
            s.emit('onInit', s);
        };
        
        // Cleanup dynamic styles
        s.cleanupStyles = function () {
            // Container
            s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
        
            // Wrapper
            s.wrapper.removeAttr('style');
        
            // Slides
            if (s.slides && s.slides.length) {
                s.slides
                    .removeClass([
                      s.params.slideVisibleClass,
                      s.params.slideActiveClass,
                      s.params.slideNextClass,
                      s.params.slidePrevClass
                    ].join(' '))
                    .removeAttr('style')
                    .removeAttr('data-swiper-column')
                    .removeAttr('data-swiper-row');
            }
        
            // Pagination/Bullets
            if (s.paginationContainer && s.paginationContainer.length) {
                s.paginationContainer.removeClass(s.params.paginationHiddenClass);
            }
            if (s.bullets && s.bullets.length) {
                s.bullets.removeClass(s.params.bulletActiveClass);
            }
        
            // Buttons
            if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
            if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
        
            // Scrollbar
            if (s.params.scrollbar && s.scrollbar) {
                if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
                if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
            }
        };
        
        // Destroy
        s.destroy = function (deleteInstance, cleanupStyles) {
            // Detach evebts
            s.detachEvents();
            // Stop autoplay
            s.stopAutoplay();
            // Disable draggable
            if (s.params.scrollbar && s.scrollbar) {
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.disableDraggable();
                }
            }
            // Destroy loop
            if (s.params.loop) {
                s.destroyLoop();
            }
            // Cleanup styles
            if (cleanupStyles) {
                s.cleanupStyles();
            }
            // Disconnect observer
            s.disconnectObservers();
        
            // Destroy zoom
            if (s.params.zoom && s.zoom) {
                s.zoom.destroy();
            }
            // Disable keyboard/mousewheel
            if (s.params.keyboardControl) {
                if (s.disableKeyboardControl) s.disableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.disableMousewheelControl) s.disableMousewheelControl();
            }
            // Disable a11y
            if (s.params.a11y && s.a11y) s.a11y.destroy();
            // Delete history popstate
            if (s.params.history && !s.params.replaceState) {
                window.removeEventListener('popstate', s.history.setHistoryPopState);
            }
            if (s.params.hashnav && s.hashnav)  {
                s.hashnav.destroy();
            }
            // Destroy callback
            s.emit('onDestroy');
            // Delete instance
            if (deleteInstance !== false) s = null;
        };
        
        s.init();
        

    
        // Return swiper instance
        return s;
    };
    

    /*==================================================
        Prototype
    ====================================================*/
    Swiper.prototype = {
        isSafari: (function () {
            var ua = window.navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
        })(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
        isArray: function (arr) {
            return Object.prototype.toString.apply(arr) === '[object Array]';
        },
        /*==================================================
        Browser
        ====================================================*/
        browser: {
            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1),
            lteIE9: (function() {
                // create temporary DIV
                var div = document.createElement('div');
                // add content to tmp DIV which is wrapped into the IE HTML conditional statement
                div.innerHTML = '<!--[if lte IE 9]><i></i><![endif]-->';
                // return true / false value based on what will browser render
                return div.getElementsByTagName('i').length === 1;
            })()
        },
        /*==================================================
        Devices
        ====================================================*/
        device: (function () {
            var ua = window.navigator.userAgent;
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            return {
                ios: ipad || iphone || ipod,
                android: android
            };
        })(),
        /*==================================================
        Feature Detection
        ====================================================*/
        support: {
            touch : (window.Modernizr && Modernizr.touch === true) || (function () {
                return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
            })(),
    
            transforms3d : (window.Modernizr && Modernizr.csstransforms3d === true) || (function () {
                var div = document.createElement('div').style;
                return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
            })(),
    
            flexbox: (function () {
                var div = document.createElement('div').style;
                var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
                for (var i = 0; i < styles.length; i++) {
                    if (styles[i] in div) return true;
                }
            })(),
    
            observer: (function () {
                return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
            })(),
    
            passiveListener: (function () {
                var supportsPassive = false;
                try {
                    var opts = Object.defineProperty({}, 'passive', {
                        get: function() {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                } catch (e) {}
                return supportsPassive;
            })(),
    
            gestures: (function () {
                return 'ongesturestart' in window;
            })()
        },
        /*==================================================
        Plugins
        ====================================================*/
        plugins: {}
    };
    

    /*===========================
    Dom7 Library
    ===========================*/
    var Dom7 = (function () {
        var Dom7 = function (arr) {
            var _this = this, i = 0;
            // Create array-like object
            for (i = 0; i < arr.length; i++) {
                _this[i] = arr[i];
            }
            _this.length = arr.length;
            // Return collection with methods
            return this;
        };
        var $ = function (selector, context) {
            var arr = [], i = 0;
            if (selector && !context) {
                if (selector instanceof Dom7) {
                    return selector;
                }
            }
            if (selector) {
                // String
                if (typeof selector === 'string') {
                    var els, tempParent, html = selector.trim();
                    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                        var toCreate = 'div';
                        if (html.indexOf('<li') === 0) toCreate = 'ul';
                        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                        if (html.indexOf('<tbody') === 0) toCreate = 'table';
                        if (html.indexOf('<option') === 0) toCreate = 'select';
                        tempParent = document.createElement(toCreate);
                        tempParent.innerHTML = selector;
                        for (i = 0; i < tempParent.childNodes.length; i++) {
                            arr.push(tempParent.childNodes[i]);
                        }
                    }
                    else {
                        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                            // Pure ID selector
                            els = [document.getElementById(selector.split('#')[1])];
                        }
                        else {
                            // Other selectors
                            els = (context || document).querySelectorAll(selector);
                        }
                        for (i = 0; i < els.length; i++) {
                            if (els[i]) arr.push(els[i]);
                        }
                    }
                }
                // Node/element
                else if (selector.nodeType || selector === window || selector === document) {
                    arr.push(selector);
                }
                //Array of elements or instance of Dom
                else if (selector.length > 0 && selector[0].nodeType) {
                    for (i = 0; i < selector.length; i++) {
                        arr.push(selector[i]);
                    }
                }
            }
            return new Dom7(arr);
        };
        Dom7.prototype = {
            // Classes and attriutes
            addClass: function (className) {
                if (typeof className === 'undefined') {
                    return this;
                }
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.add(classes[i]);
                    }
                }
                return this;
            },
            removeClass: function (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.remove(classes[i]);
                    }
                }
                return this;
            },
            hasClass: function (className) {
                if (!this[0]) return false;
                else return this[0].classList.contains(className);
            },
            toggleClass: function (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.toggle(classes[i]);
                    }
                }
                return this;
            },
            attr: function (attrs, value) {
                if (arguments.length === 1 && typeof attrs === 'string') {
                    // Get attr
                    if (this[0]) return this[0].getAttribute(attrs);
                    else return undefined;
                }
                else {
                    // Set attrs
                    for (var i = 0; i < this.length; i++) {
                        if (arguments.length === 2) {
                            // String
                            this[i].setAttribute(attrs, value);
                        }
                        else {
                            // Object
                            for (var attrName in attrs) {
                                this[i][attrName] = attrs[attrName];
                                this[i].setAttribute(attrName, attrs[attrName]);
                            }
                        }
                    }
                    return this;
                }
            },
            removeAttr: function (attr) {
                for (var i = 0; i < this.length; i++) {
                    this[i].removeAttribute(attr);
                }
                return this;
            },
            data: function (key, value) {
                if (typeof value === 'undefined') {
                    // Get value
                    if (this[0]) {
                        var dataKey = this[0].getAttribute('data-' + key);
                        if (dataKey) return dataKey;
                        else if (this[0].dom7ElementDataStorage && (key in this[0].dom7ElementDataStorage)) return this[0].dom7ElementDataStorage[key];
                        else return undefined;
                    }
                    else return undefined;
                }
                else {
                    // Set value
                    for (var i = 0; i < this.length; i++) {
                        var el = this[i];
                        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
                        el.dom7ElementDataStorage[key] = value;
                    }
                    return this;
                }
            },
            // Transforms
            transform : function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            },
            transition: function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            },
            //Events
            on: function (eventName, targetSelector, listener, capture) {
                function handleLiveEvent(e) {
                    var target = e.target;
                    if ($(target).is(targetSelector)) listener.call(target, e);
                    else {
                        var parents = $(target).parents();
                        for (var k = 0; k < parents.length; k++) {
                            if ($(parents[k]).is(targetSelector)) listener.call(parents[k], e);
                        }
                    }
                }
                var events = eventName.split(' ');
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof targetSelector === 'function' || targetSelector === false) {
                        // Usual events
                        if (typeof targetSelector === 'function') {
                            listener = arguments[1];
                            capture = arguments[2] || false;
                        }
                        for (j = 0; j < events.length; j++) {
                            this[i].addEventListener(events[j], listener, capture);
                        }
                    }
                    else {
                        //Live events
                        for (j = 0; j < events.length; j++) {
                            if (!this[i].dom7LiveListeners) this[i].dom7LiveListeners = [];
                            this[i].dom7LiveListeners.push({listener: listener, liveListener: handleLiveEvent});
                            this[i].addEventListener(events[j], handleLiveEvent, capture);
                        }
                    }
                }
    
                return this;
            },
            off: function (eventName, targetSelector, listener, capture) {
                var events = eventName.split(' ');
                for (var i = 0; i < events.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        if (typeof targetSelector === 'function' || targetSelector === false) {
                            // Usual events
                            if (typeof targetSelector === 'function') {
                                listener = arguments[1];
                                capture = arguments[2] || false;
                            }
                            this[j].removeEventListener(events[i], listener, capture);
                        }
                        else {
                            // Live event
                            if (this[j].dom7LiveListeners) {
                                for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
                                    if (this[j].dom7LiveListeners[k].listener === listener) {
                                        this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                                    }
                                }
                            }
                        }
                    }
                }
                return this;
            },
            once: function (eventName, targetSelector, listener, capture) {
                var dom = this;
                if (typeof targetSelector === 'function') {
                    targetSelector = false;
                    listener = arguments[1];
                    capture = arguments[2];
                }
                function proxy(e) {
                    listener(e);
                    dom.off(eventName, targetSelector, proxy, capture);
                }
                dom.on(eventName, targetSelector, proxy, capture);
            },
            trigger: function (eventName, eventData) {
                for (var i = 0; i < this.length; i++) {
                    var evt;
                    try {
                        evt = new window.CustomEvent(eventName, {detail: eventData, bubbles: true, cancelable: true});
                    }
                    catch (e) {
                        evt = document.createEvent('Event');
                        evt.initEvent(eventName, true, true);
                        evt.detail = eventData;
                    }
                    this[i].dispatchEvent(evt);
                }
                return this;
            },
            transitionEnd: function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i, j, dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            },
            // Sizing/Styles
            width: function () {
                if (this[0] === window) {
                    return window.innerWidth;
                }
                else {
                    if (this.length > 0) {
                        return parseFloat(this.css('width'));
                    }
                    else {
                        return null;
                    }
                }
            },
            outerWidth: function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins)
                        return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
                    else
                        return this[0].offsetWidth;
                }
                else return null;
            },
            height: function () {
                if (this[0] === window) {
                    return window.innerHeight;
                }
                else {
                    if (this.length > 0) {
                        return parseFloat(this.css('height'));
                    }
                    else {
                        return null;
                    }
                }
            },
            outerHeight: function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins)
                        return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));
                    else
                        return this[0].offsetHeight;
                }
                else return null;
            },
            offset: function () {
                if (this.length > 0) {
                    var el = this[0];
                    var box = el.getBoundingClientRect();
                    var body = document.body;
                    var clientTop  = el.clientTop  || body.clientTop  || 0;
                    var clientLeft = el.clientLeft || body.clientLeft || 0;
                    var scrollTop  = window.pageYOffset || el.scrollTop;
                    var scrollLeft = window.pageXOffset || el.scrollLeft;
                    return {
                        top: box.top  + scrollTop  - clientTop,
                        left: box.left + scrollLeft - clientLeft
                    };
                }
                else {
                    return null;
                }
            },
            css: function (props, value) {
                var i;
                if (arguments.length === 1) {
                    if (typeof props === 'string') {
                        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
                    }
                    else {
                        for (i = 0; i < this.length; i++) {
                            for (var prop in props) {
                                this[i].style[prop] = props[prop];
                            }
                        }
                        return this;
                    }
                }
                if (arguments.length === 2 && typeof props === 'string') {
                    for (i = 0; i < this.length; i++) {
                        this[i].style[props] = value;
                    }
                    return this;
                }
                return this;
            },
    
            //Dom manipulation
            each: function (callback) {
                for (var i = 0; i < this.length; i++) {
                    callback.call(this[i], i, this[i]);
                }
                return this;
            },
            html: function (html) {
                if (typeof html === 'undefined') {
                    return this[0] ? this[0].innerHTML : undefined;
                }
                else {
                    for (var i = 0; i < this.length; i++) {
                        this[i].innerHTML = html;
                    }
                    return this;
                }
            },
            text: function (text) {
                if (typeof text === 'undefined') {
                    if (this[0]) {
                        return this[0].textContent.trim();
                    }
                    else return null;
                }
                else {
                    for (var i = 0; i < this.length; i++) {
                        this[i].textContent = text;
                    }
                    return this;
                }
            },
            is: function (selector) {
                if (!this[0]) return false;
                var compareWith, i;
                if (typeof selector === 'string') {
                    var el = this[0];
                    if (el === document) return selector === document;
                    if (el === window) return selector === window;
    
                    if (el.matches) return el.matches(selector);
                    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
                    else if (el.mozMatchesSelector) return el.mozMatchesSelector(selector);
                    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);
                    else {
                        compareWith = $(selector);
                        for (i = 0; i < compareWith.length; i++) {
                            if (compareWith[i] === this[0]) return true;
                        }
                        return false;
                    }
                }
                else if (selector === document) return this[0] === document;
                else if (selector === window) return this[0] === window;
                else {
                    if (selector.nodeType || selector instanceof Dom7) {
                        compareWith = selector.nodeType ? [selector] : selector;
                        for (i = 0; i < compareWith.length; i++) {
                            if (compareWith[i] === this[0]) return true;
                        }
                        return false;
                    }
                    return false;
                }
    
            },
            index: function () {
                if (this[0]) {
                    var child = this[0];
                    var i = 0;
                    while ((child = child.previousSibling) !== null) {
                        if (child.nodeType === 1) i++;
                    }
                    return i;
                }
                else return undefined;
            },
            eq: function (index) {
                if (typeof index === 'undefined') return this;
                var length = this.length;
                var returnIndex;
                if (index > length - 1) {
                    return new Dom7([]);
                }
                if (index < 0) {
                    returnIndex = length + index;
                    if (returnIndex < 0) return new Dom7([]);
                    else return new Dom7([this[returnIndex]]);
                }
                return new Dom7([this[index]]);
            },
            append: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof newChild === 'string') {
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newChild;
                        while (tempDiv.firstChild) {
                            this[i].appendChild(tempDiv.firstChild);
                        }
                    }
                    else if (newChild instanceof Dom7) {
                        for (j = 0; j < newChild.length; j++) {
                            this[i].appendChild(newChild[j]);
                        }
                    }
                    else {
                        this[i].appendChild(newChild);
                    }
                }
                return this;
            },
            prepend: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof newChild === 'string') {
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newChild;
                        for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                        }
                        // this[i].insertAdjacentHTML('afterbegin', newChild);
                    }
                    else if (newChild instanceof Dom7) {
                        for (j = 0; j < newChild.length; j++) {
                            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                        }
                    }
                    else {
                        this[i].insertBefore(newChild, this[i].childNodes[0]);
                    }
                }
                return this;
            },
            insertBefore: function (selector) {
                var before = $(selector);
                for (var i = 0; i < this.length; i++) {
                    if (before.length === 1) {
                        before[0].parentNode.insertBefore(this[i], before[0]);
                    }
                    else if (before.length > 1) {
                        for (var j = 0; j < before.length; j++) {
                            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                        }
                    }
                }
            },
            insertAfter: function (selector) {
                var after = $(selector);
                for (var i = 0; i < this.length; i++) {
                    if (after.length === 1) {
                        after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
                    }
                    else if (after.length > 1) {
                        for (var j = 0; j < after.length; j++) {
                            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                        }
                    }
                }
            },
            next: function (selector) {
                if (this.length > 0) {
                    if (selector) {
                        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) return new Dom7([this[0].nextElementSibling]);
                        else return new Dom7([]);
                    }
                    else {
                        if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
                        else return new Dom7([]);
                    }
                }
                else return new Dom7([]);
            },
            nextAll: function (selector) {
                var nextEls = [];
                var el = this[0];
                if (!el) return new Dom7([]);
                while (el.nextElementSibling) {
                    var next = el.nextElementSibling;
                    if (selector) {
                        if($(next).is(selector)) nextEls.push(next);
                    }
                    else nextEls.push(next);
                    el = next;
                }
                return new Dom7(nextEls);
            },
            prev: function (selector) {
                if (this.length > 0) {
                    if (selector) {
                        if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) return new Dom7([this[0].previousElementSibling]);
                        else return new Dom7([]);
                    }
                    else {
                        if (this[0].previousElementSibling) return new Dom7([this[0].previousElementSibling]);
                        else return new Dom7([]);
                    }
                }
                else return new Dom7([]);
            },
            prevAll: function (selector) {
                var prevEls = [];
                var el = this[0];
                if (!el) return new Dom7([]);
                while (el.previousElementSibling) {
                    var prev = el.previousElementSibling;
                    if (selector) {
                        if($(prev).is(selector)) prevEls.push(prev);
                    }
                    else prevEls.push(prev);
                    el = prev;
                }
                return new Dom7(prevEls);
            },
            parent: function (selector) {
                var parents = [];
                for (var i = 0; i < this.length; i++) {
                    if (selector) {
                        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                    }
                    else {
                        parents.push(this[i].parentNode);
                    }
                }
                return $($.unique(parents));
            },
            parents: function (selector) {
                var parents = [];
                for (var i = 0; i < this.length; i++) {
                    var parent = this[i].parentNode;
                    while (parent) {
                        if (selector) {
                            if ($(parent).is(selector)) parents.push(parent);
                        }
                        else {
                            parents.push(parent);
                        }
                        parent = parent.parentNode;
                    }
                }
                return $($.unique(parents));
            },
            find : function (selector) {
                var foundElements = [];
                for (var i = 0; i < this.length; i++) {
                    var found = this[i].querySelectorAll(selector);
                    for (var j = 0; j < found.length; j++) {
                        foundElements.push(found[j]);
                    }
                }
                return new Dom7(foundElements);
            },
            children: function (selector) {
                var children = [];
                for (var i = 0; i < this.length; i++) {
                    var childNodes = this[i].childNodes;
    
                    for (var j = 0; j < childNodes.length; j++) {
                        if (!selector) {
                            if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
                        }
                        else {
                            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) children.push(childNodes[j]);
                        }
                    }
                }
                return new Dom7($.unique(children));
            },
            remove: function () {
                for (var i = 0; i < this.length; i++) {
                    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
                }
                return this;
            },
            add: function () {
                var dom = this;
                var i, j;
                for (i = 0; i < arguments.length; i++) {
                    var toAdd = $(arguments[i]);
                    for (j = 0; j < toAdd.length; j++) {
                        dom[dom.length] = toAdd[j];
                        dom.length++;
                    }
                }
                return dom;
            }
        };
        $.fn = Dom7.prototype;
        $.unique = function (arr) {
            var unique = [];
            for (var i = 0; i < arr.length; i++) {
                if (unique.indexOf(arr[i]) === -1) unique.push(arr[i]);
            }
            return unique;
        };
    
        return $;
    })();
    

    /*===========================
     Get Dom libraries
     ===========================*/
    var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
    for (var i = 0; i < swiperDomPlugins.length; i++) {
    	if (window[swiperDomPlugins[i]]) {
    		addLibraryPlugin(window[swiperDomPlugins[i]]);
    	}
    }
    // Required DOM Plugins
    var domLib;
    if (typeof Dom7 === 'undefined') {
    	domLib = window.Dom7 || window.Zepto || window.jQuery;
    }
    else {
    	domLib = Dom7;
    }
    

    /*===========================
    Add .swiper plugin from Dom libraries
    ===========================*/
    function addLibraryPlugin(lib) {
        lib.fn.swiper = function (params) {
            var firstInstance;
            lib(this).each(function () {
                var s = new Swiper(this, params);
                if (!firstInstance) firstInstance = s;
            });
            return firstInstance;
        };
    }
    
    if (domLib) {
        if (!('transitionEnd' in domLib.fn)) {
            domLib.fn.transitionEnd = function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i, j, dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            };
        }
        if (!('transform' in domLib.fn)) {
            domLib.fn.transform = function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            };
        }
        if (!('transition' in domLib.fn)) {
            domLib.fn.transition = function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            };
        }
        if (!('outerWidth' in domLib.fn)) {
            domLib.fn.outerWidth = function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins)
                        return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
                    else
                        return this[0].offsetWidth;
                }
                else return null;
            };
        }
    }
    

    window.Swiper = Swiper;
})();

/*===========================
Swiper AMD Export
===========================*/
if (true)
{
    module.exports = window.Swiper;
}
else if (typeof define === 'function' && define.amd) {
    define([], function () {
        'use strict';
        return window.Swiper;
    });
}

//# sourceMappingURL=maps/swiper.js.map


/***/ }),

/***/ "BtJh":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (floatFn);

/***/ }),

/***/ "C4gf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (object);

/***/ }),

/***/ "C51g":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isDef = isDef;
function isDef(val) {
  return val !== undefined && val !== null;
}

/***/ }),

/***/ "D0fQ":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("WoFR");
var hiddenKeys = __webpack_require__("M8Yd").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "DeJ7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version {{version}}
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//
// Cross module loader
// Supported: Node, AMD, Browser globals
//
;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.Popper = factory();
    }
})(undefined, function () {

    'use strict';

    var root = window;

    // default options
    var DEFAULTS = {
        // placement of the popper
        placement: 'bottom',

        gpuAcceleration: true,

        // shift popper from its origin by the given amount of pixels (can be negative)
        offset: 0,

        // the element which will act as boundary of the popper
        boundariesElement: 'viewport',

        // amount of pixel used to define a minimum distance between the boundaries and the popper
        boundariesPadding: 5,

        // popper will try to prevent overflow following this order,
        // by default, then, it could overflow on the left and on top of the boundariesElement
        preventOverflowOrder: ['left', 'right', 'top', 'bottom'],

        // the behavior used by flip to change the placement of the popper
        flipBehavior: 'flip',

        arrowElement: '[x-arrow]',

        // list of functions used to modify the offsets before they are applied to the popper
        modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],

        modifiersIgnored: [],

        forceAbsolute: false
    };

    /**
     * Create a new Popper.js instance
     * @constructor Popper
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement|Object} popper
     *      The HTML element used as popper, or a configuration used to generate the popper.
     * @param {String} [popper.tagName='div'] The tag name of the generated popper.
     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
     * @param {Object} options
     * @param {String} [options.placement=bottom]
     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
     *      left(-start, -end)`
     *
     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
     *      reference element.
     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
     *
     * @param {Boolean} [options.gpuAcceleration=true]
     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
     *      browser to use the GPU to accelerate the rendering.
     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
     *
     * @param {Number} [options.offset=0]
     *      Amount of pixels the popper will be shifted (can be negative).
     *
     * @param {String|Element} [options.boundariesElement='viewport']
     *      The element which will define the boundaries of the popper position, the popper will never be placed outside
     *      of the defined boundaries (except if `keepTogether` is enabled)
     *
     * @param {Number} [options.boundariesPadding=5]
     *      Additional padding for the boundaries
     *
     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
     *      this means that the last ones will never overflow
     *
     * @param {String|Array} [options.flipBehavior='flip']
     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
     *      its axis (`right - left`, `top - bottom`).
     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
     *
     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
     *      List of functions used to modify the data before they are applied to the popper, add your custom functions
     *      to this array to edit the offsets and placement.
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Array} [options.modifiersIgnored=[]]
     *      Put here any built-in modifier name you want to exclude from the modifiers list
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Boolean} [options.removeOnDestroy=false]
     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
     */
    function Popper(reference, popper, options) {
        this._reference = reference.jquery ? reference[0] : reference;
        this.state = {};

        // if the popper variable is a configuration object, parse it to generate an HTMLElement
        // generate a default popper if is not defined
        var isNotDefined = typeof popper === 'undefined' || popper === null;
        var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
        if (isNotDefined || isConfig) {
            this._popper = this.parse(isConfig ? popper : {});
        }
        // otherwise, use the given HTMLElement as popper
        else {
                this._popper = popper.jquery ? popper[0] : popper;
            }

        // with {} we create a new object with the options inside it
        this._options = Object.assign({}, DEFAULTS, options);

        // refactoring modifiers' list
        this._options.modifiers = this._options.modifiers.map(function (modifier) {
            // remove ignored modifiers
            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

            // set the x-placement attribute before everything else because it could be used to add margins to the popper
            // margins needs to be calculated to get the correct popper offsets
            if (modifier === 'applyStyle') {
                this._popper.setAttribute('x-placement', this._options.placement);
            }

            // return predefined modifier identified by string or keep the custom one
            return this.modifiers[modifier] || modifier;
        }.bind(this));

        // make sure to apply the popper position before any computation
        this.state.position = this._getPosition(this._popper, this._reference);
        setStyle(this._popper, { position: this.state.position, top: 0 });

        // fire the first update to position the popper in the right place
        this.update();

        // setup event listeners, they will take care of update the position in specific situations
        this._setupEventListeners();
        return this;
    }

    //
    // Methods
    //
    /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
    Popper.prototype.destroy = function () {
        this._popper.removeAttribute('x-placement');
        this._popper.style.left = '';
        this._popper.style.position = '';
        this._popper.style.top = '';
        this._popper.style[getSupportedPropertyName('transform')] = '';
        this._removeEventListeners();

        // remove the popper if user explicity asked for the deletion on destroy
        if (this._options.removeOnDestroy) {
            this._popper.remove();
        }
        return this;
    };

    /**
     * Updates the position of the popper, computing the new offsets and applying the new style
     * @method
     * @memberof Popper
     */
    Popper.prototype.update = function () {
        var data = { instance: this, styles: {} };

        // store placement inside the data object, modifiers will be able to edit `placement` if needed
        // and refer to _originalPlacement to know the original value
        data.placement = this._options.placement;
        data._originalPlacement = this._options.placement;

        // compute the popper and reference offsets and put them inside data.offsets
        data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

        // get boundaries
        data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);

        data = this.runModifiers(data, this._options.modifiers);

        if (typeof this.state.updateCallback === 'function') {
            this.state.updateCallback(data);
        }
    };

    /**
     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onCreate = function (callback) {
        // the createCallbacks return as first argument the popper instance
        callback(this);
        return this;
    };

    /**
     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
     * used to style popper and its arrow.
     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onUpdate = function (callback) {
        this.state.updateCallback = callback;
        return this;
    };

    /**
     * Helper used to generate poppers from a configuration file
     * @method
     * @memberof Popper
     * @param config {Object} configuration
     * @returns {HTMLElement} popper
     */
    Popper.prototype.parse = function (config) {
        var defaultConfig = {
            tagName: 'div',
            classNames: ['popper'],
            attributes: [],
            parent: root.document.body,
            content: '',
            contentType: 'text',
            arrowTagName: 'div',
            arrowClassNames: ['popper__arrow'],
            arrowAttributes: ['x-arrow']
        };
        config = Object.assign({}, defaultConfig, config);

        var d = root.document;

        var popper = d.createElement(config.tagName);
        addClassNames(popper, config.classNames);
        addAttributes(popper, config.attributes);
        if (config.contentType === 'node') {
            popper.appendChild(config.content.jquery ? config.content[0] : config.content);
        } else if (config.contentType === 'html') {
            popper.innerHTML = config.content;
        } else {
            popper.textContent = config.content;
        }

        if (config.arrowTagName) {
            var arrow = d.createElement(config.arrowTagName);
            addClassNames(arrow, config.arrowClassNames);
            addAttributes(arrow, config.arrowAttributes);
            popper.appendChild(arrow);
        }

        var parent = config.parent.jquery ? config.parent[0] : config.parent;

        // if the given parent is a string, use it to match an element
        // if more than one element is matched, the first one will be used as parent
        // if no elements are matched, the script will throw an error
        if (typeof parent === 'string') {
            parent = d.querySelectorAll(config.parent);
            if (parent.length > 1) {
                console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
            }
            if (parent.length === 0) {
                throw 'ERROR: the given `parent` doesn\'t exists!';
            }
            parent = parent[0];
        }
        // if the given parent is a DOM nodes list or an array of nodes with more than one element,
        // the first one will be used as parent
        if (parent.length > 1 && parent instanceof Element === false) {
            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
            parent = parent[0];
        }

        // append the generated popper to its parent
        parent.appendChild(popper);

        return popper;

        /**
         * Adds class names to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} classes
         */
        function addClassNames(element, classNames) {
            classNames.forEach(function (className) {
                element.classList.add(className);
            });
        }

        /**
         * Adds attributes to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} attributes
         * @example
         * addAttributes(element, [ 'data-info:foobar' ]);
         */
        function addAttributes(element, attributes) {
            attributes.forEach(function (attribute) {
                element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
            });
        }
    };

    /**
     * Helper used to get the position which will be applied to the popper
     * @method
     * @memberof Popper
     * @param config {HTMLElement} popper element
     * @param reference {HTMLElement} reference element
     * @returns {String} position
     */
    Popper.prototype._getPosition = function (popper, reference) {
        var container = getOffsetParent(reference);

        if (this._options.forceAbsolute) {
            return 'absolute';
        }

        // Decide if the popper will be fixed
        // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
        var isParentFixed = isFixed(reference, container);
        return isParentFixed ? 'fixed' : 'absolute';
    };

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper
     * @access private
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    Popper.prototype._getOffsets = function (popper, reference, placement) {
        placement = placement.split('-')[0];
        var popperOffsets = {};

        popperOffsets.position = this.state.position;
        var isParentFixed = popperOffsets.position === 'fixed';

        //
        // Get reference element position
        //
        var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

        //
        // Get popper sizes
        //
        var popperRect = getOuterSizes(popper);

        //
        // Compute offsets of popper
        //

        // depending by the popper placement we have to compute its offsets slightly differently
        if (['right', 'left'].indexOf(placement) !== -1) {
            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
            if (placement === 'left') {
                popperOffsets.left = referenceOffsets.left - popperRect.width;
            } else {
                popperOffsets.left = referenceOffsets.right;
            }
        } else {
            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
            if (placement === 'top') {
                popperOffsets.top = referenceOffsets.top - popperRect.height;
            } else {
                popperOffsets.top = referenceOffsets.bottom;
            }
        }

        // Add width and height to our offsets object
        popperOffsets.width = popperRect.width;
        popperOffsets.height = popperRect.height;

        return {
            popper: popperOffsets,
            reference: referenceOffsets
        };
    };

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._setupEventListeners = function () {
        // NOTE: 1 DOM access here
        this.state.updateBound = this.update.bind(this);
        root.addEventListener('resize', this.state.updateBound);
        // if the boundariesElement is window we don't need to listen for the scroll event
        if (this._options.boundariesElement !== 'window') {
            var target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
                target = root;
            }
            target.addEventListener('scroll', this.state.updateBound);
        }
    };

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._removeEventListeners = function () {
        // NOTE: 1 DOM access here
        root.removeEventListener('resize', this.state.updateBound);
        if (this._options.boundariesElement !== 'window') {
            var target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
                target = root;
            }
            target.removeEventListener('scroll', this.state.updateBound);
        }
        this.state.updateBound = null;
    };

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper
     * @access private
     * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
     * @param {Number} padding - Boundaries padding
     * @param {Element} boundariesElement - Element used to define the boundaries
     * @returns {Object} Coordinates of the boundaries
     */
    Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
        // NOTE: 1 DOM access here
        var boundaries = {};
        var width, height;
        if (boundariesElement === 'window') {
            var body = root.document.body,
                html = root.document.documentElement;

            height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
            width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);

            boundaries = {
                top: 0,
                right: width,
                bottom: height,
                left: 0
            };
        } else if (boundariesElement === 'viewport') {
            var offsetParent = getOffsetParent(this._popper);
            var scrollParent = getScrollParent(this._popper);
            var offsetParentRect = getOffsetRect(offsetParent);

            // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
            var getScrollTopValue = function getScrollTopValue(element) {
                return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
            };
            var getScrollLeftValue = function getScrollLeftValue(element) {
                return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
            };

            // if the popper is fixed we don't have to substract scrolling from the boundaries
            var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
            var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);

            boundaries = {
                top: 0 - (offsetParentRect.top - scrollTop),
                right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
                bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
                left: 0 - (offsetParentRect.left - scrollLeft)
            };
        } else {
            if (getOffsetParent(this._popper) === boundariesElement) {
                boundaries = {
                    top: 0,
                    left: 0,
                    right: boundariesElement.clientWidth,
                    bottom: boundariesElement.clientHeight
                };
            } else {
                boundaries = getOffsetRect(boundariesElement);
            }
        }
        boundaries.left += padding;
        boundaries.right -= padding;
        boundaries.top = boundaries.top + padding;
        boundaries.bottom = boundaries.bottom - padding;
        return boundaries;
    };

    /**
     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
     * @method
     * @memberof Popper
     * @access public
     * @param {Object} data
     * @param {Array} modifiers
     * @param {Function} ends
     */
    Popper.prototype.runModifiers = function (data, modifiers, ends) {
        var modifiersToRun = modifiers.slice();
        if (ends !== undefined) {
            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
        }

        modifiersToRun.forEach(function (modifier) {
            if (isFunction(modifier)) {
                data = modifier.call(this, data);
            }
        }.bind(this));

        return data;
    };

    /**
     * Helper used to know if the given modifier depends from another one.
     * @method
     * @memberof Popper
     * @param {String} requesting - name of requesting modifier
     * @param {String} requested - name of requested modifier
     * @returns {Boolean}
     */
    Popper.prototype.isModifierRequired = function (requesting, requested) {
        var index = getArrayKeyIndex(this._options.modifiers, requesting);
        return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
            return modifier === requested;
        }).length;
    };

    //
    // Modifiers
    //

    /**
     * Modifiers list
     * @namespace Popper.modifiers
     * @memberof Popper
     * @type {Object}
     */
    Popper.prototype.modifiers = {};

    /**
     * Apply the computed styles to the popper element
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The same data object
     */
    Popper.prototype.modifiers.applyStyle = function (data) {
        // apply the final offsets to the popper
        // NOTE: 1 DOM access here
        var styles = {
            position: data.offsets.popper.position
        };

        // round top and left to avoid blurry text
        var left = Math.round(data.offsets.popper.left);
        var top = Math.round(data.offsets.popper.top);

        // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
        // we automatically use the supported prefixed version if needed
        var prefixedProperty;
        if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
            styles.top = 0;
            styles.left = 0;
        }
        // othwerise, we use the standard `left` and `top` properties
        else {
                styles.left = left;
                styles.top = top;
            }

        // any property present in `data.styles` will be applied to the popper,
        // in this way we can make the 3rd party modifiers add custom styles to it
        // Be aware, modifiers could override the properties defined in the previous
        // lines of this modifier!
        Object.assign(styles, data.styles);

        setStyle(this._popper, styles);

        // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
        // NOTE: 1 DOM access here
        this._popper.setAttribute('x-placement', data.placement);

        // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
        if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
            setStyle(data.arrowElement, data.offsets.arrow);
        }

        return data;
    };

    /**
     * Modifier used to shift the popper on the start or end of its reference element side
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.shift = function (data) {
        var placement = data.placement;
        var basePlacement = placement.split('-')[0];
        var shiftVariation = placement.split('-')[1];

        // if shift shiftVariation is specified, run the modifier
        if (shiftVariation) {
            var reference = data.offsets.reference;
            var popper = getPopperClientRect(data.offsets.popper);

            var shiftOffsets = {
                y: {
                    start: { top: reference.top },
                    end: { top: reference.top + reference.height - popper.height }
                },
                x: {
                    start: { left: reference.left },
                    end: { left: reference.left + reference.width - popper.width }
                }
            };

            var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';

            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
        }

        return data;
    };

    /**
     * Modifier used to make sure the popper does not overflows from it's boundaries
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.preventOverflow = function (data) {
        var order = this._options.preventOverflowOrder;
        var popper = getPopperClientRect(data.offsets.popper);

        var check = {
            left: function left() {
                var left = popper.left;
                if (popper.left < data.boundaries.left) {
                    left = Math.max(popper.left, data.boundaries.left);
                }
                return { left: left };
            },
            right: function right() {
                var left = popper.left;
                if (popper.right > data.boundaries.right) {
                    left = Math.min(popper.left, data.boundaries.right - popper.width);
                }
                return { left: left };
            },
            top: function top() {
                var top = popper.top;
                if (popper.top < data.boundaries.top) {
                    top = Math.max(popper.top, data.boundaries.top);
                }
                return { top: top };
            },
            bottom: function bottom() {
                var top = popper.top;
                if (popper.bottom > data.boundaries.bottom) {
                    top = Math.min(popper.top, data.boundaries.bottom - popper.height);
                }
                return { top: top };
            }
        };

        order.forEach(function (direction) {
            data.offsets.popper = Object.assign(popper, check[direction]());
        });

        return data;
    };

    /**
     * Modifier used to make sure the popper is always near its reference
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.keepTogether = function (data) {
        var popper = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var f = Math.floor;

        if (popper.right < f(reference.left)) {
            data.offsets.popper.left = f(reference.left) - popper.width;
        }
        if (popper.left > f(reference.right)) {
            data.offsets.popper.left = f(reference.right);
        }
        if (popper.bottom < f(reference.top)) {
            data.offsets.popper.top = f(reference.top) - popper.height;
        }
        if (popper.top > f(reference.bottom)) {
            data.offsets.popper.top = f(reference.bottom);
        }

        return data;
    };

    /**
     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
     * Requires the `preventOverflow` modifier before it in order to work.
     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.flip = function (data) {
        // check if preventOverflow is in the list of modifiers before the flip modifier.
        // otherwise flip would not work as expected.
        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
            return data;
        }

        if (data.flipped && data.placement === data._originalPlacement) {
            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
            return data;
        }

        var placement = data.placement.split('-')[0];
        var placementOpposite = getOppositePlacement(placement);
        var variation = data.placement.split('-')[1] || '';

        var flipOrder = [];
        if (this._options.flipBehavior === 'flip') {
            flipOrder = [placement, placementOpposite];
        } else {
            flipOrder = this._options.flipBehavior;
        }

        flipOrder.forEach(function (step, index) {
            if (placement !== step || flipOrder.length === index + 1) {
                return;
            }

            placement = data.placement.split('-')[0];
            placementOpposite = getOppositePlacement(placement);

            var popperOffsets = getPopperClientRect(data.offsets.popper);

            // this boolean is used to distinguish right and bottom from top and left
            // they need different computations to get flipped
            var a = ['right', 'bottom'].indexOf(placement) !== -1;

            // using Math.floor because the reference offsets may contain decimals we are not going to consider here
            if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
                // we'll use this boolean to detect any flip loop
                data.flipped = true;
                data.placement = flipOrder[index + 1];
                if (variation) {
                    data.placement += '-' + variation;
                }
                data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;

                data = this.runModifiers(data, this._options.modifiers, this._flip);
            }
        }.bind(this));
        return data;
    };

    /**
     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
     * The offsets will shift the popper on the side of its reference element.
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.offset = function (data) {
        var offset = this._options.offset;
        var popper = data.offsets.popper;

        if (data.placement.indexOf('left') !== -1) {
            popper.top -= offset;
        } else if (data.placement.indexOf('right') !== -1) {
            popper.top += offset;
        } else if (data.placement.indexOf('top') !== -1) {
            popper.left -= offset;
        } else if (data.placement.indexOf('bottom') !== -1) {
            popper.left += offset;
        }
        return data;
    };

    /**
     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.arrow = function (data) {
        var arrow = this._options.arrowElement;

        // if the arrowElement is a string, suppose it's a CSS selector
        if (typeof arrow === 'string') {
            arrow = this._popper.querySelector(arrow);
        }

        // if arrow element is not found, don't run the modifier
        if (!arrow) {
            return data;
        }

        // the arrow element must be child of its popper
        if (!this._popper.contains(arrow)) {
            console.warn('WARNING: `arrowElement` must be child of its popper element!');
            return data;
        }

        // arrow depends on keepTogether in order to work
        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
            return data;
        }

        var arrowStyle = {};
        var placement = data.placement.split('-')[0];
        var popper = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var isVertical = ['left', 'right'].indexOf(placement) !== -1;

        var len = isVertical ? 'height' : 'width';
        var side = isVertical ? 'top' : 'left';
        var altSide = isVertical ? 'left' : 'top';
        var opSide = isVertical ? 'bottom' : 'right';
        var arrowSize = getOuterSizes(arrow)[len];

        //
        // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
        //

        // top/left side
        if (reference[opSide] - arrowSize < popper[side]) {
            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
        }
        // bottom/right side
        if (reference[side] + arrowSize > popper[opSide]) {
            data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
        }

        // compute center of the popper
        var center = reference[side] + reference[len] / 2 - arrowSize / 2;

        var sideValue = center - popper[side];

        // prevent arrow from being placed not contiguously to its popper
        sideValue = Math.max(Math.min(popper[len] - arrowSize - 3, sideValue), 3);
        arrowStyle[side] = sideValue;
        arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

        data.offsets.arrow = arrowStyle;
        data.arrowElement = arrow;

        return data;
    };

    //
    // Helpers
    //

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
        // NOTE: 1 DOM access here
        var _display = element.style.display,
            _visibility = element.style.visibility;
        element.style.display = 'block';element.style.visibility = 'hidden';
        var calcWidthToForceRepaint = element.offsetWidth;

        // original method
        var styles = root.getComputedStyle(element);
        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
        var result = { width: element.offsetWidth + y, height: element.offsetHeight + x };

        // reset element styles
        element.style.display = _display;element.style.visibility = _visibility;
        return result;
    }

    /**
     * Get the opposite placement of the given one/
     * @function
     * @ignore
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
        var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
        return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash[matched];
        });
    }

    /**
     * Given the popper offsets, generate an output similar to getBoundingClientRect
     * @function
     * @ignore
     * @argument {Object} popperOffsets
     * @returns {Object} ClientRect like output
     */
    function getPopperClientRect(popperOffsets) {
        var offsets = Object.assign({}, popperOffsets);
        offsets.right = offsets.left + offsets.width;
        offsets.bottom = offsets.top + offsets.height;
        return offsets;
    }

    /**
     * Given an array and the key to find, returns its index
     * @function
     * @ignore
     * @argument {Array} arr
     * @argument keyToFind
     * @returns index or null
     */
    function getArrayKeyIndex(arr, keyToFind) {
        var i = 0,
            key;
        for (key in arr) {
            if (arr[key] === keyToFind) {
                return i;
            }
            i++;
        }
        return null;
    }

    /**
     * Get CSS computed property of the given element
     * @function
     * @ignore
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
        // NOTE: 1 DOM access here
        var css = root.getComputedStyle(element, null);
        return css[property];
    }

    /**
     * Returns the offset parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
        // NOTE: 1 DOM access here
        var offsetParent = element.offsetParent;
        return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
    }

    /**
     * Returns the scrolling parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getScrollParent(element) {
        var parent = element.parentNode;

        if (!parent) {
            return element;
        }

        if (parent === root.document) {
            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
            // greater than 0 and return the proper element
            if (root.document.body.scrollTop) {
                return root.document.body;
            } else {
                return root.document.documentElement;
            }
        }

        // Firefox want us to check `-x` and `-y` variations as well
        if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
            // If the detected scrollParent is body, we perform an additional check on its parentNode
            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
            // fixes issue #65
            return parent;
        }
        return getScrollParent(element.parentNode);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @function
     * @ignore
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
        if (element === root.document.body) {
            return false;
        }
        if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
        }
        return element.parentNode ? isFixed(element.parentNode) : element;
    }

    /**
     * Set the style to the given popper
     * @function
     * @ignore
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
     */
    function setStyle(element, styles) {
        function is_numeric(n) {
            return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
        }
        Object.keys(styles).forEach(function (prop) {
            var unit = '';
            // add unit if the value is numeric and is one of the following
            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
                unit = 'px';
            }
            element.style[prop] = styles[prop] + unit;
        });
    }

    /**
     * Check if the given variable is a function
     * @function
     * @ignore
     * @argument {*} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
        var getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get the position of the given element, relative to its offset parent
     * @function
     * @ignore
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
    function getOffsetRect(element) {
        var elementRect = {
            width: element.offsetWidth,
            height: element.offsetHeight,
            left: element.offsetLeft,
            top: element.offsetTop
        };

        elementRect.right = elementRect.left + elementRect.width;
        elementRect.bottom = elementRect.top + elementRect.height;

        // position
        return elementRect;
    }

    /**
     * Get bounding client rect of given element
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();

        // whether the IE version is lower than 11
        var isIE = navigator.userAgent.indexOf("MSIE") != -1;

        // fix ie document bounding top always 0 bug
        var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;

        return {
            left: rect.left,
            top: rectTop,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.right - rect.left,
            height: rect.bottom - rectTop
        };
    }

    /**
     * Given an element and one of its parents, return the offset
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @param {HTMLElement} parent
     * @return {Object} rect
     */
    function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
        var elementRect = getBoundingClientRect(element);
        var parentRect = getBoundingClientRect(parent);

        if (fixed) {
            var scrollParent = getScrollParent(parent);
            parentRect.top += scrollParent.scrollTop;
            parentRect.bottom += scrollParent.scrollTop;
            parentRect.left += scrollParent.scrollLeft;
            parentRect.right += scrollParent.scrollLeft;
        }

        var rect = {
            top: elementRect.top - parentRect.top,
            left: elementRect.left - parentRect.left,
            bottom: elementRect.top - parentRect.top + elementRect.height,
            right: elementRect.left - parentRect.left + elementRect.width,
            width: elementRect.width,
            height: elementRect.height
        };
        return rect;
    }

    /**
     * Get the prefixed supported property name
     * @function
     * @ignore
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase)
     */
    function getSupportedPropertyName(property) {
        var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

        for (var i = 0; i < prefixes.length; i++) {
            var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
            if (typeof root.document.body.style[toCheck] !== 'undefined') {
                return toCheck;
            }
        }
        return null;
    }

    /**
     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
     * objects to a target object. It will return the target object.
     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     * @function
     * @ignore
     */
    if (!Object.assign) {
        Object.defineProperty(Object, 'assign', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: function value(target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert first argument to object');
                }

                var to = Object(target);
                for (var i = 1; i < arguments.length; i++) {
                    var nextSource = arguments[i];
                    if (nextSource === undefined || nextSource === null) {
                        continue;
                    }
                    nextSource = Object(nextSource);

                    var keysArray = Object.keys(nextSource);
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                        var nextKey = keysArray[nextIndex];
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
                return to;
            }
        });
    }

    return Popper;
});

/***/ }),

/***/ "E/8r":
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 178);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 178:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(179);


/***/ }),

/***/ 179:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _buttonGroup = __webpack_require__(180);

var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_buttonGroup2.default.install = function (Vue) {
  Vue.component(_buttonGroup2.default.name, _buttonGroup2.default);
};

exports.default = _buttonGroup2.default;

/***/ }),

/***/ 180:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4c0216a7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_group_vue__ = __webpack_require__(182);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4c0216a7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//

exports.default = {
  name: 'ElButtonGroup'
};

/***/ }),

/***/ 182:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-button-group"},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "E3Cb":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 137);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = __webpack_require__("BbKf");

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(138);


/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(139);

var _checkbox2 = _interopRequireDefault(_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_checkbox2.default.install = function (Vue) {
  Vue.component(_checkbox2.default.name, _checkbox2.default);
};

exports.default = _checkbox2.default;

/***/ }),

/***/ 139:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_59b8b1d6_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_vue__ = __webpack_require__(141);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_59b8b1d6_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElCheckbox',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  componentName: 'ElCheckbox',

  data: function data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false
    };
  },


  computed: {
    model: {
      get: function get() {
        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);

          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);

          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
          this.selfModel = val;
        }
      }
    },

    isChecked: function isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
    },
    isGroup: function isGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          this._checkboxGroup = parent;
          return true;
        }
      }
      return false;
    },
    store: function store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this._checkboxGroup.disabled || this.disabled : this.disabled;
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxSize: function checkboxSize() {
      var temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
    }
  },

  props: {
    value: {},
    label: {},
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: [String, Number],
    falseLabel: [String, Number],
    id: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    controls: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    border: Boolean,
    size: String
  },

  methods: {
    addToStore: function addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    handleChange: function handleChange(ev) {
      var _this = this;

      if (this.isLimitExceeded) return;
      var value = void 0;
      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }
      this.$emit('change', value, ev);
      this.$nextTick(function () {
        if (_this.isGroup) {
          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
        }
      });
    }
  },

  created: function created() {
    this.checked && this.addToStore();
  },
  mounted: function mounted() {
    // 为indeterminate元素 添加aria-controls 属性
    if (this.indeterminate) {
      this.$el.setAttribute('aria-controls', this.controls);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),

/***/ 141:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-checkbox",class:[
    _vm.border && _vm.checkboxSize ? 'el-checkbox--' + _vm.checkboxSize : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-bordered': _vm.border },
    { 'is-checked': _vm.isChecked }
  ],attrs:{"role":"checkbox","aria-checked":_vm.indeterminate ? 'mixed': _vm.isChecked,"aria-disabled":_vm.isDisabled,"id":_vm.id}},[_c('span',{staticClass:"el-checkbox__input",class:{
      'is-disabled': _vm.isDisabled,
      'is-checked': _vm.isChecked,
      'is-indeterminate': _vm.indeterminate,
      'is-focus': _vm.focus
    },attrs:{"aria-checked":"mixed"}},[_c('span',{staticClass:"el-checkbox__inner"}),(_vm.trueLabel || _vm.falseLabel)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"type":"checkbox","name":_vm.name,"disabled":_vm.isDisabled,"true-value":_vm.trueLabel,"false-value":_vm.falseLabel},domProps:{"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,null)>-1:_vm._q(_vm.model,_vm.trueLabel)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(_vm.trueLabel):(_vm.falseLabel);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}):_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"type":"checkbox","disabled":_vm.isDisabled,"name":_vm.name},domProps:{"value":_vm.label,"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,_vm.label)>-1:(_vm.model)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.label,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}})]),(_vm.$slots.default || _vm.label)?_c('span',{staticClass:"el-checkbox__label"},[_vm._t("default"),(!_vm.$slots.default)?[_vm._v(_vm._s(_vm.label))]:_vm._e()],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "EIha":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("b5rb");
var step = __webpack_require__("kDoY");
var Iterators = __webpack_require__("Ytca");
var toIObject = __webpack_require__("/RPK");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("ExXN")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "ExXN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("ifR3");
var $export = __webpack_require__("f68a");
var redefine = __webpack_require__("c+mw");
var hide = __webpack_require__("q1/O");
var has = __webpack_require__("AsM0");
var Iterators = __webpack_require__("Ytca");
var $iterCreate = __webpack_require__("/N1I");
var setToStringTag = __webpack_require__("9Poz");
var getPrototypeOf = __webpack_require__("SZqL");
var ITERATOR = __webpack_require__("IFGh")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "FDNG":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("ex+5");
var createDesc = __webpack_require__("TUEb");
var toIObject = __webpack_require__("/RPK");
var toPrimitive = __webpack_require__("7qHl");
var has = __webpack_require__("AsM0");
var IE8_DOM_DEFINE = __webpack_require__("esV0");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("PRM/") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "FRKS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

var _dom = __webpack_require__("6d3N");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasModal = false;

var getModal = function getModal() {
  if (_vue2.default.prototype.$isServer) return;
  var modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    PopupManager.modalDom = modalDom;

    modalDom.addEventListener('touchmove', function (event) {
      event.preventDefault();
      event.stopPropagation();
    });

    modalDom.addEventListener('click', function () {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick();
    });
  }

  return modalDom;
};

var instances = {};

var PopupManager = {
  zIndex: 2000,

  modalFade: true,

  getInstance: function getInstance(id) {
    return instances[id];
  },

  register: function register(id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },

  deregister: function deregister(id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },

  nextZIndex: function nextZIndex() {
    return PopupManager.zIndex++;
  },

  modalStack: [],

  doOnModalClick: function doOnModalClick() {
    var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem) return;

    var instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal) {
      instance.close();
    }
  },

  openModal: function openModal(id, zIndex, dom, modalClass, modalFade) {
    if (_vue2.default.prototype.$isServer) return;
    if (!id || zIndex === undefined) return;
    this.modalFade = modalFade;

    var modalStack = this.modalStack;

    for (var i = 0, j = modalStack.length; i < j; i++) {
      var item = modalStack[i];
      if (item.id === id) {
        return;
      }
    }

    var modalDom = getModal();

    (0, _dom.addClass)(modalDom, 'v-modal');
    if (this.modalFade && !hasModal) {
      (0, _dom.addClass)(modalDom, 'v-modal-enter');
    }
    if (modalClass) {
      var classArr = modalClass.trim().split(/\s+/);
      classArr.forEach(function (item) {
        return (0, _dom.addClass)(modalDom, item);
      });
    }
    setTimeout(function () {
      (0, _dom.removeClass)(modalDom, 'v-modal-enter');
    }, 200);

    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }

    if (zIndex) {
      modalDom.style.zIndex = zIndex;
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = '';

    this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });
  },

  closeModal: function closeModal(id) {
    var modalStack = this.modalStack;
    var modalDom = getModal();

    if (modalStack.length > 0) {
      var topItem = modalStack[modalStack.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          var classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(function (item) {
            return (0, _dom.removeClass)(modalDom, item);
          });
        }

        modalStack.pop();
        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (var i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }

    if (modalStack.length === 0) {
      if (this.modalFade) {
        (0, _dom.addClass)(modalDom, 'v-modal-leave');
      }
      setTimeout(function () {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          PopupManager.modalDom = undefined;
        }
        (0, _dom.removeClass)(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};

var getTopPopup = function getTopPopup() {
  if (_vue2.default.prototype.$isServer) return;
  if (PopupManager.modalStack.length > 0) {
    var topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    var instance = PopupManager.getInstance(topPopup.id);

    return instance;
  }
};

if (!_vue2.default.prototype.$isServer) {
  // handle `esc` key when the popup is shown
  window.addEventListener('keydown', function (event) {
    if (event.keyCode === 27) {
      var topPopup = getTopPopup();

      if (topPopup && topPopup.closeOnPressEscape) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
      }
    }
  });
}

exports.default = PopupManager;

/***/ }),

/***/ "Fgny":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Za1F");
__webpack_require__("5tK0");
__webpack_require__("UAy9");
__webpack_require__("L/M2");
module.exports = __webpack_require__("0nnt").Symbol;


/***/ }),

/***/ "Fl16":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "HYS4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__("hRKE");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__required__ = __webpack_require__("zydr");




/* eslint max-len:0 */

var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};

var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  float: function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function';
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === 'number';
  },
  object: function object(value) {
    return (typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value)) === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === 'string' && !!value.match(pattern.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern.hex);
  }
};

/**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__required__["a" /* default */])(rule, value, source, errors, options);
    return;
  }
  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(__WEBPACK_IMPORTED_MODULE_1__util__["e" /* format */](options.messages.types[ruleType], rule.fullField, rule.type));
    }
    // straight typeof check
  } else if (ruleType && (typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value)) !== rule.type) {
    errors.push(__WEBPACK_IMPORTED_MODULE_1__util__["e" /* format */](options.messages.types[ruleType], rule.fullField, rule.type));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (type);

/***/ }),

/***/ "Hzfu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _locale = __webpack_require__("gUSn");

exports.default = {
  methods: {
    t: function t() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _locale.t.apply(this, args);
    }
  }
};

/***/ }),

/***/ "IFGh":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("13kP")('wks');
var uid = __webpack_require__("Fl16");
var Symbol = __webpack_require__("lSMs").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "IPpm":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__("xB8i");


/**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      if (!rule.pattern.test(value)) {
        errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["a"] = (pattern);

/***/ }),

/***/ "IcQ3":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "JcMz":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("/RPK");
var gOPN = __webpack_require__("D0fQ").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "K1PJ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__("xB8i");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rule___ = __webpack_require__("f+uh");



/**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_1__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_1__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (boolean);

/***/ }),

/***/ "L/M2":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("fuEY")('observable');


/***/ }),

/***/ "L88V":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 111);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = __webpack_require__("BbKf");

/***/ }),

/***/ 10:
/***/ (function(module, exports) {

module.exports = __webpack_require__("UGrZ");

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = __webpack_require__("xp85");

/***/ }),

/***/ 111:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(112);


/***/ }),

/***/ 112:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _input = __webpack_require__(113);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_input2.default.install = function (Vue) {
  Vue.component(_input2.default.name, _input2.default);
};

exports.default = _input2.default;

/***/ }),

/***/ 113:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_eddb4a56_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_vue__ = __webpack_require__(116);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_eddb4a56_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 114:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _focus = __webpack_require__(11);

var _focus2 = _interopRequireDefault(_focus);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _calcTextareaHeight = __webpack_require__(115);

var _calcTextareaHeight2 = _interopRequireDefault(_calcTextareaHeight);

var _merge = __webpack_require__(10);

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElInput',

  componentName: 'ElInput',

  mixins: [_emitter2.default, (0, _focus2.default)('input'), _migrating2.default],

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  data: function data() {
    return {
      currentValue: this.value,
      textareaCalcStyle: {},
      prefixOffset: null,
      suffixOffset: null
    };
  },


  props: {
    value: [String, Number],
    placeholder: String,
    size: String,
    resize: String,
    name: String,
    form: String,
    id: String,
    maxlength: Number,
    minlength: Number,
    readonly: Boolean,
    autofocus: Boolean,
    disabled: Boolean,
    type: {
      type: String,
      default: 'text'
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    rows: {
      type: Number,
      default: 2
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    max: {},
    min: {},
    step: {},
    validateEvent: {
      type: Boolean,
      default: true
    },
    suffixIcon: String,
    prefixIcon: String,
    label: String
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    validateState: function validateState() {
      return this.elFormItem ? this.elFormItem.validateState : '';
    },
    needStatusIcon: function needStatusIcon() {
      return this.elForm ? this.elForm.statusIcon : false;
    },
    validateIcon: function validateIcon() {
      return {
        validating: 'el-icon-loading',
        success: 'el-icon-circle-check',
        error: 'el-icon-circle-close'
      }[this.validateState];
    },
    textareaStyle: function textareaStyle() {
      return (0, _merge2.default)({}, this.textareaCalcStyle, { resize: this.resize });
    },
    inputSize: function inputSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    isGroup: function isGroup() {
      return this.$slots.prepend || this.$slots.append;
    }
  },

  watch: {
    'value': function value(val, oldValue) {
      this.setCurrentValue(val);
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'icon': 'icon is removed, use suffix-icon / prefix-icon instead.',
          'on-icon-click': 'on-icon-click is removed.'
        },
        events: {
          'click': 'click is removed.'
        }
      };
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.blur', [this.currentValue]);
      }
    },
    inputSelect: function inputSelect() {
      this.$refs.input.select();
    },
    resizeTextarea: function resizeTextarea() {
      if (this.$isServer) return;
      var autosize = this.autosize,
          type = this.type;

      if (type !== 'textarea') return;
      if (!autosize) {
        this.textareaCalcStyle = {
          minHeight: (0, _calcTextareaHeight2.default)(this.$refs.textarea).minHeight
        };
        return;
      }
      var minRows = autosize.minRows;
      var maxRows = autosize.maxRows;

      this.textareaCalcStyle = (0, _calcTextareaHeight2.default)(this.$refs.textarea, minRows, maxRows);
    },
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },
    handleInput: function handleInput(event) {
      var value = event.target.value;
      this.$emit('input', value);
      this.setCurrentValue(value);
    },
    handleChange: function handleChange(event) {
      this.$emit('change', event.target.value);
    },
    setCurrentValue: function setCurrentValue(value) {
      var _this = this;

      if (value === this.currentValue) return;
      this.$nextTick(function (_) {
        _this.resizeTextarea();
      });
      this.currentValue = value;
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.change', [value]);
      }
    },
    calcIconOffset: function calcIconOffset(place) {
      var pendantMap = {
        'suf': 'append',
        'pre': 'prepend'
      };

      var pendant = pendantMap[place];

      if (this.$slots[pendant]) {
        return { transform: 'translateX(' + (place === 'suf' ? '-' : '') + this.$el.querySelector('.el-input-group__' + pendant).offsetWidth + 'px)' };
      }
    }
  },

  created: function created() {
    this.$on('inputSelect', this.inputSelect);
  },
  mounted: function mounted() {
    this.resizeTextarea();
    if (this.isGroup) {
      this.prefixOffset = this.calcIconOffset('pre');
      this.suffixOffset = this.calcIconOffset('suf');
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),

/***/ 115:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = calcTextareaHeight;
var hiddenTextarea = void 0;

var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';

var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

function calculateNodeStyling(targetElement) {
  var style = window.getComputedStyle(targetElement);

  var boxSizing = style.getPropertyValue('box-sizing');

  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));

  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));

  var contextStyle = CONTEXT_STYLE.map(function (name) {
    return name + ':' + style.getPropertyValue(name);
  }).join(';');

  return { contextStyle: contextStyle, paddingSize: paddingSize, borderSize: borderSize, boxSizing: boxSizing };
}

function calcTextareaHeight(targetElement) {
  var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  var _calculateNodeStyling = calculateNodeStyling(targetElement),
      paddingSize = _calculateNodeStyling.paddingSize,
      borderSize = _calculateNodeStyling.borderSize,
      boxSizing = _calculateNodeStyling.boxSizing,
      contextStyle = _calculateNodeStyling.contextStyle;

  hiddenTextarea.setAttribute('style', contextStyle + ';' + HIDDEN_STYLE);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

  var height = hiddenTextarea.scrollHeight;
  var result = {};

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    var minHeight = singleRowHeight * minRows;
    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = minHeight + 'px';
  }
  if (maxRows !== null) {
    var maxHeight = singleRowHeight * maxRows;
    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = height + 'px';
  hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
};

/***/ }),

/***/ 116:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:[
  _vm.type === 'textarea' ? 'el-textarea' : 'el-input',
  _vm.inputSize ? 'el-input--' + _vm.inputSize : '',
  {
    'is-disabled': _vm.disabled,
    'el-input-group': _vm.$slots.prepend || _vm.$slots.append,
    'el-input-group--append': _vm.$slots.append,
    'el-input-group--prepend': _vm.$slots.prepend,
    'el-input--prefix': _vm.$slots.prefix || _vm.prefixIcon,
    'el-input--suffix': _vm.$slots.suffix || _vm.suffixIcon
  }
]},[(_vm.type !== 'textarea')?[(_vm.$slots.prepend)?_c('div',{staticClass:"el-input-group__prepend",attrs:{"tabindex":"0"}},[_vm._t("prepend")],2):_vm._e(),(_vm.type !== 'textarea')?_c('input',_vm._b({ref:"input",staticClass:"el-input__inner",attrs:{"autocomplete":_vm.autoComplete,"aria-label":_vm.label},domProps:{"value":_vm.currentValue},on:{"input":_vm.handleInput,"focus":_vm.handleFocus,"blur":_vm.handleBlur,"change":_vm.handleChange}},'input',_vm.$props,false)):_vm._e(),(_vm.$slots.prefix || _vm.prefixIcon)?_c('span',{staticClass:"el-input__prefix",style:(_vm.prefixOffset)},[_vm._t("prefix"),(_vm.prefixIcon)?_c('i',{staticClass:"el-input__icon",class:_vm.prefixIcon}):_vm._e()],2):_vm._e(),(_vm.$slots.suffix || _vm.suffixIcon || _vm.validateState && _vm.needStatusIcon)?_c('span',{staticClass:"el-input__suffix",style:(_vm.suffixOffset)},[_c('span',{staticClass:"el-input__suffix-inner"},[_vm._t("suffix"),(_vm.suffixIcon)?_c('i',{staticClass:"el-input__icon",class:_vm.suffixIcon}):_vm._e()],2),(_vm.validateState)?_c('i',{staticClass:"el-input__icon",class:['el-input__validateIcon', _vm.validateIcon]}):_vm._e()]):_vm._e(),(_vm.$slots.append)?_c('div',{staticClass:"el-input-group__append"},[_vm._t("append")],2):_vm._e()]:_c('textarea',_vm._b({ref:"textarea",staticClass:"el-textarea__inner",style:(_vm.textareaStyle),attrs:{"aria-label":_vm.label},domProps:{"value":_vm.currentValue},on:{"input":_vm.handleInput,"focus":_vm.handleFocus,"blur":_vm.handleBlur,"change":_vm.handleChange}},'textarea',_vm.$props,false))],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = __webpack_require__("TI6a");

/***/ })

/******/ });

/***/ }),

/***/ "Ldwu":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return $; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return removeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return toggleClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return attr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return removeAttr; });
/* unused harmony export prop */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return data; });
/* unused harmony export removeData */
/* unused harmony export dataset */
/* unused harmony export val */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return off; });
/* unused harmony export once */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return trigger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return transitionEnd; });
/* unused harmony export animationEnd */
/* unused harmony export width */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return outerWidth; });
/* unused harmony export height */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return offset; });
/* unused harmony export hide */
/* unused harmony export show */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return styles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return css; });
/* unused harmony export toArray */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return each; });
/* unused harmony export forEach */
/* unused harmony export filter */
/* unused harmony export map */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return html; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return is; });
/* unused harmony export indexOf */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return index; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return eq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return append; });
/* unused harmony export appendTo */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return prepend; });
/* unused harmony export prependTo */
/* unused harmony export insertBefore */
/* unused harmony export insertAfter */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return next; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return nextAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return prev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return prevAll; });
/* unused harmony export siblings */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return parent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return parents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return closest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return children; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return remove; });
/* unused harmony export detach */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return add; });
/* unused harmony export empty */
/* unused harmony export scrollTo */
/* unused harmony export scrollTop */
/* unused harmony export scrollLeft */
/* unused harmony export animate */
/* unused harmony export stop */
/* unused harmony export click */
/* unused harmony export blur */
/* unused harmony export focus */
/* unused harmony export focusin */
/* unused harmony export focusout */
/* unused harmony export keyup */
/* unused harmony export keydown */
/* unused harmony export keypress */
/* unused harmony export submit */
/* unused harmony export change */
/* unused harmony export mousedown */
/* unused harmony export mousemove */
/* unused harmony export mouseup */
/* unused harmony export mouseenter */
/* unused harmony export mouseleave */
/* unused harmony export mouseout */
/* unused harmony export mouseover */
/* unused harmony export touchstart */
/* unused harmony export touchend */
/* unused harmony export touchmove */
/* unused harmony export resize */
/* unused harmony export scroll */
/**
 * Dom7 2.0.1
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * http://framework7.io/docs/dom.html
 *
 * Copyright 2017, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: October 2, 2017
 */
class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = document.createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [document.getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || document).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === window || selector === document) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$.fn = Dom7.prototype;
$.Class = Dom7;
$.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
}

function requestAnimationFrame(callback) {
  if (window.requestAnimationFrame) return window.requestAnimationFrame(callback);
  else if (window.webkitRequestAnimationFrame) return window.webkitRequestAnimationFrame(callback);
  return window.setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(id) {
  if (window.cancelAnimationFrame) return window.cancelAnimationFrame(id);
  else if (window.webkitCancelAnimationFrame) return window.webkitCancelAnimationFrame(id);
  return window.clearTimeout(id);
}

// Classes and attributes
function addClass(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
// eslint-disable-next-line
function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        // eslint-disable-next-line
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
}
function data(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line
  if (el.dataset) {
    // eslint-disable-next-line
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      // eslint-disable-next-line
      const attr = el.attributes[i];
      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }
  // eslint-disable-next-line
  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;
    else if (dataset[key] === 'true') dataset[key] = true;
    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }
  return dataset;
}
function val(value) {
  if (typeof value === 'undefined') {
    if (this[0]) {
      if (this[0].multiple && this[0].nodeName.toLowerCase() === 'select') {
        const values = [];
        for (let i = 0; i < this[0].selectedOptions.length; i += 1) {
          values.push(this[0].selectedOptions[i].value);
        }
        return values;
      }
      return this[0].value;
    }
    return undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].value = value;
  }
  return this;
}
// Transforms
// eslint-disable-next-line
function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    eventData.unshift(e);
    if ($(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    eventData.unshift(e);
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        if (!el.dom7Listeners) el.dom7Listeners = [];
        el.dom7Listeners.push({
          type: eventType,
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(events[j], handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        if (!el.dom7LiveListeners) el.dom7LiveListeners = [];
        el.dom7LiveListeners.push({
          type: eventType,
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(events[j], handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      if (!targetSelector) {
        if (el.dom7Listeners) {
          for (let k = 0; k < el.dom7Listeners.length; k += 1) {
            if (listener) {
              if (el.dom7Listeners[k].listener === listener) {
                el.removeEventListener(events[i], el.dom7Listeners[k].proxyListener, capture);
              }
            } else if (el.dom7Listeners[k].type === events[i]) {
              el.removeEventListener(events[i], el.dom7Listeners[k].proxyListener, capture);
            }
          }
        }
      } else if (el.dom7LiveListeners) {
        for (let k = 0; k < el.dom7LiveListeners.length; k += 1) {
          if (listener) {
            if (el.dom7LiveListeners[k].listener === listener) {
              el.removeEventListener(events[i], el.dom7LiveListeners[k].proxyListener, capture);
            }
          } else if (el.dom7LiveListeners[k].type === events[i]) {
            el.removeEventListener(events[i], el.dom7LiveListeners[k].proxyListener, capture);
          }
        }
      }
    }
  }
  return this;
}
function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }
  function proxy(e) {
    const eventData = e.target.dom7EventData || [];
    listener.apply(this, eventData);
    dom.off(eventName, targetSelector, proxy, capture);
  }
  return dom.on(eventName, targetSelector, proxy, capture);
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      let evt;
      try {
        evt = new window.CustomEvent(events[i], {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = document.createEvent('Event');
        evt.initEvent(events[i], true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      this[j].dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      this[j].dispatchEvent(evt);
      this[j].dom7EventData = [];
      delete this[j].dom7EventData;
    }
  }
  return this;
}
function transitionEnd(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function animationEnd(callback) {
  const events = ['webkitAnimationEnd', 'animationend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
// Sizing/Styles
function width() {
  if (this[0] === window) {
    return window.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  if (this[0] === window) {
    return window.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = document.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window ? window.scrollY : el.scrollTop;
    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }
  return this;
}
function show() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.style.display === 'none') {
      el.style.display = '';
    }
    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }
  return this;
}
function styles() {
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}

// Dom manipulation
function toArray() {
  const arr = [];
  for (let i = 0; i < this.length; i += 1) {
    arr.push(this[i]);
  }
  return arr;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function forEach(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], this[i], i) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
function map(callback) {
  const modifiedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    modifiedItems.push(callback.call(dom[i], i, dom[i]));
  }
  return new Dom7(modifiedItems);
}
// eslint-disable-next-line
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === document) return el === document;
  else if (selector === window) return el === window;

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function indexOf(el) {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i] === el) return i;
  }
  return -1;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
 // eslint-disable-next-line
function appendTo(parent) {
  $(parent).append(this);
  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
 // eslint-disable-next-line
function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}
function insertBefore(selector) {
  const before = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  const after = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $(unique(parents));
}
function closest(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}
function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = '';
    }
  }
  return this;
}

function scrollTo(...args) {
  let [left, top, duration, easing, callback] = args;
  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }
  if (typeof easing === 'undefined') easing = 'swing';

  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line
    let scrollLeft; // eslint-disable-line
    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;
    if (typeof easing === 'undefined') {
      easing = 'swing';
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
      let done;
      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  });
}
// scrollTop(top, duration, easing, callback) {
function scrollTop(...args) {
  let [top, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(undefined, top, duration, easing, callback);
}
function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, undefined, duration, easing, callback);
}

function animate(initialProps, initialParams) {
  const els = this;
  const a = {
    props: $.extend({}, initialProps),
    params: $.extend({
      duration: 300,
      easing: 'swing', // or 'linear'
      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),

    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - (Math.cos(progress * Math.PI) / 2);
      }
      if (typeof easing === 'function') {
        return easing(progress);
      }
      return progress;
    },
    stop() {
      if (a.frameId) {
        cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done(complete) {
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      const elements = [];

      // Define & Cache Initials & Units
      a.elements.each((index, el) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;

        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;

        elements[index] = {
          container: el,
        };
        Object.keys(props).forEach((prop) => {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue,
          };
        });
      });

      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;

      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress;
        // let el;
        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
        }

        elements.forEach((element) => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach((prop) => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const { initialValue, finalValue, unit } = el[prop];
            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
            const currentValue = el[prop].currentValue;

            if (
              (finalValue > initialValue && currentValue >= finalValue) ||
              (finalValue < initialValue && currentValue <= finalValue)) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return;
        // Then call
        a.frameId = requestAnimationFrame(render);
      }
      a.frameId = requestAnimationFrame(render);
      return a;
    },
  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;
  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;
  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

const noTrigger = ('resize scroll').split(' ');
function eventShortcut(name, ...args) {
  if (typeof args[0] === 'undefined') {
    for (let i = 0; i < this.length; i += 1) {
      if (noTrigger.indexOf(name) < 0) {
        if (name in this[i]) this[i][name]();
        else {
          $(this[i]).trigger(name);
        }
      }
    }
    return this;
  }
  return this.on(name, ...args);
}

function click(...args) {
  return eventShortcut.bind(this)('click', ...args);
}
function blur(...args) {
  return eventShortcut.bind(this)('blur', ...args);
}
function focus(...args) {
  return eventShortcut.bind(this)('focus', ...args);
}
function focusin(...args) {
  return eventShortcut.bind(this)('focusin', ...args);
}
function focusout(...args) {
  return eventShortcut.bind(this)('focusout', ...args);
}
function keyup(...args) {
  return eventShortcut.bind(this)('keyup', ...args);
}
function keydown(...args) {
  return eventShortcut.bind(this)('keydown', ...args);
}
function keypress(...args) {
  return eventShortcut.bind(this)('keypress', ...args);
}
function submit(...args) {
  return eventShortcut.bind(this)('submit', ...args);
}
function change(...args) {
  return eventShortcut.bind(this)('change', ...args);
}
function mousedown(...args) {
  return eventShortcut.bind(this)('mousedown', ...args);
}
function mousemove(...args) {
  return eventShortcut.bind(this)('mousemove', ...args);
}
function mouseup(...args) {
  return eventShortcut.bind(this)('mouseup', ...args);
}
function mouseenter(...args) {
  return eventShortcut.bind(this)('mouseenter', ...args);
}
function mouseleave(...args) {
  return eventShortcut.bind(this)('mouseleave', ...args);
}
function mouseout(...args) {
  return eventShortcut.bind(this)('mouseout', ...args);
}
function mouseover(...args) {
  return eventShortcut.bind(this)('mouseover', ...args);
}
function touchstart(...args) {
  return eventShortcut.bind(this)('touchstart', ...args);
}
function touchend(...args) {
  return eventShortcut.bind(this)('touchend', ...args);
}
function touchmove(...args) {
  return eventShortcut.bind(this)('touchmove', ...args);
}
function resize(...args) {
  return eventShortcut.bind(this)('resize', ...args);
}
function scroll(...args) {
  return eventShortcut.bind(this)('scroll', ...args);
}




/***/ }),

/***/ "LniK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("MGEp")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("ExXN")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "Lohu":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("fHSC");
var IE8_DOM_DEFINE = __webpack_require__("esV0");
var toPrimitive = __webpack_require__("7qHl");
var dP = Object.defineProperty;

exports.f = __webpack_require__("PRM/") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "M8Yd":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "M8k9":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("9goP");
var gOPS = __webpack_require__("BWjf");
var pIE = __webpack_require__("ex+5");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "MD5c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* Modified from https://github.com/sdecima/javascript-detect-element-resize
 * version: 0.5.3
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Sebastián Décima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
var isServer = typeof window === 'undefined';

/* istanbul ignore next */
var requestFrame = function () {
  if (isServer) return;
  var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
    return window.setTimeout(fn, 20);
  };
  return function (fn) {
    return raf(fn);
  };
}();

/* istanbul ignore next */
var cancelFrame = function () {
  if (isServer) return;
  var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
  return function (id) {
    return cancel(id);
  };
}();

/* istanbul ignore next */
var resetTrigger = function resetTrigger(element) {
  var trigger = element.__resizeTrigger__;
  var expand = trigger.firstElementChild;
  var contract = trigger.lastElementChild;
  var expandChild = expand.firstElementChild;

  contract.scrollLeft = contract.scrollWidth;
  contract.scrollTop = contract.scrollHeight;
  expandChild.style.width = expand.offsetWidth + 1 + 'px';
  expandChild.style.height = expand.offsetHeight + 1 + 'px';
  expand.scrollLeft = expand.scrollWidth;
  expand.scrollTop = expand.scrollHeight;
};

/* istanbul ignore next */
var checkTriggers = function checkTriggers(element) {
  return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
};

/* istanbul ignore next */
var scrollListener = function scrollListener(event) {
  var _this = this;

  resetTrigger(this);
  if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
  this.__resizeRAF__ = requestFrame(function () {
    if (checkTriggers(_this)) {
      _this.__resizeLast__.width = _this.offsetWidth;
      _this.__resizeLast__.height = _this.offsetHeight;
      _this.__resizeListeners__.forEach(function (fn) {
        fn.call(_this, event);
      });
    }
  });
};

/* Detect CSS Animations support to detect element display/re-attach */
var attachEvent = isServer ? {} : document.attachEvent;
var DOM_PREFIXES = 'Webkit Moz O ms'.split(' ');
var START_EVENTS = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' ');
var RESIZE_ANIMATION_NAME = 'resizeanim';
var animation = false;
var keyFramePrefix = '';
var animationStartEvent = 'animationstart';

/* istanbul ignore next */
if (!attachEvent && !isServer) {
  var testElement = document.createElement('fakeelement');
  if (testElement.style.animationName !== undefined) {
    animation = true;
  }

  if (animation === false) {
    var prefix = '';
    for (var i = 0; i < DOM_PREFIXES.length; i++) {
      if (testElement.style[DOM_PREFIXES[i] + 'AnimationName'] !== undefined) {
        prefix = DOM_PREFIXES[i];
        keyFramePrefix = '-' + prefix.toLowerCase() + '-';
        animationStartEvent = START_EVENTS[i];
        animation = true;
        break;
      }
    }
  }
}

var stylesCreated = false;
/* istanbul ignore next */
var createStyles = function createStyles() {
  if (!stylesCreated && !isServer) {
    var animationKeyframes = '@' + keyFramePrefix + 'keyframes ' + RESIZE_ANIMATION_NAME + ' { from { opacity: 0; } to { opacity: 0; } } ';
    var animationStyle = keyFramePrefix + 'animation: 1ms ' + RESIZE_ANIMATION_NAME + ';';

    // opacity: 0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
    var css = animationKeyframes + '\n      .resize-triggers { ' + animationStyle + ' visibility: hidden; opacity: 0; }\n      .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1 }\n      .resize-triggers > div { background: #eee; overflow: auto; }\n      .contract-trigger:before { width: 200%; height: 200%; }';

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');

    style.type = 'text/css';
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }

    head.appendChild(style);
    stylesCreated = true;
  }
};

/* istanbul ignore next */
var addResizeListener = exports.addResizeListener = function addResizeListener(element, fn) {
  if (isServer) return;
  if (attachEvent) {
    element.attachEvent('onresize', fn);
  } else {
    if (!element.__resizeTrigger__) {
      if (getComputedStyle(element).position === 'static') {
        element.style.position = 'relative';
      }
      createStyles();
      element.__resizeLast__ = {};
      element.__resizeListeners__ = [];

      var resizeTrigger = element.__resizeTrigger__ = document.createElement('div');
      resizeTrigger.className = 'resize-triggers';
      resizeTrigger.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
      element.appendChild(resizeTrigger);

      resetTrigger(element);
      element.addEventListener('scroll', scrollListener, true);

      /* Listen for a css animation to detect element display/re-attach */
      if (animationStartEvent) {
        resizeTrigger.addEventListener(animationStartEvent, function (event) {
          if (event.animationName === RESIZE_ANIMATION_NAME) {
            resetTrigger(element);
          }
        });
      }
    }
    element.__resizeListeners__.push(fn);
  }
};

/* istanbul ignore next */
var removeResizeListener = exports.removeResizeListener = function removeResizeListener(element, fn) {
  if (!element || !element.__resizeListeners__) return;
  if (attachEvent) {
    element.detachEvent('onresize', fn);
  } else {
    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
    if (!element.__resizeListeners__.length) {
      element.removeEventListener('scroll', scrollListener);
      element.__resizeTrigger__ = !element.removeChild(element.__resizeTrigger__);
    }
  }
};

/***/ }),

/***/ "MGEp":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("IcQ3");
var defined = __webpack_require__("30Io");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "MVSX":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.5.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (false) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.functionalOptions = undefined;
  this.functionalScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode, deep) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  if (deep && vnode.children) {
    cloned.children = cloneVNodes(vnode.children);
  }
  return cloned
}

function cloneVNodes (vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "production" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (false) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (false) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (false) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (false) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (false) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (false) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if (inBrowser && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (false) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "production" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                 false
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      data && data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (false) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (false) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (false) {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (false) {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject).filter(function (key) {
          /* istanbul ignore next */
          return Object.getOwnPropertyDescriptor(inject, key).enumerable
        })
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (false) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (false) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "production" !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias,
  eventKeyName
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1
    } else {
      return keyCodes !== eventKeyCode
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  // static trees can be rendered once and cached on the contructor options
  // so every instance shares the same cached trees
  var renderFns = this.$options.staticRenderFns;
  var cached = renderFns.cached || (renderFns.cached = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = renderFns[index].call(this._renderProxy, null, this);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.functionalScopeId = options._scopeId;
        vnode.functionalContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.functionalContext = contextVm;
    vnode.functionalOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "production" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (false) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid$1 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (false) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (false
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (false) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && cached$$1 !== current) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }

      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (false) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.5.2';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "production" !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(
            config.ignoredElements.length &&
            config.ignoredElements.some(function (ignore) {
              return isRegExp(ignore)
                ? ignore.test(tag)
                : ignore === tag
            })
          ) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.functionalScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.functionalContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (false) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    if (false) {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false
              ) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false
              ) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (false) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE9 || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

function baseWarn (msg) {
  console.error(("[Vue compiler]: " + msg));
}

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr (el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    false
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    );
  }
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers && modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
        "? " + baseValueExpression + ".trim()" +
        ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: ("\"" + value + "\""),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;



function parseModel (val) {
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (false) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead."
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (false) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
      "?_i(" + value + "," + valueBinding + ")>-1" + (
        trueValueBinding === 'true'
          ? (":(" + value + ")")
          : (":_q(" + value + "," + trueValueBinding + ")")
      )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" +
      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal)
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (false) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (false) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "production" !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (false) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (false
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (false) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (false
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode (content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\"/>";
  return div.innerHTML.indexOf(encoded) > 0
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});

function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+')
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (false) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (false) {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!--([\s\S]*?)-->/g, '$1')
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (false) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3]; }
        if (args[4] === '') { delete args[4]; }
        if (args[5] === '') { delete args[5]; }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(
          value,
          options.shouldDecodeNewlines
        )
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (false
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;



function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre (element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldKeepComment: options.comments,
    start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "production" !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.'
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints (el) {
        if (false) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              "Cannot use <" + (el.tag) + "> as component root element because it may " +
              'contain multiple nodes.'
            );
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            );
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (false) {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead."
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {
        postTransforms[i$1](element, options);
      }
    },

    end: function end () {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars (text) {
      if (!currentParent) {
        if (false) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored.")
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment (text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (false) {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      "production" !== 'production' && warn$2(
        ("Invalid v-for expression: " + exp)
      );
      return
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (false) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if."
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if (false) {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored."
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (false) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead."
      );
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if (false) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (!el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(
              el,
              ("update:" + (camelize(name))),
              genAssignmentCode(value, "$event")
            );
          }
        }
        if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (false) {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (false) {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          );
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      false
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead."
      );
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
      var typeBinding = getBindingAttr(el, 'type');
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });
      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

function addRawAttr (el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

var model$2 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$2
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative,
  warn
) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    var handler = events[name];
    // #5330: warn click.right, since right clicks do not actually fire click events.
    if (false
    ) {
      warn(
        "Use \"contextmenu\" instead of \"click.right\" since right clicks " +
        "do not actually fire \"click\" events."
      );
    }
    res += "\"" + name + "\":" + (genHandler(name, handler)) + ",";
  }
  return res.slice(0, -1) + '}'
}

function genHandler (
  name,
  handler
) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression
      ? handler.value
      : ("function($event){" + (handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? handler.value + '($event)'
      : isFunctionExpression
        ? ("(" + (handler.value) + ")($event)")
        : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var code = keyCodes[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(code)) + "," +
    "$event.key)"
  )
}

/*  */

function on (el, dir) {
  if (false) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      "production" !== 'production' && state.warn(
        "v-once can only be used inside v-for that is keyed. "
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if (false
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + (genProps(el.attrs)) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + (genProps(el.props)) + "},";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false, state.warn)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true, state.warn)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if (false) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  slots,
  state
) {
  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state)
    }).join(',')) + "])")
}

function genScopedSlot (
  key,
  el,
  state
) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state)
  }
  var fn = "function(" + (String(el.slotScope)) + "){" +
    "return " + (el.tag === 'template'
      ? el.if
        ? ((el.if) + "?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  return ("{key:" + key + ",fn:" + fn + "}")
}

function genForScopedSlot (
  key,
  el,
  state
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + (genScopedSlot(key, el, state)) +
    '})'
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el$1, state)
    }
    var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
  }
  return res.slice(0, -1)
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors
}

function checkNode (node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), errors);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), errors);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent (exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
    );
  }
  checkExpression(exp, text, errors);
}

function checkFor (node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier (ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
  }
}

function checkExpression (exp, text, errors) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim())
      );
    } else {
      errors.push(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n"
      );
    }
  }
}

/*  */

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (false) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (false) {
      if (compiled.errors && compiled.errors.length) {
        warn$$1(
          "Error compiling template:\n\n" + template + "\n\n" +
          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
          vm
        );
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (false) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (false) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "production" !== 'production' && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (false) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (false) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (false) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (false) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue$3.compile = compileToFunctions;

/* harmony default export */ __webpack_exports__["a"] = (Vue$3);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("QYmj"), __webpack_require__("nARF").setImmediate))

/***/ }),

/***/ "NN3v":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("tNH9");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "NU3K":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("IcQ3");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "O1yE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      prevYear: '前一年',
      nextYear: '后一年',
      prevMonth: '上个月',
      nextMonth: '下个月',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择'
    },
    pagination: {
      goto: '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      deleteTip: '按 delete 键可删除',
      delete: '删除',
      preview: '查看图片',
      continue: '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    }
  }
};

/***/ }),

/***/ "PRM/":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("YEmw")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "PTA0":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("Lohu");
var anObject = __webpack_require__("fHSC");
var getKeys = __webpack_require__("9goP");

module.exports = __webpack_require__("PRM/") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "QFRh":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("IFGh");


/***/ }),

/***/ "QYmj":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "RpWK":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (method);

/***/ }),

/***/ "SGE9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__string__ = __webpack_require__("aWoT");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__method__ = __webpack_require__("RpWK");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__("nkWw");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__boolean__ = __webpack_require__("K1PJ");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__regexp__ = __webpack_require__("Ubre");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__integer__ = __webpack_require__("sy5a");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__float__ = __webpack_require__("BtJh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__array__ = __webpack_require__("kDLO");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__object__ = __webpack_require__("C4gf");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__enum__ = __webpack_require__("U+TQ");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pattern__ = __webpack_require__("qLlb");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__date__ = __webpack_require__("26oO");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__required__ = __webpack_require__("b9OQ");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__type__ = __webpack_require__("e4BB");















/* harmony default export */ __webpack_exports__["a"] = ({
  string: __WEBPACK_IMPORTED_MODULE_0__string__["a" /* default */],
  method: __WEBPACK_IMPORTED_MODULE_1__method__["a" /* default */],
  number: __WEBPACK_IMPORTED_MODULE_2__number__["a" /* default */],
  boolean: __WEBPACK_IMPORTED_MODULE_3__boolean__["a" /* default */],
  regexp: __WEBPACK_IMPORTED_MODULE_4__regexp__["a" /* default */],
  integer: __WEBPACK_IMPORTED_MODULE_5__integer__["a" /* default */],
  float: __WEBPACK_IMPORTED_MODULE_6__float__["a" /* default */],
  array: __WEBPACK_IMPORTED_MODULE_7__array__["a" /* default */],
  object: __WEBPACK_IMPORTED_MODULE_8__object__["a" /* default */],
  'enum': __WEBPACK_IMPORTED_MODULE_9__enum__["a" /* default */],
  pattern: __WEBPACK_IMPORTED_MODULE_10__pattern__["a" /* default */],
  date: __WEBPACK_IMPORTED_MODULE_11__date__["a" /* default */],
  url: __WEBPACK_IMPORTED_MODULE_13__type__["a" /* default */],
  hex: __WEBPACK_IMPORTED_MODULE_13__type__["a" /* default */],
  email: __WEBPACK_IMPORTED_MODULE_13__type__["a" /* default */],
  required: __WEBPACK_IMPORTED_MODULE_12__required__["a" /* default */]
});

/***/ }),

/***/ "SZqL":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("AsM0");
var toObject = __webpack_require__("+rd1");
var IE_PROTO = __webpack_require__("qq67")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "Snuj":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 117);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = __webpack_require__("xp85");

/***/ }),

/***/ 117:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(118);


/***/ }),

/***/ 118:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _inputNumber = __webpack_require__(119);

var _inputNumber2 = _interopRequireDefault(_inputNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_inputNumber2.default.install = function (Vue) {
  Vue.component(_inputNumber2.default.name, _inputNumber2.default);
};

exports.default = _inputNumber2.default;

/***/ }),

/***/ 119:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d07efb5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_number_vue__ = __webpack_require__(121);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d07efb5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_number_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 120:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _debounce = __webpack_require__(13);

var _debounce2 = _interopRequireDefault(_debounce);

var _focus = __webpack_require__(11);

var _focus2 = _interopRequireDefault(_focus);

var _repeatClick = __webpack_require__(23);

var _repeatClick2 = _interopRequireDefault(_repeatClick);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElInputNumber',
  mixins: [(0, _focus2.default)('input')],
  inject: {
    elFormItem: {
      default: ''
    }
  },
  directives: {
    repeatClick: _repeatClick2.default
  },
  components: {
    ElInput: _input2.default
  },
  props: {
    step: {
      type: Number,
      default: 1
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    value: {
      default: 0
    },
    disabled: Boolean,
    size: String,
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ''
    },
    debounce: {
      type: Number,
      default: 300
    },
    name: String,
    label: String
  },
  data: function data() {
    return {
      currentValue: 0
    };
  },

  watch: {
    value: {
      immediate: true,
      handler: function handler(value) {
        var newVal = Number(value);
        if (isNaN(newVal)) return;
        if (newVal >= this.max) newVal = this.max;
        if (newVal <= this.min) newVal = this.min;
        this.currentValue = newVal;
        this.$emit('input', newVal);
      }
    }
  },
  computed: {
    minDisabled: function minDisabled() {
      return this._decrease(this.value, this.step) < this.min;
    },
    maxDisabled: function maxDisabled() {
      return this._increase(this.value, this.step) > this.max;
    },
    precision: function precision() {
      var value = this.value,
          step = this.step,
          getPrecision = this.getPrecision;

      return Math.max(getPrecision(value), getPrecision(step));
    },
    controlsAtRight: function controlsAtRight() {
      return this.controlsPosition === 'right';
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    inputNumberSize: function inputNumberSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },
  methods: {
    toPrecision: function toPrecision(num, precision) {
      if (precision === undefined) precision = this.precision;
      return parseFloat(parseFloat(Number(num).toFixed(precision)));
    },
    getPrecision: function getPrecision(value) {
      var valueString = value.toString();
      var dotPosition = valueString.indexOf('.');
      var precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    },
    _increase: function _increase(val, step) {
      if (typeof val !== 'number') return this.currentValue;

      var precisionFactor = Math.pow(10, this.precision);

      return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
    },
    _decrease: function _decrease(val, step) {
      if (typeof val !== 'number') return this.currentValue;

      var precisionFactor = Math.pow(10, this.precision);

      return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
    },
    increase: function increase() {
      if (this.disabled || this.maxDisabled) return;
      var value = this.value || 0;
      var newVal = this._increase(value, this.step);
      if (newVal > this.max) return;
      this.setCurrentValue(newVal);
    },
    decrease: function decrease() {
      if (this.disabled || this.minDisabled) return;
      var value = this.value || 0;
      var newVal = this._decrease(value, this.step);
      if (newVal < this.min) return;
      this.setCurrentValue(newVal);
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
      this.$refs.input.setCurrentValue(this.currentValue);
    },
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },
    setCurrentValue: function setCurrentValue(newVal) {
      var oldVal = this.currentValue;
      if (newVal >= this.max) newVal = this.max;
      if (newVal <= this.min) newVal = this.min;
      if (oldVal === newVal) {
        this.$refs.input.setCurrentValue(this.currentValue);
        return;
      }
      this.$emit('change', newVal, oldVal);
      this.$emit('input', newVal);
      this.currentValue = newVal;
    },
    handleInput: function handleInput(value) {
      if (value === '') {
        return;
      }

      if (value.indexOf('.') === value.length - 1) {
        return;
      }

      if (value.indexOf('-') === value.length - 1) {
        return;
      }

      var newVal = Number(value);
      if (!isNaN(newVal)) {
        this.setCurrentValue(newVal);
      } else {
        this.$refs.input.setCurrentValue(this.currentValue);
      }
    }
  },
  created: function created() {
    var _this = this;

    this.debounceHandleInput = (0, _debounce2.default)(this.debounce, function (value) {
      _this.handleInput(value);
    });
  },
  mounted: function mounted() {
    var innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('role', 'spinbutton');
    innerInput.setAttribute('aria-valuemax', this.max);
    innerInput.setAttribute('aria-valuemin', this.min);
    innerInput.setAttribute('aria-valuenow', this.currentValue);
    innerInput.setAttribute('aria-disabled', this.disabled);
  },
  updated: function updated() {
    var innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('aria-valuenow', this.currentValue);
  }
};

/***/ }),

/***/ 121:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-input-number",class:[
    _vm.inputNumberSize ? 'el-input-number--' + _vm.inputNumberSize : '',
    { 'is-disabled': _vm.disabled },
    { 'is-without-controls': !_vm.controls },
    { 'is-controls-right': _vm.controlsAtRight }
  ]},[(_vm.controls)?_c('span',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-input-number__decrease",class:{'is-disabled': _vm.minDisabled},attrs:{"role":"button"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.decrease($event)}}},[_c('i',{class:("el-icon-" + (_vm.controlsAtRight ? 'arrow-down' : 'minus'))})]):_vm._e(),(_vm.controls)?_c('span',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-input-number__increase",class:{'is-disabled': _vm.maxDisabled},attrs:{"role":"button"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.increase($event)}}},[_c('i',{class:("el-icon-" + (_vm.controlsAtRight ? 'arrow-up' : 'plus'))})]):_vm._e(),_c('el-input',{ref:"input",attrs:{"value":_vm.currentValue,"disabled":_vm.disabled,"size":_vm.inputNumberSize,"max":_vm.max,"min":_vm.min,"name":_vm.name,"label":_vm.label},on:{"blur":_vm.handleBlur,"focus":_vm.handleFocus,"input":_vm.debounceHandleInput},nativeOn:{"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.increase($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.decrease($event)}]}},[(_vm.$slots.prepend)?_c('template',{attrs:{"slot":"prepend"},slot:"prepend"},[_vm._t("prepend")],2):_vm._e(),(_vm.$slots.append)?_c('template',{attrs:{"slot":"append"},slot:"append"},[_vm._t("append")],2):_vm._e()],2)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),

/***/ 13:
/***/ (function(module, exports) {

module.exports = __webpack_require__("x018");

/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

exports.default = {
  bind: function bind(el, binding, vnode) {
    var interval = null;
    var startTime = void 0;
    var handler = function handler() {
      return vnode.context[binding.expression].apply();
    };
    var clear = function clear() {
      if (new Date() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };

    (0, _dom.on)(el, 'mousedown', function (e) {
      if (e.button !== 0) return;
      startTime = new Date();
      (0, _dom.once)(document, 'mouseup', clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
};

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("6d3N");

/***/ }),

/***/ 6:
/***/ (function(module, exports) {

module.exports = __webpack_require__("L88V");

/***/ })

/******/ });

/***/ }),

/***/ "TI6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */
exports.default = {
  mounted: function mounted() {
    if (true) return;
    if (!this.$vnode) return;

    var _getMigratingConfig = this.getMigratingConfig(),
        _getMigratingConfig$p = _getMigratingConfig.props,
        props = _getMigratingConfig$p === undefined ? {} : _getMigratingConfig$p,
        _getMigratingConfig$e = _getMigratingConfig.events,
        events = _getMigratingConfig$e === undefined ? {} : _getMigratingConfig$e;

    var _$vnode = this.$vnode,
        data = _$vnode.data,
        componentOptions = _$vnode.componentOptions;

    var definedProps = data.attrs || {};
    var definedEvents = componentOptions.listeners || {};

    for (var propName in definedProps) {
      if (definedProps.hasOwnProperty(propName) && props[propName]) {
        console.warn('[Element Migrating][' + this.$options.name + '][Attribute]: ' + props[propName]);
      }
    }

    for (var eventName in definedEvents) {
      if (definedEvents.hasOwnProperty(eventName) && events[eventName]) {
        console.warn('[Element Migrating][' + this.$options.name + '][Event]: ' + events[eventName]);
      }
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {},
        events: {}
      };
    }
  }
};

/***/ }),

/***/ "TUEb":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "U+TQ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");


var ENUM = 'enum';

/**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function enumerable(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */][ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (enumerable);

/***/ }),

/***/ "U4OO":
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VueEventCalendar"] = factory();
	else
		root["VueEventCalendar"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = dateTimeFormatter;
/* harmony export (immutable) */ __webpack_exports__["a"] = isEqualDateStr;
function dateTimeFormatter(date, format) {
  // 时间格式化辅助函数 date:毫秒数 format:'yyyy-MM-dd hh:mm:ss'
  if (!date || date == "") {
    return "";
  }

  if (typeof date === "string") {
    var mts = date.match(/(\/Date\((\d+)\)\/)/);
    if (mts && mts.length >= 3) {
      date = parseInt(mts[2]);
    }
  }

  date = new Date(date);
  if (!date || date.toUTCString() == "Invalid Date") {
    return "";
  }

  var map = {
    "M": date.getMonth() + 1, //月份
    "d": date.getDate(), //日
    "h": date.getHours(), //小时
    "m": date.getMinutes(), //分
    "s": date.getSeconds(), //秒
    "q": Math.floor((date.getMonth() + 3) / 3), //季度
    "S": date.getMilliseconds() //毫秒
  };

  format = format.replace(/([yMdhmsqS])+/g, function (all, t) {
    var v = map[t];
    if (v !== undefined) {
      if (all.length > 1) {
        v = '0' + v;
        v = v.substr(v.length - 2);
      }
      return v;
    } else if (t === 'y') {
      return (date.getFullYear() + '').substr(4 - all.length);
    }
    return all;
  });

  return format;
}
function isEqualDateStr(dateStr1, dateStr2) {
  var dateArr1 = dateStr1.split('/');
  var dateArr2 = dateStr2.split('/');
  if (parseInt(dateArr1[0], 10) !== parseInt(dateArr2[0], 10)) {
    return false;
  }
  if (parseInt(dateArr1[1], 10) !== parseInt(dateArr2[1], 10)) {
    return false;
  }
  if (parseInt(dateArr1[2], 10) !== parseInt(dateArr2[2], 10)) {
    return false;
  }
  return true;
}

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = options.computed || (options.computed = {})
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  en: {
    dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'All Events',
    notHaveEvents: 'Not Have Events'
  },
  zh: {
    dayNames: ["日", "一", "二", "三", "四", "五", "六"],
    monthNames: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    format: 'yyyy年MM月',
    fullFormat: 'yyyy年MM月dd日',
    dayEventsTitle: '全部事件',
    notHaveEvents: '没有事件'
  },
  us: {
    dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    format: 'MM/yyyy',
    fullFormat: 'MM/dd/yyyy',
    dayEventsTitle: 'All Events',
    notHaveEvents: 'Not Have Events'
  },
  es: {
    dayNames: ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sá"],
    monthNames: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Todos los eventos',
    notHaveEvents: 'Nada'
  },
  'pt-br': {
    dayNames: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
    monthNames: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Todos os eventos',
    notHaveEvents: 'Nenhum evento'
  },
  ja: {
    dayNames: ["日", "月", "火", "水", "木", "金", "土"],
    monthNames: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    format: 'yyyy/MM',
    fullFormat: 'yyyy/MM/dd',
    dayEventsTitle: '全てのイベント',
    notHaveEvents: 'イベントはありません'
  },
  ko: {
    dayNames: ["일", "월", "화", "수", "목", "금", "토"],
    monthNames: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
    format: 'yyyy/MM',
    fullFormat: 'yyyy/MM/dd',
    dayEventsTitle: '모든 이벤트',
    notHaveEvents: '일정이 없습니다'
  },
  fr: {
    dayNames: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
    monthNames: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Tous les événements',
    notHaveEvents: 'Aucun événement'
  },
  it: {
    dayNames: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
    monthNames: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Tutti gli eventi',
    notHaveEvents: 'Nessun evento'
  },
  ru: {
    dayNames: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
    monthNames: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Все события',
    notHaveEvents: 'События отсутствуют'
  },
  sv: {
    dayNames: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
    monthNames: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Alla händelser',
    notHaveEvents: 'Inga händelser'
  },
  de: {
    dayNames: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    monthNames: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
    format: 'MM/yyyy',
    fullFormat: 'dd.MM.yyyy',
    dayEventsTitle: 'Alle Veranstaltungen',
    notHaveEvents: 'Keine Veranstaltungen'
  },
  vi: {
    dayNames: ["T2", "T3", "T4", "T5", "T6", "T7", "CN"],
    monthNames: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
    format: 'MM/yyyy',
    fullFormat: 'dd/MM/yyyy',
    dayEventsTitle: 'Tất cả sự kiện',
    notHaveEvents: 'Không có sự kiện nào'
  }
});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(10)

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(8),
  /* template */
  __webpack_require__(16),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__i18n_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tools_js__ = __webpack_require__(0);
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
  data: function data() {
    return {
      i18n: __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */]
    };
  },

  props: {
    event: {
      type: Object,
      required: true
    },
    index: {
      type: Number,
      required: true
    },
    locale: {
      type: String,
      required: true
    }
  },
  methods: {
    dateTimeFormatter: __WEBPACK_IMPORTED_MODULE_1__tools_js__["b" /* dateTimeFormatter */]
  }
});

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__i18n_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tools_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cal_event_item_vue__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cal_event_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__cal_event_item_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'cal-events',
  data: function data() {
    return {
      i18n: __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */]
    };
  },

  components: {
    'cal-event-item': __WEBPACK_IMPORTED_MODULE_2__cal_event_item_vue___default.a
  },
  props: {
    title: String,
    dayEvents: {
      type: Object,
      required: true
    },
    locale: {
      type: String,
      required: true
    },
    color: {
      type: String,
      required: true
    }
  },
  computed: {
    dayEventsTitle: function dayEventsTitle() {
      if (this.title) return this.title;
      if (this.dayEvents.date !== 'all') {
        var tempDate = void 0;
        if (this.dayEvents.events.length !== 0) {
          tempDate = Date.parse(new Date(this.dayEvents.events[0].date));
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__tools_js__["b" /* dateTimeFormatter */])(tempDate, __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */][this.locale].fullFormat);
        } else {
          tempDate = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__tools_js__["b" /* dateTimeFormatter */])(Date.parse(new Date(this.dayEvents.date)), __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */][this.locale].fullFormat);
          return tempDate + ' ' + __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */][this.locale].notHaveEvents;
        }
      } else {
        return __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */][this.locale].dayEventsTitle;
      }
    },
    events: function events() {
      return this.dayEvents.events;
    },
    bgColor: function bgColor() {
      return { backgroundColor: this.color };
    }
  },
  methods: {
    dateTimeFormatter: __WEBPACK_IMPORTED_MODULE_1__tools_js__["b" /* dateTimeFormatter */]
  }
});

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__i18n_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tools_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




var inBrowser = typeof window !== 'undefined';
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'cal-panel',
  data: function data() {
    return {
      i18n: __WEBPACK_IMPORTED_MODULE_0__i18n_js__["a" /* default */]
    };
  },

  props: {
    events: {
      type: Array,
      required: true
    },
    calendar: {
      type: Object,
      required: true
    },
    selectedDay: {
      type: String,
      required: false
    }
  },
  computed: {
    dayList: function dayList() {
      var firstDay = new Date(this.calendar.params.curYear, this.calendar.params.curMonth, 1);
      var dayOfWeek = firstDay.getDay();
      // 根据当前日期计算偏移量 // Calculate the offset based on the current date
      if (this.calendar.options.weekStartOn > dayOfWeek) {
        dayOfWeek = dayOfWeek - this.calendar.options.weekStartOn + 7;
      } else if (this.calendar.options.weekStartOn < dayOfWeek) {
        dayOfWeek = dayOfWeek - this.calendar.options.weekStartOn;
      }

      var startDate = new Date(firstDay);
      startDate.setDate(firstDay.getDate() - dayOfWeek);

      var item = void 0,
          status = void 0,
          tempArr = [],
          tempItem = void 0;
      for (var i = 0; i < 42; i++) {
        item = new Date(startDate);
        item.setDate(startDate.getDate() + i);

        if (this.calendar.params.curMonth === item.getMonth()) {
          status = 1;
        } else {
          status = 0;
        }
        tempItem = {
          date: item.getFullYear() + '/' + (item.getMonth() + 1) + '/' + item.getDate(),
          status: status,
          customClass: []
        };
        this.events.forEach(function (event) {
          if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__tools_js__["a" /* isEqualDateStr */])(event.date, tempItem.date)) {
            tempItem.title = event.title;
            tempItem.desc = event.desc || '';
            if (event.customClass) tempItem.customClass.push(event.customClass);
          }
        });
        tempArr.push(tempItem);
      }
      return tempArr;
    },
    today: function today() {
      var dateObj = new Date();
      return dateObj.getFullYear() + '/' + (dateObj.getMonth() + 1) + '/' + dateObj.getDate();
    },
    curYearMonth: function curYearMonth() {
      var tempDate = Date.parse(new Date(this.calendar.params.curYear + '/' + (this.calendar.params.curMonth + 1) + '/01'));
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__tools_js__["b" /* dateTimeFormatter */])(tempDate, this.i18n[this.calendar.options.locale].format);
    },
    customColor: function customColor() {
      return this.calendar.options.color;
    }
  },
  methods: {
    nextMonth: function nextMonth() {
      this.$EventCalendar.nextMonth();
      this.$emit('month-changed', this.curYearMonth);
    },
    preMonth: function preMonth() {
      this.$EventCalendar.preMonth();
      this.$emit('month-changed', this.curYearMonth);
    },
    handleChangeCurday: function handleChangeCurday(date) {
      if (date.status) {
        this.$emit('cur-day-changed', date.date);
      }
    }
  }
});

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tools_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_cal_events_vue__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_cal_events_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_cal_events_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_cal_panel_vue__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_cal_panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__components_cal_panel_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






var inBrowser = typeof window !== 'undefined';
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'vue-event-calendar',
  components: {
    'cal-events': __WEBPACK_IMPORTED_MODULE_1__components_cal_events_vue___default.a,
    'cal-panel': __WEBPACK_IMPORTED_MODULE_2__components_cal_panel_vue___default.a
  },
  data: function data() {
    return {
      selectedDayEvents: {
        date: 'all',
        events: this.events || [] //default show all event
      }
    };
  },

  props: {
    title: String,
    events: {
      type: Array,
      required: true,
      default: [],
      validator: function validator(events) {
        var validate = true;
        events.forEach(function (event, index) {
          if (!event.date) {
            console.error('Vue-Event-Calendar-Error:' + 'Prop events Wrong at index ' + index);
            validate = false;
          }
        });
        return validate;
      }
    }
  },
  computed: {
    calendarOptions: function calendarOptions() {
      var dateObj = new Date();
      if (inBrowser) {
        return window.VueCalendarBarEventBus.CALENDAR_EVENTS_DATA;
      } else {
        return {
          options: {
            locale: 'en', //zh
            color: ' #f29543'
          },
          params: {
            curYear: dateObj.getFullYear(),
            curMonth: dateObj.getMonth(),
            curDate: dateObj.getDate(),
            curEventsDate: 'all'
          }
        };
      }
    },
    calendarParams: function calendarParams() {
      var dateObj = new Date();
      if (inBrowser) {
        return window.VueCalendarBarEventBus.CALENDAR_EVENTS_DATA.params;
      } else {
        return {
          curYear: dateObj.getFullYear(),
          curMonth: dateObj.getMonth(),
          curDate: dateObj.getDate(),
          curEventsDate: 'all'
        };
      }
    }
  },
  created: function created() {
    if (this.calendarParams.curEventsDate !== 'all') {
      this.handleChangeCurDay(this.calendarParams.curEventsDate);
    }
  },

  methods: {
    handleChangeCurDay: function handleChangeCurDay(date) {
      var events = this.events.filter(function (event) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__tools_js__["a" /* isEqualDateStr */])(event.date, date);
      });
      if (events.length > 0) {
        this.selectedDayEvents = {
          date: date,
          events: events
        };
      }
      this.$emit('day-changed', {
        date: date,
        events: events
      });
    },
    handleMonthChanged: function handleMonthChanged(yearMonth) {
      this.$emit('month-changed', yearMonth);
    }
  },
  watch: {
    calendarParams: function calendarParams() {
      var _this = this;

      if (this.calendarParams.curEventsDate !== 'all') {
        var events = this.events.filter(function (event) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__tools_js__["a" /* isEqualDateStr */])(event.date, _this.calendarParams.curEventsDate);
        });
        this.selectedDayEvents = {
          date: this.calendarParams.curEventsDate,
          events: events
        };
      } else {
        this.selectedDayEvents = {
          date: 'all',
          events: this.events
        };
      }
    },
    events: function events() {
      this.selectedDayEvents = {
        date: 'all',
        events: this.events || []
      };
    }
  }
});

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vue_event_calendar_vue__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vue_event_calendar_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__vue_event_calendar_vue__);


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



function install(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var isVueNext = Vue.version.split('.')[0] === '2';
  var inBrowser = typeof window !== 'undefined';
  var dateObj = new Date();
  var DEFAULT_OPTION = {
    locale: 'zh', // en
    color: ' #f29543',
    className: 'selected-day',
    weekStartOn: 0 // 0 mean sunday
  };
  var Calendar = {
    $vm: null,
    bindEventBus: function bindEventBus(vm) {
      this.$vm = vm;
    },
    toDate: function toDate(dateString) {
      if (dateString === 'all') {
        this.$vm.CALENDAR_EVENTS_DATA.params = {
          curYear: dateObj.getFullYear(),
          curMonth: dateObj.getMonth(),
          curDate: dateObj.getDate(),
          curEventsDate: 'all'
        };
      } else {
        var dateArr = dateString.split('/');
        dateArr = dateArr.map(function (item) {
          return parseInt(item, 10);
        });
        this.$vm.CALENDAR_EVENTS_DATA.params = {
          curYear: dateArr[0],
          curMonth: dateArr[1] - 1,
          curDate: dateArr[2],
          curEventsDate: dateString
        };
      }
    },
    nextMonth: function nextMonth() {
      if (this.$vm.CALENDAR_EVENTS_DATA.params.curMonth < 11) {
        this.$vm.CALENDAR_EVENTS_DATA.params.curMonth++;
      } else {
        this.$vm.CALENDAR_EVENTS_DATA.params.curYear++;
        this.$vm.CALENDAR_EVENTS_DATA.params.curMonth = 0;
      }
    },
    preMonth: function preMonth() {
      if (this.$vm.CALENDAR_EVENTS_DATA.params.curMonth > 0) {
        this.$vm.CALENDAR_EVENTS_DATA.params.curMonth--;
      } else {
        this.$vm.CALENDAR_EVENTS_DATA.params.curYear--;
        this.$vm.CALENDAR_EVENTS_DATA.params.curMonth = 11;
      }
    }
  };

  var calendarOptions = Object.assign(DEFAULT_OPTION, options);

  var VueCalendarBarEventBus = new Vue({
    data: {
      CALENDAR_EVENTS_DATA: {
        options: calendarOptions,
        params: {
          curYear: dateObj.getFullYear(),
          curMonth: dateObj.getMonth(),
          curDate: dateObj.getDate(),
          curEventsDate: 'all'
        }
      }
    }
  });

  if (inBrowser) {
    window.VueCalendarBarEventBus = VueCalendarBarEventBus;
    Calendar.bindEventBus(VueCalendarBarEventBus);
  }

  Vue.component('vue-event-calendar', __WEBPACK_IMPORTED_MODULE_0__vue_event_calendar_vue___default.a);

  Vue.prototype.$EventCalendar = Calendar;
}

/* harmony default export */ __webpack_exports__["default"] = (install);

if (( false ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  module.exports.install = install;
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(4)(module)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(5),
  /* template */
  __webpack_require__(14),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(6),
  /* template */
  __webpack_require__(15),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(7),
  /* template */
  __webpack_require__(17),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "wrapper"
  }, [_c('h3', {
    staticClass: "title"
  }, [_vm._v(_vm._s(_vm.index + 1) + ". " + _vm._s(_vm.event.title))]), _vm._v(" "), _c('p', {
    staticClass: "time"
  }, [_vm._v(_vm._s(_vm.dateTimeFormatter(Date.parse(new Date(_vm.event.date)), _vm.i18n[_vm.locale].fullFormat)))]), _vm._v(" "), _c('p', {
    staticClass: "desc"
  }, [_vm._v(_vm._s(_vm.event.desc))])])
},staticRenderFns: []}

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "events-wrapper",
    style: (_vm.bgColor)
  }, [_c('h2', {
    staticClass: "date"
  }, [_vm._v("\n    " + _vm._s(_vm.dayEventsTitle) + "\n  ")]), _vm._v(" "), _c('div', {
    staticClass: "cal-events"
  }, [_vm._t("default", _vm._l((_vm.events), function(event, index) {
    return _c('div', {
      staticClass: "event-item"
    }, [_c('cal-event-item', {
      attrs: {
        "event": event,
        "index": index,
        "locale": _vm.locale
      }
    })], 1)
  }))], 2)])
},staticRenderFns: []}

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "__vev_calendar-wrapper"
  }, [_c('cal-panel', {
    attrs: {
      "events": _vm.events,
      "calendar": _vm.calendarOptions,
      "selectedDay": _vm.selectedDayEvents.date
    },
    on: {
      "cur-day-changed": _vm.handleChangeCurDay,
      "month-changed": _vm.handleMonthChanged
    }
  }), _vm._v(" "), _c('cal-events', {
    attrs: {
      "title": _vm.title,
      "dayEvents": _vm.selectedDayEvents,
      "locale": _vm.calendarOptions.options.locale,
      "color": _vm.calendarOptions.options.color
    }
  }, [_vm._t("default", null, {
    showEvents: _vm.selectedDayEvents.events
  })], 2)], 1)
},staticRenderFns: []}

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "cal-wrapper"
  }, [_c('div', {
    staticClass: "cal-header"
  }, [_c('div', {
    staticClass: "l",
    on: {
      "click": _vm.preMonth
    }
  }, [_c('div', {
    staticClass: "arrow-left icon"
  }, [_vm._v(" ")])]), _vm._v(" "), _c('div', {
    staticClass: "title"
  }, [_vm._v(_vm._s(_vm.curYearMonth))]), _vm._v(" "), _c('div', {
    staticClass: "r",
    on: {
      "click": _vm.nextMonth
    }
  }, [_c('div', {
    staticClass: "arrow-right icon"
  }, [_vm._v(" ")])])]), _vm._v(" "), _c('div', {
    staticClass: "cal-body"
  }, [_c('div', {
    staticClass: "weeks"
  }, _vm._l((_vm.i18n[_vm.calendar.options.locale].dayNames), function(dayName, dayIndex) {
    return _c('span', {
      key: dayIndex,
      staticClass: "item"
    }, [_vm._v("\n        " + _vm._s(_vm.i18n[_vm.calendar.options.locale].dayNames[(dayIndex + _vm.calendar.options.weekStartOn) % 7]) + "\n      ")])
  })), _vm._v(" "), _c('div', {
    staticClass: "dates"
  }, _vm._l((_vm.dayList), function(date) {
    return _c('div', {
      key: date.date,
      staticClass: "item",
      class: [( _obj = {
        today: date.status ? (_vm.today == date.date) : false,
        event: date.status ? (date.title != undefined) : false
      }, _obj[_vm.calendar.options.className] = (date.date == _vm.selectedDay), _obj ) ].concat( date.customClass)
    }, [_c('p', {
      staticClass: "date-num",
      style: ({
        color: date.title != undefined ? ((date.date == _vm.selectedDay) ? '#fff' : _vm.customColor) : 'inherit'
      }),
      on: {
        "click": function($event) {
          _vm.handleChangeCurday(date)
        }
      }
    }, [_vm._v("\n          " + _vm._s(date.status ? date.date.split('/')[2] : ' '))]), _vm._v(" "), (date.status ? (_vm.today == date.date) : false) ? _c('span', {
      staticClass: "is-today",
      style: ({
        backgroundColor: _vm.customColor
      })
    }) : _vm._e(), _vm._v(" "), (date.status ? (date.title != undefined) : false) ? _c('span', {
      staticClass: "is-event",
      style: ({
        borderColor: _vm.customColor,
        backgroundColor: (date.date == _vm.selectedDay) ? _vm.customColor : 'inherit'
      })
    }) : _vm._e()])
    var _obj;
  }))])])
},staticRenderFns: []}

/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "UAy9":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("fuEY")('asyncIterator');


/***/ }),

/***/ "UGrZ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (target) {
  for (var i = 1, j = arguments.length; i < j; i++) {
    var source = arguments[i] || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        var value = source[prop];
        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
};

;

/***/ }),

/***/ "Ubre":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value)) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (regexp);

/***/ }),

/***/ "V0EG":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "V0fI":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__("4YfN");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__("hRKE");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__("xB8i");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__validator___ = __webpack_require__("SGE9");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__messages__ = __webpack_require__("xnvR");






/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */
function Schema(descriptor) {
  this.rules = null;
  this._messages = __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* messages */];
  this.define(descriptor);
}

Schema.prototype = {
  messages: function messages(_messages) {
    if (_messages) {
      this._messages = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["a" /* deepMerge */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__messages__["b" /* newMessages */])(), _messages);
    }
    return this._messages;
  },
  define: function define(rules) {
    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }
    if ((typeof rules === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(rules)) !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }
    this.rules = {};
    var z = void 0;
    var item = void 0;
    for (z in rules) {
      if (rules.hasOwnProperty(z)) {
        item = rules[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_) {
    var _this = this;

    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var oc = arguments[2];

    var source = source_;
    var options = o;
    var callback = oc;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    function complete(results) {
      var i = void 0;
      var field = void 0;
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          errors = errors.concat.apply(errors, e);
        } else {
          errors.push(e);
        }
      }

      for (i = 0; i < results.length; i++) {
        add(results[i]);
      }
      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        for (i = 0; i < errors.length; i++) {
          field = errors[i].field;
          fields[field] = fields[field] || [];
          fields[field].push(errors[i]);
        }
      }
      callback(errors, fields);
    }

    if (options.messages) {
      var messages = this.messages();
      if (messages === __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* messages */]) {
        messages = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__messages__["b" /* newMessages */])();
      }
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["a" /* deepMerge */])(messages, options.messages);
      options.messages = messages;
    } else {
      options.messages = this.messages();
    }
    var arr = void 0;
    var value = void 0;
    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      arr = _this.rules[z];
      value = source[z];
      arr.forEach(function (r) {
        var rule = r;
        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, source);
          }
          value = source[z] = rule.transform(value);
        }
        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, rule);
        }
        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);
        if (!rule.validator) {
          return;
        }
        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["b" /* asyncMap */])(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(rule.fields) === 'object' || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(rule.defaultField) === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullfield(key, schema) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, schema, {
          fullField: rule.fullField + '.' + key
        });
      }

      function cb() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var errors = e;
        if (!Array.isArray(errors)) {
          errors = [errors];
        }
        if (errors.length) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["c" /* warning */])('async-validator:', errors);
        }
        if (errors.length && rule.message) {
          errors = [].concat(rule.message);
        }

        errors = errors.map(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["d" /* complementError */])(rule));

        if (options.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }
        if (!deep) {
          doIt(errors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message) {
              errors = [].concat(rule.message).map(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["d" /* complementError */])(rule));
            } else if (options.error) {
              errors = [options.error(rule, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["e" /* format */])(options.messages.required, rule.field))];
            } else {
              errors = [];
            }
            return doIt(errors);
          }

          var fieldsSchema = {};
          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }
          fieldsSchema = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, fieldsSchema, data.rule.fields);
          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }
          var schema = new Schema(fieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function (errs) {
            doIt(errs && errs.length ? errors.concat(errs) : errs);
          });
        }
      }

      var res = rule.validator(rule, data.value, cb, data.source, options);
      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }
    if (typeof rule.validator !== 'function' && rule.type && !__WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */].hasOwnProperty(rule.type)) {
      throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["e" /* format */])('Unknown rule type %s', rule.type));
    }
    return rule.type || 'string';
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }
    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');
    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }
    if (keys.length === 1 && keys[0] === 'required') {
      return __WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */].required;
    }
    return __WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */][this.getType(rule)] || false;
  }
};

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }
  __WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */][type] = validator;
};

Schema.messages = __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* messages */];

/* harmony default export */ __webpack_exports__["default"] = (Schema);

/***/ }),

/***/ "VMHY":
/***/ (function(module, exports) {

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   noTrailing     Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   debounceMode   If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */
module.exports = function ( delay, noTrailing, callback, debounceMode ) {

	// After wrapper has stopped being called, this timeout ensures that
	// `callback` is executed at the proper times in `throttle` and `end`
	// debounce modes.
	var timeoutID;

	// Keep track of the last time `callback` was executed.
	var lastExec = 0;

	// `noTrailing` defaults to falsy.
	if ( typeof noTrailing !== 'boolean' ) {
		debounceMode = callback;
		callback = noTrailing;
		noTrailing = undefined;
	}

	// The `wrapper` function encapsulates all of the throttling / debouncing
	// functionality and when executed will limit the rate at which `callback`
	// is executed.
	function wrapper () {

		var self = this;
		var elapsed = Number(new Date()) - lastExec;
		var args = arguments;

		// Execute `callback` and update the `lastExec` timestamp.
		function exec () {
			lastExec = Number(new Date());
			callback.apply(self, args);
		}

		// If `debounceMode` is true (at begin) this is used to clear the flag
		// to allow future `callback` executions.
		function clear () {
			timeoutID = undefined;
		}

		if ( debounceMode && !timeoutID ) {
			// Since `wrapper` is being called for the first time and
			// `debounceMode` is true (at begin), execute `callback`.
			exec();
		}

		// Clear any existing timeout.
		if ( timeoutID ) {
			clearTimeout(timeoutID);
		}

		if ( debounceMode === undefined && elapsed > delay ) {
			// In throttle mode, if `delay` time has been exceeded, execute
			// `callback`.
			exec();

		} else if ( noTrailing !== true ) {
			// In trailing throttle mode, since `delay` time has not been
			// exceeded, schedule `callback` to execute `delay` ms after most
			// recent execution.
			//
			// If `debounceMode` is true (at begin), schedule `clear` to execute
			// after `delay` ms.
			//
			// If `debounceMode` is false (at end), schedule `callback` to
			// execute after `delay` ms.
			timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
		}

	}

	// Return the wrapper function.
	return wrapper;

};


/***/ }),

/***/ "Vfex":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("sNst");
module.exports = __webpack_require__("0nnt").Object.assign;


/***/ }),

/***/ "WoFR":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("AsM0");
var toIObject = __webpack_require__("/RPK");
var arrayIndexOf = __webpack_require__("ZeNl")(false);
var IE_PROTO = __webpack_require__("qq67")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "X609":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "XoPO":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 166);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = __webpack_require__("BbKf");

/***/ }),

/***/ 166:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(167);


/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _option = __webpack_require__(33);

var _option2 = _interopRequireDefault(_option);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_option2.default.install = function (Vue) {
  Vue.component(_option2.default.name, _option2.default);
};

exports.default = _option2.default;

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = __webpack_require__("caRQ");

/***/ }),

/***/ 33:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ed77bae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_vue__ = __webpack_require__(35);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ed77bae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_emitter2.default],

  name: 'ElOption',

  componentName: 'ElOption',

  inject: ['select'],

  props: {
    value: {
      required: true
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    };
  },


  computed: {
    isObject: function isObject() {
      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
    },
    currentLabel: function currentLabel() {
      return this.label || (this.isObject ? '' : this.value);
    },
    currentValue: function currentValue() {
      return this.value || this.label || '';
    },
    itemSelected: function itemSelected() {
      if (!this.select.multiple) {
        return this.isEqual(this.value, this.select.value);
      } else {
        return this.contains(this.select.value, this.value);
      }
    },
    limitReached: function limitReached() {
      if (this.select.multiple) {
        return !this.itemSelected && this.select.value.length >= this.select.multipleLimit && this.select.multipleLimit > 0;
      } else {
        return false;
      }
    }
  },

  watch: {
    currentLabel: function currentLabel() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    },
    value: function value() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    }
  },

  methods: {
    isEqual: function isEqual(a, b) {
      if (!this.isObject) {
        return a === b;
      } else {
        var valueKey = this.select.valueKey;
        return (0, _util.getValueByPath)(a, valueKey) === (0, _util.getValueByPath)(b, valueKey);
      }
    },
    contains: function contains() {
      var _this = this;

      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var target = arguments[1];

      if (!this.isObject) {
        return arr.indexOf(target) > -1;
      } else {
        var _ret = function () {
          var valueKey = _this.select.valueKey;
          return {
            v: arr.some(function (item) {
              return (0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(target, valueKey);
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
    },
    handleGroupDisabled: function handleGroupDisabled(val) {
      this.groupDisabled = val;
    },
    hoverItem: function hoverItem() {
      if (!this.disabled && !this.groupDisabled) {
        this.select.hoverIndex = this.select.options.indexOf(this);
      }
    },
    selectOptionClick: function selectOptionClick() {
      if (this.disabled !== true && this.groupDisabled !== true) {
        this.dispatch('ElSelect', 'handleOptionClick', this);
      }
    },
    queryChange: function queryChange(query) {
      // query 里如果有正则中的特殊字符，需要先将这些字符转义
      var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
      if (!this.visible) {
        this.select.filteredOptionsCount--;
      }
    }
  },

  created: function created() {
    this.select.options.push(this);
    this.select.cachedOptions.push(this);
    this.select.optionsCount++;
    this.select.filteredOptionsCount++;

    this.$on('queryChange', this.queryChange);
    this.$on('handleGroupDisabled', this.handleGroupDisabled);
  },
  beforeDestroy: function beforeDestroy() {
    this.select.onOptionDestroy(this.select.options.indexOf(this));
  }
};

/***/ }),

/***/ 35:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-select-dropdown__item",class:{
    'selected': _vm.itemSelected,
    'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
    'hover': _vm.hover
  },on:{"mouseenter":_vm.hoverItem,"click":function($event){$event.stopPropagation();_vm.selectOptionClick($event)}}},[_vm._t("default",[_c('span',[_vm._v(_vm._s(_vm.currentLabel))])])],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "YEmw":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "Yban":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 157);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = __webpack_require__("BbKf");

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = __webpack_require__("xp85");

/***/ }),

/***/ 13:
/***/ (function(module, exports) {

module.exports = __webpack_require__("x018");

/***/ }),

/***/ 14:
/***/ (function(module, exports) {

module.exports = __webpack_require__("gUSn");

/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(158);


/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _select = __webpack_require__(159);

var _select2 = _interopRequireDefault(_select);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_select2.default.install = function (Vue) {
  Vue.component(_select2.default.name, _select2.default);
};

exports.default = _select2.default;

/***/ }),

/***/ 159:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ab76e696_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_vue__ = __webpack_require__(165);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ab76e696_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 160:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _focus = __webpack_require__(11);

var _focus2 = _interopRequireDefault(_focus);

var _locale = __webpack_require__(3);

var _locale2 = _interopRequireDefault(_locale);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _selectDropdown = __webpack_require__(161);

var _selectDropdown2 = _interopRequireDefault(_selectDropdown);

var _option = __webpack_require__(33);

var _option2 = _interopRequireDefault(_option);

var _tag = __webpack_require__(24);

var _tag2 = _interopRequireDefault(_tag);

var _scrollbar = __webpack_require__(18);

var _scrollbar2 = _interopRequireDefault(_scrollbar);

var _debounce = __webpack_require__(13);

var _debounce2 = _interopRequireDefault(_debounce);

var _clickoutside = __webpack_require__(9);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _dom = __webpack_require__(4);

var _resizeEvent = __webpack_require__(19);

var _locale3 = __webpack_require__(14);

var _scrollIntoView = __webpack_require__(25);

var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

var _util = __webpack_require__(2);

var _navigationMixin = __webpack_require__(164);

var _navigationMixin2 = _interopRequireDefault(_navigationMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sizeMap = {
  'medium': 36,
  'small': 32,
  'mini': 28
};

exports.default = {
  mixins: [_emitter2.default, _locale2.default, (0, _focus2.default)('reference'), _navigationMixin2.default],

  name: 'ElSelect',

  componentName: 'ElSelect',

  inject: {
    elFormItem: {
      default: ''
    }
  },

  provide: function provide() {
    return {
      'select': this
    };
  },


  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    iconClass: function iconClass() {
      var criteria = this.clearable && !this.disabled && this.inputHovering && !this.multiple && this.value !== undefined && this.value !== '';
      return criteria ? 'circle-close is-show-close' : this.remote && this.filterable ? '' : 'arrow-up';
    },
    debounce: function debounce() {
      return this.remote ? 300 : 0;
    },
    emptyText: function emptyText() {
      if (this.loading) {
        return this.loadingText || this.t('el.select.loading');
      } else {
        if (this.remote && this.query === '' && this.options.length === 0) return false;
        if (this.filterable && this.query && this.options.length > 0 && this.filteredOptionsCount === 0) {
          return this.noMatchText || this.t('el.select.noMatch');
        }
        if (this.options.length === 0) {
          return this.noDataText || this.t('el.select.noData');
        }
      }
      return null;
    },
    showNewOption: function showNewOption() {
      var _this = this;

      var hasExistingOption = this.options.filter(function (option) {
        return !option.created;
      }).some(function (option) {
        return option.currentLabel === _this.query;
      });
      return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
    },
    selectSize: function selectSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  components: {
    ElInput: _input2.default,
    ElSelectMenu: _selectDropdown2.default,
    ElOption: _option2.default,
    ElTag: _tag2.default,
    ElScrollbar: _scrollbar2.default
  },

  directives: { Clickoutside: _clickoutside2.default },

  props: {
    name: String,
    id: String,
    value: {
      required: true
    },
    size: String,
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: String,
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String,
      default: function _default() {
        return (0, _locale3.t)('el.select.placeholder');
      }
    },
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: {
      type: String,
      default: 'value'
    }
  },

  data: function data() {
    return {
      options: [],
      cachedOptions: [],
      createdLabel: null,
      createdSelected: false,
      selected: this.multiple ? [] : {},
      inputLength: 20,
      inputWidth: 0,
      cachedPlaceHolder: '',
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: false,
      selectedLabel: '',
      hoverIndex: -1,
      query: '',
      previousQuery: '',
      inputHovering: false,
      currentPlaceholder: ''
    };
  },


  watch: {
    disabled: function disabled() {
      var _this2 = this;

      this.$nextTick(function () {
        _this2.resetInputHeight();
      });
    },
    placeholder: function placeholder(val) {
      this.cachedPlaceHolder = this.currentPlaceholder = val;
    },
    value: function value(val) {
      if (this.multiple) {
        this.resetInputHeight();
        if (val.length > 0 || this.$refs.input && this.query !== '') {
          this.currentPlaceholder = '';
        } else {
          this.currentPlaceholder = this.cachedPlaceHolder;
        }
        if (this.filterable && !this.reserveKeyword) {
          this.query = '';
          this.handleQueryChange(this.query);
        }
      }
      this.setSelected();
      if (this.filterable && !this.multiple) {
        this.inputLength = 20;
      }
    },
    visible: function visible(val) {
      var _this3 = this;

      if (!val) {
        this.$refs.reference.$el.querySelector('input').blur();
        this.handleIconHide();
        this.broadcast('ElSelectDropdown', 'destroyPopper');
        if (this.$refs.input) {
          this.$refs.input.blur();
        }
        this.query = '';
        this.selectedLabel = '';
        this.inputLength = 20;
        this.resetHoverIndex();
        this.$nextTick(function () {
          if (_this3.$refs.input && _this3.$refs.input.value === '' && _this3.selected.length === 0) {
            _this3.currentPlaceholder = _this3.cachedPlaceHolder;
          }
        });
        if (!this.multiple) {
          if (this.selected) {
            if (this.filterable && this.allowCreate && this.createdSelected && this.createdOption) {
              this.selectedLabel = this.createdLabel;
            } else {
              this.selectedLabel = this.selected.currentLabel;
            }
            if (this.filterable) this.query = this.selectedLabel;
          }
        }
      } else {
        this.handleIconShow();
        this.broadcast('ElSelectDropdown', 'updatePopper');
        if (this.filterable) {
          this.query = this.remote ? '' : this.selectedLabel;
          this.handleQueryChange(this.query);
          if (this.multiple) {
            this.$refs.input.focus();
          } else {
            if (!this.remote) {
              this.broadcast('ElOption', 'queryChange', '');
              this.broadcast('ElOptionGroup', 'queryChange');
            }
            this.broadcast('ElInput', 'inputSelect');
          }
        }
      }
      this.$emit('visible-change', val);
    },
    options: function options() {
      if (this.$isServer) return;
      if (this.multiple) {
        this.resetInputHeight();
      }
      var inputs = this.$el.querySelectorAll('input');
      if ([].indexOf.call(inputs, document.activeElement) === -1) {
        this.setSelected();
      }
      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    }
  },

  methods: {
    handleQueryChange: function handleQueryChange(val) {
      var _this4 = this;

      if (this.previousQuery === val) return;
      this.previousQuery = val;
      this.$nextTick(function () {
        if (_this4.visible) _this4.broadcast('ElSelectDropdown', 'updatePopper');
      });
      this.hoverIndex = -1;
      if (this.multiple && this.filterable) {
        this.inputLength = this.$refs.input.value.length * 15 + 20;
        this.managePlaceholder();
        this.resetInputHeight();
      }
      if (this.remote && typeof this.remoteMethod === 'function') {
        this.hoverIndex = -1;
        this.remoteMethod(val);
      } else if (typeof this.filterMethod === 'function') {
        this.filterMethod(val);
        this.broadcast('ElOptionGroup', 'queryChange');
      } else {
        this.filteredOptionsCount = this.optionsCount;
        this.broadcast('ElOption', 'queryChange', val);
        this.broadcast('ElOptionGroup', 'queryChange');
      }
      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    },
    handleIconHide: function handleIconHide() {
      var icon = this.$el.querySelector('.el-input__icon');
      if (icon) {
        (0, _dom.removeClass)(icon, 'is-reverse');
      }
    },
    handleIconShow: function handleIconShow() {
      var icon = this.$el.querySelector('.el-input__icon');
      if (icon && !(0, _dom.hasClass)(icon, 'el-icon-circle-close')) {
        (0, _dom.addClass)(icon, 'is-reverse');
      }
    },
    scrollToOption: function scrollToOption(option) {
      var target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
      if (this.$refs.popper && target) {
        var menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
        (0, _scrollIntoView2.default)(menu, target);
      }
    },
    handleMenuEnter: function handleMenuEnter() {
      var _this5 = this;

      this.$nextTick(function () {
        return _this5.scrollToOption(_this5.selected);
      });
    },
    emitChange: function emitChange(val) {
      if (!(0, _util.valueEquals)(this.value, val)) {
        this.$emit('change', val);
        this.dispatch('ElFormItem', 'el.form.change', val);
      }
    },
    getOption: function getOption(value) {
      var option = void 0;
      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      for (var i = this.cachedOptions.length - 1; i >= 0; i--) {
        var cachedOption = this.cachedOptions[i];
        var isEqual = isObject ? (0, _util.getValueByPath)(cachedOption.value, this.valueKey) === (0, _util.getValueByPath)(value, this.valueKey) : cachedOption.value === value;
        if (isEqual) {
          option = cachedOption;
          break;
        }
      }
      if (option) return option;
      var label = !isObject ? value : '';
      var newOption = {
        value: value,
        currentLabel: label
      };
      if (this.multiple) {
        newOption.hitState = false;
      }
      return newOption;
    },
    setSelected: function setSelected() {
      var _this6 = this;

      if (!this.multiple) {
        var option = this.getOption(this.value);
        if (option.created) {
          this.createdLabel = option.currentLabel;
          this.createdSelected = true;
        } else {
          this.createdSelected = false;
        }
        this.selectedLabel = option.currentLabel;
        this.selected = option;
        if (this.filterable) this.query = this.selectedLabel;
        return;
      }
      var result = [];
      if (Array.isArray(this.value)) {
        this.value.forEach(function (value) {
          result.push(_this6.getOption(value));
        });
      }
      this.selected = result;
      this.$nextTick(function () {
        _this6.resetInputHeight();
      });
    },
    handleFocus: function handleFocus(event) {
      this.visible = true;
      this.$emit('focus', event);
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },
    handleIconClick: function handleIconClick(event) {
      if (this.iconClass.indexOf('circle-close') > -1) {
        this.deleteSelected(event);
      } else {
        this.toggleMenu();
      }
    },
    handleMouseDown: function handleMouseDown(event) {
      if (event.target.tagName !== 'INPUT') return;
      if (this.visible) {
        this.handleClose();
        event.preventDefault();
      }
    },
    doDestroy: function doDestroy() {
      this.$refs.popper && this.$refs.popper.doDestroy();
    },
    handleClose: function handleClose() {
      this.visible = false;
    },
    toggleLastOptionHitState: function toggleLastOptionHitState(hit) {
      if (!Array.isArray(this.selected)) return;
      var option = this.selected[this.selected.length - 1];
      if (!option) return;

      if (hit === true || hit === false) {
        option.hitState = hit;
        return hit;
      }

      option.hitState = !option.hitState;
      return option.hitState;
    },
    deletePrevTag: function deletePrevTag(e) {
      if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
        var value = this.value.slice();
        value.pop();
        this.$emit('input', value);
        this.emitChange(value);
      }
    },
    managePlaceholder: function managePlaceholder() {
      if (this.currentPlaceholder !== '') {
        this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
      }
    },
    resetInputState: function resetInputState(e) {
      if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
      this.inputLength = this.$refs.input.value.length * 15 + 20;
      this.resetInputHeight();
    },
    resetInputHeight: function resetInputHeight() {
      var _this7 = this;

      this.$nextTick(function () {
        if (!_this7.$refs.reference) return;
        var inputChildNodes = _this7.$refs.reference.$el.childNodes;
        var input = [].filter.call(inputChildNodes, function (item) {
          return item.tagName === 'INPUT';
        })[0];
        var tags = _this7.$refs.tags;
        input.style.height = _this7.selected.length === 0 ? sizeMap[_this7.selectSize] + 'px' : Math.max(tags ? tags.clientHeight + 10 : 0, sizeMap[_this7.selectSize] || 40) + 'px';
        if (_this7.visible && _this7.emptyText !== false) {
          _this7.broadcast('ElSelectDropdown', 'updatePopper');
        }
      });
    },
    resetHoverIndex: function resetHoverIndex() {
      var _this8 = this;

      setTimeout(function () {
        if (!_this8.multiple) {
          _this8.hoverIndex = _this8.options.indexOf(_this8.selected);
        } else {
          if (_this8.selected.length > 0) {
            _this8.hoverIndex = Math.min.apply(null, _this8.selected.map(function (item) {
              return _this8.options.indexOf(item);
            }));
          } else {
            _this8.hoverIndex = -1;
          }
        }
      }, 300);
    },
    handleOptionSelect: function handleOptionSelect(option) {
      var _this9 = this;

      if (this.multiple) {
        var value = this.value.slice();
        var optionIndex = this.getValueIndex(value, option.value);
        if (optionIndex > -1) {
          value.splice(optionIndex, 1);
        } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
          value.push(option.value);
        }
        this.$emit('input', value);
        this.emitChange(value);
        if (option.created) {
          this.query = '';
          this.handleQueryChange('');
          this.inputLength = 20;
        }
        if (this.filterable) this.$refs.input.focus();
      } else {
        this.$emit('input', option.value);
        this.emitChange(option.value);
        this.visible = false;
      }
      this.$nextTick(function () {
        return _this9.scrollToOption(option);
      });
    },
    getValueIndex: function getValueIndex() {
      var _this10 = this;

      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var value = arguments[1];

      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      if (!isObject) {
        return arr.indexOf(value);
      } else {
        var _ret = function () {
          var valueKey = _this10.valueKey;
          var index = -1;
          arr.some(function (item, i) {
            if ((0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return {
            v: index
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
    },
    toggleMenu: function toggleMenu() {
      if (!this.disabled) {
        this.visible = !this.visible;
        if (this.visible) {
          (this.$refs.input || this.$refs.reference).focus();
        }
      }
    },
    selectOption: function selectOption() {
      if (this.options[this.hoverIndex]) {
        this.handleOptionSelect(this.options[this.hoverIndex]);
      }
    },
    deleteSelected: function deleteSelected(event) {
      event.stopPropagation();
      this.$emit('input', '');
      this.emitChange('');
      this.visible = false;
      this.$emit('clear');
    },
    deleteTag: function deleteTag(event, tag) {
      var index = this.selected.indexOf(tag);
      if (index > -1 && !this.disabled) {
        var value = this.value.slice();
        value.splice(index, 1);
        this.$emit('input', value);
        this.emitChange(value);
        this.$emit('remove-tag', tag);
      }
      event.stopPropagation();
    },
    onInputChange: function onInputChange() {
      if (this.filterable && this.query !== this.selectedLabel) {
        this.query = this.selectedLabel;
        this.handleQueryChange(this.query);
      }
    },
    onOptionDestroy: function onOptionDestroy(index) {
      if (index > -1) {
        this.optionsCount--;
        this.filteredOptionsCount--;
        this.options.splice(index, 1);
      }
    },
    resetInputWidth: function resetInputWidth() {
      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
    },
    handleResize: function handleResize() {
      this.resetInputWidth();
      if (this.multiple) this.resetInputHeight();
    },
    checkDefaultFirstOption: function checkDefaultFirstOption() {
      this.hoverIndex = -1;
      for (var i = 0; i !== this.options.length; ++i) {
        var option = this.options[i];
        if (this.query) {
          // pick first options that passes the filter
          if (!option.disabled && !option.groupDisabled && option.visible) {
            this.hoverIndex = i;
            break;
          }
        } else {
          // pick currently selected option
          if (option.itemSelected) {
            this.hoverIndex = i;
            break;
          }
        }
      }
    },
    getValueKey: function getValueKey(item) {
      if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
        return item.value;
      } else {
        return (0, _util.getValueByPath)(item.value, this.valueKey);
      }
    }
  },

  created: function created() {
    var _this11 = this;

    this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
    if (this.multiple && !Array.isArray(this.value)) {
      this.$emit('input', []);
    }
    if (!this.multiple && Array.isArray(this.value)) {
      this.$emit('input', '');
    }

    this.debouncedOnInputChange = (0, _debounce2.default)(this.debounce, function () {
      _this11.onInputChange();
    });

    this.$on('handleOptionClick', this.handleOptionSelect);
    this.$on('setSelected', this.setSelected);
  },
  mounted: function mounted() {
    var _this12 = this;

    if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
      this.currentPlaceholder = '';
    }
    (0, _resizeEvent.addResizeListener)(this.$el, this.handleResize);
    if (this.remote && this.multiple) {
      this.resetInputHeight();
    }
    this.$nextTick(function () {
      if (_this12.$refs.reference && _this12.$refs.reference.$el) {
        _this12.inputWidth = _this12.$refs.reference.$el.getBoundingClientRect().width;
      }
    });
    this.setSelected();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$el && this.handleResize) (0, _resizeEvent.removeResizeListener)(this.$el, this.handleResize);
  }
};

/***/ }),

/***/ 161:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0a24e159_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_dropdown_vue__ = __webpack_require__(163);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0a24e159_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_dropdown_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElSelectDropdown',

  componentName: 'ElSelectDropdown',

  mixins: [_vuePopper2.default],

  props: {
    placement: {
      default: 'bottom-start'
    },

    boundariesPadding: {
      default: 0
    },

    popperOptions: {
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    },

    visibleArrow: {
      default: true
    }
  },

  data: function data() {
    return {
      minWidth: ''
    };
  },


  computed: {
    popperClass: function popperClass() {
      return this.$parent.popperClass;
    }
  },

  watch: {
    '$parent.inputWidth': function $parentInputWidth() {
      this.minWidth = this.$parent.$el.getBoundingClientRect().width + 'px';
    }
  },

  mounted: function mounted() {
    var _this = this;

    this.referenceElm = this.$parent.$refs.reference.$el;
    this.$parent.popperElm = this.popperElm = this.$el;
    this.$on('updatePopper', function () {
      if (_this.$parent.visible) _this.updatePopper();
    });
    this.$on('destroyPopper', this.destroyPopper);
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),

/***/ 163:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-select-dropdown el-popper",class:[{ 'is-multiple': _vm.$parent.multiple }, _vm.popperClass],style:({ minWidth: _vm.minWidth })},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),

/***/ 164:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  data: function data() {
    return {
      hoverOption: -1
    };
  },


  computed: {
    optionsAllDisabled: function optionsAllDisabled() {
      return this.options.length === this.options.filter(function (item) {
        return item.disabled === true;
      }).length;
    }
  },

  watch: {
    hoverIndex: function hoverIndex(val) {
      var _this = this;

      if (typeof val === 'number' && val > -1) {
        this.hoverOption = this.options[val] || {};
      }
      this.options.forEach(function (option) {
        option.hover = _this.hoverOption === option;
      });
    }
  },

  methods: {
    navigateOptions: function navigateOptions(direction) {
      var _this2 = this;

      if (!this.visible) {
        this.visible = true;
        return;
      }
      if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
      if (!this.optionsAllDisabled) {
        if (direction === 'next') {
          this.hoverIndex++;
          if (this.hoverIndex === this.options.length) {
            this.hoverIndex = 0;
          }
        } else if (direction === 'prev') {
          this.hoverIndex--;
          if (this.hoverIndex < 0) {
            this.hoverIndex = this.options.length - 1;
          }
        }
        var option = this.options[this.hoverIndex];
        if (option.disabled === true || option.groupDisabled === true || !option.visible) {
          this.navigateOptions(direction);
        }
      }
      this.$nextTick(function () {
        return _this2.scrollToOption(_this2.hoverOption);
      });
    }
  }
};

/***/ }),

/***/ 165:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],staticClass:"el-select",class:[_vm.selectSize ? 'el-select--' + _vm.selectSize : '']},[(_vm.multiple)?_c('div',{ref:"tags",staticClass:"el-select__tags",style:({ 'max-width': _vm.inputWidth - 32 + 'px' }),on:{"click":function($event){$event.stopPropagation();_vm.toggleMenu($event)}}},[_c('transition-group',{on:{"after-leave":_vm.resetInputHeight}},_vm._l((_vm.selected),function(item){return _c('el-tag',{key:_vm.getValueKey(item),attrs:{"closable":!_vm.disabled,"size":"small","hit":item.hitState,"type":"info","disable-transitions":""},on:{"close":function($event){_vm.deleteTag($event, item)}}},[_c('span',{staticClass:"el-select__tags-text"},[_vm._v(_vm._s(item.currentLabel))])])})),(_vm.filterable)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.query),expression:"query"}],ref:"input",staticClass:"el-select__input",class:[_vm.selectSize ? ("is-" + _vm.selectSize) : ''],style:({ width: _vm.inputLength + 'px', 'max-width': _vm.inputWidth - 42 + 'px' }),attrs:{"type":"text","disabled":_vm.disabled,"debounce":_vm.remote ? 300 : 0},domProps:{"value":(_vm.query)},on:{"focus":_vm.handleFocus,"keyup":_vm.managePlaceholder,"keydown":[_vm.resetInputState,function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('next')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('prev')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }$event.preventDefault();_vm.selectOption($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"esc",27,$event.key)){ return null; }$event.stopPropagation();$event.preventDefault();_vm.visible = false},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"delete",[8,46],$event.key)){ return null; }_vm.deletePrevTag($event)}],"input":[function($event){if($event.target.composing){ return; }_vm.query=$event.target.value},function (e) { return _vm.handleQueryChange(e.target.value); }]}}):_vm._e()],1):_vm._e(),_c('el-input',{ref:"reference",class:{ 'is-focus': _vm.visible },attrs:{"type":"text","placeholder":_vm.currentPlaceholder,"name":_vm.name,"id":_vm.id,"size":_vm.selectSize,"disabled":_vm.disabled,"readonly":!_vm.filterable || _vm.multiple,"validate-event":false},on:{"focus":_vm.handleFocus,"blur":_vm.handleBlur},nativeOn:{"mousedown":function($event){_vm.handleMouseDown($event)},"keyup":function($event){_vm.debouncedOnInputChange($event)},"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('next')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('prev')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }$event.preventDefault();_vm.selectOption($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"esc",27,$event.key)){ return null; }$event.stopPropagation();$event.preventDefault();_vm.visible = false},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"tab",9,$event.key)){ return null; }_vm.visible = false}],"paste":function($event){_vm.debouncedOnInputChange($event)},"mouseenter":function($event){_vm.inputHovering = true},"mouseleave":function($event){_vm.inputHovering = false}},model:{value:(_vm.selectedLabel),callback:function ($$v) {_vm.selectedLabel=$$v},expression:"selectedLabel"}},[_c('i',{class:['el-select__caret', 'el-input__icon', 'el-icon-' + _vm.iconClass],attrs:{"slot":"suffix"},on:{"click":_vm.handleIconClick},slot:"suffix"})]),_c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"before-enter":_vm.handleMenuEnter,"after-leave":_vm.doDestroy}},[_c('el-select-menu',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible && _vm.emptyText !== false),expression:"visible && emptyText !== false"}],ref:"popper"},[_c('el-scrollbar',{directives:[{name:"show",rawName:"v-show",value:(_vm.options.length > 0 && !_vm.loading),expression:"options.length > 0 && !loading"}],class:{ 'is-empty': !_vm.allowCreate && _vm.query && _vm.filteredOptionsCount === 0 },attrs:{"tag":"ul","wrap-class":"el-select-dropdown__wrap","view-class":"el-select-dropdown__list"}},[(_vm.showNewOption)?_c('el-option',{attrs:{"value":_vm.query,"created":""}}):_vm._e(),_vm._t("default")],2),(_vm.emptyText && (_vm.allowCreate && _vm.options.length === 0 || !_vm.allowCreate))?_c('p',{staticClass:"el-select-dropdown__empty"},[_vm._v(_vm._s(_vm.emptyText))]):_vm._e()],1)],1)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),

/***/ 18:
/***/ (function(module, exports) {

module.exports = __webpack_require__("xhq7");

/***/ }),

/***/ 19:
/***/ (function(module, exports) {

module.exports = __webpack_require__("MD5c");

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = __webpack_require__("caRQ");

/***/ }),

/***/ 24:
/***/ (function(module, exports) {

module.exports = __webpack_require__("p4+t");

/***/ }),

/***/ 25:
/***/ (function(module, exports) {

module.exports = __webpack_require__("leuU");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = __webpack_require__("Hzfu");

/***/ }),

/***/ 33:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ed77bae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_vue__ = __webpack_require__(35);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ed77bae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_emitter2.default],

  name: 'ElOption',

  componentName: 'ElOption',

  inject: ['select'],

  props: {
    value: {
      required: true
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    };
  },


  computed: {
    isObject: function isObject() {
      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
    },
    currentLabel: function currentLabel() {
      return this.label || (this.isObject ? '' : this.value);
    },
    currentValue: function currentValue() {
      return this.value || this.label || '';
    },
    itemSelected: function itemSelected() {
      if (!this.select.multiple) {
        return this.isEqual(this.value, this.select.value);
      } else {
        return this.contains(this.select.value, this.value);
      }
    },
    limitReached: function limitReached() {
      if (this.select.multiple) {
        return !this.itemSelected && this.select.value.length >= this.select.multipleLimit && this.select.multipleLimit > 0;
      } else {
        return false;
      }
    }
  },

  watch: {
    currentLabel: function currentLabel() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    },
    value: function value() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    }
  },

  methods: {
    isEqual: function isEqual(a, b) {
      if (!this.isObject) {
        return a === b;
      } else {
        var valueKey = this.select.valueKey;
        return (0, _util.getValueByPath)(a, valueKey) === (0, _util.getValueByPath)(b, valueKey);
      }
    },
    contains: function contains() {
      var _this = this;

      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var target = arguments[1];

      if (!this.isObject) {
        return arr.indexOf(target) > -1;
      } else {
        var _ret = function () {
          var valueKey = _this.select.valueKey;
          return {
            v: arr.some(function (item) {
              return (0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(target, valueKey);
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
    },
    handleGroupDisabled: function handleGroupDisabled(val) {
      this.groupDisabled = val;
    },
    hoverItem: function hoverItem() {
      if (!this.disabled && !this.groupDisabled) {
        this.select.hoverIndex = this.select.options.indexOf(this);
      }
    },
    selectOptionClick: function selectOptionClick() {
      if (this.disabled !== true && this.groupDisabled !== true) {
        this.dispatch('ElSelect', 'handleOptionClick', this);
      }
    },
    queryChange: function queryChange(query) {
      // query 里如果有正则中的特殊字符，需要先将这些字符转义
      var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
      if (!this.visible) {
        this.select.filteredOptionsCount--;
      }
    }
  },

  created: function created() {
    this.select.options.push(this);
    this.select.cachedOptions.push(this);
    this.select.optionsCount++;
    this.select.filteredOptionsCount++;

    this.$on('queryChange', this.queryChange);
    this.$on('handleGroupDisabled', this.handleGroupDisabled);
  },
  beforeDestroy: function beforeDestroy() {
    this.select.onOptionDestroy(this.select.options.indexOf(this));
  }
};

/***/ }),

/***/ 35:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-select-dropdown__item",class:{
    'selected': _vm.itemSelected,
    'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
    'hover': _vm.hover
  },on:{"mouseenter":_vm.hoverItem,"click":function($event){$event.stopPropagation();_vm.selectOptionClick($event)}}},[_vm._t("default",[_c('span',[_vm._v(_vm._s(_vm.currentLabel))])])],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("6d3N");

/***/ }),

/***/ 6:
/***/ (function(module, exports) {

module.exports = __webpack_require__("L88V");

/***/ }),

/***/ 8:
/***/ (function(module, exports) {

module.exports = __webpack_require__("jA/d");

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

module.exports = __webpack_require__("ZAo2");

/***/ })

/******/ });

/***/ }),

/***/ "Ytca":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "Yyxk":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("Fgny"), __esModule: true };

/***/ }),

/***/ "ZAo2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

var _dom = __webpack_require__("6d3N");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nodeList = [];
var ctx = '@@clickoutsideContext';

var startClick = void 0;
var seed = 0;

!_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mousedown', function (e) {
  return startClick = e;
});

!_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mouseup', function (e) {
  nodeList.forEach(function (node) {
    return node[ctx].documentHandler(e, startClick);
  });
});
/**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */
exports.default = {
  bind: function bind(el, binding, vnode) {
    nodeList.push(el);
    var id = seed++;
    var documentHandler = function documentHandler() {
      var mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!vnode.context || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || vnode.context.popperElm && (vnode.context.popperElm.contains(mouseup.target) || vnode.context.popperElm.contains(mousedown.target))) return;

      if (binding.expression && el[ctx].methodName && vnode.context[el[ctx].methodName]) {
        vnode.context[el[ctx].methodName]();
      } else {
        el[ctx].bindingFn && el[ctx].bindingFn();
      }
    };
    el[ctx] = {
      id: id,
      documentHandler: documentHandler,
      methodName: binding.expression,
      bindingFn: binding.value
    };
  },
  update: function update(el, binding) {
    el[ctx].methodName = binding.expression;
    el[ctx].bindingFn = binding.value;
  },
  unbind: function unbind(el) {
    var len = nodeList.length;

    for (var i = 0; i < len; i++) {
      if (nodeList[i][ctx].id === el[ctx].id) {
        nodeList.splice(i, 1);
        break;
      }
    }
  }
};

/***/ }),

/***/ "Za1F":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("lSMs");
var has = __webpack_require__("AsM0");
var DESCRIPTORS = __webpack_require__("PRM/");
var $export = __webpack_require__("f68a");
var redefine = __webpack_require__("c+mw");
var META = __webpack_require__("xRTu").KEY;
var $fails = __webpack_require__("YEmw");
var shared = __webpack_require__("13kP");
var setToStringTag = __webpack_require__("9Poz");
var uid = __webpack_require__("Fl16");
var wks = __webpack_require__("IFGh");
var wksExt = __webpack_require__("QFRh");
var wksDefine = __webpack_require__("fuEY");
var enumKeys = __webpack_require__("M8k9");
var isArray = __webpack_require__("NN3v");
var anObject = __webpack_require__("fHSC");
var toIObject = __webpack_require__("/RPK");
var toPrimitive = __webpack_require__("7qHl");
var createDesc = __webpack_require__("TUEb");
var _create = __webpack_require__("38t3");
var gOPNExt = __webpack_require__("JcMz");
var $GOPD = __webpack_require__("FDNG");
var $DP = __webpack_require__("Lohu");
var $keys = __webpack_require__("9goP");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("D0fQ").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("ex+5").f = $propertyIsEnumerable;
  __webpack_require__("BWjf").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("ifR3")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("q1/O")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "ZeNl":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("/RPK");
var toLength = __webpack_require__("NU3K");
var toAbsoluteIndex = __webpack_require__("gJmu");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "aA9S":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("Vfex"), __esModule: true };

/***/ }),

/***/ "aWoT":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string') && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options, 'string');
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string')) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (string);

/***/ }),

/***/ "b5rb":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "b9OQ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__("hRKE");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rule___ = __webpack_require__("f+uh");



function required(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value);
  __WEBPACK_IMPORTED_MODULE_1__rule___["a" /* default */].required(rule, value, source, errors, options, type);
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (required);

/***/ }),

/***/ "c+mw":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("q1/O");


/***/ }),

/***/ "caRQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.noop = noop;
exports.hasOwn = hasOwn;
exports.toObject = toObject;
exports.getPropByPath = getPropByPath;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function noop() {};

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
};

function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
};

function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
};

var getValueByPath = exports.getValueByPath = function getValueByPath(object, prop) {
  prop = prop || '';
  var paths = prop.split('.');
  var current = object;
  var result = null;
  for (var i = 0, j = paths.length; i < j; i++) {
    var path = paths[i];
    if (!current) break;

    if (i === j - 1) {
      result = current[path];
      break;
    }
    current = current[path];
  }
  return result;
};

function getPropByPath(obj, path, strict) {
  var tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');

  var keyArr = path.split('.');
  var i = 0;
  for (var len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    var key = keyArr[i];
    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
};

var generateId = exports.generateId = function generateId() {
  return Math.floor(Math.random() * 10000);
};

var valueEquals = exports.valueEquals = function valueEquals(a, b) {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
};

/***/ }),

/***/ "cigS":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
  * vue-router v2.8.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if (false) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children)
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h()
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);
    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass);
      // pass non-declared props as attrs
      var attrs = data.attrs = data.attrs || {};
      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children)
  }
};

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if (false) {
        warn(
          false,
          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
          "expecting an object, function or boolean."
        );
      }
  }
}

function extend (to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "production" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */


var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  // handle null value #1566
  if (!a || !b) { return a === b }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null
            ? 'router-link-active'
            : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null
            ? 'router-link-exact-active'
            : globalExactActiveClass;
    var activeClass = this.activeClass == null
            ? activeClassFallback
            : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null
            ? exactActiveClassFallback
            : this.exactActiveClass;
    var compareTarget = location.path
      ? createRoute(null, location, null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) { on[e] = handler; });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed && _Vue === Vue) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, { pretty: true })
  } catch (e) {
    if (false) {
      warn(false, ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  }
}

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (false) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
      "string id. Use an actual component instead."
    );
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  );

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (false) {
      if (route.name && !route.redirect && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
          "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
          "the default child route will not be rendered. Remove the name from " +
          "this route and use the name of the default child route for named " +
          "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (false) {
      warn(
        false,
        "Duplicate named routes definition: " +
        "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function compileRouteRegex (path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (false) {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], ("Duplicate param keys in route with path: \"" + path + "\""));
      keys[key.name] = true;
    });
  }
  return regex
}

function normalizePath (path, parent, strict) {
  if (!strict) { path = path.replace(/\/$/, ''); }
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */


function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, ("path " + (current.path)));
    } else if (false) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

function assign (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

/*  */


function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (false) {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
        ? originalRedirect(createRoute(record, location, null, router))
        : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (false) {
        warn(
          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
        );
      }
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (false) {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if (false) {
        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */


var positionStore = Object.create(null);

function setupScroll () {
  // Fix for #1585 for Firefox
  window.history.replaceState({ key: getStateKey() }, '');
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (false) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);

    if (!shouldScroll) {
      return
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition((shouldScroll), position);
      }).catch(function (err) {
        if (false) {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

function scrollToPosition (shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);
    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState = inBrowser && (function () {
  var ua = window.navigator.userAgent;

  if (
    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    ua.indexOf('Mobile Safari') !== -1 &&
    ua.indexOf('Chrome') === -1 &&
    ua.indexOf('Windows Phone') === -1
  ) {
    return false
  }

  return window.history && 'pushState' in window.history
})();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now
  ? window.performance
  : Date;

var _key = genKey();

function genKey () {
  return Time.now().toFixed(3)
}

function getStateKey () {
  return _key
}

function setStateKey (key) {
  _key = key;
}

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "production" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

var hasSymbol =
  typeof Symbol === 'function' &&
  typeof Symbol.toStringTag === 'symbol';

function isESModule (obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) { cb(route); });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) { cb(err); });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort()
  }

  var ref = resolveQueue(this.current.matched, route.matched);
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort()
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' && (
            typeof to.path === 'string' ||
            typeof to.name === 'string'
          ))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort()
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) { cb(); });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid)
  })
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */


var HTML5History = (function (History$$1) {
  function HTML5History (router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === initLocation) {
        return
      }

      this$1.transitionTo(location, function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if ( History$$1 ) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */


var HashHistory = (function (History$$1) {
  function HashHistory (router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History$$1 ) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;
      if (!ensureSlash()) {
        return
      }
      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(
      cleanPath(base + '/#' + location)
    );
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1)
}

function getUrl (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return (base + "#" + path)
}

function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */


var AbstractHistory = (function (History$$1) {
  function AbstractHistory (router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */

var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (false) {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  "production" !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    );
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  var location = normalizeLocation(
    to,
    current || this.history.current,
    append,
    this
  );
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '2.8.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["a"] = (VueRouter);


/***/ }),

/***/ "e/mt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__("6d3N");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Transition = function () {
  function Transition() {
    _classCallCheck(this, Transition);
  }

  Transition.prototype.beforeEnter = function beforeEnter(el) {
    (0, _dom.addClass)(el, 'collapse-transition');
    if (!el.dataset) el.dataset = {};

    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;

    el.style.height = '0';
    el.style.paddingTop = 0;
    el.style.paddingBottom = 0;
  };

  Transition.prototype.enter = function enter(el) {
    el.dataset.oldOverflow = el.style.overflow;
    if (el.scrollHeight !== 0) {
      el.style.height = el.scrollHeight + 'px';
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    } else {
      el.style.height = '';
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    }

    el.style.overflow = 'hidden';
  };

  Transition.prototype.afterEnter = function afterEnter(el) {
    // for safari: remove class then reset height is necessary
    (0, _dom.removeClass)(el, 'collapse-transition');
    el.style.height = '';
    el.style.overflow = el.dataset.oldOverflow;
  };

  Transition.prototype.beforeLeave = function beforeLeave(el) {
    if (!el.dataset) el.dataset = {};
    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;
    el.dataset.oldOverflow = el.style.overflow;

    el.style.height = el.scrollHeight + 'px';
    el.style.overflow = 'hidden';
  };

  Transition.prototype.leave = function leave(el) {
    if (el.scrollHeight !== 0) {
      // for safari: add class after set height, or it will jump to zero height suddenly, weired
      (0, _dom.addClass)(el, 'collapse-transition');
      el.style.height = 0;
      el.style.paddingTop = 0;
      el.style.paddingBottom = 0;
    }
  };

  Transition.prototype.afterLeave = function afterLeave(el) {
    (0, _dom.removeClass)(el, 'collapse-transition');
    el.style.height = '';
    el.style.overflow = el.dataset.oldOverflow;
    el.style.paddingTop = el.dataset.oldPaddingTop;
    el.style.paddingBottom = el.dataset.oldPaddingBottom;
  };

  return Transition;
}();

exports.default = {
  name: 'ElCollapseTransition',
  functional: true,
  render: function render(h, _ref) {
    var children = _ref.children;

    var data = {
      on: new Transition()
    };

    return h('transition', data, children);
  }
};

/***/ }),

/***/ "e4BB":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



function type(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, ruleType) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options, ruleType);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, ruleType)) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (type);

/***/ }),

/***/ "esV0":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("PRM/") && !__webpack_require__("YEmw")(function () {
  return Object.defineProperty(__webpack_require__("l3hl")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "ex+5":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "f+uh":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__required__ = __webpack_require__("zydr");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__whitespace__ = __webpack_require__("i8Ld");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__type__ = __webpack_require__("HYS4");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__range__ = __webpack_require__("mbGH");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__enum__ = __webpack_require__("5YsT");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pattern__ = __webpack_require__("IPpm");







/* harmony default export */ __webpack_exports__["a"] = ({
  required: __WEBPACK_IMPORTED_MODULE_0__required__["a" /* default */],
  whitespace: __WEBPACK_IMPORTED_MODULE_1__whitespace__["a" /* default */],
  type: __WEBPACK_IMPORTED_MODULE_2__type__["a" /* default */],
  range: __WEBPACK_IMPORTED_MODULE_3__range__["a" /* default */],
  'enum': __WEBPACK_IMPORTED_MODULE_4__enum__["a" /* default */],
  pattern: __WEBPACK_IMPORTED_MODULE_5__pattern__["a" /* default */]
});

/***/ }),

/***/ "f68a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("lSMs");
var core = __webpack_require__("0nnt");
var ctx = __webpack_require__("tjS7");
var hide = __webpack_require__("q1/O");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "fHSC":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("X609");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "fuEY":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("lSMs");
var core = __webpack_require__("0nnt");
var LIBRARY = __webpack_require__("ifR3");
var wksExt = __webpack_require__("QFRh");
var defineProperty = __webpack_require__("Lohu").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "gJmu":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("IcQ3");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "gLa1":
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ "gUSn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.i18n = exports.use = exports.t = undefined;

var _zhCN = __webpack_require__("O1yE");

var _zhCN2 = _interopRequireDefault(_zhCN);

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

var _deepmerge = __webpack_require__("/ZBN");

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _format = __webpack_require__("ulw0");

var _format2 = _interopRequireDefault(_format);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var format = (0, _format2.default)(_vue2.default);
var lang = _zhCN2.default;
var merged = false;
var i18nHandler = function i18nHandler() {
  var vuei18n = Object.getPrototypeOf(this || _vue2.default).$t;
  if (typeof vuei18n === 'function' && !!_vue2.default.locale) {
    if (!merged) {
      merged = true;
      _vue2.default.locale(_vue2.default.config.lang, (0, _deepmerge2.default)(lang, _vue2.default.locale(_vue2.default.config.lang) || {}, { clone: true }));
    }
    return vuei18n.apply(this, arguments);
  }
};

var t = exports.t = function t(path, options) {
  var value = i18nHandler.apply(this, arguments);
  if (value !== null && value !== undefined) return value;

  var array = path.split('.');
  var current = lang;

  for (var i = 0, j = array.length; i < j; i++) {
    var property = array[i];
    value = current[property];
    if (i === j - 1) return format(value, options);
    if (!value) return '';
    current = value;
  }
  return '';
};

var use = exports.use = function use(l) {
  lang = l || lang;
};

var i18n = exports.i18n = function i18n(fn) {
  i18nHandler = fn || i18nHandler;
};

exports.default = { use: use, t: t, i18n: i18n };

/***/ }),

/***/ "hJiY":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 43);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("BbKf");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("Hzfu");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("caRQ");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("6d3N");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("5vqR");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("L88V");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("TI6a");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("jA/d");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.nextYear = exports.prevYear = exports.nextMonth = exports.prevMonth = exports.timeWithinRange = exports.limitTimeRange = exports.clearMilliseconds = exports.clearTime = exports.modifyTime = exports.modifyDate = exports.range = exports.getRangeHours = exports.getWeekNumber = exports.getStartDateOfMonth = exports.nextDate = exports.prevDate = exports.getFirstDayOfMonth = exports.getDayCountOfYear = exports.getDayCountOfMonth = exports.parseDate = exports.formatDate = exports.isDateObject = exports.isDate = exports.toDate = undefined;

var _date = __webpack_require__(172);

var _date2 = _interopRequireDefault(_date);

var _locale = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var weeks = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
var months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
var getI18nSettings = function getI18nSettings() {
  return {
    dayNamesShort: weeks.map(function (week) {
      return (0, _locale.t)('el.datepicker.weeks.' + week);
    }),
    dayNames: weeks.map(function (week) {
      return (0, _locale.t)('el.datepicker.weeks.' + week);
    }),
    monthNamesShort: months.map(function (month) {
      return (0, _locale.t)('el.datepicker.months.' + month);
    }),
    monthNames: months.map(function (month, index) {
      return (0, _locale.t)('el.datepicker.month' + (index + 1));
    }),
    amPm: ['am', 'pm']
  };
};

var newArray = function newArray(start, end) {
  var result = [];
  for (var i = start; i <= end; i++) {
    result.push(i);
  }
  return result;
};

var toDate = exports.toDate = function toDate(date) {
  return isDate(date) ? new Date(date) : null;
};

var isDate = exports.isDate = function isDate(date) {
  if (date === null || date === undefined) return false;
  if (isNaN(new Date(date).getTime())) return false;
  return true;
};

var isDateObject = exports.isDateObject = function isDateObject(val) {
  return val instanceof Date;
};

var formatDate = exports.formatDate = function formatDate(date, format) {
  date = toDate(date);
  if (!date) return '';
  return _date2.default.format(date, format || 'yyyy-MM-dd', getI18nSettings());
};

var parseDate = exports.parseDate = function parseDate(string, format) {
  return _date2.default.parse(string, format || 'yyyy-MM-dd', getI18nSettings());
};

var getDayCountOfMonth = exports.getDayCountOfMonth = function getDayCountOfMonth(year, month) {
  if (month === 3 || month === 5 || month === 8 || month === 10) {
    return 30;
  }

  if (month === 1) {
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
      return 29;
    } else {
      return 28;
    }
  }

  return 31;
};

var getDayCountOfYear = exports.getDayCountOfYear = function getDayCountOfYear(year) {
  var isLeapYear = year % 400 === 0 || year % 100 !== 0 && year % 4 === 0;
  return isLeapYear ? 366 : 365;
};

var getFirstDayOfMonth = exports.getFirstDayOfMonth = function getFirstDayOfMonth(date) {
  var temp = new Date(date.getTime());
  temp.setDate(1);
  return temp.getDay();
};

// see: https://stackoverflow.com/questions/3674539/incrementing-a-date-in-javascript
// {prev, next} Date should work for Daylight Saving Time
// Adding 24 * 60 * 60 * 1000 does not work in the above scenario
var prevDate = exports.prevDate = function prevDate(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return new Date(date.getFullYear(), date.getMonth(), date.getDate() - amount);
};

var nextDate = exports.nextDate = function nextDate(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return new Date(date.getFullYear(), date.getMonth(), date.getDate() + amount);
};

var getStartDateOfMonth = exports.getStartDateOfMonth = function getStartDateOfMonth(year, month) {
  var result = new Date(year, month, 1);
  var day = result.getDay();

  if (day === 0) {
    return prevDate(result, 7);
  } else {
    return prevDate(result, day);
  }
};

var getWeekNumber = exports.getWeekNumber = function getWeekNumber(src) {
  var date = new Date(src.getTime());
  date.setHours(0, 0, 0, 0);
  // Thursday in current week decides the year.
  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
  // January 4 is always in week 1.
  var week1 = new Date(date.getFullYear(), 0, 4);
  // Adjust to Thursday in week 1 and count number of weeks from date to week 1.
  // Rounding should be fine for Daylight Saving Time. Its shift should never be more than 12 hours.
  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
};

var getRangeHours = exports.getRangeHours = function getRangeHours(ranges) {
  var hours = [];
  var disabledHours = [];

  (ranges || []).forEach(function (range) {
    var value = range.map(function (date) {
      return date.getHours();
    });

    disabledHours = disabledHours.concat(newArray(value[0], value[1]));
  });

  if (disabledHours.length) {
    for (var i = 0; i < 24; i++) {
      hours[i] = disabledHours.indexOf(i) === -1;
    }
  } else {
    for (var _i = 0; _i < 24; _i++) {
      hours[_i] = false;
    }
  }

  return hours;
};

var range = exports.range = function range(n) {
  // see https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
  return Array.apply(null, { length: n }).map(function (_, n) {
    return n;
  });
};

var modifyDate = exports.modifyDate = function modifyDate(date, y, m, d) {
  return new Date(y, m, d, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};

var modifyTime = exports.modifyTime = function modifyTime(date, h, m, s) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, s, date.getMilliseconds());
};

var clearTime = exports.clearTime = function clearTime(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
};

var clearMilliseconds = exports.clearMilliseconds = function clearMilliseconds(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
};

var limitTimeRange = exports.limitTimeRange = function limitTimeRange(date, ranges) {
  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'HH:mm:ss';

  // TODO: refactory a more elegant solution
  if (ranges.length === 0) return date;
  var normalizeDate = function normalizeDate(date) {
    return _date2.default.parse(_date2.default.format(date, format), format);
  };
  var ndate = normalizeDate(date);
  var nranges = ranges.map(function (range) {
    return range.map(normalizeDate);
  });
  if (nranges.some(function (nrange) {
    return ndate >= nrange[0] && ndate <= nrange[1];
  })) return date;

  var minDate = nranges[0][0];
  var maxDate = nranges[0][0];

  nranges.forEach(function (nrange) {
    minDate = new Date(Math.min(nrange[0], minDate));
    maxDate = new Date(Math.max(nrange[1], minDate));
  });

  var ret = ndate < minDate ? minDate : maxDate;
  // preserve Year/Month/Date
  return modifyDate(ret, date.getFullYear(), date.getMonth(), date.getDate());
};

var timeWithinRange = exports.timeWithinRange = function timeWithinRange(date, selectableRange, format) {
  var limitedDate = limitTimeRange(date, selectableRange, format);
  return limitedDate.getTime() === date.getTime();
};

var prevMonth = exports.prevMonth = function prevMonth(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  if (month === 0) {
    year -= 1;
    month = 11;
  } else {
    month -= 1;
  }
  var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
  return modifyDate(date, year, month, monthDate);
};

var nextMonth = exports.nextMonth = function nextMonth(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  if (month === 11) {
    year += 1;
    month = 0;
  } else {
    month += 1;
  }
  var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
  return modifyDate(date, year, month, monthDate);
};

// check for leap year Feburary
var prevYear = exports.prevYear = function prevYear(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  var year = date.getFullYear() - amount;
  var month = date.getMonth();
  var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
  return modifyDate(date, year, month, monthDate);
};

var nextYear = exports.nextYear = function nextYear(date) {
  var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  var year = date.getFullYear() + amount;
  var month = date.getMonth();
  var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
  return modifyDate(date, year, month, monthDate);
};

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("x018");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("ZAo2");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("UGrZ");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("E3Cb");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("xp85");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("zYT2");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("gUSn");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("9lqe");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("MD5c");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("xhq7");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("e/mt");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("rNOT");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("rBjB");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("p4+t");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("leuU");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getRowIdentity = exports.mousewheel = exports.getColumnByCell = exports.getColumnById = exports.orderBy = exports.getCell = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _util = __webpack_require__(3);

var getCell = exports.getCell = function getCell(event) {
  var cell = event.target;

  while (cell && cell.tagName.toUpperCase() !== 'HTML') {
    if (cell.tagName.toUpperCase() === 'TD') {
      return cell;
    }
    cell = cell.parentNode;
  }

  return null;
};

var isObject = function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
};

var orderBy = exports.orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array;
  }
  if (typeof reverse === 'string') {
    reverse = reverse === 'descending' ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }
  var getKey = sortMethod ? null : function (value, index) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }
      return sortBy.map(function (by) {
        if (typeof by === 'string') {
          return (0, _util.getValueByPath)(value, by);
        } else {
          return by(value, index, array);
        }
      });
    }
    if (sortKey !== '$key') {
      if (isObject(value) && '$value' in value) value = value.$value;
    }
    return [isObject(value) ? (0, _util.getValueByPath)(value, sortKey) : value];
  };
  var compare = function compare(a, b) {
    if (sortMethod) {
      return sortMethod(a.value, b.value);
    }
    for (var i = 0, len = a.key.length; i < len; i++) {
      if (a.key[i] < b.key[i]) {
        return -1;
      }
      if (a.key[i] > b.key[i]) {
        return 1;
      }
    }
    return 0;
  };
  return array.map(function (value, index) {
    return {
      value: value,
      index: index,
      key: getKey ? getKey(value, index) : null
    };
  }).sort(function (a, b) {
    var order = compare(a, b);
    if (!order) {
      // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
      order = a.index - b.index;
    }
    return order * reverse;
  }).map(function (item) {
    return item.value;
  });
};

var getColumnById = exports.getColumnById = function getColumnById(table, columnId) {
  var column = null;
  table.columns.forEach(function (item) {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};

var getColumnByCell = exports.getColumnByCell = function getColumnByCell(table, cell) {
  var matches = (cell.className || '').match(/el-table_[^\s]+/gm);
  if (matches) {
    return getColumnById(table, matches[0]);
  }
  return null;
};

var isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

var mousewheel = exports.mousewheel = function mousewheel(element, callback) {
  if (element && element.addEventListener) {
    element.addEventListener(isFirefox ? 'DOMMouseScroll' : 'mousewheel', callback);
  }
};

var getRowIdentity = exports.getRowIdentity = function getRowIdentity(row, rowKey) {
  if (!row) throw new Error('row is required when get row identity');
  if (typeof rowKey === 'string') {
    if (rowKey.indexOf('.') < 0) {
      return row[rowKey];
    }
    var key = rowKey.split('.');
    var current = row;
    for (var i = 0; i < key.length; i++) {
      current = current[key[i]];
    }
    return current;
  } else if (typeof rowKey === 'function') {
    return rowKey.call(null, row);
  }
};

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_vue__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b32bdda0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_picker_vue__ = __webpack_require__(173);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b32bdda0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_picker_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_vue__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4135ea9a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_vue__ = __webpack_require__(179);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4135ea9a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (element, options) {
  if (_vue2.default.prototype.$isServer) return;
  var moveFn = function moveFn(event) {
    if (options.drag) {
      options.drag(event);
    }
  };
  var upFn = function upFn(event) {
    document.removeEventListener('mousemove', moveFn);
    document.removeEventListener('mouseup', upFn);
    document.onselectstart = null;
    document.ondragstart = null;

    isDragging = false;

    if (options.end) {
      options.end(event);
    }
  };
  element.addEventListener('mousedown', function (event) {
    if (isDragging) return;
    document.onselectstart = function () {
      return false;
    };
    document.ondragstart = function () {
      return false;
    };

    document.addEventListener('mousemove', moveFn);
    document.addEventListener('mouseup', upFn);
    isDragging = true;

    if (options.start) {
      options.start(event);
    }
  });
};

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isDragging = false;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var aria = aria || {};

aria.Utils = aria.Utils || {};

/**
 * @desc Set focus on descendant nodes until the first focusable element is
 *       found.
 * @param element
 *          DOM node for which to find the first focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */
aria.Utils.focusFirstDescendant = function (element) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (aria.Utils.attemptFocus(child) || aria.Utils.focusFirstDescendant(child)) {
      return true;
    }
  }
  return false;
};

/**
 * @desc Find the last descendant node that is focusable.
 * @param element
 *          DOM node for which to find the last focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */

aria.Utils.focusLastDescendant = function (element) {
  for (var i = element.childNodes.length - 1; i >= 0; i--) {
    var child = element.childNodes[i];
    if (aria.Utils.attemptFocus(child) || aria.Utils.focusLastDescendant(child)) {
      return true;
    }
  }
  return false;
};

/**
 * @desc Set Attempt to set focus on the current node.
 * @param element
 *          The node to attempt to focus on.
 * @returns
 *  true if element is focused.
 */
aria.Utils.attemptFocus = function (element) {
  if (!aria.Utils.isFocusable(element)) {
    return false;
  }
  aria.Utils.IgnoreUtilFocusChanges = true;
  try {
    element.focus();
  } catch (e) {}
  aria.Utils.IgnoreUtilFocusChanges = false;
  return document.activeElement === element;
};

aria.Utils.isFocusable = function (element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {
    return true;
  }

  if (element.disabled) {
    return false;
  }

  switch (element.nodeName) {
    case 'A':
      return !!element.href && element.rel !== 'ignore';
    case 'INPUT':
      return element.type !== 'hidden' && element.type !== 'file';
    case 'BUTTON':
    case 'SELECT':
    case 'TEXTAREA':
      return true;
    default:
      return false;
  }
};

/**
 * 触发一个事件
 * mouseenter, mouseleave, mouseover, keyup, change, click 等
 * @param  {Element} elm
 * @param  {String} name
 * @param  {*} opts
 */
aria.Utils.triggerEvent = function (elm, name) {
  var eventName = void 0;

  if (/^mouse|click/.test(name)) {
    eventName = 'MouseEvents';
  } else if (/^key/.test(name)) {
    eventName = 'KeyboardEvent';
  } else {
    eventName = 'HTMLEvents';
  }
  var evt = document.createEvent(eventName);

  for (var _len = arguments.length, opts = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    opts[_key - 2] = arguments[_key];
  }

  evt.initEvent.apply(evt, [name].concat(opts));
  elm.dispatchEvent ? elm.dispatchEvent(evt) : elm.fireEvent('on' + name, evt);

  return elm;
};

aria.Utils.keys = {
  tab: 9,
  enter: 13,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40
};

exports.default = aria.Utils;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  computed: {
    indexPath: function indexPath() {
      var path = [this.index];
      var parent = this.$parent;
      while (parent.$options.componentName !== 'ElMenu') {
        if (parent.index) {
          path.unshift(parent.index);
        }
        parent = parent.$parent;
      }
      return path;
    },
    rootMenu: function rootMenu() {
      var parent = this.$parent;
      while (parent && parent.$options.componentName !== 'ElMenu') {
        parent = parent.$parent;
      }
      return parent;
    },
    parentMenu: function parentMenu() {
      var parent = this.$parent;
      while (parent && ['ElMenu', 'ElSubmenu'].indexOf(parent.$options.componentName) === -1) {
        parent = parent.$parent;
      }
      return parent;
    },
    paddingStyle: function paddingStyle() {
      if (this.rootMenu.mode !== 'vertical') return {};

      var padding = 20;
      var parent = this.$parent;

      if (this.rootMenu.collapse) {
        padding = 20;
      } else {
        while (parent && parent.$options.componentName !== 'ElMenu') {
          if (parent.$options.componentName === 'ElSubmenu') {
            padding += 20;
          }
          parent = parent.$parent;
        }
      }
      return { paddingLeft: padding + 'px' };
    }
  }
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

exports.default = {
  bind: function bind(el, binding, vnode) {
    var interval = null;
    var startTime = void 0;
    var handler = function handler() {
      return vnode.context[binding.expression].apply();
    };
    var clear = function clear() {
      if (new Date() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };

    (0, _dom.on)(el, 'mousedown', function (e) {
      if (e.button !== 0) return;
      startTime = new Date();
      (0, _dom.once)(document, 'mouseup', clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
};

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ed77bae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_vue__ = __webpack_require__(138);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ed77bae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("VMHY");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("wDOA");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("kL9Z");

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_spinner_vue__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_spinner_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_spinner_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_48e066fc_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_spinner_vue__ = __webpack_require__(178);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_spinner_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_48e066fc_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_spinner_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_table_vue__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_table_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_table_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_135ffc92_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_date_table_vue__ = __webpack_require__(187);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_table_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_135ffc92_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_date_table_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var NODE_KEY = exports.NODE_KEY = '$treeNodeId';

var markNodeData = exports.markNodeData = function markNodeData(node, data) {
  if (data[NODE_KEY]) return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};

var getNodeKey = exports.getNodeKey = function getNodeKey(key, data) {
  if (!key) return data[NODE_KEY];
  return data[key];
};

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_loading_vue__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_loading_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_loading_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0d8d1339_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_loading_vue__ = __webpack_require__(277);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_loading_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0d8d1339_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_loading_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("w4xd");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("rGkY");

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_dragger_vue__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_dragger_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_dragger_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4d4d91e8_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_upload_dragger_vue__ = __webpack_require__(297);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_dragger_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4d4d91e8_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_upload_dragger_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(44);


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(45);

var _index2 = _interopRequireDefault(_index);

var _index3 = __webpack_require__(52);

var _index4 = _interopRequireDefault(_index3);

var _index5 = __webpack_require__(56);

var _index6 = _interopRequireDefault(_index5);

var _index7 = __webpack_require__(63);

var _index8 = _interopRequireDefault(_index7);

var _index9 = __webpack_require__(67);

var _index10 = _interopRequireDefault(_index9);

var _index11 = __webpack_require__(71);

var _index12 = _interopRequireDefault(_index11);

var _index13 = __webpack_require__(75);

var _index14 = _interopRequireDefault(_index13);

var _index15 = __webpack_require__(82);

var _index16 = _interopRequireDefault(_index15);

var _index17 = __webpack_require__(86);

var _index18 = _interopRequireDefault(_index17);

var _index19 = __webpack_require__(90);

var _index20 = _interopRequireDefault(_index19);

var _index21 = __webpack_require__(94);

var _index22 = _interopRequireDefault(_index21);

var _index23 = __webpack_require__(99);

var _index24 = _interopRequireDefault(_index23);

var _index25 = __webpack_require__(103);

var _index26 = _interopRequireDefault(_index25);

var _index27 = __webpack_require__(107);

var _index28 = _interopRequireDefault(_index27);

var _index29 = __webpack_require__(111);

var _index30 = _interopRequireDefault(_index29);

var _index31 = __webpack_require__(115);

var _index32 = _interopRequireDefault(_index31);

var _index33 = __webpack_require__(119);

var _index34 = _interopRequireDefault(_index33);

var _index35 = __webpack_require__(123);

var _index36 = _interopRequireDefault(_index35);

var _index37 = __webpack_require__(127);

var _index38 = _interopRequireDefault(_index37);

var _index39 = __webpack_require__(131);

var _index40 = _interopRequireDefault(_index39);

var _index41 = __webpack_require__(141);

var _index42 = _interopRequireDefault(_index41);

var _index43 = __webpack_require__(142);

var _index44 = _interopRequireDefault(_index43);

var _index45 = __webpack_require__(146);

var _index46 = _interopRequireDefault(_index45);

var _index47 = __webpack_require__(150);

var _index48 = _interopRequireDefault(_index47);

var _index49 = __webpack_require__(154);

var _index50 = _interopRequireDefault(_index49);

var _index51 = __webpack_require__(167);

var _index52 = _interopRequireDefault(_index51);

var _index53 = __webpack_require__(169);

var _index54 = _interopRequireDefault(_index53);

var _index55 = __webpack_require__(192);

var _index56 = _interopRequireDefault(_index55);

var _index57 = __webpack_require__(197);

var _index58 = _interopRequireDefault(_index57);

var _index59 = __webpack_require__(202);

var _index60 = _interopRequireDefault(_index59);

var _index61 = __webpack_require__(207);

var _index62 = _interopRequireDefault(_index61);

var _index63 = __webpack_require__(209);

var _index64 = _interopRequireDefault(_index63);

var _index65 = __webpack_require__(215);

var _index66 = _interopRequireDefault(_index65);

var _index67 = __webpack_require__(219);

var _index68 = _interopRequireDefault(_index67);

var _index69 = __webpack_require__(223);

var _index70 = _interopRequireDefault(_index69);

var _index71 = __webpack_require__(227);

var _index72 = _interopRequireDefault(_index71);

var _index73 = __webpack_require__(232);

var _index74 = _interopRequireDefault(_index73);

var _index75 = __webpack_require__(240);

var _index76 = _interopRequireDefault(_index75);

var _index77 = __webpack_require__(244);

var _index78 = _interopRequireDefault(_index77);

var _index79 = __webpack_require__(248);

var _index80 = _interopRequireDefault(_index79);

var _index81 = __webpack_require__(257);

var _index82 = _interopRequireDefault(_index81);

var _index83 = __webpack_require__(261);

var _index84 = _interopRequireDefault(_index83);

var _index85 = __webpack_require__(266);

var _index86 = _interopRequireDefault(_index85);

var _index87 = __webpack_require__(274);

var _index88 = _interopRequireDefault(_index87);

var _index89 = __webpack_require__(279);

var _index90 = _interopRequireDefault(_index89);

var _index91 = __webpack_require__(283);

var _index92 = _interopRequireDefault(_index91);

var _index93 = __webpack_require__(285);

var _index94 = _interopRequireDefault(_index93);

var _index95 = __webpack_require__(287);

var _index96 = _interopRequireDefault(_index95);

var _index97 = __webpack_require__(300);

var _index98 = _interopRequireDefault(_index97);

var _index99 = __webpack_require__(304);

var _index100 = _interopRequireDefault(_index99);

var _index101 = __webpack_require__(308);

var _index102 = _interopRequireDefault(_index101);

var _index103 = __webpack_require__(313);

var _index104 = _interopRequireDefault(_index103);

var _index105 = __webpack_require__(317);

var _index106 = _interopRequireDefault(_index105);

var _index107 = __webpack_require__(321);

var _index108 = _interopRequireDefault(_index107);

var _index109 = __webpack_require__(325);

var _index110 = _interopRequireDefault(_index109);

var _index111 = __webpack_require__(329);

var _index112 = _interopRequireDefault(_index111);

var _index113 = __webpack_require__(333);

var _index114 = _interopRequireDefault(_index113);

var _index115 = __webpack_require__(337);

var _index116 = _interopRequireDefault(_index115);

var _index117 = __webpack_require__(341);

var _index118 = _interopRequireDefault(_index117);

var _index119 = __webpack_require__(345);

var _index120 = _interopRequireDefault(_index119);

var _index121 = __webpack_require__(349);

var _index122 = _interopRequireDefault(_index121);

var _index123 = __webpack_require__(353);

var _index124 = _interopRequireDefault(_index123);

var _index125 = __webpack_require__(360);

var _index126 = _interopRequireDefault(_index125);

var _index127 = __webpack_require__(377);

var _index128 = _interopRequireDefault(_index127);

var _index129 = __webpack_require__(384);

var _index130 = _interopRequireDefault(_index129);

var _index131 = __webpack_require__(388);

var _index132 = _interopRequireDefault(_index131);

var _index133 = __webpack_require__(392);

var _index134 = _interopRequireDefault(_index133);

var _index135 = __webpack_require__(396);

var _index136 = _interopRequireDefault(_index135);

var _index137 = __webpack_require__(400);

var _index138 = _interopRequireDefault(_index137);

var _locale = __webpack_require__(16);

var _locale2 = _interopRequireDefault(_locale);

var _collapseTransition = __webpack_require__(20);

var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var components = [_index2.default, _index4.default, _index6.default, _index8.default, _index10.default, _index12.default, _index14.default, _index16.default, _index18.default, _index20.default, _index22.default, _index24.default, _index26.default, _index28.default, _index30.default, _index32.default, _index34.default, _index36.default, _index38.default, _index40.default, _index42.default, _index44.default, _index46.default, _index48.default, _index50.default, _index52.default, _index54.default, _index56.default, _index58.default, _index60.default, _index62.default, _index66.default, _index68.default, _index70.default, _index72.default, _index74.default, _index76.default, _index78.default, _index80.default, _index82.default, _index86.default, _index90.default, _index92.default, _index94.default, _index96.default, _index98.default, _index100.default, _index104.default, _index106.default, _index108.default, _index110.default, _index112.default, _index114.default, _index116.default, _index118.default, _index120.default, _index122.default, _index124.default, _index126.default, _index128.default, _index130.default, _index132.default, _index134.default, _index136.default, _index138.default, _collapseTransition2.default]; /* Automatically generated by './build/bin/build-entry.js' */

var install = function install(Vue) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  /* istanbul ignore if */
  if (install.installed) return;
  _locale2.default.use(opts.locale);
  _locale2.default.i18n(opts.i18n);

  components.map(function (component) {
    Vue.component(component.name, component);
  });

  Vue.use(_index88.default.directive);

  var ELEMENT = {};
  ELEMENT.size = opts.size || '';

  Vue.prototype.$loading = _index88.default.service;
  Vue.prototype.$msgbox = _index64.default;
  Vue.prototype.$alert = _index64.default.alert;
  Vue.prototype.$confirm = _index64.default.confirm;
  Vue.prototype.$prompt = _index64.default.prompt;
  Vue.prototype.$notify = _index84.default;
  Vue.prototype.$message = _index102.default;

  Vue.prototype.$ELEMENT = ELEMENT;
};

/* istanbul ignore if */
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
};

module.exports = {
  version: '2.0.4',
  locale: _locale2.default.use,
  i18n: _locale2.default.i18n,
  install: install,
  CollapseTransition: _collapseTransition2.default,
  Loading: _index88.default,
  Pagination: _index2.default,
  Dialog: _index4.default,
  Autocomplete: _index6.default,
  Dropdown: _index8.default,
  DropdownMenu: _index10.default,
  DropdownItem: _index12.default,
  Menu: _index14.default,
  Submenu: _index16.default,
  MenuItem: _index18.default,
  MenuItemGroup: _index20.default,
  Input: _index22.default,
  InputNumber: _index24.default,
  Radio: _index26.default,
  RadioGroup: _index28.default,
  RadioButton: _index30.default,
  Checkbox: _index32.default,
  CheckboxButton: _index34.default,
  CheckboxGroup: _index36.default,
  Switch: _index38.default,
  Select: _index40.default,
  Option: _index42.default,
  OptionGroup: _index44.default,
  Button: _index46.default,
  ButtonGroup: _index48.default,
  Table: _index50.default,
  TableColumn: _index52.default,
  DatePicker: _index54.default,
  TimeSelect: _index56.default,
  TimePicker: _index58.default,
  Popover: _index60.default,
  Tooltip: _index62.default,
  MessageBox: _index64.default,
  Breadcrumb: _index66.default,
  BreadcrumbItem: _index68.default,
  Form: _index70.default,
  FormItem: _index72.default,
  Tabs: _index74.default,
  TabPane: _index76.default,
  Tag: _index78.default,
  Tree: _index80.default,
  Alert: _index82.default,
  Notification: _index84.default,
  Slider: _index86.default,
  Icon: _index90.default,
  Row: _index92.default,
  Col: _index94.default,
  Upload: _index96.default,
  Progress: _index98.default,
  Spinner: _index100.default,
  Message: _index102.default,
  Badge: _index104.default,
  Card: _index106.default,
  Rate: _index108.default,
  Steps: _index110.default,
  Step: _index112.default,
  Carousel: _index114.default,
  Scrollbar: _index116.default,
  CarouselItem: _index118.default,
  Collapse: _index120.default,
  CollapseItem: _index122.default,
  Cascader: _index124.default,
  ColorPicker: _index126.default,
  Transfer: _index128.default,
  Container: _index130.default,
  Header: _index132.default,
  Aside: _index134.default,
  Main: _index136.default,
  Footer: _index138.default
};

module.exports.default = module.exports;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pagination = __webpack_require__(46);

var _pagination2 = _interopRequireDefault(_pagination);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_pagination2.default.install = function (Vue) {
  Vue.component(_pagination2.default.name, _pagination2.default);
};

exports.default = _pagination2.default;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pager = __webpack_require__(47);

var _pager2 = _interopRequireDefault(_pager);

var _select = __webpack_require__(50);

var _select2 = _interopRequireDefault(_select);

var _option = __webpack_require__(51);

var _option2 = _interopRequireDefault(_option);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElPagination',

  props: {
    pageSize: {
      type: Number,
      default: 10
    },

    small: Boolean,

    total: Number,

    pageCount: Number,

    currentPage: {
      type: Number,
      default: 1
    },

    layout: {
      default: 'prev, pager, next, jumper, ->, total'
    },

    pageSizes: {
      type: Array,
      default: function _default() {
        return [10, 20, 30, 40, 50, 100];
      }
    },

    popperClass: String,

    prevText: String,

    nextText: String
  },

  data: function data() {
    return {
      internalCurrentPage: 1,
      internalPageSize: 0
    };
  },
  render: function render(h) {
    var template = h(
      'div',
      { 'class': 'el-pagination' },
      []
    );
    var layout = this.layout || '';
    if (!layout) return;
    var TEMPLATE_MAP = {
      prev: h(
        'prev',
        null,
        []
      ),
      jumper: h(
        'jumper',
        null,
        []
      ),
      pager: h(
        'pager',
        {
          attrs: { currentPage: this.internalCurrentPage, pageCount: this.internalPageCount },
          on: {
            'change': this.handleCurrentChange
          }
        },
        []
      ),
      next: h(
        'next',
        null,
        []
      ),
      sizes: h(
        'sizes',
        {
          attrs: { pageSizes: this.pageSizes }
        },
        []
      ),
      slot: h(
        'my-slot',
        null,
        []
      ),
      total: h(
        'total',
        null,
        []
      )
    };
    var components = layout.split(',').map(function (item) {
      return item.trim();
    });
    var rightWrapper = h(
      'div',
      { 'class': 'el-pagination__rightwrapper' },
      []
    );
    var haveRightWrapper = false;

    if (this.small) {
      template.data.class += ' el-pagination--small';
    }

    components.forEach(function (compo) {
      if (compo === '->') {
        haveRightWrapper = true;
        return;
      }

      if (!haveRightWrapper) {
        template.children.push(TEMPLATE_MAP[compo]);
      } else {
        rightWrapper.children.push(TEMPLATE_MAP[compo]);
      }
    });

    if (haveRightWrapper) {
      template.children.unshift(rightWrapper);
    }

    return template;
  },


  components: {
    MySlot: {
      render: function render(h) {
        return this.$parent.$slots.default ? this.$parent.$slots.default[0] : '';
      }
    },
    Prev: {
      render: function render(h) {
        return h(
          'button',
          {
            attrs: {
              type: 'button'
            },
            'class': ['btn-prev', { disabled: this.$parent.internalCurrentPage <= 1 }],
            on: {
              'click': this.$parent.prev
            }
          },
          [this.$parent.prevText ? h(
            'span',
            null,
            [this.$parent.prevText]
          ) : h(
            'i',
            { 'class': 'el-icon el-icon-arrow-left' },
            []
          )]
        );
      }
    },

    Next: {
      render: function render(h) {
        return h(
          'button',
          {
            attrs: {
              type: 'button'
            },
            'class': ['btn-next', { disabled: this.$parent.internalCurrentPage === this.$parent.internalPageCount || this.$parent.internalPageCount === 0 }],
            on: {
              'click': this.$parent.next
            }
          },
          [this.$parent.nextText ? h(
            'span',
            null,
            [this.$parent.nextText]
          ) : h(
            'i',
            { 'class': 'el-icon el-icon-arrow-right' },
            []
          )]
        );
      }
    },

    Sizes: {
      mixins: [_locale2.default],

      props: {
        pageSizes: Array
      },

      watch: {
        pageSizes: {
          immediate: true,
          handler: function handler(newVal, oldVal) {
            if ((0, _util.valueEquals)(newVal, oldVal)) return;
            if (Array.isArray(newVal)) {
              this.$parent.internalPageSize = newVal.indexOf(this.$parent.pageSize) > -1 ? this.$parent.pageSize : this.pageSizes[0];
            }
          }
        }
      },

      render: function render(h) {
        var _this = this;

        return h(
          'span',
          { 'class': 'el-pagination__sizes' },
          [h(
            'el-select',
            {
              attrs: {
                value: this.$parent.internalPageSize,
                popperClass: (this.$parent.popperClass || '') + ' is-arrow-fixed'
              },
              on: {
                'input': this.handleChange
              }
            },
            [this.pageSizes.map(function (item) {
              return h(
                'el-option',
                {
                  attrs: {
                    value: item,
                    label: item + _this.t('el.pagination.pagesize') }
                },
                []
              );
            })]
          )]
        );
      },


      components: {
        ElSelect: _select2.default,
        ElOption: _option2.default
      },

      methods: {
        handleChange: function handleChange(val) {
          if (val !== this.$parent.internalPageSize) {
            this.$parent.internalPageSize = val = parseInt(val, 10);
            this.$parent.$emit('size-change', val);
          }
        }
      }
    },

    Jumper: {
      mixins: [_locale2.default],

      data: function data() {
        return {
          oldValue: null
        };
      },


      components: { ElInput: _input2.default },

      methods: {
        handleFocus: function handleFocus(event) {
          this.oldValue = event.target.value;
        },
        handleBlur: function handleBlur(_ref) {
          var target = _ref.target;

          this.reassignMaxValue(target);
        },
        handleKeyUp: function handleKeyUp(event) {
          var key = event.key || '';
          var keyCode = event.keyCode || '';
          if (key && key === 'Enter' || keyCode && keyCode === 13) {
            this.reassignMaxValue(event.target);
            this.handleChange(event.target.value);
          }
        },
        handleChange: function handleChange(value) {
          this.$parent.internalCurrentPage = this.$parent.getValidCurrentPage(value);
          this.oldValue = null;
        },
        reassignMaxValue: function reassignMaxValue(target) {
          if (+target.value > this.$parent.internalPageCount) {
            target.value = this.$parent.internalPageCount;
          }
        }
      },

      render: function render(h) {
        return h(
          'span',
          { 'class': 'el-pagination__jump' },
          [this.t('el.pagination.goto'), h(
            'el-input',
            {
              'class': 'el-pagination__editor is-in-pagination',
              attrs: { min: 1,
                max: this.$parent.internalPageCount,
                value: this.$parent.internalCurrentPage,

                type: 'number'
              },
              domProps: {
                'value': this.$parent.internalCurrentPage
              },
              on: {
                'change': this.handleChange,
                'focus': this.handleFocus,
                'blur': this.handleBlur
              },
              nativeOn: {
                'keyup': this.handleKeyUp
              }
            },
            []
          ), this.t('el.pagination.pageClassifier')]
        );
      }
    },

    Total: {
      mixins: [_locale2.default],

      render: function render(h) {
        return typeof this.$parent.total === 'number' ? h(
          'span',
          { 'class': 'el-pagination__total' },
          [this.t('el.pagination.total', { total: this.$parent.total })]
        ) : '';
      }
    },

    Pager: _pager2.default
  },

  methods: {
    handleCurrentChange: function handleCurrentChange(val) {
      this.internalCurrentPage = this.getValidCurrentPage(val);
    },
    prev: function prev() {
      var newVal = this.internalCurrentPage - 1;
      this.internalCurrentPage = this.getValidCurrentPage(newVal);
    },
    next: function next() {
      var newVal = this.internalCurrentPage + 1;
      this.internalCurrentPage = this.getValidCurrentPage(newVal);
    },
    getValidCurrentPage: function getValidCurrentPage(value) {
      value = parseInt(value, 10);

      var havePageCount = typeof this.internalPageCount === 'number';

      var resetValue = void 0;
      if (!havePageCount) {
        if (isNaN(value) || value < 1) resetValue = 1;
      } else {
        if (value < 1) {
          resetValue = 1;
        } else if (value > this.internalPageCount) {
          resetValue = this.internalPageCount;
        }
      }

      if (resetValue === undefined && isNaN(value)) {
        resetValue = 1;
      } else if (resetValue === 0) {
        resetValue = 1;
      }

      return resetValue === undefined ? value : resetValue;
    }
  },

  computed: {
    internalPageCount: function internalPageCount() {
      if (typeof this.total === 'number') {
        return Math.ceil(this.total / this.internalPageSize);
      } else if (typeof this.pageCount === 'number') {
        return this.pageCount;
      }
      return null;
    }
  },

  watch: {
    currentPage: {
      immediate: true,
      handler: function handler(val) {
        this.internalCurrentPage = val;
      }
    },

    pageSize: {
      immediate: true,
      handler: function handler(val) {
        this.internalPageSize = val;
      }
    },

    internalCurrentPage: function internalCurrentPage(newVal, oldVal) {
      var _this2 = this;

      newVal = parseInt(newVal, 10);

      /* istanbul ignore if */
      if (isNaN(newVal)) {
        newVal = oldVal || 1;
      } else {
        newVal = this.getValidCurrentPage(newVal);
      }

      if (newVal !== undefined) {
        this.$nextTick(function () {
          _this2.internalCurrentPage = newVal;
          if (oldVal !== newVal) {
            _this2.$emit('update:currentPage', newVal);
            _this2.$emit('current-change', _this2.internalCurrentPage);
          }
        });
      } else {
        this.$emit('update:currentPage', newVal);
        this.$emit('current-change', this.internalCurrentPage);
      }
    },
    internalPageCount: function internalPageCount(newVal) {
      /* istanbul ignore if */
      var oldPage = this.internalCurrentPage;
      if (newVal > 0 && oldPage === 0) {
        this.internalCurrentPage = 1;
      } else if (oldPage > newVal) {
        this.internalCurrentPage = newVal === 0 ? 1 : newVal;
      }
    }
  }
};

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_pager_vue__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_pager_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_pager_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e5b72590_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_pager_vue__ = __webpack_require__(49);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_pager_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e5b72590_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_pager_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElPager',

  props: {
    currentPage: Number,

    pageCount: Number
  },

  watch: {
    showPrevMore: function showPrevMore(val) {
      if (!val) this.quickprevIconClass = 'el-icon-more';
    },
    showNextMore: function showNextMore(val) {
      if (!val) this.quicknextIconClass = 'el-icon-more';
    }
  },

  methods: {
    onPagerClick: function onPagerClick(event) {
      var target = event.target;
      if (target.tagName === 'UL') {
        return;
      }

      var newPage = Number(event.target.textContent);
      var pageCount = this.pageCount;
      var currentPage = this.currentPage;

      if (target.className.indexOf('more') !== -1) {
        if (target.className.indexOf('quickprev') !== -1) {
          newPage = currentPage - 5;
        } else if (target.className.indexOf('quicknext') !== -1) {
          newPage = currentPage + 5;
        }
      }

      /* istanbul ignore if */
      if (!isNaN(newPage)) {
        if (newPage < 1) {
          newPage = 1;
        }

        if (newPage > pageCount) {
          newPage = pageCount;
        }
      }

      if (newPage !== currentPage) {
        this.$emit('change', newPage);
      }
    }
  },

  computed: {
    pagers: function pagers() {
      var pagerCount = 7;

      var currentPage = Number(this.currentPage);
      var pageCount = Number(this.pageCount);

      var showPrevMore = false;
      var showNextMore = false;

      if (pageCount > pagerCount) {
        if (currentPage > pagerCount - 3) {
          showPrevMore = true;
        }

        if (currentPage < pageCount - 3) {
          showNextMore = true;
        }
      }

      var array = [];

      if (showPrevMore && !showNextMore) {
        var startPage = pageCount - (pagerCount - 2);
        for (var i = startPage; i < pageCount; i++) {
          array.push(i);
        }
      } else if (!showPrevMore && showNextMore) {
        for (var _i = 2; _i < pagerCount; _i++) {
          array.push(_i);
        }
      } else if (showPrevMore && showNextMore) {
        var offset = Math.floor(pagerCount / 2) - 1;
        for (var _i2 = currentPage - offset; _i2 <= currentPage + offset; _i2++) {
          array.push(_i2);
        }
      } else {
        for (var _i3 = 2; _i3 < pageCount; _i3++) {
          array.push(_i3);
        }
      }

      this.showPrevMore = showPrevMore;
      this.showNextMore = showNextMore;

      return array;
    }
  },

  data: function data() {
    return {
      current: null,
      showPrevMore: false,
      showNextMore: false,
      quicknextIconClass: 'el-icon-more',
      quickprevIconClass: 'el-icon-more'
    };
  }
};

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{staticClass:"el-pager",on:{"click":_vm.onPagerClick}},[(_vm.pageCount > 0)?_c('li',{staticClass:"number",class:{ active: _vm.currentPage === 1 }},[_vm._v("1")]):_vm._e(),(_vm.showPrevMore)?_c('li',{staticClass:"el-icon more btn-quickprev",class:[_vm.quickprevIconClass],on:{"mouseenter":function($event){_vm.quickprevIconClass = 'el-icon-d-arrow-left'},"mouseleave":function($event){_vm.quickprevIconClass = 'el-icon-more'}}}):_vm._e(),_vm._l((_vm.pagers),function(pager){return _c('li',{staticClass:"number",class:{ active: _vm.currentPage === pager }},[_vm._v(_vm._s(pager))])}),(_vm.showNextMore)?_c('li',{staticClass:"el-icon more btn-quicknext",class:[_vm.quicknextIconClass],on:{"mouseenter":function($event){_vm.quicknextIconClass = 'el-icon-d-arrow-right'},"mouseleave":function($event){_vm.quicknextIconClass = 'el-icon-more'}}}):_vm._e(),(_vm.pageCount > 1)?_c('li',{staticClass:"number",class:{ active: _vm.currentPage === _vm.pageCount }},[_vm._v(_vm._s(_vm.pageCount))]):_vm._e()],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("Yban");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("XoPO");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(53);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_component2.default.install = function (Vue) {
  Vue.component(_component2.default.name, _component2.default);
};

exports.default = _component2.default;

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2ab518c0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_component_vue__ = __webpack_require__(55);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2ab518c0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_component_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _popup = __webpack_require__(17);

var _popup2 = _interopRequireDefault(_popup);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElDialog',

  mixins: [_popup2.default, _emitter2.default, _migrating2.default],

  props: {
    title: {
      type: String,
      default: ''
    },

    modal: {
      type: Boolean,
      default: true
    },

    modalAppendToBody: {
      type: Boolean,
      default: true
    },

    appendToBody: {
      type: Boolean,
      default: false
    },

    lockScroll: {
      type: Boolean,
      default: true
    },

    closeOnClickModal: {
      type: Boolean,
      default: true
    },

    closeOnPressEscape: {
      type: Boolean,
      default: true
    },

    showClose: {
      type: Boolean,
      default: true
    },

    width: String,

    fullscreen: Boolean,

    customClass: {
      type: String,
      default: ''
    },

    top: {
      type: String,
      default: '15vh'
    },
    beforeClose: Function,
    center: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      closed: false
    };
  },


  watch: {
    visible: function visible(val) {
      var _this = this;

      this.$emit('update:visible', val);
      if (val) {
        this.closed = false;
        this.$emit('open');
        this.$el.addEventListener('scroll', this.updatePopper);
        this.$nextTick(function () {
          _this.$refs.dialog.scrollTop = 0;
        });
        if (this.appendToBody) {
          document.body.appendChild(this.$el);
        }
      } else {
        this.$el.removeEventListener('scroll', this.updatePopper);
        if (!this.closed) this.$emit('close');
      }
    }
  },

  computed: {
    style: function style() {
      var style = {};
      if (this.width) {
        style.width = this.width;
      }
      if (!this.fullscreen) {
        style.marginTop = this.top;
      }
      return style;
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'size': 'size is removed.'
        }
      };
    },
    handleWrapperClick: function handleWrapperClick() {
      if (!this.closeOnClickModal) return;
      this.handleClose();
    },
    handleClose: function handleClose() {
      if (typeof this.beforeClose === 'function') {
        this.beforeClose(this.hide);
      } else {
        this.hide();
      }
    },
    hide: function hide(cancel) {
      if (cancel !== false) {
        this.$emit('update:visible', false);
        this.$emit('close');
        this.closed = true;
      }
    },
    updatePopper: function updatePopper() {
      this.broadcast('ElSelectDropdown', 'updatePopper');
      this.broadcast('ElDropdownMenu', 'updatePopper');
    }
  },

  mounted: function mounted() {
    if (this.visible) {
      this.rendered = true;
      this.open();
      if (this.appendToBody) {
        document.body.appendChild(this.$el);
      }
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"dialog-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-dialog__wrapper",on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }_vm.handleWrapperClick($event)}}},[_c('div',{ref:"dialog",staticClass:"el-dialog",class:[{ 'is-fullscreen': _vm.fullscreen, 'el-dialog--center': _vm.center }, _vm.customClass],style:(_vm.style)},[_c('div',{staticClass:"el-dialog__header"},[_vm._t("title",[_c('span',{staticClass:"el-dialog__title"},[_vm._v(_vm._s(_vm.title))])]),(_vm.showClose)?_c('button',{staticClass:"el-dialog__headerbtn",attrs:{"type":"button","aria-label":"Close"},on:{"click":_vm.handleClose}},[_c('i',{staticClass:"el-dialog__close el-icon el-icon-close"})]):_vm._e()],2),(_vm.rendered)?_c('div',{staticClass:"el-dialog__body"},[_vm._t("default")],2):_vm._e(),(_vm.$slots.footer)?_c('div',{staticClass:"el-dialog__footer"},[_vm._t("footer")],2):_vm._e()])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _autocomplete = __webpack_require__(57);

var _autocomplete2 = _interopRequireDefault(_autocomplete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_autocomplete2.default.install = function (Vue) {
  Vue.component(_autocomplete2.default.name, _autocomplete2.default);
};

exports.default = _autocomplete2.default;

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_vue__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_01836196_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_autocomplete_vue__ = __webpack_require__(62);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_01836196_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_autocomplete_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _autocompleteSuggestions = __webpack_require__(59);

var _autocompleteSuggestions2 = _interopRequireDefault(_autocompleteSuggestions);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _util = __webpack_require__(3);

var _focus = __webpack_require__(14);

var _focus2 = _interopRequireDefault(_focus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElAutocomplete',

  mixins: [_emitter2.default, (0, _focus2.default)('input'), _migrating2.default],

  componentName: 'ElAutocomplete',

  components: {
    ElInput: _input2.default,
    ElAutocompleteSuggestions: _autocompleteSuggestions2.default
  },

  directives: { Clickoutside: _clickoutside2.default },

  props: {
    valueKey: {
      type: String,
      default: 'value'
    },
    popperClass: String,
    placeholder: String,
    disabled: Boolean,
    name: String,
    size: String,
    value: String,
    autofocus: Boolean,
    fetchSuggestions: Function,
    triggerOnFocus: {
      type: Boolean,
      default: true
    },
    customItem: String,
    selectWhenUnmatched: {
      type: Boolean,
      default: false
    },
    label: String,
    debounce: {
      type: Number,
      default: 300
    }
  },
  data: function data() {
    return {
      activated: false,
      isOnComposition: false,
      suggestions: [],
      loading: false,
      highlightedIndex: -1
    };
  },

  computed: {
    suggestionVisible: function suggestionVisible() {
      var suggestions = this.suggestions;
      var isValidData = Array.isArray(suggestions) && suggestions.length > 0;
      return (isValidData || this.loading) && this.activated;
    },
    id: function id() {
      return 'el-autocomplete-' + (0, _util.generateId)();
    }
  },
  watch: {
    suggestionVisible: function suggestionVisible(val) {
      this.broadcast('ElAutocompleteSuggestions', 'visible', [val, this.$refs.input.$refs.input.offsetWidth]);
    }
  },
  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'custom-item': 'custom-item is removed, use scoped slot instead.',
          'props': 'props is removed, use value-key instead.'
        }
      };
    },
    getData: function getData(queryString) {
      var _this = this;

      this.loading = true;
      this.fetchSuggestions(queryString, function (suggestions) {
        _this.loading = false;
        if (Array.isArray(suggestions)) {
          _this.suggestions = suggestions;
        } else {
          console.error('autocomplete suggestions must be an array');
        }
      });
    },
    handleComposition: function handleComposition(event) {
      if (event.type === 'compositionend') {
        this.isOnComposition = false;
        this.handleChange(event.target.value);
      } else {
        this.isOnComposition = true;
      }
    },
    handleChange: function handleChange(value) {
      this.$emit('input', value);
      if (this.isOnComposition || !this.triggerOnFocus && !value) {
        this.suggestions = [];
        return;
      }
      this.debouncedGetData(value);
    },
    handleFocus: function handleFocus(event) {
      this.activated = true;
      this.$emit('focus', event);
      if (this.triggerOnFocus) {
        this.debouncedGetData(this.value);
      }
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },
    close: function close(e) {
      this.activated = false;
    },
    handleKeyEnter: function handleKeyEnter(e) {
      var _this2 = this;

      if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
        e.preventDefault();
        this.select(this.suggestions[this.highlightedIndex]);
      } else if (this.selectWhenUnmatched) {
        this.$emit('select', { value: this.value });
        this.$nextTick(function (_) {
          _this2.suggestions = [];
          _this2.highlightedIndex = -1;
        });
      }
    },
    select: function select(item) {
      var _this3 = this;

      this.$emit('input', item[this.valueKey]);
      this.$emit('select', item);
      this.$nextTick(function (_) {
        _this3.suggestions = [];
        _this3.highlightedIndex = -1;
      });
    },
    highlight: function highlight(index) {
      if (!this.suggestionVisible || this.loading) {
        return;
      }
      if (index < 0) {
        this.highlightedIndex = -1;
        return;
      }
      if (index >= this.suggestions.length) {
        index = this.suggestions.length - 1;
      }
      var suggestion = this.$refs.suggestions.$el.querySelector('.el-autocomplete-suggestion__wrap');
      var suggestionList = suggestion.querySelectorAll('.el-autocomplete-suggestion__list li');

      var highlightItem = suggestionList[index];
      var scrollTop = suggestion.scrollTop;
      var offsetTop = highlightItem.offsetTop;

      if (offsetTop + highlightItem.scrollHeight > scrollTop + suggestion.clientHeight) {
        suggestion.scrollTop += highlightItem.scrollHeight;
      }
      if (offsetTop < scrollTop) {
        suggestion.scrollTop -= highlightItem.scrollHeight;
      }
      this.highlightedIndex = index;
      this.$el.querySelector('.el-input__inner').setAttribute('aria-activedescendant', this.id + '-item-' + this.highlightedIndex);
    }
  },
  mounted: function mounted() {
    var _this4 = this;

    this.debouncedGetData = (0, _debounce2.default)(this.debounce, function (val) {
      _this4.getData(val);
    });
    this.$on('item-click', function (item) {
      _this4.select(item);
    });
    var $input = this.$el.querySelector('.el-input__inner');
    $input.setAttribute('role', 'textbox');
    $input.setAttribute('aria-autocomplete', 'list');
    $input.setAttribute('aria-controls', 'id');
    $input.setAttribute('aria-activedescendant', this.id + '-item-' + this.highlightedIndex);
  },
  beforeDestroy: function beforeDestroy() {
    this.$refs.suggestions.$destroy();
  }
};

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_suggestions_vue__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_suggestions_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_suggestions_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3f749952_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_autocomplete_suggestions_vue__ = __webpack_require__(61);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_autocomplete_suggestions_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3f749952_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_autocomplete_suggestions_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _scrollbar = __webpack_require__(19);

var _scrollbar2 = _interopRequireDefault(_scrollbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { ElScrollbar: _scrollbar2.default },
  mixins: [_vuePopper2.default, _emitter2.default],

  componentName: 'ElAutocompleteSuggestions',

  data: function data() {
    return {
      parent: this.$parent,
      dropdownWidth: ''
    };
  },


  props: {
    options: {
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    },
    id: String
  },

  methods: {
    select: function select(item) {
      this.dispatch('ElAutocomplete', 'item-click', item);
    }
  },

  updated: function updated() {
    var _this = this;

    this.$nextTick(function (_) {
      _this.updatePopper();
    });
  },
  mounted: function mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$refs.input.$refs.input;
    this.referenceList = this.$el.querySelector('.el-autocomplete-suggestion__list');
    this.referenceList.setAttribute('role', 'listbox');
    this.referenceList.setAttribute('id', this.id);
  },
  created: function created() {
    var _this2 = this;

    this.$on('visible', function (val, inputWidth) {
      _this2.dropdownWidth = inputWidth + 'px';
      _this2.showPopper = val;
    });
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":_vm.doDestroy}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-autocomplete-suggestion el-popper",class:{ 'is-loading': _vm.parent.loading },style:({ width: _vm.dropdownWidth }),attrs:{"role":"region"}},[_c('el-scrollbar',{attrs:{"tag":"ul","wrap-class":"el-autocomplete-suggestion__wrap","view-class":"el-autocomplete-suggestion__list"}},[(_vm.parent.loading)?_c('li',[_c('i',{staticClass:"el-icon-loading"})]):_vm._t("default")],2)],1)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.close),expression:"close"}],staticClass:"el-autocomplete",attrs:{"aria-haspopup":"listbox","role":"combobox","aria-expanded":_vm.suggestionVisible,"aria-owns":_vm.id}},[_c('el-input',_vm._b({ref:"input",attrs:{"label":_vm.label},on:{"input":_vm.handleChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur},nativeOn:{"compositionstart":function($event){_vm.handleComposition($event)},"compositionupdate":function($event){_vm.handleComposition($event)},"compositionend":function($event){_vm.handleComposition($event)},"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.highlight(_vm.highlightedIndex - 1)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.highlight(_vm.highlightedIndex + 1)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.handleKeyEnter($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"tab",9,$event.key)){ return null; }_vm.close($event)}]}},'el-input',_vm.$props,false),[(_vm.$slots.prepend)?_c('template',{attrs:{"slot":"prepend"},slot:"prepend"},[_vm._t("prepend")],2):_vm._e(),(_vm.$slots.append)?_c('template',{attrs:{"slot":"append"},slot:"append"},[_vm._t("append")],2):_vm._e(),(_vm.$slots.prefix)?_c('template',{attrs:{"slot":"prefix"},slot:"prefix"},[_vm._t("prefix")],2):_vm._e(),(_vm.$slots.suffix)?_c('template',{attrs:{"slot":"suffix"},slot:"suffix"},[_vm._t("suffix")],2):_vm._e()],2),_c('el-autocomplete-suggestions',{ref:"suggestions",class:[_vm.popperClass ? _vm.popperClass : ''],attrs:{"visible-arrow":"","placement":"bottom-start","id":_vm.id}},_vm._l((_vm.suggestions),function(item,index){return _c('li',{key:index,class:{'highlighted': _vm.highlightedIndex === index},attrs:{"id":(_vm.id + "-item-" + index),"role":"option","aria-selected":_vm.highlightedIndex === index},on:{"click":function($event){_vm.select(item)}}},[_vm._t("default",[_vm._v("\n        "+_vm._s(item[_vm.valueKey])+"\n      ")],{item:item})],2)}))],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dropdown = __webpack_require__(64);

var _dropdown2 = _interopRequireDefault(_dropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_dropdown2.default.install = function (Vue) {
  Vue.component(_dropdown2.default.name, _dropdown2.default);
};

exports.default = _dropdown2.default;

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_vue__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _button = __webpack_require__(15);

var _button2 = _interopRequireDefault(_button);

var _buttonGroup = __webpack_require__(66);

var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElDropdown',

  componentName: 'ElDropdown',

  mixins: [_emitter2.default, _migrating2.default],

  directives: { Clickoutside: _clickoutside2.default },

  components: {
    ElButton: _button2.default,
    ElButtonGroup: _buttonGroup2.default
  },

  provide: function provide() {
    return {
      dropdown: this
    };
  },


  props: {
    trigger: {
      type: String,
      default: 'hover'
    },
    type: String,
    size: {
      type: String,
      default: ''
    },
    splitButton: Boolean,
    hideOnClick: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: 'bottom-end'
    },
    visibleArrow: {
      default: true
    },
    showTimeout: {
      type: Number,
      default: 250
    },
    hideTimeout: {
      type: Number,
      default: 150
    }
  },

  data: function data() {
    return {
      timeout: null,
      visible: false,
      triggerElm: null,
      menuItems: null,
      menuItemsArray: null,
      dropdownElm: null,
      focusing: false
    };
  },


  computed: {
    dropdownSize: function dropdownSize() {
      return this.size || (this.$ELEMENT || {}).size;
    },
    listId: function listId() {
      return 'dropdown-menu-' + (0, _util.generateId)();
    }
  },

  mounted: function mounted() {
    this.$on('menu-item-click', this.handleMenuItemClick);
    this.initEvent();
    this.initAria();
  },


  watch: {
    visible: function visible(val) {
      this.broadcast('ElDropdownMenu', 'visible', val);
      this.$emit('visible-change', val);
    },
    focusing: function focusing(val) {
      var selfDefine = this.$el.querySelector('.el-dropdown-selfdefine');
      if (selfDefine) {
        // 自定义
        if (val) {
          selfDefine.className += ' focusing';
        } else {
          selfDefine.className = selfDefine.className.replace('focusing', '');
        }
      }
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'menu-align': 'menu-align is renamed to placement.'
        }
      };
    },
    show: function show() {
      var _this = this;

      if (this.triggerElm.disabled) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this.visible = true;
      }, this.showTimeout);
    },
    hide: function hide() {
      var _this2 = this;

      if (this.triggerElm.disabled) return;
      this.removeTabindex();
      this.resetTabindex(this.triggerElm);
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this2.visible = false;
      }, this.hideTimeout);
    },
    handleClick: function handleClick() {
      if (this.triggerElm.disabled) return;
      this.visible = !this.visible;
    },
    handleTriggerKeyDown: function handleTriggerKeyDown(ev) {
      var keyCode = ev.keyCode;
      if ([38, 40].includes(keyCode)) {
        // up/down
        this.removeTabindex();
        this.resetTabindex(this.menuItems[0]);
        this.menuItems[0].focus();
        ev.preventDefault();
        ev.stopPropagation();
      } else if (keyCode === 13) {
        // space enter选中
        this.handleClick();
      } else if ([9, 27].includes(keyCode)) {
        // tab || esc
        this.hide();
      }
      return;
    },
    handleItemKeyDown: function handleItemKeyDown(ev) {
      var keyCode = ev.keyCode;
      var target = ev.target;
      var currentIndex = this.menuItemsArray.indexOf(target);
      var max = this.menuItemsArray.length - 1;
      var nextIndex = void 0;
      if ([38, 40].includes(keyCode)) {
        // up/down
        if (keyCode === 38) {
          // up
          nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
        } else {
          // down
          nextIndex = currentIndex < max ? currentIndex + 1 : max;
        }
        this.removeTabindex();
        this.resetTabindex(this.menuItems[nextIndex]);
        this.menuItems[nextIndex].focus();
        ev.preventDefault();
        ev.stopPropagation();
      } else if (keyCode === 13) {
        // enter选中
        this.triggerElm.focus();
        target.click();
        if (!this.hideOnClick) {
          // click关闭
          this.visible = false;
        }
      } else if ([9, 27].includes(keyCode)) {
        // tab // esc
        this.hide();
        this.triggerElm.focus();
      }
      return;
    },
    resetTabindex: function resetTabindex(ele) {
      // 下次tab时组件聚焦元素
      this.removeTabindex();
      ele.setAttribute('tabindex', '0'); // 下次期望的聚焦元素
    },
    removeTabindex: function removeTabindex() {
      this.triggerElm.setAttribute('tabindex', '-1');
      this.menuItemsArray.forEach(function (item) {
        item.setAttribute('tabindex', '-1');
      });
    },
    initAria: function initAria() {
      this.dropdownElm.setAttribute('id', this.listId);
      this.triggerElm.setAttribute('aria-haspopup', 'list');
      this.triggerElm.setAttribute('aria-controls', this.listId);
      this.menuItems = this.dropdownElm.querySelectorAll("[tabindex='-1']");
      this.menuItemsArray = Array.prototype.slice.call(this.menuItems);

      if (!this.splitButton) {
        // 自定义
        this.triggerElm.setAttribute('role', 'button');
        this.triggerElm.setAttribute('tabindex', '0');
        this.triggerElm.className += ' el-dropdown-selfdefine'; // 控制
      }
    },
    initEvent: function initEvent() {
      var _this3 = this;

      var trigger = this.trigger,
          show = this.show,
          hide = this.hide,
          handleClick = this.handleClick,
          splitButton = this.splitButton,
          handleTriggerKeyDown = this.handleTriggerKeyDown,
          handleItemKeyDown = this.handleItemKeyDown;

      this.triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;

      var dropdownElm = this.dropdownElm = this.$slots.dropdown[0].elm;

      this.triggerElm.addEventListener('keydown', handleTriggerKeyDown); // triggerElm keydown
      dropdownElm.addEventListener('keydown', handleItemKeyDown, true); // item keydown
      // 控制自定义元素的样式
      if (!splitButton) {
        this.triggerElm.addEventListener('focus', function () {
          _this3.focusing = true;
        });
        this.triggerElm.addEventListener('blur', function () {
          _this3.focusing = false;
        });
        this.triggerElm.addEventListener('click', function () {
          _this3.focusing = false;
        });
      }
      if (trigger === 'hover') {
        this.triggerElm.addEventListener('mouseenter', show);
        this.triggerElm.addEventListener('mouseleave', hide);
        dropdownElm.addEventListener('mouseenter', show);
        dropdownElm.addEventListener('mouseleave', hide);
      } else if (trigger === 'click') {
        this.triggerElm.addEventListener('click', handleClick);
      }
    },
    handleMenuItemClick: function handleMenuItemClick(command, instance) {
      if (this.hideOnClick) {
        this.visible = false;
      }
      this.$emit('command', command, instance);
    }
  },

  render: function render(h) {
    var _this4 = this;

    var hide = this.hide,
        splitButton = this.splitButton,
        type = this.type,
        dropdownSize = this.dropdownSize;


    var handleMainButtonClick = function handleMainButtonClick(event) {
      _this4.$emit('click', event);
      hide();
    };

    var triggerElm = !splitButton ? this.$slots.default : h(
      'el-button-group',
      null,
      [h(
        'el-button',
        {
          attrs: { type: type, size: dropdownSize },
          nativeOn: {
            'click': handleMainButtonClick
          }
        },
        [this.$slots.default]
      ), h(
        'el-button',
        { ref: 'trigger', attrs: { type: type, size: dropdownSize },
          'class': 'el-dropdown__caret-button' },
        [h(
          'i',
          { 'class': 'el-dropdown__icon el-icon-arrow-down' },
          []
        )]
      )]
    );

    return h(
      'div',
      { 'class': 'el-dropdown', directives: [{
          name: 'clickoutside',
          value: hide
        }]
      },
      [triggerElm, this.$slots.dropdown]
    );
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("E/8r");

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dropdownMenu = __webpack_require__(68);

var _dropdownMenu2 = _interopRequireDefault(_dropdownMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_dropdownMenu2.default.install = function (Vue) {
  Vue.component(_dropdownMenu2.default.name, _dropdownMenu2.default);
};

exports.default = _dropdownMenu2.default;

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_menu_vue__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_menu_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_menu_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_066202f2_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_dropdown_menu_vue__ = __webpack_require__(70);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_menu_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_066202f2_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_dropdown_menu_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElDropdownMenu',

  componentName: 'ElDropdownMenu',

  mixins: [_vuePopper2.default],

  props: {
    visibleArrow: {
      type: Boolean,
      default: true
    }
  },

  data: function data() {
    return {
      size: this.dropdown.size
    };
  },


  inject: ['dropdown'],

  created: function created() {
    var _this = this;

    this.$on('updatePopper', function () {
      if (_this.showPopper) _this.updatePopper();
    });
    this.$on('visible', function (val) {
      _this.showPopper = val;
    });
  },
  mounted: function mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$el;
  },


  watch: {
    'dropdown.placement': {
      immediate: true,
      handler: function handler(val) {
        this.currentPlacement = val;
      }
    }
  }
}; //
//
//
//
//
//
//

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":_vm.doDestroy}},[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-dropdown-menu el-popper",class:[_vm.size && ("el-dropdown-menu--" + _vm.size)]},[_vm._t("default")],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dropdownItem = __webpack_require__(72);

var _dropdownItem2 = _interopRequireDefault(_dropdownItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_dropdownItem2.default.install = function (Vue) {
  Vue.component(_dropdownItem2.default.name, _dropdownItem2.default);
};

exports.default = _dropdownItem2.default;

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_item_vue__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_item_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66fb6a3b_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_dropdown_item_vue__ = __webpack_require__(74);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dropdown_item_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66fb6a3b_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_dropdown_item_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElDropdownItem',

  mixins: [_emitter2.default],

  props: {
    command: {},
    disabled: Boolean,
    divided: Boolean
  },

  methods: {
    handleClick: function handleClick(e) {
      this.dispatch('ElDropdown', 'menu-item-click', [this.command, this]);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{staticClass:"el-dropdown-menu__item",class:{
    'is-disabled': _vm.disabled,
    'el-dropdown-menu__item--divided': _vm.divided
  },attrs:{"aria-disabled":_vm.disabled,"tabindex":_vm.disabled ? null : -1},on:{"click":_vm.handleClick}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _menu = __webpack_require__(76);

var _menu2 = _interopRequireDefault(_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_menu2.default.install = function (Vue) {
  Vue.component(_menu2.default.name, _menu2.default);
};

exports.default = _menu2.default;

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_700225d6_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_menu_vue__ = __webpack_require__(81);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_700225d6_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_menu_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _ariaMenubar = __webpack_require__(78);

var _ariaMenubar2 = _interopRequireDefault(_ariaMenubar);

var _dom = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElMenu',

  componentName: 'ElMenu',

  mixins: [_emitter2.default, _migrating2.default],

  provide: function provide() {
    return {
      rootMenu: this
    };
  },


  components: {
    'el-menu-collapse-transition': {
      functional: true,
      render: function render(createElement, context) {
        var data = {
          props: {
            mode: 'out-in'
          },
          on: {
            beforeEnter: function beforeEnter(el) {
              el.style.opacity = 0.2;
            },
            enter: function enter(el) {
              (0, _dom.addClass)(el, 'el-opacity-transition');
              el.style.opacity = 1;
            },
            afterEnter: function afterEnter(el) {
              (0, _dom.removeClass)(el, 'el-opacity-transition');
              el.style.opacity = '';
            },
            beforeLeave: function beforeLeave(el) {
              if (!el.dataset) el.dataset = {};

              if ((0, _dom.hasClass)(el, 'el-menu--collapse')) {
                (0, _dom.removeClass)(el, 'el-menu--collapse');
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.scrollWidth;
                (0, _dom.addClass)(el, 'el-menu--collapse');
              }

              el.style.width = el.scrollWidth + 'px';
              el.style.overflow = 'hidden';
            },
            leave: function leave(el) {
              if (!(0, _dom.hasClass)(el, 'el-menu--collapse')) {
                (0, _dom.addClass)(el, 'horizontal-collapse-transition');
                el.style.width = '64px';
              } else {
                (0, _dom.addClass)(el, 'horizontal-collapse-transition');
                el.style.width = el.dataset.scrollWidth + 'px';
              }
            },
            afterLeave: function afterLeave(el) {
              (0, _dom.removeClass)(el, 'horizontal-collapse-transition');
              if ((0, _dom.hasClass)(el, 'el-menu--collapse')) {
                el.style.width = el.dataset.scrollWidth + 'px';
              } else {
                el.style.width = '64px';
              }
              el.style.overflow = el.dataset.oldOverflow;
            }
          }
        };
        return createElement('transition', data, context.children);
      }
    }
  },

  props: {
    mode: {
      type: String,
      default: 'vertical'
    },
    defaultActive: {
      type: String,
      default: ''
    },
    defaultOpeneds: Array,
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      default: 'hover'
    },
    collapse: Boolean,
    backgroundColor: String,
    textColor: String,
    activeTextColor: String
  },
  data: function data() {
    return {
      activeIndex: this.defaultActive,
      openedMenus: this.defaultOpeneds ? this.defaultOpeneds.slice(0) : [],
      items: {},
      submenus: {}
    };
  },

  computed: {
    hoverBackground: function hoverBackground() {
      return this.backgroundColor ? this.mixColor(this.backgroundColor, 0.2) : '';
    }
  },
  watch: {
    defaultActive: function defaultActive(value) {
      var item = this.items[value];
      if (item) {
        this.activeIndex = item.index;
        this.initOpenedMenu();
      } else {
        this.activeIndex = '';
      }
    },
    defaultOpeneds: function defaultOpeneds(value) {
      this.openedMenus = value;
    },
    collapse: function collapse(value) {
      if (value) this.openedMenus = [];
    }
  },
  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'theme': 'theme is removed.'
        }
      };
    },
    getColorChannels: function getColorChannels(color) {
      color = color.replace('#', '');
      if (/^[0-9a-fA-F]{3}$/.test(color)) {
        color = color.split('');
        for (var i = 2; i >= 0; i--) {
          color.splice(i, 0, color[i]);
        }
        color = color.join('');
      }
      if (/^[0-9a-fA-F]{6}$/.test(color)) {
        return {
          red: parseInt(color.slice(0, 2), 16),
          green: parseInt(color.slice(2, 4), 16),
          blue: parseInt(color.slice(4, 6), 16)
        };
      } else {
        return {
          red: 255,
          green: 255,
          blue: 255
        };
      }
    },
    mixColor: function mixColor(color, percent) {
      var _getColorChannels = this.getColorChannels(color),
          red = _getColorChannels.red,
          green = _getColorChannels.green,
          blue = _getColorChannels.blue;

      if (percent > 0) {
        // shade given color
        red *= 1 - percent;
        green *= 1 - percent;
        blue *= 1 - percent;
      } else {
        // tint given color
        red += (255 - red) * percent;
        green += (255 - green) * percent;
        blue += (255 - blue) * percent;
      }
      return 'rgb(' + Math.round(red) + ', ' + Math.round(green) + ', ' + Math.round(blue) + ')';
    },
    addItem: function addItem(item) {
      this.$set(this.items, item.index, item);
    },
    removeItem: function removeItem(item) {
      delete this.items[item.index];
    },
    addSubmenu: function addSubmenu(item) {
      this.$set(this.submenus, item.index, item);
    },
    removeSubmenu: function removeSubmenu(item) {
      delete this.submenus[item.index];
    },
    openMenu: function openMenu(index, indexPath) {
      var openedMenus = this.openedMenus;
      if (openedMenus.indexOf(index) !== -1) return;
      // 将不在该菜单路径下的其余菜单收起
      // collapse all menu that are not under current menu item
      if (this.uniqueOpened) {
        this.openedMenus = openedMenus.filter(function (index) {
          return indexPath.indexOf(index) !== -1;
        });
      }
      this.openedMenus.push(index);
    },
    closeMenu: function closeMenu(index) {
      var i = this.openedMenus.indexOf(index);
      if (i !== -1) {
        this.openedMenus.splice(i, 1);
      }
    },
    handleSubmenuClick: function handleSubmenuClick(submenu) {
      var index = submenu.index,
          indexPath = submenu.indexPath;

      var isOpened = this.openedMenus.indexOf(index) !== -1;

      if (isOpened) {
        this.closeMenu(index);
        this.$emit('close', index, indexPath);
      } else {
        this.openMenu(index, indexPath);
        this.$emit('open', index, indexPath);
      }
    },
    handleItemClick: function handleItemClick(item) {
      var index = item.index,
          indexPath = item.indexPath;

      this.activeIndex = item.index;
      this.$emit('select', index, indexPath, item);

      if (this.mode === 'horizontal' || this.collapse) {
        this.openedMenus = [];
      }

      if (this.router) {
        this.routeToItem(item);
      }
    },

    // 初始化展开菜单
    // initialize opened menu
    initOpenedMenu: function initOpenedMenu() {
      var _this = this;

      var index = this.activeIndex;
      var activeItem = this.items[index];
      if (!activeItem || this.mode === 'horizontal' || this.collapse) return;

      var indexPath = activeItem.indexPath;

      // 展开该菜单项的路径上所有子菜单
      // expand all submenus of the menu item
      indexPath.forEach(function (index) {
        var submenu = _this.submenus[index];
        submenu && _this.openMenu(index, submenu.indexPath);
      });
    },
    routeToItem: function routeToItem(item) {
      var route = item.route || item.index;
      try {
        this.$router.push(route);
      } catch (e) {
        console.error(e);
      }
    },
    open: function open(index) {
      var _this2 = this;

      var indexPath = this.submenus[index.toString()].indexPath;

      indexPath.forEach(function (i) {
        return _this2.openMenu(i, indexPath);
      });
    },
    close: function close(index) {
      this.closeMenu(index);
    }
  },
  mounted: function mounted() {
    this.initOpenedMenu();
    this.$on('item-click', this.handleItemClick);
    this.$on('submenu-click', this.handleSubmenuClick);
    if (this.mode === 'horizontal') {
      new _ariaMenubar2.default(this.$el); // eslint-disable-line
    }
  }
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ariaMenuitem = __webpack_require__(79);

var _ariaMenuitem2 = _interopRequireDefault(_ariaMenuitem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Menu = function Menu(domNode) {
  this.domNode = domNode;
  this.init();
};

Menu.prototype.init = function () {
  var menuChildren = this.domNode.childNodes;
  [].filter.call(menuChildren, function (child) {
    return child.nodeType === 1;
  }).forEach(function (child) {
    new _ariaMenuitem2.default(child); // eslint-disable-line
  });
};
exports.default = Menu;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ariaUtils = __webpack_require__(29);

var _ariaUtils2 = _interopRequireDefault(_ariaUtils);

var _ariaSubmenu = __webpack_require__(80);

var _ariaSubmenu2 = _interopRequireDefault(_ariaSubmenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MenuItem = function MenuItem(domNode) {
  this.domNode = domNode;
  this.submenu = null;
  this.init();
};

MenuItem.prototype.init = function () {
  this.domNode.setAttribute('tabindex', '0');
  var menuChild = this.domNode.querySelector('.el-menu');
  if (menuChild) {
    this.submenu = new _ariaSubmenu2.default(this, menuChild);
  }
  this.addListeners();
};

MenuItem.prototype.addListeners = function () {
  var _this = this;

  var keys = _ariaUtils2.default.keys;
  this.domNode.addEventListener('keydown', function (event) {
    var prevDef = false;
    switch (event.keyCode) {
      case keys.down:
        _ariaUtils2.default.triggerEvent(event.currentTarget, 'mouseenter');
        _this.submenu.gotoSubIndex(0);
        prevDef = true;
        break;
      case keys.up:
        _ariaUtils2.default.triggerEvent(event.currentTarget, 'mouseenter');
        _this.submenu.gotoSubIndex(_this.submenu.subMenuItems.length - 1);
        prevDef = true;
        break;
      case keys.tab:
        _ariaUtils2.default.triggerEvent(event.currentTarget, 'mouseleave');
        break;
      case keys.enter:
      case keys.space:
        prevDef = true;
        event.currentTarget.click();
        break;
    }
    if (prevDef) {
      event.preventDefault();
    }
  });
};

exports.default = MenuItem;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ariaUtils = __webpack_require__(29);

var _ariaUtils2 = _interopRequireDefault(_ariaUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SubMenu = function SubMenu(parent, domNode) {
  this.domNode = domNode;
  this.parent = parent;
  this.subMenuItems = [];
  this.subIndex = 0;
  this.init();
};

SubMenu.prototype.init = function () {
  this.subMenuItems = this.domNode.querySelectorAll('li');
  this.addListeners();
};

SubMenu.prototype.gotoSubIndex = function (idx) {
  if (idx === this.subMenuItems.length) {
    idx = 0;
  } else if (idx < 0) {
    idx = this.subMenuItems.length - 1;
  }
  this.subMenuItems[idx].focus();
  this.subIndex = idx;
};

SubMenu.prototype.addListeners = function () {
  var _this = this;

  var keys = _ariaUtils2.default.keys;
  var parentNode = this.parent.domNode;
  Array.prototype.forEach.call(this.subMenuItems, function (el) {
    el.addEventListener('keydown', function (event) {
      var prevDef = false;
      switch (event.keyCode) {
        case keys.down:
          _this.gotoSubIndex(_this.subIndex + 1);
          prevDef = true;
          break;
        case keys.up:
          _this.gotoSubIndex(_this.subIndex - 1);
          prevDef = true;
          break;
        case keys.tab:
          _ariaUtils2.default.triggerEvent(parentNode, 'mouseleave');
          break;
        case keys.enter:
        case keys.space:
          prevDef = true;
          event.currentTarget.click();
          break;
      }
      if (prevDef) {
        event.preventDefault();
        event.stopPropagation();
      }
      return false;
    });
  });
};

exports.default = SubMenu;

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('el-menu-collapse-transition',[_c('ul',{key:+_vm.collapse,staticClass:"el-menu",class:{
      'el-menu--horizontal': _vm.mode === 'horizontal',
      'el-menu--collapse': _vm.collapse
    },style:({ backgroundColor: _vm.backgroundColor || '' }),attrs:{"role":"menubar"}},[_vm._t("default")],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _submenu = __webpack_require__(83);

var _submenu2 = _interopRequireDefault(_submenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_submenu2.default.install = function (Vue) {
  Vue.component(_submenu2.default.name, _submenu2.default);
};

exports.default = _submenu2.default;

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_submenu_vue__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_submenu_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_submenu_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_cb16354e_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_submenu_vue__ = __webpack_require__(85);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_submenu_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_cb16354e_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_submenu_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _collapseTransition = __webpack_require__(20);

var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

var _menuMixin = __webpack_require__(30);

var _menuMixin2 = _interopRequireDefault(_menuMixin);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElSubmenu',

  componentName: 'ElSubmenu',

  mixins: [_menuMixin2.default, _emitter2.default],

  components: { ElCollapseTransition: _collapseTransition2.default },

  props: {
    index: {
      type: String,
      required: true
    }
  },

  data: function data() {
    return {
      timeout: null,
      items: {},
      submenus: {}
    };
  },

  computed: {
    menuTransitionName: function menuTransitionName() {
      return this.rootMenu.collapse ? 'el-zoom-in-left' : 'el-zoom-in-top';
    },
    opened: function opened() {
      return this.rootMenu.openedMenus.indexOf(this.index) > -1;
    },
    active: function active() {
      var isActive = false;
      var submenus = this.submenus;
      var items = this.items;

      Object.keys(items).forEach(function (index) {
        if (items[index].active) {
          isActive = true;
        }
      });

      Object.keys(submenus).forEach(function (index) {
        if (submenus[index].active) {
          isActive = true;
        }
      });

      return isActive;
    },
    hoverBackground: function hoverBackground() {
      return this.rootMenu.hoverBackground;
    },
    backgroundColor: function backgroundColor() {
      return this.rootMenu.backgroundColor || '';
    },
    activeTextColor: function activeTextColor() {
      return this.rootMenu.activeTextColor || '';
    },
    textColor: function textColor() {
      return this.rootMenu.textColor || '';
    },
    mode: function mode() {
      return this.rootMenu.mode;
    },
    titleStyle: function titleStyle() {
      if (this.mode !== 'horizontal') {
        return {
          color: this.textColor
        };
      }
      return {
        borderBottomColor: this.active ? this.rootMenu.activeTextColor ? this.activeTextColor : '' : 'transparent',
        color: this.active ? this.activeTextColor : this.textColor
      };
    }
  },
  methods: {
    addItem: function addItem(item) {
      this.$set(this.items, item.index, item);
    },
    removeItem: function removeItem(item) {
      delete this.items[item.index];
    },
    addSubmenu: function addSubmenu(item) {
      this.$set(this.submenus, item.index, item);
    },
    removeSubmenu: function removeSubmenu(item) {
      delete this.submenus[item.index];
    },
    handleClick: function handleClick() {
      var rootMenu = this.rootMenu;

      if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal' || rootMenu.collapse && rootMenu.mode === 'vertical') {
        return;
      }
      this.dispatch('ElMenu', 'submenu-click', this);
    },
    handleMouseenter: function handleMouseenter() {
      var _this = this;

      var rootMenu = this.rootMenu;

      if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
        return;
      }
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this.rootMenu.openMenu(_this.index, _this.indexPath);
      }, 300);
    },
    handleMouseleave: function handleMouseleave() {
      var _this2 = this;

      var rootMenu = this.rootMenu;

      if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
        return;
      }
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this2.rootMenu.closeMenu(_this2.index);
      }, 300);
    },
    handleTitleMouseenter: function handleTitleMouseenter() {
      if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
      var title = this.$refs['submenu-title'];
      title && (title.style.backgroundColor = this.rootMenu.hoverBackground);
    },
    handleTitleMouseleave: function handleTitleMouseleave() {
      if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
      var title = this.$refs['submenu-title'];
      title && (title.style.backgroundColor = this.rootMenu.backgroundColor || '');
    }
  },
  created: function created() {
    this.parentMenu.addSubmenu(this);
    this.rootMenu.addSubmenu(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.parentMenu.removeSubmenu(this);
    this.rootMenu.removeSubmenu(this);
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{class:{
    'el-submenu': true,
    'is-active': _vm.active,
    'is-opened': _vm.opened
  },attrs:{"role":"menuitem","aria-haspopup":"true","aria-expanded":_vm.opened},on:{"mouseenter":_vm.handleMouseenter,"mouseleave":_vm.handleMouseleave,"focus":_vm.handleMouseenter}},[_c('div',{ref:"submenu-title",staticClass:"el-submenu__title",style:([_vm.paddingStyle, _vm.titleStyle, { backgroundColor: _vm.backgroundColor }]),on:{"click":_vm.handleClick,"mouseenter":_vm.handleTitleMouseenter,"mouseleave":_vm.handleTitleMouseleave}},[_vm._t("title"),_c('i',{class:{
      'el-submenu__icon-arrow': true,
      'el-icon-arrow-down': _vm.rootMenu.mode === 'horizontal' || _vm.rootMenu.mode === 'vertical' && !_vm.rootMenu.collapse,
      'el-icon-arrow-right': _vm.rootMenu.mode === 'vertical' && _vm.rootMenu.collapse
    }})],2),(_vm.rootMenu.mode === 'horizontal' || (_vm.rootMenu.mode === 'vertical' && _vm.rootMenu.collapse))?[_c('transition',{attrs:{"name":_vm.menuTransitionName}},[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.opened),expression:"opened"}],staticClass:"el-menu",style:({ backgroundColor: _vm.rootMenu.backgroundColor || '' }),attrs:{"role":"menu"}},[_vm._t("default")],2)])]:_c('el-collapse-transition',[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.opened),expression:"opened"}],staticClass:"el-menu",style:({ backgroundColor: _vm.rootMenu.backgroundColor || '' }),attrs:{"role":"menu"}},[_vm._t("default")],2)])],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _menuItem = __webpack_require__(87);

var _menuItem2 = _interopRequireDefault(_menuItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_menuItem2.default.install = function (Vue) {
  Vue.component(_menuItem2.default.name, _menuItem2.default);
};

exports.default = _menuItem2.default;

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_vue__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0d9fbafb_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_menu_item_vue__ = __webpack_require__(89);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0d9fbafb_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_menu_item_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _menuMixin = __webpack_require__(30);

var _menuMixin2 = _interopRequireDefault(_menuMixin);

var _tooltip = __webpack_require__(22);

var _tooltip2 = _interopRequireDefault(_tooltip);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElMenuItem',

  componentName: 'ElMenuItem',

  mixins: [_menuMixin2.default, _emitter2.default],

  components: { ElTooltip: _tooltip2.default },

  props: {
    index: {
      type: String,
      required: true
    },
    route: {
      type: [String, Object],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    }
  },
  computed: {
    active: function active() {
      return this.index === this.rootMenu.activeIndex;
    },
    hoverBackground: function hoverBackground() {
      return this.rootMenu.hoverBackground;
    },
    backgroundColor: function backgroundColor() {
      return this.rootMenu.backgroundColor || '';
    },
    activeTextColor: function activeTextColor() {
      return this.rootMenu.activeTextColor || '';
    },
    textColor: function textColor() {
      return this.rootMenu.textColor || '';
    },
    mode: function mode() {
      return this.rootMenu.mode;
    },
    itemStyle: function itemStyle() {
      var style = {
        color: this.active ? this.activeTextColor : this.textColor
      };
      if (this.mode === 'horizontal' && !this.isNested) {
        style.borderBottomColor = this.active ? this.rootMenu.activeTextColor ? this.activeTextColor : '' : 'transparent';
      }
      return style;
    },
    isNested: function isNested() {
      return this.parentMenu !== this.rootMenu;
    }
  },
  methods: {
    onMouseEnter: function onMouseEnter() {
      if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
      this.$el.style.backgroundColor = this.hoverBackground;
    },
    onMouseLeave: function onMouseLeave() {
      if (this.mode === 'horizontal' && !this.rootMenu.backgroundColor) return;
      this.$el.style.backgroundColor = this.backgroundColor;
    },
    handleClick: function handleClick() {
      this.dispatch('ElMenu', 'item-click', this);
      this.$emit('click', this);
    }
  },
  created: function created() {
    this.parentMenu.addItem(this);
    this.rootMenu.addItem(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.parentMenu.removeItem(this);
    this.rootMenu.removeItem(this);
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{staticClass:"el-menu-item",class:{
    'is-active': _vm.active,
    'is-disabled': _vm.disabled
  },style:([_vm.paddingStyle, _vm.itemStyle, { backgroundColor: _vm.backgroundColor }]),attrs:{"role":"menuitem","tabindex":"-1"},on:{"click":_vm.handleClick,"mouseenter":_vm.onMouseEnter,"focus":_vm.onMouseEnter,"blur":_vm.onMouseLeave,"mouseleave":_vm.onMouseLeave}},[(_vm.$parent === _vm.rootMenu && _vm.rootMenu.collapse)?_c('el-tooltip',{attrs:{"effect":"dark","placement":"right"}},[_c('div',{attrs:{"slot":"content"},slot:"content"},[_vm._t("title")],2),_c('div',{staticStyle:{"position":"absolute","left":"0","top":"0","height":"100%","width":"100%","display":"inline-block","box-sizing":"border-box","padding":"0 20px"}},[_vm._t("default")],2)]):[_vm._t("default"),_vm._t("title")]],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _menuItemGroup = __webpack_require__(91);

var _menuItemGroup2 = _interopRequireDefault(_menuItemGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_menuItemGroup2.default.install = function (Vue) {
  Vue.component(_menuItemGroup2.default.name, _menuItemGroup2.default);
};

exports.default = _menuItemGroup2.default;

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_group_vue__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_421f262d_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_menu_item_group_vue__ = __webpack_require__(93);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_item_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_421f262d_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_menu_item_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElMenuItemGroup',

  componentName: 'ElMenuItemGroup',

  inject: ['rootMenu'],
  props: {
    title: {
      type: String
    }
  },
  data: function data() {
    return {
      paddingLeft: 20
    };
  },

  computed: {
    levelPadding: function levelPadding() {
      var padding = 20;
      var parent = this.$parent;
      if (this.rootMenu.collapse) return 20;
      while (parent && parent.$options.componentName !== 'ElMenu') {
        if (parent.$options.componentName === 'ElSubmenu') {
          padding += 20;
        }
        parent = parent.$parent;
      }
      return padding;
    }
  }
};

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{staticClass:"el-menu-item-group"},[_c('div',{staticClass:"el-menu-item-group__title",style:({paddingLeft: _vm.levelPadding + 'px'})},[(!_vm.$slots.title)?[_vm._v(_vm._s(_vm.title))]:_vm._t("title")],2),_c('ul',[_vm._t("default")],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _input = __webpack_require__(95);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_input2.default.install = function (Vue) {
  Vue.component(_input2.default.name, _input2.default);
};

exports.default = _input2.default;

/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_eddb4a56_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_vue__ = __webpack_require__(98);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_eddb4a56_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _focus = __webpack_require__(14);

var _focus2 = _interopRequireDefault(_focus);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _calcTextareaHeight = __webpack_require__(97);

var _calcTextareaHeight2 = _interopRequireDefault(_calcTextareaHeight);

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElInput',

  componentName: 'ElInput',

  mixins: [_emitter2.default, (0, _focus2.default)('input'), _migrating2.default],

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  data: function data() {
    return {
      currentValue: this.value,
      textareaCalcStyle: {},
      prefixOffset: null,
      suffixOffset: null
    };
  },


  props: {
    value: [String, Number],
    placeholder: String,
    size: String,
    resize: String,
    name: String,
    form: String,
    id: String,
    maxlength: Number,
    minlength: Number,
    readonly: Boolean,
    autofocus: Boolean,
    disabled: Boolean,
    type: {
      type: String,
      default: 'text'
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    rows: {
      type: Number,
      default: 2
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    max: {},
    min: {},
    step: {},
    validateEvent: {
      type: Boolean,
      default: true
    },
    suffixIcon: String,
    prefixIcon: String,
    label: String
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    validateState: function validateState() {
      return this.elFormItem ? this.elFormItem.validateState : '';
    },
    needStatusIcon: function needStatusIcon() {
      return this.elForm ? this.elForm.statusIcon : false;
    },
    validateIcon: function validateIcon() {
      return {
        validating: 'el-icon-loading',
        success: 'el-icon-circle-check',
        error: 'el-icon-circle-close'
      }[this.validateState];
    },
    textareaStyle: function textareaStyle() {
      return (0, _merge2.default)({}, this.textareaCalcStyle, { resize: this.resize });
    },
    inputSize: function inputSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    isGroup: function isGroup() {
      return this.$slots.prepend || this.$slots.append;
    }
  },

  watch: {
    'value': function value(val, oldValue) {
      this.setCurrentValue(val);
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'icon': 'icon is removed, use suffix-icon / prefix-icon instead.',
          'on-icon-click': 'on-icon-click is removed.'
        },
        events: {
          'click': 'click is removed.'
        }
      };
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.blur', [this.currentValue]);
      }
    },
    inputSelect: function inputSelect() {
      this.$refs.input.select();
    },
    resizeTextarea: function resizeTextarea() {
      if (this.$isServer) return;
      var autosize = this.autosize,
          type = this.type;

      if (type !== 'textarea') return;
      if (!autosize) {
        this.textareaCalcStyle = {
          minHeight: (0, _calcTextareaHeight2.default)(this.$refs.textarea).minHeight
        };
        return;
      }
      var minRows = autosize.minRows;
      var maxRows = autosize.maxRows;

      this.textareaCalcStyle = (0, _calcTextareaHeight2.default)(this.$refs.textarea, minRows, maxRows);
    },
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },
    handleInput: function handleInput(event) {
      var value = event.target.value;
      this.$emit('input', value);
      this.setCurrentValue(value);
    },
    handleChange: function handleChange(event) {
      this.$emit('change', event.target.value);
    },
    setCurrentValue: function setCurrentValue(value) {
      var _this = this;

      if (value === this.currentValue) return;
      this.$nextTick(function (_) {
        _this.resizeTextarea();
      });
      this.currentValue = value;
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.change', [value]);
      }
    },
    calcIconOffset: function calcIconOffset(place) {
      var pendantMap = {
        'suf': 'append',
        'pre': 'prepend'
      };

      var pendant = pendantMap[place];

      if (this.$slots[pendant]) {
        return { transform: 'translateX(' + (place === 'suf' ? '-' : '') + this.$el.querySelector('.el-input-group__' + pendant).offsetWidth + 'px)' };
      }
    }
  },

  created: function created() {
    this.$on('inputSelect', this.inputSelect);
  },
  mounted: function mounted() {
    this.resizeTextarea();
    if (this.isGroup) {
      this.prefixOffset = this.calcIconOffset('pre');
      this.suffixOffset = this.calcIconOffset('suf');
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = calcTextareaHeight;
var hiddenTextarea = void 0;

var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';

var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

function calculateNodeStyling(targetElement) {
  var style = window.getComputedStyle(targetElement);

  var boxSizing = style.getPropertyValue('box-sizing');

  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));

  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));

  var contextStyle = CONTEXT_STYLE.map(function (name) {
    return name + ':' + style.getPropertyValue(name);
  }).join(';');

  return { contextStyle: contextStyle, paddingSize: paddingSize, borderSize: borderSize, boxSizing: boxSizing };
}

function calcTextareaHeight(targetElement) {
  var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  var _calculateNodeStyling = calculateNodeStyling(targetElement),
      paddingSize = _calculateNodeStyling.paddingSize,
      borderSize = _calculateNodeStyling.borderSize,
      boxSizing = _calculateNodeStyling.boxSizing,
      contextStyle = _calculateNodeStyling.contextStyle;

  hiddenTextarea.setAttribute('style', contextStyle + ';' + HIDDEN_STYLE);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

  var height = hiddenTextarea.scrollHeight;
  var result = {};

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    var minHeight = singleRowHeight * minRows;
    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = minHeight + 'px';
  }
  if (maxRows !== null) {
    var maxHeight = singleRowHeight * maxRows;
    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = height + 'px';
  hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
};

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:[
  _vm.type === 'textarea' ? 'el-textarea' : 'el-input',
  _vm.inputSize ? 'el-input--' + _vm.inputSize : '',
  {
    'is-disabled': _vm.disabled,
    'el-input-group': _vm.$slots.prepend || _vm.$slots.append,
    'el-input-group--append': _vm.$slots.append,
    'el-input-group--prepend': _vm.$slots.prepend,
    'el-input--prefix': _vm.$slots.prefix || _vm.prefixIcon,
    'el-input--suffix': _vm.$slots.suffix || _vm.suffixIcon
  }
]},[(_vm.type !== 'textarea')?[(_vm.$slots.prepend)?_c('div',{staticClass:"el-input-group__prepend",attrs:{"tabindex":"0"}},[_vm._t("prepend")],2):_vm._e(),(_vm.type !== 'textarea')?_c('input',_vm._b({ref:"input",staticClass:"el-input__inner",attrs:{"autocomplete":_vm.autoComplete,"aria-label":_vm.label},domProps:{"value":_vm.currentValue},on:{"input":_vm.handleInput,"focus":_vm.handleFocus,"blur":_vm.handleBlur,"change":_vm.handleChange}},'input',_vm.$props,false)):_vm._e(),(_vm.$slots.prefix || _vm.prefixIcon)?_c('span',{staticClass:"el-input__prefix",style:(_vm.prefixOffset)},[_vm._t("prefix"),(_vm.prefixIcon)?_c('i',{staticClass:"el-input__icon",class:_vm.prefixIcon}):_vm._e()],2):_vm._e(),(_vm.$slots.suffix || _vm.suffixIcon || _vm.validateState && _vm.needStatusIcon)?_c('span',{staticClass:"el-input__suffix",style:(_vm.suffixOffset)},[_c('span',{staticClass:"el-input__suffix-inner"},[_vm._t("suffix"),(_vm.suffixIcon)?_c('i',{staticClass:"el-input__icon",class:_vm.suffixIcon}):_vm._e()],2),(_vm.validateState)?_c('i',{staticClass:"el-input__icon",class:['el-input__validateIcon', _vm.validateIcon]}):_vm._e()]):_vm._e(),(_vm.$slots.append)?_c('div',{staticClass:"el-input-group__append"},[_vm._t("append")],2):_vm._e()]:_c('textarea',_vm._b({ref:"textarea",staticClass:"el-textarea__inner",style:(_vm.textareaStyle),attrs:{"aria-label":_vm.label},domProps:{"value":_vm.currentValue},on:{"input":_vm.handleInput,"focus":_vm.handleFocus,"blur":_vm.handleBlur,"change":_vm.handleChange}},'textarea',_vm.$props,false))],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _inputNumber = __webpack_require__(100);

var _inputNumber2 = _interopRequireDefault(_inputNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_inputNumber2.default.install = function (Vue) {
  Vue.component(_inputNumber2.default.name, _inputNumber2.default);
};

exports.default = _inputNumber2.default;

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d07efb5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_number_vue__ = __webpack_require__(102);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_input_number_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d07efb5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_input_number_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _focus = __webpack_require__(14);

var _focus2 = _interopRequireDefault(_focus);

var _repeatClick = __webpack_require__(31);

var _repeatClick2 = _interopRequireDefault(_repeatClick);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElInputNumber',
  mixins: [(0, _focus2.default)('input')],
  inject: {
    elFormItem: {
      default: ''
    }
  },
  directives: {
    repeatClick: _repeatClick2.default
  },
  components: {
    ElInput: _input2.default
  },
  props: {
    step: {
      type: Number,
      default: 1
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    value: {
      default: 0
    },
    disabled: Boolean,
    size: String,
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ''
    },
    debounce: {
      type: Number,
      default: 300
    },
    name: String,
    label: String
  },
  data: function data() {
    return {
      currentValue: 0
    };
  },

  watch: {
    value: {
      immediate: true,
      handler: function handler(value) {
        var newVal = Number(value);
        if (isNaN(newVal)) return;
        if (newVal >= this.max) newVal = this.max;
        if (newVal <= this.min) newVal = this.min;
        this.currentValue = newVal;
        this.$emit('input', newVal);
      }
    }
  },
  computed: {
    minDisabled: function minDisabled() {
      return this._decrease(this.value, this.step) < this.min;
    },
    maxDisabled: function maxDisabled() {
      return this._increase(this.value, this.step) > this.max;
    },
    precision: function precision() {
      var value = this.value,
          step = this.step,
          getPrecision = this.getPrecision;

      return Math.max(getPrecision(value), getPrecision(step));
    },
    controlsAtRight: function controlsAtRight() {
      return this.controlsPosition === 'right';
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    inputNumberSize: function inputNumberSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },
  methods: {
    toPrecision: function toPrecision(num, precision) {
      if (precision === undefined) precision = this.precision;
      return parseFloat(parseFloat(Number(num).toFixed(precision)));
    },
    getPrecision: function getPrecision(value) {
      var valueString = value.toString();
      var dotPosition = valueString.indexOf('.');
      var precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    },
    _increase: function _increase(val, step) {
      if (typeof val !== 'number') return this.currentValue;

      var precisionFactor = Math.pow(10, this.precision);

      return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
    },
    _decrease: function _decrease(val, step) {
      if (typeof val !== 'number') return this.currentValue;

      var precisionFactor = Math.pow(10, this.precision);

      return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
    },
    increase: function increase() {
      if (this.disabled || this.maxDisabled) return;
      var value = this.value || 0;
      var newVal = this._increase(value, this.step);
      if (newVal > this.max) return;
      this.setCurrentValue(newVal);
    },
    decrease: function decrease() {
      if (this.disabled || this.minDisabled) return;
      var value = this.value || 0;
      var newVal = this._decrease(value, this.step);
      if (newVal < this.min) return;
      this.setCurrentValue(newVal);
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
      this.$refs.input.setCurrentValue(this.currentValue);
    },
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },
    setCurrentValue: function setCurrentValue(newVal) {
      var oldVal = this.currentValue;
      if (newVal >= this.max) newVal = this.max;
      if (newVal <= this.min) newVal = this.min;
      if (oldVal === newVal) {
        this.$refs.input.setCurrentValue(this.currentValue);
        return;
      }
      this.$emit('change', newVal, oldVal);
      this.$emit('input', newVal);
      this.currentValue = newVal;
    },
    handleInput: function handleInput(value) {
      if (value === '') {
        return;
      }

      if (value.indexOf('.') === value.length - 1) {
        return;
      }

      if (value.indexOf('-') === value.length - 1) {
        return;
      }

      var newVal = Number(value);
      if (!isNaN(newVal)) {
        this.setCurrentValue(newVal);
      } else {
        this.$refs.input.setCurrentValue(this.currentValue);
      }
    }
  },
  created: function created() {
    var _this = this;

    this.debounceHandleInput = (0, _debounce2.default)(this.debounce, function (value) {
      _this.handleInput(value);
    });
  },
  mounted: function mounted() {
    var innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('role', 'spinbutton');
    innerInput.setAttribute('aria-valuemax', this.max);
    innerInput.setAttribute('aria-valuemin', this.min);
    innerInput.setAttribute('aria-valuenow', this.currentValue);
    innerInput.setAttribute('aria-disabled', this.disabled);
  },
  updated: function updated() {
    var innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('aria-valuenow', this.currentValue);
  }
};

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-input-number",class:[
    _vm.inputNumberSize ? 'el-input-number--' + _vm.inputNumberSize : '',
    { 'is-disabled': _vm.disabled },
    { 'is-without-controls': !_vm.controls },
    { 'is-controls-right': _vm.controlsAtRight }
  ]},[(_vm.controls)?_c('span',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-input-number__decrease",class:{'is-disabled': _vm.minDisabled},attrs:{"role":"button"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.decrease($event)}}},[_c('i',{class:("el-icon-" + (_vm.controlsAtRight ? 'arrow-down' : 'minus'))})]):_vm._e(),(_vm.controls)?_c('span',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-input-number__increase",class:{'is-disabled': _vm.maxDisabled},attrs:{"role":"button"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.increase($event)}}},[_c('i',{class:("el-icon-" + (_vm.controlsAtRight ? 'arrow-up' : 'plus'))})]):_vm._e(),_c('el-input',{ref:"input",attrs:{"value":_vm.currentValue,"disabled":_vm.disabled,"size":_vm.inputNumberSize,"max":_vm.max,"min":_vm.min,"name":_vm.name,"label":_vm.label},on:{"blur":_vm.handleBlur,"focus":_vm.handleFocus,"input":_vm.debounceHandleInput},nativeOn:{"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.increase($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.decrease($event)}]}},[(_vm.$slots.prepend)?_c('template',{attrs:{"slot":"prepend"},slot:"prepend"},[_vm._t("prepend")],2):_vm._e(),(_vm.$slots.append)?_c('template',{attrs:{"slot":"append"},slot:"append"},[_vm._t("append")],2):_vm._e()],2)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _radio = __webpack_require__(104);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_radio2.default.install = function (Vue) {
  Vue.component('el-radio', _radio2.default);
};

exports.default = _radio2.default;

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_vue__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0cfea8f7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_radio_vue__ = __webpack_require__(106);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0cfea8f7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_radio_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElRadio',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  componentName: 'ElRadio',

  props: {
    value: {},
    label: {},
    disabled: Boolean,
    name: String,
    border: Boolean,
    size: String
  },

  data: function data() {
    return {
      focus: false
    };
  },

  computed: {
    isGroup: function isGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElRadioGroup') {
          parent = parent.$parent;
        } else {
          this._radioGroup = parent;
          return true;
        }
      }
      return false;
    },

    model: {
      get: function get() {
        return this.isGroup ? this._radioGroup.value : this.value;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.dispatch('ElRadioGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
        }
      }
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    radioSize: function radioSize() {
      var temRadioSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._radioGroup.radioGroupSize || temRadioSize : temRadioSize;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this._radioGroup.disabled || this.disabled : this.disabled;
    },
    tabIndex: function tabIndex() {
      return !this.isDisabled ? this.isGroup ? this.model === this.label ? 0 : -1 : 0 : -1;
    }
  },

  methods: {
    handleChange: function handleChange() {
      var _this = this;

      this.$nextTick(function () {
        _this.$emit('change', _this.model);
        _this.isGroup && _this.dispatch('ElRadioGroup', 'handleChange', _this.model);
      });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-radio",class:[
    _vm.border && _vm.radioSize ? 'el-radio--' + _vm.radioSize : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-focus': _vm.focus },
    { 'is-bordered': _vm.border },
    { 'is-checked': _vm.model === _vm.label }
  ],attrs:{"role":"radio","aria-checked":_vm.model === _vm.label,"aria-disabled":_vm.isDisabled,"tabindex":_vm.tabIndex},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"space",32,$event.key)){ return null; }$event.stopPropagation();$event.preventDefault();_vm.model = _vm.label}}},[_c('span',{staticClass:"el-radio__input",class:{
      'is-disabled': _vm.isDisabled,
      'is-checked': _vm.model === _vm.label
    }},[_c('span',{staticClass:"el-radio__inner"}),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-radio__original",attrs:{"type":"radio","name":_vm.name,"disabled":_vm.isDisabled,"tabindex":"-1"},domProps:{"value":_vm.label,"checked":_vm._q(_vm.model,_vm.label)},on:{"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false},"change":[function($event){_vm.model=_vm.label},_vm.handleChange]}})]),_c('span',{staticClass:"el-radio__label"},[_vm._t("default"),(!_vm.$slots.default)?[_vm._v(_vm._s(_vm.label))]:_vm._e()],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _radioGroup = __webpack_require__(108);

var _radioGroup2 = _interopRequireDefault(_radioGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_radioGroup2.default.install = function (Vue) {
  Vue.component(_radioGroup2.default.name, _radioGroup2.default);
};

exports.default = _radioGroup2.default;

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_group_vue__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b0ab1ae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_radio_group_vue__ = __webpack_require__(110);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b0ab1ae_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_radio_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var keyCode = Object.freeze({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
}); //
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElRadioGroup',

  componentName: 'ElRadioGroup',

  inject: {
    elFormItem: {
      default: ''
    }
  },

  mixins: [_emitter2.default],

  props: {
    value: {},
    size: String,
    fill: String,
    textColor: String,
    disabled: Boolean
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    radioGroupSize: function radioGroupSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  created: function created() {
    var _this = this;

    this.$on('handleChange', function (value) {
      _this.$emit('change', value);
    });
  },
  mounted: function mounted() {
    // 当radioGroup没有默认选项时，第一个可以选中Tab导航
    var radios = this.$el.querySelectorAll('[type=radio]');
    var firstLabel = this.$el.querySelectorAll('[role=radio]')[0];
    if (![].some.call(radios, function (radio) {
      return radio.checked;
    }) && firstLabel) {
      firstLabel.tabIndex = 0;
    }
  },

  methods: {
    handleKeydown: function handleKeydown(e) {
      // 左右上下按键 可以在radio组内切换不同选项
      var target = e.target;
      var className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]';
      var radios = this.$el.querySelectorAll(className);
      var length = radios.length;
      var index = [].indexOf.call(radios, target);
      var roleRadios = this.$el.querySelectorAll('[role=radio]');
      switch (e.keyCode) {
        case keyCode.LEFT:
        case keyCode.UP:
          e.stopPropagation();
          e.preventDefault();
          if (index === 0) {
            roleRadios[length - 1].click();
          } else {
            roleRadios[index - 1].click();
          }
          break;
        case keyCode.RIGHT:
        case keyCode.DOWN:
          if (index === length - 1) {
            e.stopPropagation();
            e.preventDefault();
            roleRadios[0].click();
          } else {
            roleRadios[index + 1].click();
          }
          break;
        default:
          break;
      }
    }
  },
  watch: {
    value: function value(_value) {
      this.dispatch('ElFormItem', 'el.form.change', [this.value]);
    }
  }
};

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-radio-group",attrs:{"role":"radiogroup"},on:{"keydown":_vm.handleKeydown}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _radioButton = __webpack_require__(112);

var _radioButton2 = _interopRequireDefault(_radioButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_radioButton2.default.install = function (Vue) {
  Vue.component(_radioButton2.default.name, _radioButton2.default);
};

exports.default = _radioButton2.default;

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_button_vue__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_button_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_button_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_20684d78_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_radio_button_vue__ = __webpack_require__(114);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_radio_button_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_20684d78_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_radio_button_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElRadioButton',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  props: {
    label: {},
    disabled: Boolean,
    name: String
  },
  data: function data() {
    return {
      focus: false
    };
  },

  computed: {
    value: {
      get: function get() {
        return this._radioGroup.value;
      },
      set: function set(value) {
        this._radioGroup.$emit('input', value);
      }
    },
    _radioGroup: function _radioGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElRadioGroup') {
          parent = parent.$parent;
        } else {
          return parent;
        }
      }
      return false;
    },
    activeStyle: function activeStyle() {
      return {
        backgroundColor: this._radioGroup.fill || '',
        borderColor: this._radioGroup.fill || '',
        boxShadow: this._radioGroup.fill ? '-1px 0 0 0 ' + this._radioGroup.fill : '',
        color: this._radioGroup.textColor || ''
      };
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    size: function size() {
      return this._radioGroup.radioGroupSize || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    isDisabled: function isDisabled() {
      return this.disabled || this._radioGroup.disabled;
    },
    tabIndex: function tabIndex() {
      return !this.isDisabled ? this._radioGroup ? this.value === this.label ? 0 : -1 : 0 : -1;
    }
  },

  methods: {
    handleChange: function handleChange() {
      var _this = this;

      this.$nextTick(function () {
        _this.dispatch('ElRadioGroup', 'handleChange', _this.value);
      });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-radio-button",class:[
    _vm.size ? 'el-radio-button--' + _vm.size : '',
    { 'is-active': _vm.value === _vm.label },
    { 'is-disabled': _vm.isDisabled },
    { 'is-focus': _vm.focus }
  ],attrs:{"role":"radio","aria-checked":_vm.value === _vm.label,"aria-disabled":_vm.isDisabled,"tabindex":_vm.tabIndex},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"space",32,$event.key)){ return null; }$event.stopPropagation();$event.preventDefault();_vm.value = _vm.label}}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.value),expression:"value"}],staticClass:"el-radio-button__orig-radio",attrs:{"type":"radio","name":_vm.name,"disabled":_vm.isDisabled,"tabindex":"-1"},domProps:{"value":_vm.label,"checked":_vm._q(_vm.value,_vm.label)},on:{"change":[function($event){_vm.value=_vm.label},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}),_c('span',{staticClass:"el-radio-button__inner",style:(_vm.value === _vm.label ? _vm.activeStyle : null)},[_vm._t("default"),(!_vm.$slots.default)?[_vm._v(_vm._s(_vm.label))]:_vm._e()],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(116);

var _checkbox2 = _interopRequireDefault(_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_checkbox2.default.install = function (Vue) {
  Vue.component(_checkbox2.default.name, _checkbox2.default);
};

exports.default = _checkbox2.default;

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_59b8b1d6_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_vue__ = __webpack_require__(118);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_59b8b1d6_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElCheckbox',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  componentName: 'ElCheckbox',

  data: function data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false
    };
  },


  computed: {
    model: {
      get: function get() {
        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);

          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);

          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
          this.selfModel = val;
        }
      }
    },

    isChecked: function isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
    },
    isGroup: function isGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          this._checkboxGroup = parent;
          return true;
        }
      }
      return false;
    },
    store: function store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this._checkboxGroup.disabled || this.disabled : this.disabled;
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxSize: function checkboxSize() {
      var temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
    }
  },

  props: {
    value: {},
    label: {},
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: [String, Number],
    falseLabel: [String, Number],
    id: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    controls: String, /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    border: Boolean,
    size: String
  },

  methods: {
    addToStore: function addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    handleChange: function handleChange(ev) {
      var _this = this;

      if (this.isLimitExceeded) return;
      var value = void 0;
      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }
      this.$emit('change', value, ev);
      this.$nextTick(function () {
        if (_this.isGroup) {
          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
        }
      });
    }
  },

  created: function created() {
    this.checked && this.addToStore();
  },
  mounted: function mounted() {
    // 为indeterminate元素 添加aria-controls 属性
    if (this.indeterminate) {
      this.$el.setAttribute('aria-controls', this.controls);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-checkbox",class:[
    _vm.border && _vm.checkboxSize ? 'el-checkbox--' + _vm.checkboxSize : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-bordered': _vm.border },
    { 'is-checked': _vm.isChecked }
  ],attrs:{"role":"checkbox","aria-checked":_vm.indeterminate ? 'mixed': _vm.isChecked,"aria-disabled":_vm.isDisabled,"id":_vm.id}},[_c('span',{staticClass:"el-checkbox__input",class:{
      'is-disabled': _vm.isDisabled,
      'is-checked': _vm.isChecked,
      'is-indeterminate': _vm.indeterminate,
      'is-focus': _vm.focus
    },attrs:{"aria-checked":"mixed"}},[_c('span',{staticClass:"el-checkbox__inner"}),(_vm.trueLabel || _vm.falseLabel)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"type":"checkbox","name":_vm.name,"disabled":_vm.isDisabled,"true-value":_vm.trueLabel,"false-value":_vm.falseLabel},domProps:{"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,null)>-1:_vm._q(_vm.model,_vm.trueLabel)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(_vm.trueLabel):(_vm.falseLabel);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}):_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"type":"checkbox","disabled":_vm.isDisabled,"name":_vm.name},domProps:{"value":_vm.label,"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,_vm.label)>-1:(_vm.model)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.label,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}})]),(_vm.$slots.default || _vm.label)?_c('span',{staticClass:"el-checkbox__label"},[_vm._t("default"),(!_vm.$slots.default)?[_vm._v(_vm._s(_vm.label))]:_vm._e()],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkboxButton = __webpack_require__(120);

var _checkboxButton2 = _interopRequireDefault(_checkboxButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_checkboxButton2.default.install = function (Vue) {
  Vue.component(_checkboxButton2.default.name, _checkboxButton2.default);
};

exports.default = _checkboxButton2.default;

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_button_vue__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_button_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_button_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_fea65ccc_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_button_vue__ = __webpack_require__(122);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_button_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_fea65ccc_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_button_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElCheckboxButton',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  data: function data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false
    };
  },


  props: {
    value: {},
    label: {},
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: [String, Number],
    falseLabel: [String, Number]
  },
  computed: {
    model: {
      get: function get() {
        return this._checkboxGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set: function set(val) {
        if (this._checkboxGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);

          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);

          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else if (this.value !== undefined) {
          this.$emit('input', val);
        } else {
          this.selfModel = val;
        }
      }
    },

    isChecked: function isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
    },
    _checkboxGroup: function _checkboxGroup() {
      var parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          return parent;
        }
      }
      return false;
    },
    store: function store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },
    activeStyle: function activeStyle() {
      return {
        backgroundColor: this._checkboxGroup.fill || '',
        borderColor: this._checkboxGroup.fill || '',
        color: this._checkboxGroup.textColor || '',
        'box-shadow': '-1px 0 0 0 ' + this._checkboxGroup.fill

      };
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    size: function size() {
      return this._checkboxGroup.checkboxGroupSize || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    isDisabled: function isDisabled() {
      return this._checkboxGroup ? this._checkboxGroup.disabled || this.disabled : this.disabled;
    }
  },
  methods: {
    addToStore: function addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    handleChange: function handleChange(ev) {
      var _this = this;

      if (this.isLimitExceeded) return;
      var value = void 0;
      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }
      this.$emit('change', value, ev);
      this.$nextTick(function () {
        if (_this._checkboxGroup) {
          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
        }
      });
    }
  },

  created: function created() {
    this.checked && this.addToStore();
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-checkbox-button",class:[
      _vm.size ? 'el-checkbox-button--' + _vm.size : '',
      { 'is-disabled': _vm.isDisabled },
      { 'is-checked': _vm.isChecked },
      { 'is-focus': _vm.focus } ],attrs:{"role":"checkbox","aria-checked":_vm.isChecked,"aria-disabled":_vm.isDisabled}},[(_vm.trueLabel || _vm.falseLabel)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox-button__original",attrs:{"type":"checkbox","name":_vm.name,"disabled":_vm.isDisabled,"true-value":_vm.trueLabel,"false-value":_vm.falseLabel},domProps:{"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,null)>-1:_vm._q(_vm.model,_vm.trueLabel)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(_vm.trueLabel):(_vm.falseLabel);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}):_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox-button__original",attrs:{"type":"checkbox","name":_vm.name,"disabled":_vm.isDisabled},domProps:{"value":_vm.label,"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,_vm.label)>-1:(_vm.model)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.label,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}),(_vm.$slots.default || _vm.label)?_c('span',{staticClass:"el-checkbox-button__inner",style:(_vm.isChecked ? _vm.activeStyle : null)},[_vm._t("default",[_vm._v(_vm._s(_vm.label))])],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkboxGroup = __webpack_require__(124);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_checkboxGroup2.default.install = function (Vue) {
  Vue.component(_checkboxGroup2.default.name, _checkboxGroup2.default);
};

exports.default = _checkboxGroup2.default;

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_376416c7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_group_vue__ = __webpack_require__(126);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_376416c7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElCheckboxGroup',

  componentName: 'ElCheckboxGroup',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  props: {
    value: {},
    disabled: Boolean,
    min: Number,
    max: Number,
    size: String,
    fill: String,
    textColor: String
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxGroupSize: function checkboxGroupSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  watch: {
    value: function value(_value) {
      this.dispatch('ElFormItem', 'el.form.change', [_value]);
    }
  }
};

/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-checkbox-group",attrs:{"role":"group","aria-label":"checkbox-group"}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(128);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_component2.default.install = function (Vue) {
  Vue.component(_component2.default.name, _component2.default);
};

exports.default = _component2.default;

/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_487d0a8c_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_component_vue__ = __webpack_require__(130);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_component_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_487d0a8c_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_component_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _focus = __webpack_require__(14);

var _focus2 = _interopRequireDefault(_focus);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElSwitch',
  mixins: [(0, _focus2.default)('input'), _migrating2.default],
  props: {
    value: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 0
    },
    activeIconClass: {
      type: String,
      default: ''
    },
    inactiveIconClass: {
      type: String,
      default: ''
    },
    activeText: String,
    inactiveText: String,
    activeColor: {
      type: String,
      default: ''
    },
    inactiveColor: {
      type: String,
      default: ''
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    name: {
      type: String,
      default: ''
    }
  },
  data: function data() {
    return {
      coreWidth: this.width
    };
  },
  created: function created() {
    if (!~[this.activeValue, this.inactiveValue].indexOf(this.value)) {
      this.$emit('input', this.inactiveValue);
    }
  },

  computed: {
    checked: function checked() {
      return this.value === this.activeValue;
    },
    transform: function transform() {
      return this.checked ? 'translate3d(' + (this.coreWidth - 20) + 'px, 0, 0)' : '';
    }
  },
  watch: {
    checked: function checked() {
      this.$refs.input.checked = this.checked;
      if (this.activeColor || this.inactiveColor) {
        this.setBackgroundColor();
      }
    }
  },
  methods: {
    handleChange: function handleChange(event) {
      var _this = this;

      this.$emit('input', !this.checked ? this.activeValue : this.inactiveValue);
      this.$emit('change', !this.checked ? this.activeValue : this.inactiveValue);
      this.$nextTick(function () {
        // set input's checked property
        // in case parent refuses to change component's value
        _this.$refs.input.checked = _this.checked;
      });
    },
    setBackgroundColor: function setBackgroundColor() {
      var newColor = this.checked ? this.activeColor : this.inactiveColor;
      this.$refs.core.style.borderColor = newColor;
      this.$refs.core.style.backgroundColor = newColor;
    },
    switchValue: function switchValue() {
      this.$refs.input.click();
    },
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'on-color': 'on-color is renamed to active-color.',
          'off-color': 'off-color is renamed to inactive-color.',
          'on-text': 'on-text is renamed to active-text.',
          'off-text': 'off-text is renamed to inactive-text.',
          'on-value': 'on-value is renamed to active-value.',
          'off-value': 'off-value is renamed to inactive-value.',
          'on-icon-class': 'on-icon-class is renamed to active-icon-class.',
          'off-icon-class': 'off-icon-class is renamed to inactive-icon-class.'
        }
      };
    }
  },
  mounted: function mounted() {
    /* istanbul ignore if */
    this.coreWidth = this.width || 40;
    if (this.activeColor || this.inactiveColor) {
      this.setBackgroundColor();
    }
    this.$refs.input.checked = this.checked;
  }
};

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-switch",class:{ 'is-disabled': _vm.disabled, 'is-checked': _vm.checked },attrs:{"role":"switch","aria-checked":_vm.checked,"aria-disabled":_vm.disabled},on:{"click":_vm.switchValue}},[_c('input',{ref:"input",staticClass:"el-switch__input",attrs:{"type":"checkbox","name":_vm.name,"true-value":_vm.activeValue,"false-value":_vm.inactiveValue,"disabled":_vm.disabled},on:{"change":_vm.handleChange,"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.switchValue($event)}}}),(_vm.inactiveIconClass || _vm.inactiveText)?_c('span',{class:['el-switch__label', 'el-switch__label--left', !_vm.checked ? 'is-active' : '']},[(_vm.inactiveIconClass)?_c('i',{class:[_vm.inactiveIconClass]}):_vm._e(),(!_vm.inactiveIconClass && _vm.inactiveText)?_c('span',{attrs:{"aria-hidden":_vm.checked}},[_vm._v(_vm._s(_vm.inactiveText))]):_vm._e()]):_vm._e(),_c('span',{ref:"core",staticClass:"el-switch__core",style:({ 'width': _vm.coreWidth + 'px' })},[_c('span',{staticClass:"el-switch__button",style:({ transform: _vm.transform })})]),(_vm.activeIconClass || _vm.activeText)?_c('span',{class:['el-switch__label', 'el-switch__label--right', _vm.checked ? 'is-active' : '']},[(_vm.activeIconClass)?_c('i',{class:[_vm.activeIconClass]}):_vm._e(),(!_vm.activeIconClass && _vm.activeText)?_c('span',{attrs:{"aria-hidden":!_vm.checked}},[_vm._v(_vm._s(_vm.activeText))]):_vm._e()]):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _select = __webpack_require__(132);

var _select2 = _interopRequireDefault(_select);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_select2.default.install = function (Vue) {
  Vue.component(_select2.default.name, _select2.default);
};

exports.default = _select2.default;

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ab76e696_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_vue__ = __webpack_require__(140);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ab76e696_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _focus = __webpack_require__(14);

var _focus2 = _interopRequireDefault(_focus);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _selectDropdown = __webpack_require__(134);

var _selectDropdown2 = _interopRequireDefault(_selectDropdown);

var _option = __webpack_require__(32);

var _option2 = _interopRequireDefault(_option);

var _tag = __webpack_require__(23);

var _tag2 = _interopRequireDefault(_tag);

var _scrollbar = __webpack_require__(19);

var _scrollbar2 = _interopRequireDefault(_scrollbar);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _dom = __webpack_require__(4);

var _resizeEvent = __webpack_require__(18);

var _locale3 = __webpack_require__(16);

var _scrollIntoView = __webpack_require__(24);

var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

var _util = __webpack_require__(3);

var _navigationMixin = __webpack_require__(139);

var _navigationMixin2 = _interopRequireDefault(_navigationMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sizeMap = {
  'medium': 36,
  'small': 32,
  'mini': 28
};

exports.default = {
  mixins: [_emitter2.default, _locale2.default, (0, _focus2.default)('reference'), _navigationMixin2.default],

  name: 'ElSelect',

  componentName: 'ElSelect',

  inject: {
    elFormItem: {
      default: ''
    }
  },

  provide: function provide() {
    return {
      'select': this
    };
  },


  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    iconClass: function iconClass() {
      var criteria = this.clearable && !this.disabled && this.inputHovering && !this.multiple && this.value !== undefined && this.value !== '';
      return criteria ? 'circle-close is-show-close' : this.remote && this.filterable ? '' : 'arrow-up';
    },
    debounce: function debounce() {
      return this.remote ? 300 : 0;
    },
    emptyText: function emptyText() {
      if (this.loading) {
        return this.loadingText || this.t('el.select.loading');
      } else {
        if (this.remote && this.query === '' && this.options.length === 0) return false;
        if (this.filterable && this.query && this.options.length > 0 && this.filteredOptionsCount === 0) {
          return this.noMatchText || this.t('el.select.noMatch');
        }
        if (this.options.length === 0) {
          return this.noDataText || this.t('el.select.noData');
        }
      }
      return null;
    },
    showNewOption: function showNewOption() {
      var _this = this;

      var hasExistingOption = this.options.filter(function (option) {
        return !option.created;
      }).some(function (option) {
        return option.currentLabel === _this.query;
      });
      return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
    },
    selectSize: function selectSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  components: {
    ElInput: _input2.default,
    ElSelectMenu: _selectDropdown2.default,
    ElOption: _option2.default,
    ElTag: _tag2.default,
    ElScrollbar: _scrollbar2.default
  },

  directives: { Clickoutside: _clickoutside2.default },

  props: {
    name: String,
    id: String,
    value: {
      required: true
    },
    size: String,
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: String,
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String,
      default: function _default() {
        return (0, _locale3.t)('el.select.placeholder');
      }
    },
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: {
      type: String,
      default: 'value'
    }
  },

  data: function data() {
    return {
      options: [],
      cachedOptions: [],
      createdLabel: null,
      createdSelected: false,
      selected: this.multiple ? [] : {},
      inputLength: 20,
      inputWidth: 0,
      cachedPlaceHolder: '',
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: false,
      selectedLabel: '',
      hoverIndex: -1,
      query: '',
      previousQuery: '',
      inputHovering: false,
      currentPlaceholder: ''
    };
  },


  watch: {
    disabled: function disabled() {
      var _this2 = this;

      this.$nextTick(function () {
        _this2.resetInputHeight();
      });
    },
    placeholder: function placeholder(val) {
      this.cachedPlaceHolder = this.currentPlaceholder = val;
    },
    value: function value(val) {
      if (this.multiple) {
        this.resetInputHeight();
        if (val.length > 0 || this.$refs.input && this.query !== '') {
          this.currentPlaceholder = '';
        } else {
          this.currentPlaceholder = this.cachedPlaceHolder;
        }
        if (this.filterable && !this.reserveKeyword) {
          this.query = '';
          this.handleQueryChange(this.query);
        }
      }
      this.setSelected();
      if (this.filterable && !this.multiple) {
        this.inputLength = 20;
      }
    },
    visible: function visible(val) {
      var _this3 = this;

      if (!val) {
        this.$refs.reference.$el.querySelector('input').blur();
        this.handleIconHide();
        this.broadcast('ElSelectDropdown', 'destroyPopper');
        if (this.$refs.input) {
          this.$refs.input.blur();
        }
        this.query = '';
        this.selectedLabel = '';
        this.inputLength = 20;
        this.resetHoverIndex();
        this.$nextTick(function () {
          if (_this3.$refs.input && _this3.$refs.input.value === '' && _this3.selected.length === 0) {
            _this3.currentPlaceholder = _this3.cachedPlaceHolder;
          }
        });
        if (!this.multiple) {
          if (this.selected) {
            if (this.filterable && this.allowCreate && this.createdSelected && this.createdOption) {
              this.selectedLabel = this.createdLabel;
            } else {
              this.selectedLabel = this.selected.currentLabel;
            }
            if (this.filterable) this.query = this.selectedLabel;
          }
        }
      } else {
        this.handleIconShow();
        this.broadcast('ElSelectDropdown', 'updatePopper');
        if (this.filterable) {
          this.query = this.remote ? '' : this.selectedLabel;
          this.handleQueryChange(this.query);
          if (this.multiple) {
            this.$refs.input.focus();
          } else {
            if (!this.remote) {
              this.broadcast('ElOption', 'queryChange', '');
              this.broadcast('ElOptionGroup', 'queryChange');
            }
            this.broadcast('ElInput', 'inputSelect');
          }
        }
      }
      this.$emit('visible-change', val);
    },
    options: function options() {
      if (this.$isServer) return;
      if (this.multiple) {
        this.resetInputHeight();
      }
      var inputs = this.$el.querySelectorAll('input');
      if ([].indexOf.call(inputs, document.activeElement) === -1) {
        this.setSelected();
      }
      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    }
  },

  methods: {
    handleQueryChange: function handleQueryChange(val) {
      var _this4 = this;

      if (this.previousQuery === val) return;
      this.previousQuery = val;
      this.$nextTick(function () {
        if (_this4.visible) _this4.broadcast('ElSelectDropdown', 'updatePopper');
      });
      this.hoverIndex = -1;
      if (this.multiple && this.filterable) {
        this.inputLength = this.$refs.input.value.length * 15 + 20;
        this.managePlaceholder();
        this.resetInputHeight();
      }
      if (this.remote && typeof this.remoteMethod === 'function') {
        this.hoverIndex = -1;
        this.remoteMethod(val);
      } else if (typeof this.filterMethod === 'function') {
        this.filterMethod(val);
        this.broadcast('ElOptionGroup', 'queryChange');
      } else {
        this.filteredOptionsCount = this.optionsCount;
        this.broadcast('ElOption', 'queryChange', val);
        this.broadcast('ElOptionGroup', 'queryChange');
      }
      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    },
    handleIconHide: function handleIconHide() {
      var icon = this.$el.querySelector('.el-input__icon');
      if (icon) {
        (0, _dom.removeClass)(icon, 'is-reverse');
      }
    },
    handleIconShow: function handleIconShow() {
      var icon = this.$el.querySelector('.el-input__icon');
      if (icon && !(0, _dom.hasClass)(icon, 'el-icon-circle-close')) {
        (0, _dom.addClass)(icon, 'is-reverse');
      }
    },
    scrollToOption: function scrollToOption(option) {
      var target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
      if (this.$refs.popper && target) {
        var menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
        (0, _scrollIntoView2.default)(menu, target);
      }
    },
    handleMenuEnter: function handleMenuEnter() {
      var _this5 = this;

      this.$nextTick(function () {
        return _this5.scrollToOption(_this5.selected);
      });
    },
    emitChange: function emitChange(val) {
      if (!(0, _util.valueEquals)(this.value, val)) {
        this.$emit('change', val);
        this.dispatch('ElFormItem', 'el.form.change', val);
      }
    },
    getOption: function getOption(value) {
      var option = void 0;
      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      for (var i = this.cachedOptions.length - 1; i >= 0; i--) {
        var cachedOption = this.cachedOptions[i];
        var isEqual = isObject ? (0, _util.getValueByPath)(cachedOption.value, this.valueKey) === (0, _util.getValueByPath)(value, this.valueKey) : cachedOption.value === value;
        if (isEqual) {
          option = cachedOption;
          break;
        }
      }
      if (option) return option;
      var label = !isObject ? value : '';
      var newOption = {
        value: value,
        currentLabel: label
      };
      if (this.multiple) {
        newOption.hitState = false;
      }
      return newOption;
    },
    setSelected: function setSelected() {
      var _this6 = this;

      if (!this.multiple) {
        var option = this.getOption(this.value);
        if (option.created) {
          this.createdLabel = option.currentLabel;
          this.createdSelected = true;
        } else {
          this.createdSelected = false;
        }
        this.selectedLabel = option.currentLabel;
        this.selected = option;
        if (this.filterable) this.query = this.selectedLabel;
        return;
      }
      var result = [];
      if (Array.isArray(this.value)) {
        this.value.forEach(function (value) {
          result.push(_this6.getOption(value));
        });
      }
      this.selected = result;
      this.$nextTick(function () {
        _this6.resetInputHeight();
      });
    },
    handleFocus: function handleFocus(event) {
      this.visible = true;
      this.$emit('focus', event);
    },
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },
    handleIconClick: function handleIconClick(event) {
      if (this.iconClass.indexOf('circle-close') > -1) {
        this.deleteSelected(event);
      } else {
        this.toggleMenu();
      }
    },
    handleMouseDown: function handleMouseDown(event) {
      if (event.target.tagName !== 'INPUT') return;
      if (this.visible) {
        this.handleClose();
        event.preventDefault();
      }
    },
    doDestroy: function doDestroy() {
      this.$refs.popper && this.$refs.popper.doDestroy();
    },
    handleClose: function handleClose() {
      this.visible = false;
    },
    toggleLastOptionHitState: function toggleLastOptionHitState(hit) {
      if (!Array.isArray(this.selected)) return;
      var option = this.selected[this.selected.length - 1];
      if (!option) return;

      if (hit === true || hit === false) {
        option.hitState = hit;
        return hit;
      }

      option.hitState = !option.hitState;
      return option.hitState;
    },
    deletePrevTag: function deletePrevTag(e) {
      if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
        var value = this.value.slice();
        value.pop();
        this.$emit('input', value);
        this.emitChange(value);
      }
    },
    managePlaceholder: function managePlaceholder() {
      if (this.currentPlaceholder !== '') {
        this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
      }
    },
    resetInputState: function resetInputState(e) {
      if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
      this.inputLength = this.$refs.input.value.length * 15 + 20;
      this.resetInputHeight();
    },
    resetInputHeight: function resetInputHeight() {
      var _this7 = this;

      this.$nextTick(function () {
        if (!_this7.$refs.reference) return;
        var inputChildNodes = _this7.$refs.reference.$el.childNodes;
        var input = [].filter.call(inputChildNodes, function (item) {
          return item.tagName === 'INPUT';
        })[0];
        var tags = _this7.$refs.tags;
        input.style.height = _this7.selected.length === 0 ? sizeMap[_this7.selectSize] + 'px' : Math.max(tags ? tags.clientHeight + 10 : 0, sizeMap[_this7.selectSize] || 40) + 'px';
        if (_this7.visible && _this7.emptyText !== false) {
          _this7.broadcast('ElSelectDropdown', 'updatePopper');
        }
      });
    },
    resetHoverIndex: function resetHoverIndex() {
      var _this8 = this;

      setTimeout(function () {
        if (!_this8.multiple) {
          _this8.hoverIndex = _this8.options.indexOf(_this8.selected);
        } else {
          if (_this8.selected.length > 0) {
            _this8.hoverIndex = Math.min.apply(null, _this8.selected.map(function (item) {
              return _this8.options.indexOf(item);
            }));
          } else {
            _this8.hoverIndex = -1;
          }
        }
      }, 300);
    },
    handleOptionSelect: function handleOptionSelect(option) {
      var _this9 = this;

      if (this.multiple) {
        var value = this.value.slice();
        var optionIndex = this.getValueIndex(value, option.value);
        if (optionIndex > -1) {
          value.splice(optionIndex, 1);
        } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
          value.push(option.value);
        }
        this.$emit('input', value);
        this.emitChange(value);
        if (option.created) {
          this.query = '';
          this.handleQueryChange('');
          this.inputLength = 20;
        }
        if (this.filterable) this.$refs.input.focus();
      } else {
        this.$emit('input', option.value);
        this.emitChange(option.value);
        this.visible = false;
      }
      this.$nextTick(function () {
        return _this9.scrollToOption(option);
      });
    },
    getValueIndex: function getValueIndex() {
      var _this10 = this;

      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var value = arguments[1];

      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      if (!isObject) {
        return arr.indexOf(value);
      } else {
        var _ret = function () {
          var valueKey = _this10.valueKey;
          var index = -1;
          arr.some(function (item, i) {
            if ((0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return {
            v: index
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
    },
    toggleMenu: function toggleMenu() {
      if (!this.disabled) {
        this.visible = !this.visible;
        if (this.visible) {
          (this.$refs.input || this.$refs.reference).focus();
        }
      }
    },
    selectOption: function selectOption() {
      if (this.options[this.hoverIndex]) {
        this.handleOptionSelect(this.options[this.hoverIndex]);
      }
    },
    deleteSelected: function deleteSelected(event) {
      event.stopPropagation();
      this.$emit('input', '');
      this.emitChange('');
      this.visible = false;
      this.$emit('clear');
    },
    deleteTag: function deleteTag(event, tag) {
      var index = this.selected.indexOf(tag);
      if (index > -1 && !this.disabled) {
        var value = this.value.slice();
        value.splice(index, 1);
        this.$emit('input', value);
        this.emitChange(value);
        this.$emit('remove-tag', tag);
      }
      event.stopPropagation();
    },
    onInputChange: function onInputChange() {
      if (this.filterable && this.query !== this.selectedLabel) {
        this.query = this.selectedLabel;
        this.handleQueryChange(this.query);
      }
    },
    onOptionDestroy: function onOptionDestroy(index) {
      if (index > -1) {
        this.optionsCount--;
        this.filteredOptionsCount--;
        this.options.splice(index, 1);
      }
    },
    resetInputWidth: function resetInputWidth() {
      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
    },
    handleResize: function handleResize() {
      this.resetInputWidth();
      if (this.multiple) this.resetInputHeight();
    },
    checkDefaultFirstOption: function checkDefaultFirstOption() {
      this.hoverIndex = -1;
      for (var i = 0; i !== this.options.length; ++i) {
        var option = this.options[i];
        if (this.query) {
          // pick first options that passes the filter
          if (!option.disabled && !option.groupDisabled && option.visible) {
            this.hoverIndex = i;
            break;
          }
        } else {
          // pick currently selected option
          if (option.itemSelected) {
            this.hoverIndex = i;
            break;
          }
        }
      }
    },
    getValueKey: function getValueKey(item) {
      if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
        return item.value;
      } else {
        return (0, _util.getValueByPath)(item.value, this.valueKey);
      }
    }
  },

  created: function created() {
    var _this11 = this;

    this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
    if (this.multiple && !Array.isArray(this.value)) {
      this.$emit('input', []);
    }
    if (!this.multiple && Array.isArray(this.value)) {
      this.$emit('input', '');
    }

    this.debouncedOnInputChange = (0, _debounce2.default)(this.debounce, function () {
      _this11.onInputChange();
    });

    this.$on('handleOptionClick', this.handleOptionSelect);
    this.$on('setSelected', this.setSelected);
  },
  mounted: function mounted() {
    var _this12 = this;

    if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
      this.currentPlaceholder = '';
    }
    (0, _resizeEvent.addResizeListener)(this.$el, this.handleResize);
    if (this.remote && this.multiple) {
      this.resetInputHeight();
    }
    this.$nextTick(function () {
      if (_this12.$refs.reference && _this12.$refs.reference.$el) {
        _this12.inputWidth = _this12.$refs.reference.$el.getBoundingClientRect().width;
      }
    });
    this.setSelected();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$el && this.handleResize) (0, _resizeEvent.removeResizeListener)(this.$el, this.handleResize);
  }
};

/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0a24e159_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_dropdown_vue__ = __webpack_require__(136);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_select_dropdown_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0a24e159_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_select_dropdown_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElSelectDropdown',

  componentName: 'ElSelectDropdown',

  mixins: [_vuePopper2.default],

  props: {
    placement: {
      default: 'bottom-start'
    },

    boundariesPadding: {
      default: 0
    },

    popperOptions: {
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    },

    visibleArrow: {
      default: true
    }
  },

  data: function data() {
    return {
      minWidth: ''
    };
  },


  computed: {
    popperClass: function popperClass() {
      return this.$parent.popperClass;
    }
  },

  watch: {
    '$parent.inputWidth': function $parentInputWidth() {
      this.minWidth = this.$parent.$el.getBoundingClientRect().width + 'px';
    }
  },

  mounted: function mounted() {
    var _this = this;

    this.referenceElm = this.$parent.$refs.reference.$el;
    this.$parent.popperElm = this.popperElm = this.$el;
    this.$on('updatePopper', function () {
      if (_this.$parent.visible) _this.updatePopper();
    });
    this.$on('destroyPopper', this.destroyPopper);
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-select-dropdown el-popper",class:[{ 'is-multiple': _vm.$parent.multiple }, _vm.popperClass],style:({ minWidth: _vm.minWidth })},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_emitter2.default],

  name: 'ElOption',

  componentName: 'ElOption',

  inject: ['select'],

  props: {
    value: {
      required: true
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    };
  },


  computed: {
    isObject: function isObject() {
      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
    },
    currentLabel: function currentLabel() {
      return this.label || (this.isObject ? '' : this.value);
    },
    currentValue: function currentValue() {
      return this.value || this.label || '';
    },
    itemSelected: function itemSelected() {
      if (!this.select.multiple) {
        return this.isEqual(this.value, this.select.value);
      } else {
        return this.contains(this.select.value, this.value);
      }
    },
    limitReached: function limitReached() {
      if (this.select.multiple) {
        return !this.itemSelected && this.select.value.length >= this.select.multipleLimit && this.select.multipleLimit > 0;
      } else {
        return false;
      }
    }
  },

  watch: {
    currentLabel: function currentLabel() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    },
    value: function value() {
      if (!this.created && !this.select.remote) this.dispatch('ElSelect', 'setSelected');
    }
  },

  methods: {
    isEqual: function isEqual(a, b) {
      if (!this.isObject) {
        return a === b;
      } else {
        var valueKey = this.select.valueKey;
        return (0, _util.getValueByPath)(a, valueKey) === (0, _util.getValueByPath)(b, valueKey);
      }
    },
    contains: function contains() {
      var _this = this;

      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var target = arguments[1];

      if (!this.isObject) {
        return arr.indexOf(target) > -1;
      } else {
        var _ret = function () {
          var valueKey = _this.select.valueKey;
          return {
            v: arr.some(function (item) {
              return (0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(target, valueKey);
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
    },
    handleGroupDisabled: function handleGroupDisabled(val) {
      this.groupDisabled = val;
    },
    hoverItem: function hoverItem() {
      if (!this.disabled && !this.groupDisabled) {
        this.select.hoverIndex = this.select.options.indexOf(this);
      }
    },
    selectOptionClick: function selectOptionClick() {
      if (this.disabled !== true && this.groupDisabled !== true) {
        this.dispatch('ElSelect', 'handleOptionClick', this);
      }
    },
    queryChange: function queryChange(query) {
      // query 里如果有正则中的特殊字符，需要先将这些字符转义
      var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
      if (!this.visible) {
        this.select.filteredOptionsCount--;
      }
    }
  },

  created: function created() {
    this.select.options.push(this);
    this.select.cachedOptions.push(this);
    this.select.optionsCount++;
    this.select.filteredOptionsCount++;

    this.$on('queryChange', this.queryChange);
    this.$on('handleGroupDisabled', this.handleGroupDisabled);
  },
  beforeDestroy: function beforeDestroy() {
    this.select.onOptionDestroy(this.select.options.indexOf(this));
  }
};

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-select-dropdown__item",class:{
    'selected': _vm.itemSelected,
    'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
    'hover': _vm.hover
  },on:{"mouseenter":_vm.hoverItem,"click":function($event){$event.stopPropagation();_vm.selectOptionClick($event)}}},[_vm._t("default",[_c('span',[_vm._v(_vm._s(_vm.currentLabel))])])],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  data: function data() {
    return {
      hoverOption: -1
    };
  },


  computed: {
    optionsAllDisabled: function optionsAllDisabled() {
      return this.options.length === this.options.filter(function (item) {
        return item.disabled === true;
      }).length;
    }
  },

  watch: {
    hoverIndex: function hoverIndex(val) {
      var _this = this;

      if (typeof val === 'number' && val > -1) {
        this.hoverOption = this.options[val] || {};
      }
      this.options.forEach(function (option) {
        option.hover = _this.hoverOption === option;
      });
    }
  },

  methods: {
    navigateOptions: function navigateOptions(direction) {
      var _this2 = this;

      if (!this.visible) {
        this.visible = true;
        return;
      }
      if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
      if (!this.optionsAllDisabled) {
        if (direction === 'next') {
          this.hoverIndex++;
          if (this.hoverIndex === this.options.length) {
            this.hoverIndex = 0;
          }
        } else if (direction === 'prev') {
          this.hoverIndex--;
          if (this.hoverIndex < 0) {
            this.hoverIndex = this.options.length - 1;
          }
        }
        var option = this.options[this.hoverIndex];
        if (option.disabled === true || option.groupDisabled === true || !option.visible) {
          this.navigateOptions(direction);
        }
      }
      this.$nextTick(function () {
        return _this2.scrollToOption(_this2.hoverOption);
      });
    }
  }
};

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],staticClass:"el-select",class:[_vm.selectSize ? 'el-select--' + _vm.selectSize : '']},[(_vm.multiple)?_c('div',{ref:"tags",staticClass:"el-select__tags",style:({ 'max-width': _vm.inputWidth - 32 + 'px' }),on:{"click":function($event){$event.stopPropagation();_vm.toggleMenu($event)}}},[_c('transition-group',{on:{"after-leave":_vm.resetInputHeight}},_vm._l((_vm.selected),function(item){return _c('el-tag',{key:_vm.getValueKey(item),attrs:{"closable":!_vm.disabled,"size":"small","hit":item.hitState,"type":"info","disable-transitions":""},on:{"close":function($event){_vm.deleteTag($event, item)}}},[_c('span',{staticClass:"el-select__tags-text"},[_vm._v(_vm._s(item.currentLabel))])])})),(_vm.filterable)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.query),expression:"query"}],ref:"input",staticClass:"el-select__input",class:[_vm.selectSize ? ("is-" + _vm.selectSize) : ''],style:({ width: _vm.inputLength + 'px', 'max-width': _vm.inputWidth - 42 + 'px' }),attrs:{"type":"text","disabled":_vm.disabled,"debounce":_vm.remote ? 300 : 0},domProps:{"value":(_vm.query)},on:{"focus":_vm.handleFocus,"keyup":_vm.managePlaceholder,"keydown":[_vm.resetInputState,function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('next')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('prev')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }$event.preventDefault();_vm.selectOption($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"esc",27,$event.key)){ return null; }$event.stopPropagation();$event.preventDefault();_vm.visible = false},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"delete",[8,46],$event.key)){ return null; }_vm.deletePrevTag($event)}],"input":[function($event){if($event.target.composing){ return; }_vm.query=$event.target.value},function (e) { return _vm.handleQueryChange(e.target.value); }]}}):_vm._e()],1):_vm._e(),_c('el-input',{ref:"reference",class:{ 'is-focus': _vm.visible },attrs:{"type":"text","placeholder":_vm.currentPlaceholder,"name":_vm.name,"id":_vm.id,"size":_vm.selectSize,"disabled":_vm.disabled,"readonly":!_vm.filterable || _vm.multiple,"validate-event":false},on:{"focus":_vm.handleFocus,"blur":_vm.handleBlur},nativeOn:{"mousedown":function($event){_vm.handleMouseDown($event)},"keyup":function($event){_vm.debouncedOnInputChange($event)},"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('next')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.navigateOptions('prev')},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }$event.preventDefault();_vm.selectOption($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"esc",27,$event.key)){ return null; }$event.stopPropagation();$event.preventDefault();_vm.visible = false},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"tab",9,$event.key)){ return null; }_vm.visible = false}],"paste":function($event){_vm.debouncedOnInputChange($event)},"mouseenter":function($event){_vm.inputHovering = true},"mouseleave":function($event){_vm.inputHovering = false}},model:{value:(_vm.selectedLabel),callback:function ($$v) {_vm.selectedLabel=$$v},expression:"selectedLabel"}},[_c('i',{class:['el-select__caret', 'el-input__icon', 'el-icon-' + _vm.iconClass],attrs:{"slot":"suffix"},on:{"click":_vm.handleIconClick},slot:"suffix"})]),_c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"before-enter":_vm.handleMenuEnter,"after-leave":_vm.doDestroy}},[_c('el-select-menu',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible && _vm.emptyText !== false),expression:"visible && emptyText !== false"}],ref:"popper"},[_c('el-scrollbar',{directives:[{name:"show",rawName:"v-show",value:(_vm.options.length > 0 && !_vm.loading),expression:"options.length > 0 && !loading"}],class:{ 'is-empty': !_vm.allowCreate && _vm.query && _vm.filteredOptionsCount === 0 },attrs:{"tag":"ul","wrap-class":"el-select-dropdown__wrap","view-class":"el-select-dropdown__list"}},[(_vm.showNewOption)?_c('el-option',{attrs:{"value":_vm.query,"created":""}}):_vm._e(),_vm._t("default")],2),(_vm.emptyText && (_vm.allowCreate && _vm.options.length === 0 || !_vm.allowCreate))?_c('p',{staticClass:"el-select-dropdown__empty"},[_vm._v(_vm._s(_vm.emptyText))]):_vm._e()],1)],1)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _option = __webpack_require__(32);

var _option2 = _interopRequireDefault(_option);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_option2.default.install = function (Vue) {
  Vue.component(_option2.default.name, _option2.default);
};

exports.default = _option2.default;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _optionGroup = __webpack_require__(143);

var _optionGroup2 = _interopRequireDefault(_optionGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_optionGroup2.default.install = function (Vue) {
  Vue.component(_optionGroup2.default.name, _optionGroup2.default);
};

exports.default = _optionGroup2.default;

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_group_vue__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_378254a0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_group_vue__ = __webpack_require__(145);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_option_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_378254a0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_option_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_emitter2.default],

  name: 'ElOptionGroup',

  componentName: 'ElOptionGroup',

  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      visible: true
    };
  },


  watch: {
    disabled: function disabled(val) {
      this.broadcast('ElOption', 'handleGroupDisabled', val);
    }
  },

  methods: {
    queryChange: function queryChange() {
      this.visible = this.$children && Array.isArray(this.$children) && this.$children.some(function (option) {
        return option.visible === true;
      });
    }
  },

  created: function created() {
    this.$on('queryChange', this.queryChange);
  },
  mounted: function mounted() {
    if (this.disabled) {
      this.broadcast('ElOption', 'handleGroupDisabled', this.disabled);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{staticClass:"el-select-group__wrap"},[_c('li',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-select-group__title"},[_vm._v(_vm._s(_vm.label))]),_c('li',[_c('ul',{staticClass:"el-select-group"},[_vm._t("default")],2)])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _button = __webpack_require__(147);

var _button2 = _interopRequireDefault(_button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_button2.default.install = function (Vue) {
  Vue.component(_button2.default.name, _button2.default);
};

exports.default = _button2.default;

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_36b70ef5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__ = __webpack_require__(149);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_36b70ef5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElButton',

  inject: {
    elFormItem: {
      default: ''
    }
  },

  props: {
    type: {
      type: String,
      default: 'default'
    },
    size: String,
    icon: {
      type: String,
      default: ''
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    buttonSize: function buttonSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  methods: {
    handleClick: function handleClick(evt) {
      this.$emit('click', evt);
    },
    handleInnerClick: function handleInnerClick(evt) {
      if (this.disabled) {
        evt.stopPropagation();
      }
    }
  }
};

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"el-button",class:[
    _vm.type ? 'el-button--' + _vm.type : '',
    _vm.buttonSize ? 'el-button--' + _vm.buttonSize : '',
    {
      'is-disabled': _vm.disabled,
      'is-loading': _vm.loading,
      'is-plain': _vm.plain,
      'is-round': _vm.round
    }
  ],attrs:{"disabled":_vm.disabled,"autofocus":_vm.autofocus,"type":_vm.nativeType},on:{"click":_vm.handleClick}},[(_vm.loading)?_c('i',{staticClass:"el-icon-loading",on:{"click":_vm.handleInnerClick}}):_vm._e(),(_vm.icon && !_vm.loading)?_c('i',{class:_vm.icon,on:{"click":_vm.handleInnerClick}}):_vm._e(),(_vm.$slots.default)?_c('span',{on:{"click":_vm.handleInnerClick}},[_vm._t("default")],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _buttonGroup = __webpack_require__(151);

var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_buttonGroup2.default.install = function (Vue) {
  Vue.component(_buttonGroup2.default.name, _buttonGroup2.default);
};

exports.default = _buttonGroup2.default;

/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4c0216a7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_group_vue__ = __webpack_require__(153);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4c0216a7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//

exports.default = {
  name: 'ElButtonGroup'
};

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-button-group"},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _table = __webpack_require__(155);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_table2.default.install = function (Vue) {
  Vue.component(_table2.default.name, _table2.default);
};

exports.default = _table2.default;

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_table_vue__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_table_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_table_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_271dac46_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_table_vue__ = __webpack_require__(166);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_table_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_271dac46_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_table_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _throttle = __webpack_require__(33);

var _throttle2 = _interopRequireDefault(_throttle);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _resizeEvent = __webpack_require__(18);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

var _tableStore = __webpack_require__(157);

var _tableStore2 = _interopRequireDefault(_tableStore);

var _tableLayout = __webpack_require__(158);

var _tableLayout2 = _interopRequireDefault(_tableLayout);

var _tableBody = __webpack_require__(159);

var _tableBody2 = _interopRequireDefault(_tableBody);

var _tableHeader = __webpack_require__(160);

var _tableHeader2 = _interopRequireDefault(_tableHeader);

var _tableFooter = __webpack_require__(165);

var _tableFooter2 = _interopRequireDefault(_tableFooter);

var _util = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var tableIdSeed = 1;

exports.default = {
  name: 'ElTable',

  mixins: [_locale2.default, _migrating2.default],

  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    size: String,

    width: [String, Number],

    height: [String, Number],

    maxHeight: [String, Number],

    fit: {
      type: Boolean,
      default: true
    },

    stripe: Boolean,

    border: Boolean,

    rowKey: [String, Function],

    context: {},

    showHeader: {
      type: Boolean,
      default: true
    },

    showSummary: Boolean,

    sumText: String,

    summaryMethod: Function,

    rowClassName: [String, Function],

    rowStyle: [Object, Function],

    cellClassName: [String, Function],

    cellStyle: [Object, Function],

    headerRowClassName: [String, Function],

    headerRowStyle: [Object, Function],

    headerCellClassName: [String, Function],

    headerCellStyle: [Object, Function],

    highlightCurrentRow: Boolean,

    currentRowKey: [String, Number],

    emptyText: String,

    expandRowKeys: Array,

    defaultExpandAll: Boolean,

    defaultSort: Object,

    tooltipEffect: String,

    spanMethod: Function
  },

  components: {
    TableHeader: _tableHeader2.default,
    TableFooter: _tableFooter2.default,
    TableBody: _tableBody2.default,
    ElCheckbox: _checkbox2.default
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        events: {
          expand: 'expand is renamed to expand-change'
        }
      };
    },
    setCurrentRow: function setCurrentRow(row) {
      this.store.commit('setCurrentRow', row);
    },
    toggleRowSelection: function toggleRowSelection(row, selected) {
      this.store.toggleRowSelection(row, selected);
      this.store.updateAllSelected();
    },
    toggleRowExpansion: function toggleRowExpansion(row, expanded) {
      this.store.toggleRowExpansion(row, expanded);
    },
    clearSelection: function clearSelection() {
      this.store.clearSelection();
    },
    clearFilter: function clearFilter() {
      this.store.clearFilter();
    },
    clearSort: function clearSort() {
      this.store.clearSort();
    },
    handleMouseLeave: function handleMouseLeave() {
      this.store.commit('setHoverRow', null);
      if (this.hoverState) this.hoverState = null;
    },
    updateScrollY: function updateScrollY() {
      this.layout.updateScrollY();
    },
    bindEvents: function bindEvents() {
      var _this = this;

      var _$refs = this.$refs,
          headerWrapper = _$refs.headerWrapper,
          footerWrapper = _$refs.footerWrapper;

      var refs = this.$refs;
      var self = this;
      this.bodyWrapper.addEventListener('scroll', function () {
        if (headerWrapper) headerWrapper.scrollLeft = this.scrollLeft;
        if (footerWrapper) footerWrapper.scrollLeft = this.scrollLeft;
        if (refs.fixedBodyWrapper) refs.fixedBodyWrapper.scrollTop = this.scrollTop;
        if (refs.rightFixedBodyWrapper) refs.rightFixedBodyWrapper.scrollTop = this.scrollTop;
        var maxScrollLeftPosition = this.scrollWidth - this.offsetWidth - 1;
        var scrollLeft = this.scrollLeft;
        if (scrollLeft >= maxScrollLeftPosition) {
          self.scrollPosition = 'right';
        } else if (scrollLeft === 0) {
          self.scrollPosition = 'left';
        } else {
          self.scrollPosition = 'middle';
        }
      });

      var scrollBodyWrapper = function scrollBodyWrapper(event) {
        var deltaX = event.deltaX,
            deltaY = event.deltaY;


        if (Math.abs(deltaX) < Math.abs(deltaY)) return;

        if (deltaX > 0) {
          _this.bodyWrapper.scrollLeft += 10;
        } else if (deltaX < 0) {
          _this.bodyWrapper.scrollLeft -= 10;
        }
      };
      if (headerWrapper) {
        (0, _util.mousewheel)(headerWrapper, (0, _throttle2.default)(16, scrollBodyWrapper));
      }
      if (footerWrapper) {
        (0, _util.mousewheel)(footerWrapper, (0, _throttle2.default)(16, scrollBodyWrapper));
      }

      if (this.fit) {
        this.windowResizeListener = (0, _throttle2.default)(50, function () {
          if (_this.$ready) _this.doLayout();
        });
        (0, _resizeEvent.addResizeListener)(this.$el, this.windowResizeListener);
      }
    },
    doLayout: function doLayout() {
      var _this2 = this;

      this.store.updateColumns();
      this.updateScrollY();
      this.layout.update();
      this.$nextTick(function () {
        if (_this2.destroyed) return;
        if (_this2.height) {
          _this2.layout.setHeight(_this2.height);
        } else if (_this2.maxHeight) {
          _this2.layout.setMaxHeight(_this2.maxHeight);
        } else if (_this2.shouldUpdateHeight) {
          _this2.layout.updateHeight();
        }
        if (_this2.$el) {
          _this2.isHidden = _this2.$el.clientWidth === 0;
          if (_this2.isHidden && _this2.layout.bodyWidth) {
            setTimeout(function () {
              return _this2.debouncedLayout();
            });
          }
        }
      });
    }
  },

  created: function created() {
    var _this3 = this;

    this.tableId = 'el-table_' + tableIdSeed + '_';
    this.debouncedLayout = (0, _debounce2.default)(50, function () {
      return _this3.doLayout();
    });
  },


  computed: {
    tableSize: function tableSize() {
      return this.size || (this.$ELEMENT || {}).size;
    },
    bodyWrapper: function bodyWrapper() {
      return this.$refs.bodyWrapper;
    },
    shouldUpdateHeight: function shouldUpdateHeight() {
      return typeof this.height === 'number' || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
    },
    selection: function selection() {
      return this.store.states.selection;
    },
    columns: function columns() {
      return this.store.states.columns;
    },
    tableData: function tableData() {
      return this.store.states.data;
    },
    fixedColumns: function fixedColumns() {
      return this.store.states.fixedColumns;
    },
    rightFixedColumns: function rightFixedColumns() {
      return this.store.states.rightFixedColumns;
    },
    bodyHeight: function bodyHeight() {
      var style = {};

      if (this.height) {
        style = {
          height: this.layout.bodyHeight ? this.layout.bodyHeight + 'px' : ''
        };
      } else if (this.maxHeight) {
        style = {
          'max-height': (this.showHeader ? this.maxHeight - this.layout.headerHeight - this.layout.footerHeight : this.maxHeight - this.layout.footerHeight) + 'px'
        };
      }

      return style;
    },
    bodyWidth: function bodyWidth() {
      var _layout = this.layout,
          bodyWidth = _layout.bodyWidth,
          scrollY = _layout.scrollY,
          gutterWidth = _layout.gutterWidth;

      return bodyWidth ? bodyWidth - (scrollY ? gutterWidth : 0) + 'px' : '';
    },
    fixedBodyHeight: function fixedBodyHeight() {
      var style = {};

      if (this.height) {
        style = {
          height: this.layout.fixedBodyHeight ? this.layout.fixedBodyHeight + 'px' : ''
        };
      } else if (this.maxHeight) {
        var maxHeight = this.layout.scrollX ? this.maxHeight - this.layout.gutterWidth : this.maxHeight;

        if (this.showHeader) {
          maxHeight -= this.layout.headerHeight;
        }

        style = {
          'max-height': maxHeight + 'px'
        };
      }

      return style;
    },
    fixedHeight: function fixedHeight() {
      var style = {};

      if (this.maxHeight) {
        style = {
          bottom: this.layout.scrollX && this.data.length ? this.layout.gutterWidth + 'px' : ''
        };
      } else {
        style = {
          height: this.layout.viewportHeight ? this.layout.viewportHeight + 'px' : ''
        };
      }

      return style;
    }
  },

  watch: {
    height: function height(value) {
      this.layout.setHeight(value);
    },
    maxHeight: function maxHeight(value) {
      this.layout.setMaxHeight(value);
    },
    currentRowKey: function currentRowKey(newVal) {
      this.store.setCurrentRowKey(newVal);
    },


    data: {
      immediate: true,
      handler: function handler(val) {
        this.store.commit('setData', val);
        if (this.$ready) this.doLayout();
      }
    },

    expandRowKeys: {
      immediate: true,
      handler: function handler(newVal) {
        if (newVal) {
          this.store.setExpandRowKeys(newVal);
        }
      }
    }
  },

  destroyed: function destroyed() {
    this.destroyed = true;
    if (this.windowResizeListener) (0, _resizeEvent.removeResizeListener)(this.$el, this.windowResizeListener);
  },
  mounted: function mounted() {
    var _this4 = this;

    this.bindEvents();
    this.doLayout();

    // init filters
    this.store.states.columns.forEach(function (column) {
      if (column.filteredValue && column.filteredValue.length) {
        _this4.store.commit('filterChange', {
          column: column,
          values: column.filteredValue,
          silent: true
        });
      }
    });

    this.$ready = true;
  },
  data: function data() {
    var store = new _tableStore2.default(this, {
      rowKey: this.rowKey,
      defaultExpandAll: this.defaultExpandAll
    });
    var layout = new _tableLayout2.default({
      store: store,
      table: this,
      fit: this.fit,
      showHeader: this.showHeader
    });
    return {
      store: store,
      layout: layout,
      isHidden: false,
      renderExpanded: null,
      resizeProxyVisible: false,
      // 是否拥有多级表头
      isGroup: false,
      scrollPosition: 'left',
      destroyed: false
    };
  }
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

var _util = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sortData = function sortData(data, states) {
  var sortingColumn = states.sortingColumn;
  if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
    return data;
  }
  return (0, _util.orderBy)(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};

var getKeysMap = function getKeysMap(array, rowKey) {
  var arrayMap = {};
  (array || []).forEach(function (row, index) {
    arrayMap[(0, _util.getRowIdentity)(row, rowKey)] = { row: row, index: index };
  });
  return arrayMap;
};

var toggleRowSelection = function toggleRowSelection(states, row, selected) {
  var changed = false;
  var selection = states.selection;
  var index = selection.indexOf(row);
  if (typeof selected === 'undefined') {
    if (index === -1) {
      selection.push(row);
      changed = true;
    } else {
      selection.splice(index, 1);
      changed = true;
    }
  } else {
    if (selected && index === -1) {
      selection.push(row);
      changed = true;
    } else if (!selected && index > -1) {
      selection.splice(index, 1);
      changed = true;
    }
  }

  return changed;
};

var toggleRowExpansion = function toggleRowExpansion(states, row, expanded) {
  var changed = false;
  var expandRows = states.expandRows;
  if (typeof expanded !== 'undefined') {
    var index = expandRows.indexOf(row);
    if (expanded) {
      if (index === -1) {
        expandRows.push(row);
        changed = true;
      }
    } else {
      if (index !== -1) {
        expandRows.splice(index, 1);
        changed = true;
      }
    }
  } else {
    var _index = expandRows.indexOf(row);
    if (_index === -1) {
      expandRows.push(row);
      changed = true;
    } else {
      expandRows.splice(_index, 1);
      changed = true;
    }
  }

  return changed;
};

var TableStore = function TableStore(table) {
  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!table) {
    throw new Error('Table is required.');
  }
  this.table = table;

  this.states = {
    rowKey: null,
    _columns: [],
    originColumns: [],
    columns: [],
    fixedColumns: [],
    rightFixedColumns: [],
    leafColumns: [],
    fixedLeafColumns: [],
    rightFixedLeafColumns: [],
    isComplex: false,
    _data: null,
    filteredData: null,
    data: null,
    sortingColumn: null,
    sortProp: null,
    sortOrder: null,
    isAllSelected: false,
    selection: [],
    reserveSelection: false,
    selectable: null,
    currentRow: null,
    hoverRow: null,
    filters: {},
    expandRows: [],
    defaultExpandAll: false
  };

  for (var prop in initialState) {
    if (initialState.hasOwnProperty(prop) && this.states.hasOwnProperty(prop)) {
      this.states[prop] = initialState[prop];
    }
  }
};

TableStore.prototype.mutations = {
  setData: function setData(states, data) {
    var _this = this;

    var dataInstanceChanged = states._data !== data;
    states._data = data;

    Object.keys(states.filters).forEach(function (columnId) {
      var values = states.filters[columnId];
      if (!values || values.length === 0) return;
      var column = (0, _util.getColumnById)(_this.states, columnId);
      if (column && column.filterMethod) {
        data = data.filter(function (row) {
          return values.some(function (value) {
            return column.filterMethod.call(null, value, row);
          });
        });
      }
    });

    states.filteredData = data;
    states.data = sortData(data || [], states);

    // states.data.forEach((item) => {
    //   if (!item.$extra) {
    //     Object.defineProperty(item, '$extra', {
    //       value: {},
    //       enumerable: false
    //     });
    //   }
    // });

    this.updateCurrentRow();

    if (!states.reserveSelection) {
      if (dataInstanceChanged) {
        this.clearSelection();
      } else {
        this.cleanSelection();
      }
      this.updateAllSelected();
    } else {
      (function () {
        var rowKey = states.rowKey;
        if (rowKey) {
          (function () {
            var selection = states.selection;
            var selectedMap = getKeysMap(selection, rowKey);

            states.data.forEach(function (row) {
              var rowId = (0, _util.getRowIdentity)(row, rowKey);
              var rowInfo = selectedMap[rowId];
              if (rowInfo) {
                selection[rowInfo.index] = row;
              }
            });

            _this.updateAllSelected();
          })();
        } else {
          console.warn('WARN: rowKey is required when reserve-selection is enabled.');
        }
      })();
    }

    var defaultExpandAll = states.defaultExpandAll;
    if (defaultExpandAll) {
      this.states.expandRows = (states.data || []).slice(0);
    }

    _vue2.default.nextTick(function () {
      return _this.table.updateScrollY();
    });
  },
  changeSortCondition: function changeSortCondition(states, options) {
    var _this2 = this;

    states.data = sortData(states.filteredData || states._data || [], states);

    if (!options || !options.silent) {
      this.table.$emit('sort-change', {
        column: this.states.sortingColumn,
        prop: this.states.sortProp,
        order: this.states.sortOrder
      });
    }

    _vue2.default.nextTick(function () {
      return _this2.table.updateScrollY();
    });
  },
  filterChange: function filterChange(states, options) {
    var _this3 = this;

    var column = options.column,
        values = options.values,
        silent = options.silent;

    if (values && !Array.isArray(values)) {
      values = [values];
    }

    var prop = column.property;
    var filters = {};

    if (prop) {
      states.filters[column.id] = values;
      filters[column.columnKey || column.id] = values;
    }

    var data = states._data;

    Object.keys(states.filters).forEach(function (columnId) {
      var values = states.filters[columnId];
      if (!values || values.length === 0) return;
      var column = (0, _util.getColumnById)(_this3.states, columnId);
      if (column && column.filterMethod) {
        data = data.filter(function (row) {
          return values.some(function (value) {
            return column.filterMethod.call(null, value, row);
          });
        });
      }
    });

    states.filteredData = data;
    states.data = sortData(data, states);

    if (!silent) {
      this.table.$emit('filter-change', filters);
    }

    _vue2.default.nextTick(function () {
      return _this3.table.updateScrollY();
    });
  },
  insertColumn: function insertColumn(states, column, index, parent) {
    var array = states._columns;
    if (parent) {
      array = parent.children;
      if (!array) array = parent.children = [];
    }

    if (typeof index !== 'undefined') {
      array.splice(index, 0, column);
    } else {
      array.push(column);
    }

    if (column.type === 'selection') {
      states.selectable = column.selectable;
      states.reserveSelection = column.reserveSelection;
    }

    this.updateColumns(); // hack for dynamics insert column
    this.scheduleLayout();
  },
  removeColumn: function removeColumn(states, column) {
    var _columns = states._columns;
    if (_columns) {
      _columns.splice(_columns.indexOf(column), 1);
    }

    this.updateColumns(); // hack for dynamics remove column
    this.scheduleLayout();
  },
  setHoverRow: function setHoverRow(states, row) {
    states.hoverRow = row;
  },
  setCurrentRow: function setCurrentRow(states, row) {
    var oldCurrentRow = states.currentRow;
    states.currentRow = row;

    if (oldCurrentRow !== row) {
      this.table.$emit('current-change', row, oldCurrentRow);
    }
  },
  rowSelectedChanged: function rowSelectedChanged(states, row) {
    var changed = toggleRowSelection(states, row);
    var selection = states.selection;

    if (changed) {
      var table = this.table;
      table.$emit('selection-change', selection);
      table.$emit('select', selection, row);
    }

    this.updateAllSelected();
  },


  toggleAllSelection: (0, _debounce2.default)(10, function (states) {
    var data = states.data || [];
    var value = !states.isAllSelected;
    var selection = this.states.selection;
    var selectionChanged = false;

    data.forEach(function (item, index) {
      if (states.selectable) {
        if (states.selectable.call(null, item, index) && toggleRowSelection(states, item, value)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowSelection(states, item, value)) {
          selectionChanged = true;
        }
      }
    });

    var table = this.table;
    if (selectionChanged) {
      table.$emit('selection-change', selection);
    }
    table.$emit('select-all', selection);
    states.isAllSelected = value;
  })
};

var doFlattenColumns = function doFlattenColumns(columns) {
  var result = [];
  columns.forEach(function (column) {
    if (column.children) {
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};

TableStore.prototype.updateColumns = function () {
  var states = this.states;
  var _columns = states._columns || [];
  states.fixedColumns = _columns.filter(function (column) {
    return column.fixed === true || column.fixed === 'left';
  });
  states.rightFixedColumns = _columns.filter(function (column) {
    return column.fixed === 'right';
  });

  if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
    _columns[0].fixed = true;
    states.fixedColumns.unshift(_columns[0]);
  }

  var notFixedColumns = _columns.filter(function (column) {
    return !column.fixed;
  });
  states.originColumns = [].concat(states.fixedColumns).concat(notFixedColumns).concat(states.rightFixedColumns);

  var leafColumns = doFlattenColumns(notFixedColumns);
  var fixedLeafColumns = doFlattenColumns(states.fixedColumns);
  var rightFixedLeafColumns = doFlattenColumns(states.rightFixedColumns);

  states.leafColumnsLength = leafColumns.length;
  states.fixedLeafColumnsLength = fixedLeafColumns.length;
  states.rightFixedLeafColumnsLength = rightFixedLeafColumns.length;

  states.columns = [].concat(fixedLeafColumns).concat(leafColumns).concat(rightFixedLeafColumns);
  states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
};

TableStore.prototype.isSelected = function (row) {
  return (this.states.selection || []).indexOf(row) > -1;
};

TableStore.prototype.clearSelection = function () {
  var states = this.states;
  states.isAllSelected = false;
  var oldSelection = states.selection;
  states.selection = [];
  if (oldSelection.length > 0) {
    this.table.$emit('selection-change', states.selection);
  }
};

TableStore.prototype.setExpandRowKeys = function (rowKeys) {
  var expandRows = [];
  var data = this.states.data;
  var rowKey = this.states.rowKey;
  if (!rowKey) throw new Error('[Table] prop row-key should not be empty.');
  var keysMap = getKeysMap(data, rowKey);
  rowKeys.forEach(function (key) {
    var info = keysMap[key];
    if (info) {
      expandRows.push(info.row);
    }
  });

  this.states.expandRows = expandRows;
};

TableStore.prototype.toggleRowSelection = function (row, selected) {
  var changed = toggleRowSelection(this.states, row, selected);
  if (changed) {
    this.table.$emit('selection-change', this.states.selection);
  }
};

TableStore.prototype.toggleRowExpansion = function (row, expanded) {
  var changed = toggleRowExpansion(this.states, row, expanded);
  if (changed) {
    this.table.$emit('expand-change', row, this.states.expandRows);
  }
};

TableStore.prototype.cleanSelection = function () {
  var selection = this.states.selection || [];
  var data = this.states.data;
  var rowKey = this.states.rowKey;
  var deleted = void 0;
  if (rowKey) {
    deleted = [];
    var selectedMap = getKeysMap(selection, rowKey);
    var dataMap = getKeysMap(data, rowKey);
    for (var key in selectedMap) {
      if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
        deleted.push(selectedMap[key].row);
      }
    }
  } else {
    deleted = selection.filter(function (item) {
      return data.indexOf(item) === -1;
    });
  }

  deleted.forEach(function (deletedItem) {
    selection.splice(selection.indexOf(deletedItem), 1);
  });

  if (deleted.length) {
    this.table.$emit('selection-change', selection);
  }
};

TableStore.prototype.clearFilter = function () {
  var states = this.states;
  var _table$$refs = this.table.$refs,
      tableHeader = _table$$refs.tableHeader,
      fixedTableHeader = _table$$refs.fixedTableHeader,
      rightFixedTableHeader = _table$$refs.rightFixedTableHeader;

  var panels = {};

  if (tableHeader) panels = (0, _merge2.default)(panels, tableHeader.filterPanels);
  if (fixedTableHeader) panels = (0, _merge2.default)(panels, fixedTableHeader.filterPanels);
  if (rightFixedTableHeader) panels = (0, _merge2.default)(panels, rightFixedTableHeader.filterPanels);

  var keys = Object.keys(panels);
  if (!keys.length) return;

  keys.forEach(function (key) {
    panels[key].filteredValue = [];
  });

  states.filters = {};

  this.commit('filterChange', {
    column: {},
    values: [],
    silent: true
  });
};

TableStore.prototype.clearSort = function () {
  var states = this.states;
  if (!states.sortingColumn) return;
  states.sortingColumn.order = null;
  states.sortProp = null;
  states.sortOrder = null;

  this.commit('changeSortCondition', {
    silent: true
  });
};

TableStore.prototype.updateAllSelected = function () {
  var states = this.states;
  var selection = states.selection,
      rowKey = states.rowKey,
      selectable = states.selectable,
      data = states.data;

  if (!data || data.length === 0) {
    states.isAllSelected = false;
    return;
  }

  var selectedMap = void 0;
  if (rowKey) {
    selectedMap = getKeysMap(states.selection, rowKey);
  }

  var isSelected = function isSelected(row) {
    if (selectedMap) {
      return !!selectedMap[(0, _util.getRowIdentity)(row, rowKey)];
    } else {
      return selection.indexOf(row) !== -1;
    }
  };

  var isAllSelected = true;
  var selectedCount = 0;
  for (var i = 0, j = data.length; i < j; i++) {
    var item = data[i];
    if (selectable) {
      var isRowSelectable = selectable.call(null, item, i);
      if (isRowSelectable) {
        if (!isSelected(item)) {
          isAllSelected = false;
          break;
        } else {
          selectedCount++;
        }
      }
    } else {
      if (!isSelected(item)) {
        isAllSelected = false;
        break;
      } else {
        selectedCount++;
      }
    }
  }

  if (selectedCount === 0) isAllSelected = false;

  states.isAllSelected = isAllSelected;
};

TableStore.prototype.scheduleLayout = function () {
  this.table.debouncedLayout();
};

TableStore.prototype.setCurrentRowKey = function (key) {
  var states = this.states;
  var rowKey = states.rowKey;
  if (!rowKey) throw new Error('[Table] row-key should not be empty.');
  var data = states.data || [];
  var keysMap = getKeysMap(data, rowKey);
  var info = keysMap[key];
  if (info) {
    states.currentRow = info.row;
  }
};

TableStore.prototype.updateCurrentRow = function () {
  var states = this.states;
  var table = this.table;
  var data = states.data || [];
  var oldCurrentRow = states.currentRow;

  if (data.indexOf(oldCurrentRow) === -1) {
    states.currentRow = null;

    if (states.currentRow !== oldCurrentRow) {
      table.$emit('current-change', null, oldCurrentRow);
    }
  }
};

TableStore.prototype.commit = function (name) {
  var mutations = this.mutations;
  if (mutations[name]) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    mutations[name].apply(this, [this.states].concat(args));
  } else {
    throw new Error('Action not found: ' + name);
  }
};

exports.default = TableStore;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _scrollbarWidth = __webpack_require__(34);

var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TableLayout = function () {
  function TableLayout(options) {
    _classCallCheck(this, TableLayout);

    this.table = null;
    this.store = null;
    this.columns = null;
    this.fit = true;
    this.showHeader = true;

    this.height = null;
    this.scrollX = false;
    this.scrollY = false;
    this.bodyWidth = null;
    this.fixedWidth = null;
    this.rightFixedWidth = null;
    this.tableHeight = null;
    this.headerHeight = 44; // Table Header Height
    this.appendHeight = 0; // Append Slot Height
    this.footerHeight = 44; // Table Footer Height
    this.viewportHeight = null; // Table Height - Scroll Bar Height
    this.bodyHeight = null; // Table Height - Table Header Height
    this.fixedBodyHeight = null; // Table Height - Table Header Height - Scroll Bar Height
    this.gutterWidth = (0, _scrollbarWidth2.default)();

    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      }
    }

    if (!this.table) {
      throw new Error('table is required for Table Layout');
    }
    if (!this.store) {
      throw new Error('store is required for Table Layout');
    }
  }

  TableLayout.prototype.updateScrollY = function updateScrollY() {
    var height = this.height;
    if (typeof height !== 'string' && typeof height !== 'number') return;
    var bodyWrapper = this.table.bodyWrapper;
    if (this.table.$el && bodyWrapper) {
      var body = bodyWrapper.querySelector('.el-table__body');
      this.scrollY = body.offsetHeight > bodyWrapper.offsetHeight;
    }
  };

  TableLayout.prototype.setHeight = function setHeight(value) {
    var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';

    var el = this.table.$el;
    if (typeof value === 'string' && /^\d+$/.test(value)) {
      value = Number(value);
    }

    this.height = value;

    if (!el) return;
    if (typeof value === 'number') {
      el.style[prop] = value + 'px';

      this.updateHeight();
    } else if (typeof value === 'string') {
      if (value === '') {
        el.style[prop] = '';
      }
      this.updateHeight();
    }
  };

  TableLayout.prototype.setMaxHeight = function setMaxHeight(value) {
    return this.setHeight(value, 'max-height');
  };

  TableLayout.prototype.updateHeight = function updateHeight() {
    var height = this.tableHeight = this.table.$el.clientHeight;
    var noData = !this.table.data || this.table.data.length === 0;
    var _table$$refs = this.table.$refs,
        headerWrapper = _table$$refs.headerWrapper,
        appendWrapper = _table$$refs.appendWrapper,
        footerWrapper = _table$$refs.footerWrapper;

    var footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
    this.appendHeight = appendWrapper ? appendWrapper.offsetHeight : 0;
    if (this.showHeader && !headerWrapper) return;
    if (!this.showHeader) {
      this.headerHeight = 0;
      if (this.height !== null && (!isNaN(this.height) || typeof this.height === 'string')) {
        this.bodyHeight = height - footerHeight + (footerWrapper ? 1 : 0);
      }
      this.fixedBodyHeight = this.scrollX ? height - this.gutterWidth : height;
    } else {
      var headerHeight = this.headerHeight = headerWrapper.offsetHeight;
      var bodyHeight = height - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
      if (this.height !== null && (!isNaN(this.height) || typeof this.height === 'string')) {
        this.bodyHeight = bodyHeight;
      }
      this.fixedBodyHeight = this.scrollX ? bodyHeight - this.gutterWidth : bodyHeight;
    }
    this.viewportHeight = this.scrollX ? height - (noData ? 0 : this.gutterWidth) : height;
  };

  TableLayout.prototype.update = function update() {
    var fit = this.fit;
    var columns = this.table.columns;
    var bodyWidth = this.table.$el.clientWidth;
    var bodyMinWidth = 0;

    var flattenColumns = [];
    columns.forEach(function (column) {
      if (column.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });

    var flexColumns = flattenColumns.filter(function (column) {
      return typeof column.width !== 'number';
    });

    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach(function (column) {
        bodyMinWidth += column.width || column.minWidth || 80;
      });

      var scrollYWidth = this.scrollY ? this.gutterWidth : 0;

      if (bodyMinWidth <= bodyWidth - scrollYWidth) {
        // DON'T HAVE SCROLL BAR
        this.scrollX = false;

        var totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;

        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          (function () {
            var allColumnsWidth = flexColumns.reduce(function (prev, column) {
              return prev + (column.minWidth || 80);
            }, 0);
            var flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
            var noneFirstWidth = 0;

            flexColumns.forEach(function (column, index) {
              if (index === 0) return;
              var flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
              noneFirstWidth += flexWidth;
              column.realWidth = (column.minWidth || 80) + flexWidth;
            });

            flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
          })();
        }
      } else {
        // HAVE HORIZONTAL SCROLL BAR
        this.scrollX = true;
        flexColumns.forEach(function (column) {
          column.realWidth = column.minWidth;
        });
      }

      this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
    } else {
      flattenColumns.forEach(function (column) {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = column.width || column.minWidth;
        }

        bodyMinWidth += column.realWidth;
      });
      this.scrollX = bodyMinWidth > bodyWidth;

      this.bodyWidth = bodyMinWidth;
    }

    var fixedColumns = this.store.states.fixedColumns;

    if (fixedColumns.length > 0) {
      var fixedWidth = 0;
      fixedColumns.forEach(function (column) {
        fixedWidth += column.realWidth;
      });

      this.fixedWidth = fixedWidth;
    }

    var rightFixedColumns = this.store.states.rightFixedColumns;
    if (rightFixedColumns.length > 0) {
      var rightFixedWidth = 0;
      rightFixedColumns.forEach(function (column) {
        rightFixedWidth += column.realWidth;
      });

      this.rightFixedWidth = rightFixedWidth;
    }
  };

  return TableLayout;
}();

exports.default = TableLayout;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _util = __webpack_require__(25);

var _dom = __webpack_require__(4);

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _tooltip = __webpack_require__(22);

var _tooltip2 = _interopRequireDefault(_tooltip);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    ElCheckbox: _checkbox2.default,
    ElTooltip: _tooltip2.default
  },

  props: {
    store: {
      required: true
    },
    stripe: Boolean,
    context: {},
    layout: {
      required: true
    },
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: String,
    highlight: Boolean
  },

  render: function render(h) {
    var _this = this;

    var columnsHidden = this.columns.map(function (column, index) {
      return _this.isColumnHidden(index);
    });
    return h(
      'table',
      {
        'class': 'el-table__body',
        attrs: { cellspacing: '0',
          cellpadding: '0',
          border: '0' }
      },
      [h(
        'colgroup',
        null,
        [this._l(this.columns, function (column) {
          return h(
            'col',
            {
              attrs: {
                name: column.id,
                width: column.realWidth || column.width
              }
            },
            []
          );
        })]
      ), h(
        'tbody',
        null,
        [this._l(this.data, function (row, $index) {
          return [h(
            'tr',
            {
              style: _this.rowStyle ? _this.getRowStyle(row, $index) : null,
              key: _this.table.rowKey ? _this.getKeyOfRow(row, $index) : $index,
              on: {
                'dblclick': function dblclick($event) {
                  return _this.handleDoubleClick($event, row);
                },
                'click': function click($event) {
                  return _this.handleClick($event, row);
                },
                'contextmenu': function contextmenu($event) {
                  return _this.handleContextMenu($event, row);
                },
                'mouseenter': function mouseenter(_) {
                  return _this.handleMouseEnter($index);
                },
                'mouseleave': function mouseleave(_) {
                  return _this.handleMouseLeave();
                }
              },

              'class': [_this.getRowClass(row, $index)] },
            [_this._l(_this.columns, function (column, cellIndex) {
              var _getSpan = _this.getSpan(row, column, $index, cellIndex),
                  rowspan = _getSpan.rowspan,
                  colspan = _getSpan.colspan;

              if (!rowspan || !colspan) {
                return '';
              } else {
                if (rowspan === 1 && colspan === 1) {
                  return h(
                    'td',
                    {
                      style: _this.getCellStyle($index, cellIndex, row, column),
                      'class': _this.getCellClass($index, cellIndex, row, column),
                      on: {
                        'mouseenter': function mouseenter($event) {
                          return _this.handleCellMouseEnter($event, row);
                        },
                        'mouseleave': _this.handleCellMouseLeave
                      }
                    },
                    [column.renderCell.call(_this._renderProxy, h, {
                      row: row,
                      column: column,
                      $index: $index,
                      store: _this.store,
                      _self: _this.context || _this.table.$vnode.context
                    }, columnsHidden[cellIndex])]
                  );
                } else {
                  return h(
                    'td',
                    {
                      style: _this.getCellStyle($index, cellIndex, row, column),
                      'class': _this.getCellClass($index, cellIndex, row, column),
                      attrs: { rowspan: rowspan,
                        colspan: colspan
                      },
                      on: {
                        'mouseenter': function mouseenter($event) {
                          return _this.handleCellMouseEnter($event, row);
                        },
                        'mouseleave': _this.handleCellMouseLeave
                      }
                    },
                    [column.renderCell.call(_this._renderProxy, h, {
                      row: row,
                      column: column,
                      $index: $index,
                      store: _this.store,
                      _self: _this.context || _this.table.$vnode.context
                    }, columnsHidden[cellIndex])]
                  );
                }
              }
            }), !_this.fixed && _this.layout.scrollY && _this.layout.gutterWidth ? h(
              'td',
              { 'class': 'gutter' },
              []
            ) : '']
          ), _this.store.states.expandRows.indexOf(row) > -1 ? h(
            'tr',
            null,
            [h(
              'td',
              {
                attrs: { colspan: _this.columns.length },
                'class': 'el-table__expanded-cell' },
              [_this.table.renderExpanded ? _this.table.renderExpanded(h, { row: row, $index: $index, store: _this.store }) : '']
            )]
          ) : ''];
        }).concat(h(
          'el-tooltip',
          {
            attrs: { effect: this.table.tooltipEffect, placement: 'top', content: this.tooltipContent },
            ref: 'tooltip' },
          []
        ))]
      )]
    );
  },


  watch: {
    'store.states.hoverRow': function storeStatesHoverRow(newVal, oldVal) {
      if (!this.store.states.isComplex) return;
      var el = this.$el;
      if (!el) return;
      var rows = el.querySelectorAll('tbody > tr.el-table__row');
      var oldRow = rows[oldVal];
      var newRow = rows[newVal];
      if (oldRow) {
        (0, _dom.removeClass)(oldRow, 'hover-row');
      }
      if (newRow) {
        (0, _dom.addClass)(newRow, 'hover-row');
      }
    },
    'store.states.currentRow': function storeStatesCurrentRow(newVal, oldVal) {
      if (!this.highlight) return;
      var el = this.$el;
      if (!el) return;
      var data = this.store.states.data;
      var rows = el.querySelectorAll('tbody > tr.el-table__row');
      var oldRow = rows[data.indexOf(oldVal)];
      var newRow = rows[data.indexOf(newVal)];
      if (oldRow) {
        (0, _dom.removeClass)(oldRow, 'current-row');
      } else if (rows) {
        [].forEach.call(rows, function (row) {
          return (0, _dom.removeClass)(row, 'current-row');
        });
      }
      if (newRow) {
        (0, _dom.addClass)(newRow, 'current-row');
      }
    }
  },

  computed: {
    table: function table() {
      return this.$parent;
    },
    data: function data() {
      return this.store.states.data;
    },
    columnsCount: function columnsCount() {
      return this.store.states.columns.length;
    },
    leftFixedLeafCount: function leftFixedLeafCount() {
      return this.store.states.fixedLeafColumnsLength;
    },
    rightFixedLeafCount: function rightFixedLeafCount() {
      return this.store.states.rightFixedLeafColumnsLength;
    },
    leftFixedCount: function leftFixedCount() {
      return this.store.states.fixedColumns.length;
    },
    rightFixedCount: function rightFixedCount() {
      return this.store.states.rightFixedColumns.length;
    },
    columns: function columns() {
      return this.store.states.columns;
    }
  },

  data: function data() {
    return {
      tooltipContent: ''
    };
  },
  created: function created() {
    this.activateTooltip = (0, _debounce2.default)(50, function (tooltip) {
      return tooltip.handleShowPopper();
    });
  },


  methods: {
    getKeyOfRow: function getKeyOfRow(row, index) {
      var rowKey = this.table.rowKey;
      if (rowKey) {
        return (0, _util.getRowIdentity)(row, rowKey);
      }
      return index;
    },
    isColumnHidden: function isColumnHidden(index) {
      if (this.fixed === true || this.fixed === 'left') {
        return index >= this.leftFixedLeafCount;
      } else if (this.fixed === 'right') {
        return index < this.columnsCount - this.rightFixedLeafCount;
      } else {
        return index < this.leftFixedLeafCount || index >= this.columnsCount - this.rightFixedLeafCount;
      }
    },
    getSpan: function getSpan(row, column, rowIndex, columnIndex) {
      var rowspan = 1;
      var colspan = 1;

      var fn = this.table.spanMethod;
      if (typeof fn === 'function') {
        var result = fn({
          row: row,
          column: column,
          rowIndex: rowIndex,
          columnIndex: columnIndex
        });

        if (Array.isArray(result)) {
          rowspan = result[0];
          colspan = result[1];
        } else if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
          rowspan = result.rowspan;
          colspan = result.colspan;
        }
      }

      return {
        rowspan: rowspan,
        colspan: colspan
      };
    },
    getRowStyle: function getRowStyle(row, rowIndex) {
      var rowStyle = this.table.rowStyle;
      if (typeof rowStyle === 'function') {
        return rowStyle.call(null, {
          row: row,
          rowIndex: rowIndex
        });
      }
      return rowStyle;
    },
    getRowClass: function getRowClass(row, rowIndex) {
      var classes = ['el-table__row'];

      if (this.stripe && rowIndex % 2 === 1) {
        classes.push('el-table__row--striped');
      }
      var rowClassName = this.table.rowClassName;
      if (typeof rowClassName === 'string') {
        classes.push(rowClassName);
      } else if (typeof rowClassName === 'function') {
        classes.push(rowClassName.call(null, {
          row: row,
          rowIndex: rowIndex
        }));
      }

      if (this.store.states.expandRows.indexOf(row) > -1) {
        classes.push('expanded');
      }

      return classes.join(' ');
    },
    getCellStyle: function getCellStyle(rowIndex, columnIndex, row, column) {
      var cellStyle = this.table.cellStyle;
      if (typeof cellStyle === 'function') {
        return cellStyle.call(null, {
          rowIndex: rowIndex,
          columnIndex: columnIndex,
          row: row,
          column: column
        });
      }
      return cellStyle;
    },
    getCellClass: function getCellClass(rowIndex, columnIndex, row, column) {
      var classes = [column.id, column.align, column.className];

      if (this.isColumnHidden(columnIndex)) {
        classes.push('is-hidden');
      }

      var cellClassName = this.table.cellClassName;
      if (typeof cellClassName === 'string') {
        classes.push(cellClassName);
      } else if (typeof cellClassName === 'function') {
        classes.push(cellClassName.call(null, {
          rowIndex: rowIndex,
          columnIndex: columnIndex,
          row: row,
          column: column
        }));
      }

      return classes.join(' ');
    },
    handleCellMouseEnter: function handleCellMouseEnter(event, row) {
      var table = this.table;
      var cell = (0, _util.getCell)(event);

      if (cell) {
        var column = (0, _util.getColumnByCell)(table, cell);
        var hoverState = table.hoverState = { cell: cell, column: column, row: row };
        table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
      }

      // 判断是否text-overflow, 如果是就显示tooltip
      var cellChild = event.target.querySelector('.cell');

      if ((0, _dom.hasClass)(cellChild, 'el-tooltip') && cellChild.scrollWidth > cellChild.offsetWidth) {
        var tooltip = this.$refs.tooltip;

        this.tooltipContent = cell.innerText;
        tooltip.referenceElm = cell;
        tooltip.$refs.popper && (tooltip.$refs.popper.style.display = 'none');
        tooltip.doDestroy();
        tooltip.setExpectedState(true);
        this.activateTooltip(tooltip);
      }
    },
    handleCellMouseLeave: function handleCellMouseLeave(event) {
      var tooltip = this.$refs.tooltip;
      if (tooltip) {
        tooltip.setExpectedState(false);
        tooltip.handleClosePopper();
      }
      var cell = (0, _util.getCell)(event);
      if (!cell) return;

      var oldHoverState = this.table.hoverState;
      this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
    },
    handleMouseEnter: function handleMouseEnter(index) {
      this.store.commit('setHoverRow', index);
    },
    handleMouseLeave: function handleMouseLeave() {
      this.store.commit('setHoverRow', null);
    },
    handleContextMenu: function handleContextMenu(event, row) {
      this.handleEvent(event, row, 'contextmenu');
    },
    handleDoubleClick: function handleDoubleClick(event, row) {
      this.handleEvent(event, row, 'dblclick');
    },
    handleClick: function handleClick(event, row) {
      this.store.commit('setCurrentRow', row);
      this.handleEvent(event, row, 'click');
    },
    handleEvent: function handleEvent(event, row, name) {
      var table = this.table;
      var cell = (0, _util.getCell)(event);
      var column = void 0;
      if (cell) {
        column = (0, _util.getColumnByCell)(table, cell);
        if (column) {
          table.$emit('cell-' + name, row, column, cell, event);
        }
      }
      table.$emit('row-' + name, row, event, column);
    },
    handleExpandClick: function handleExpandClick(row) {
      this.store.toggleRowExpansion(row);
    }
  }
};

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _tag = __webpack_require__(23);

var _tag2 = _interopRequireDefault(_tag);

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _filterPanel = __webpack_require__(161);

var _filterPanel2 = _interopRequireDefault(_filterPanel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getAllColumns = function getAllColumns(columns) {
  var result = [];
  columns.forEach(function (column) {
    if (column.children) {
      result.push(column);
      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};

var convertToRows = function convertToRows(originColumns) {
  var maxLevel = 1;
  var traverse = function traverse(column, parent) {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children) {
      var colSpan = 0;
      column.children.forEach(function (subColumn) {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };

  originColumns.forEach(function (column) {
    column.level = 1;
    traverse(column);
  });

  var rows = [];
  for (var i = 0; i < maxLevel; i++) {
    rows.push([]);
  }

  var allColumns = getAllColumns(originColumns);

  allColumns.forEach(function (column) {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }
    rows[column.level - 1].push(column);
  });

  return rows;
};

exports.default = {
  name: 'ElTableHeader',

  render: function render(h) {
    var _this = this;

    var originColumns = this.store.states.originColumns;
    var columnRows = convertToRows(originColumns, this.columns);
    // 是否拥有多级表头
    var isGroup = columnRows.length > 1;
    if (isGroup) this.$parent.isGroup = true;

    return h(
      'table',
      {
        'class': 'el-table__header',
        attrs: { cellspacing: '0',
          cellpadding: '0',
          border: '0' }
      },
      [h(
        'colgroup',
        null,
        [this._l(this.columns, function (column) {
          return h(
            'col',
            {
              attrs: {
                name: column.id,
                width: column.realWidth || column.width
              }
            },
            []
          );
        }), !this.fixed && this.layout.gutterWidth ? h(
          'col',
          {
            attrs: { name: 'gutter', width: this.layout.scrollY ? this.layout.gutterWidth : '' }
          },
          []
        ) : '']
      ), h(
        'thead',
        { 'class': [{ 'is-group': isGroup, 'has-gutter': this.hasGutter }] },
        [this._l(columnRows, function (columns, rowIndex) {
          return h(
            'tr',
            {
              style: _this.getHeaderRowStyle(rowIndex),
              'class': _this.getHeaderRowClass(rowIndex)
            },
            [_this._l(columns, function (column, cellIndex) {
              return h(
                'th',
                {
                  attrs: {
                    colspan: column.colSpan,
                    rowspan: column.rowSpan
                  },
                  on: {
                    'mousemove': function mousemove($event) {
                      return _this.handleMouseMove($event, column);
                    },
                    'mouseout': _this.handleMouseOut,
                    'mousedown': function mousedown($event) {
                      return _this.handleMouseDown($event, column);
                    },
                    'click': function click($event) {
                      return _this.handleHeaderClick($event, column);
                    }
                  },

                  style: _this.getHeaderCellStyle(rowIndex, cellIndex, columns, column),
                  'class': _this.getHeaderCellClass(rowIndex, cellIndex, columns, column) },
                [h(
                  'div',
                  { 'class': ['cell', column.filteredValue && column.filteredValue.length > 0 ? 'highlight' : '', column.labelClassName] },
                  [column.renderHeader ? column.renderHeader.call(_this._renderProxy, h, { column: column, $index: cellIndex, store: _this.store, _self: _this.$parent.$vnode.context }) : column.label, column.sortable ? h(
                    'span',
                    { 'class': 'caret-wrapper', on: {
                        'click': function click($event) {
                          return _this.handleSortClick($event, column);
                        }
                      }
                    },
                    [h(
                      'span',
                      { 'class': 'sort-caret ascending', on: {
                          'click': function click($event) {
                            return _this.handleSortClick($event, column, 'ascending');
                          }
                        }
                      },
                      [h(
                        'i',
                        { 'class': 'el-icon-sort-up' },
                        []
                      )]
                    ), h(
                      'span',
                      { 'class': 'sort-caret descending', on: {
                          'click': function click($event) {
                            return _this.handleSortClick($event, column, 'descending');
                          }
                        }
                      },
                      [h(
                        'i',
                        { 'class': 'el-icon-sort-down' },
                        []
                      )]
                    )]
                  ) : '', column.filterable ? h(
                    'span',
                    { 'class': 'el-table__column-filter-trigger', on: {
                        'click': function click($event) {
                          return _this.handleFilterClick($event, column);
                        }
                      }
                    },
                    [h(
                      'i',
                      { 'class': ['el-icon-arrow-down', column.filterOpened ? 'el-icon-arrow-up' : ''] },
                      []
                    )]
                  ) : '']
                )]
              );
            }), _this.hasGutter ? h(
              'th',
              { 'class': 'gutter', style: { width: _this.layout.scrollY ? _this.layout.gutterWidth + 'px' : '0' } },
              []
            ) : '']
          );
        })]
      )]
    );
  },


  props: {
    fixed: String,
    store: {
      required: true
    },
    layout: {
      required: true
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: function _default() {
        return {
          prop: '',
          order: ''
        };
      }
    }
  },

  components: {
    ElCheckbox: _checkbox2.default,
    ElTag: _tag2.default
  },

  computed: {
    table: function table() {
      return this.$parent;
    },
    isAllSelected: function isAllSelected() {
      return this.store.states.isAllSelected;
    },
    columnsCount: function columnsCount() {
      return this.store.states.columns.length;
    },
    leftFixedCount: function leftFixedCount() {
      return this.store.states.fixedColumns.length;
    },
    rightFixedCount: function rightFixedCount() {
      return this.store.states.rightFixedColumns.length;
    },
    leftFixedLeafCount: function leftFixedLeafCount() {
      return this.store.states.fixedLeafColumnsLength;
    },
    rightFixedLeafCount: function rightFixedLeafCount() {
      return this.store.states.rightFixedLeafColumnsLength;
    },
    columns: function columns() {
      return this.store.states.columns;
    },
    hasGutter: function hasGutter() {
      return !this.fixed && this.layout.gutterWidth;
    }
  },

  created: function created() {
    this.filterPanels = {};
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.defaultSort.prop) {
      (function () {
        var states = _this2.store.states;
        states.sortProp = _this2.defaultSort.prop;
        states.sortOrder = _this2.defaultSort.order || 'ascending';
        _this2.$nextTick(function (_) {
          for (var i = 0, length = _this2.columns.length; i < length; i++) {
            var column = _this2.columns[i];
            if (column.property === states.sortProp) {
              column.order = states.sortOrder;
              states.sortingColumn = column;
              break;
            }
          }

          if (states.sortingColumn) {
            _this2.store.commit('changeSortCondition');
          }
        });
      })();
    }
  },
  beforeDestroy: function beforeDestroy() {
    var panels = this.filterPanels;
    for (var prop in panels) {
      if (panels.hasOwnProperty(prop) && panels[prop]) {
        panels[prop].$destroy(true);
      }
    }
  },


  methods: {
    isCellHidden: function isCellHidden(index, columns) {
      var start = 0;
      for (var i = 0; i < index; i++) {
        start += columns[i].colSpan;
      }
      var after = start + columns[index].colSpan - 1;
      if (this.fixed === true || this.fixed === 'left') {
        return after >= this.leftFixedLeafCount;
      } else if (this.fixed === 'right') {
        return start < this.columnsCount - this.rightFixedLeafCount;
      } else {
        return after < this.leftFixedLeafCount || start >= this.columnsCount - this.rightFixedLeafCount;
      }
    },
    getHeaderRowStyle: function getHeaderRowStyle(rowIndex) {
      var headerRowStyle = this.table.headerRowStyle;
      if (typeof headerRowStyle === 'function') {
        return headerRowStyle.call(null, { rowIndex: rowIndex });
      }
      return headerRowStyle;
    },
    getHeaderRowClass: function getHeaderRowClass(rowIndex) {
      var classes = [];

      var headerRowClassName = this.table.headerRowClassName;
      if (typeof headerRowClassName === 'string') {
        classes.push(headerRowClassName);
      } else if (typeof headerRowClassName === 'function') {
        classes.push(headerRowClassName.call(null, { rowIndex: rowIndex }));
      }

      return classes.join(' ');
    },
    getHeaderCellStyle: function getHeaderCellStyle(rowIndex, columnIndex, row, column) {
      var headerCellStyle = this.table.headerCellStyle;
      if (typeof headerCellStyle === 'function') {
        return headerCellStyle.call(null, {
          rowIndex: rowIndex,
          columnIndex: columnIndex,
          row: row,
          column: column
        });
      }
      return headerCellStyle;
    },
    getHeaderCellClass: function getHeaderCellClass(rowIndex, columnIndex, row, column) {
      var classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];

      if (rowIndex === 0 && this.isCellHidden(columnIndex, row)) {
        classes.push('is-hidden');
      }

      if (!column.children) {
        classes.push('is-leaf');
      }

      if (column.sortable) {
        classes.push('is-sortable');
      }

      var headerCellClassName = this.table.headerCellClassName;
      if (typeof headerCellClassName === 'string') {
        classes.push(headerCellClassName);
      } else if (typeof headerCellClassName === 'function') {
        classes.push(headerCellClassName.call(null, {
          rowIndex: rowIndex,
          columnIndex: columnIndex,
          row: row,
          column: column
        }));
      }

      return classes.join(' ');
    },
    toggleAllSelection: function toggleAllSelection() {
      this.store.commit('toggleAllSelection');
    },
    handleFilterClick: function handleFilterClick(event, column) {
      event.stopPropagation();
      var target = event.target;
      var cell = target.parentNode;
      var table = this.$parent;

      var filterPanel = this.filterPanels[column.id];

      if (filterPanel && column.filterOpened) {
        filterPanel.showPopper = false;
        return;
      }

      if (!filterPanel) {
        filterPanel = new _vue2.default(_filterPanel2.default);
        this.filterPanels[column.id] = filterPanel;
        if (column.filterPlacement) {
          filterPanel.placement = column.filterPlacement;
        }
        filterPanel.table = table;
        filterPanel.cell = cell;
        filterPanel.column = column;
        !this.$isServer && filterPanel.$mount(document.createElement('div'));
      }

      setTimeout(function () {
        filterPanel.showPopper = true;
      }, 16);
    },
    handleHeaderClick: function handleHeaderClick(event, column) {
      if (!column.filters && column.sortable) {
        this.handleSortClick(event, column);
      } else if (column.filters && !column.sortable) {
        this.handleFilterClick(event, column);
      }

      this.$parent.$emit('header-click', column, event);
    },
    handleMouseDown: function handleMouseDown(event, column) {
      var _this3 = this;

      if (this.$isServer) return;
      if (column.children && column.children.length > 0) return;
      /* istanbul ignore if */
      if (this.draggingColumn && this.border) {
        (function () {
          _this3.dragging = true;

          _this3.$parent.resizeProxyVisible = true;

          var table = _this3.$parent;
          var tableEl = table.$el;
          var tableLeft = tableEl.getBoundingClientRect().left;
          var columnEl = _this3.$el.querySelector('th.' + column.id);
          var columnRect = columnEl.getBoundingClientRect();
          var minLeft = columnRect.left - tableLeft + 30;

          (0, _dom.addClass)(columnEl, 'noclick');

          _this3.dragState = {
            startMouseLeft: event.clientX,
            startLeft: columnRect.right - tableLeft,
            startColumnLeft: columnRect.left - tableLeft,
            tableLeft: tableLeft
          };

          var resizeProxy = table.$refs.resizeProxy;
          resizeProxy.style.left = _this3.dragState.startLeft + 'px';

          document.onselectstart = function () {
            return false;
          };
          document.ondragstart = function () {
            return false;
          };

          var handleMouseMove = function handleMouseMove(event) {
            var deltaLeft = event.clientX - _this3.dragState.startMouseLeft;
            var proxyLeft = _this3.dragState.startLeft + deltaLeft;

            resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
          };

          var handleMouseUp = function handleMouseUp() {
            if (_this3.dragging) {
              var _dragState = _this3.dragState,
                  startColumnLeft = _dragState.startColumnLeft,
                  startLeft = _dragState.startLeft;

              var finalLeft = parseInt(resizeProxy.style.left, 10);
              var columnWidth = finalLeft - startColumnLeft;
              column.width = column.realWidth = columnWidth;
              table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);

              _this3.store.scheduleLayout();

              document.body.style.cursor = '';
              _this3.dragging = false;
              _this3.draggingColumn = null;
              _this3.dragState = {};

              table.resizeProxyVisible = false;
            }

            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.onselectstart = null;
            document.ondragstart = null;

            setTimeout(function () {
              (0, _dom.removeClass)(columnEl, 'noclick');
            }, 0);
          };

          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        })();
      }
    },
    handleMouseMove: function handleMouseMove(event, column) {
      if (column.children && column.children.length > 0) return;
      var target = event.target;
      while (target && target.tagName !== 'TH') {
        target = target.parentNode;
      }

      if (!column || !column.resizable) return;

      if (!this.dragging && this.border) {
        var rect = target.getBoundingClientRect();

        var bodyStyle = document.body.style;
        if (rect.width > 12 && rect.right - event.pageX < 8) {
          bodyStyle.cursor = 'col-resize';
          if ((0, _dom.hasClass)(target, 'is-sortable')) {
            target.style.cursor = 'col-resize';
          }
          this.draggingColumn = column;
        } else if (!this.dragging) {
          bodyStyle.cursor = '';
          if ((0, _dom.hasClass)(target, 'is-sortable')) {
            target.style.cursor = 'pointer';
          }
          this.draggingColumn = null;
        }
      }
    },
    handleMouseOut: function handleMouseOut() {
      if (this.$isServer) return;
      document.body.style.cursor = '';
    },
    toggleOrder: function toggleOrder(order) {
      return !order ? 'ascending' : order === 'ascending' ? 'descending' : null;
    },
    handleSortClick: function handleSortClick(event, column, givenOrder) {
      event.stopPropagation();
      var order = givenOrder || this.toggleOrder(column.order);

      var target = event.target;
      while (target && target.tagName !== 'TH') {
        target = target.parentNode;
      }

      if (target && target.tagName === 'TH') {
        if ((0, _dom.hasClass)(target, 'noclick')) {
          (0, _dom.removeClass)(target, 'noclick');
          return;
        }
      }

      if (!column.sortable) return;

      var states = this.store.states;
      var sortProp = states.sortProp;
      var sortOrder = void 0;
      var sortingColumn = states.sortingColumn;

      if (sortingColumn !== column) {
        if (sortingColumn) {
          sortingColumn.order = null;
        }
        states.sortingColumn = column;
        sortProp = column.property;
      }

      if (!order) {
        sortOrder = column.order = null;
        states.sortingColumn = null;
        sortProp = null;
      } else {
        sortOrder = column.order = order;
      }

      states.sortProp = sortProp;
      states.sortOrder = sortOrder;

      this.store.commit('changeSortCondition');
    }
  },

  data: function data() {
    return {
      draggingColumn: null,
      dragging: false,
      dragState: {}
    };
  }
};

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_filter_panel_vue__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_filter_panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_filter_panel_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_a82ec7a0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_filter_panel_vue__ = __webpack_require__(164);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_filter_panel_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_a82ec7a0_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_filter_panel_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _popup = __webpack_require__(17);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _dropdown = __webpack_require__(163);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _checkboxGroup = __webpack_require__(35);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElTableFilterPanel',

  mixins: [_vuePopper2.default, _locale2.default],

  directives: {
    Clickoutside: _clickoutside2.default
  },

  components: {
    ElCheckbox: _checkbox2.default,
    ElCheckboxGroup: _checkboxGroup2.default
  },

  props: {
    placement: {
      type: String,
      default: 'bottom-end'
    }
  },

  customRender: function customRender(h) {
    return h(
      'div',
      { 'class': 'el-table-filter' },
      [h(
        'div',
        { 'class': 'el-table-filter__content' },
        []
      ), h(
        'div',
        { 'class': 'el-table-filter__bottom' },
        [h(
          'button',
          {
            on: {
              'click': this.handleConfirm
            }
          },
          [this.t('el.table.confirmFilter')]
        ), h(
          'button',
          {
            on: {
              'click': this.handleReset
            }
          },
          [this.t('el.table.resetFilter')]
        )]
      )]
    );
  },


  methods: {
    isActive: function isActive(filter) {
      return filter.value === this.filterValue;
    },
    handleOutsideClick: function handleOutsideClick() {
      this.showPopper = false;
    },
    handleConfirm: function handleConfirm() {
      this.confirmFilter(this.filteredValue);
      this.handleOutsideClick();
    },
    handleReset: function handleReset() {
      this.filteredValue = [];
      this.confirmFilter(this.filteredValue);
      this.handleOutsideClick();
    },
    handleSelect: function handleSelect(filterValue) {
      this.filterValue = filterValue;

      if (typeof filterValue !== 'undefined' && filterValue !== null) {
        this.confirmFilter(this.filteredValue);
      } else {
        this.confirmFilter([]);
      }

      this.handleOutsideClick();
    },
    confirmFilter: function confirmFilter(filteredValue) {
      this.table.store.commit('filterChange', {
        column: this.column,
        values: filteredValue
      });
    }
  },

  data: function data() {
    return {
      table: null,
      cell: null,
      column: null
    };
  },


  computed: {
    filters: function filters() {
      return this.column && this.column.filters;
    },


    filterValue: {
      get: function get() {
        return (this.column.filteredValue || [])[0];
      },
      set: function set(value) {
        if (this.filteredValue) {
          if (typeof value !== 'undefined' && value !== null) {
            this.filteredValue.splice(0, 1, value);
          } else {
            this.filteredValue.splice(0, 1);
          }
        }
      }
    },

    filteredValue: {
      get: function get() {
        if (this.column) {
          return this.column.filteredValue || [];
        }
        return [];
      },
      set: function set(value) {
        if (this.column) {
          this.column.filteredValue = value;
        }
      }
    },

    multiple: function multiple() {
      if (this.column) {
        return this.column.filterMultiple;
      }
      return true;
    }
  },

  mounted: function mounted() {
    var _this = this;

    this.popperElm = this.$el;
    this.referenceElm = this.cell;
    this.table.bodyWrapper.addEventListener('scroll', function () {
      _this.updatePopper();
    });

    this.$watch('showPopper', function (value) {
      if (_this.column) _this.column.filterOpened = value;
      if (value) {
        _dropdown2.default.open(_this);
      } else {
        _dropdown2.default.close(_this);
      }
    });
  },

  watch: {
    showPopper: function showPopper(val) {
      if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < _popup.PopupManager.zIndex) {
        this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
      }
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dropdowns = [];

!_vue2.default.prototype.$isServer && document.addEventListener('click', function (event) {
  dropdowns.forEach(function (dropdown) {
    var target = event.target;
    if (!dropdown || !dropdown.$el) return;
    if (target === dropdown.$el || dropdown.$el.contains(target)) {
      return;
    }
    dropdown.handleOutsideClick && dropdown.handleOutsideClick(event);
  });
});

exports.default = {
  open: function open(instance) {
    if (instance) {
      dropdowns.push(instance);
    }
  },
  close: function close(instance) {
    var index = dropdowns.indexOf(instance);
    if (index !== -1) {
      dropdowns.splice(instance, 1);
    }
  }
};

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"}},[(_vm.multiple)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-table-filter"},[_c('div',{staticClass:"el-table-filter__content"},[_c('el-checkbox-group',{staticClass:"el-table-filter__checkbox-group",model:{value:(_vm.filteredValue),callback:function ($$v) {_vm.filteredValue=$$v},expression:"filteredValue"}},_vm._l((_vm.filters),function(filter){return _c('el-checkbox',{key:filter.value,attrs:{"label":filter.value}},[_vm._v(_vm._s(filter.text))])}))],1),_c('div',{staticClass:"el-table-filter__bottom"},[_c('button',{class:{ 'is-disabled': _vm.filteredValue.length === 0 },attrs:{"disabled":_vm.filteredValue.length === 0},on:{"click":_vm.handleConfirm}},[_vm._v(_vm._s(_vm.t('el.table.confirmFilter')))]),_c('button',{on:{"click":_vm.handleReset}},[_vm._v(_vm._s(_vm.t('el.table.resetFilter')))])])]):_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-table-filter"},[_c('ul',{staticClass:"el-table-filter__list"},[_c('li',{staticClass:"el-table-filter__list-item",class:{ 'is-active': _vm.filterValue === undefined || _vm.filterValue === null },on:{"click":function($event){_vm.handleSelect(null)}}},[_vm._v(_vm._s(_vm.t('el.table.clearFilter')))]),_vm._l((_vm.filters),function(filter){return _c('li',{key:filter.value,staticClass:"el-table-filter__list-item",class:{ 'is-active': _vm.isActive(filter) },attrs:{"label":filter.value},on:{"click":function($event){_vm.handleSelect(filter.value)}}},[_vm._v(_vm._s(filter.text))])})],2)])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  name: 'ElTableFooter',

  render: function render(h) {
    var _this = this;

    var sums = [];
    this.columns.forEach(function (column, index) {
      if (index === 0) {
        sums[index] = _this.sumText;
        return;
      }
      var values = _this.store.states.data.map(function (item) {
        return Number(item[column.property]);
      });
      var precisions = [];
      var notNumber = true;
      values.forEach(function (value) {
        if (!isNaN(value)) {
          notNumber = false;
          var decimal = ('' + value).split('.')[1];
          precisions.push(decimal ? decimal.length : 0);
        }
      });
      var precision = Math.max.apply(null, precisions);
      if (!notNumber) {
        sums[index] = values.reduce(function (prev, curr) {
          var value = Number(curr);
          if (!isNaN(value)) {
            return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
          } else {
            return prev;
          }
        }, 0);
      } else {
        sums[index] = '';
      }
    });

    return h(
      'table',
      {
        'class': 'el-table__footer',
        attrs: { cellspacing: '0',
          cellpadding: '0',
          border: '0' }
      },
      [h(
        'colgroup',
        null,
        [this._l(this.columns, function (column) {
          return h(
            'col',
            {
              attrs: {
                name: column.id,
                width: column.realWidth || column.width
              }
            },
            []
          );
        }), !this.fixed && this.layout.gutterWidth ? h(
          'col',
          {
            attrs: { name: 'gutter', width: this.layout.scrollY ? this.layout.gutterWidth : '' }
          },
          []
        ) : '']
      ), h(
        'tbody',
        { 'class': [{ 'has-gutter': this.hasGutter }] },
        [h(
          'tr',
          null,
          [this._l(this.columns, function (column, cellIndex) {
            return h(
              'td',
              {
                attrs: {
                  colspan: column.colSpan,
                  rowspan: column.rowSpan
                },
                'class': [column.id, column.headerAlign, column.className || '', _this.isCellHidden(cellIndex, _this.columns) ? 'is-hidden' : '', !column.children ? 'is-leaf' : '', column.labelClassName] },
              [h(
                'div',
                { 'class': ['cell', column.labelClassName] },
                [_this.summaryMethod ? _this.summaryMethod({ columns: _this.columns, data: _this.store.states.data })[cellIndex] : sums[cellIndex]]
              )]
            );
          }), this.hasGutter ? h(
            'td',
            { 'class': 'gutter', style: { width: this.layout.scrollY ? this.layout.gutterWidth + 'px' : '0' } },
            []
          ) : '']
        )]
      )]
    );
  },


  props: {
    fixed: String,
    store: {
      required: true
    },
    layout: {
      required: true
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: function _default() {
        return {
          prop: '',
          order: ''
        };
      }
    }
  },

  computed: {
    isAllSelected: function isAllSelected() {
      return this.store.states.isAllSelected;
    },
    columnsCount: function columnsCount() {
      return this.store.states.columns.length;
    },
    leftFixedCount: function leftFixedCount() {
      return this.store.states.fixedColumns.length;
    },
    rightFixedCount: function rightFixedCount() {
      return this.store.states.rightFixedColumns.length;
    },
    columns: function columns() {
      return this.store.states.columns;
    },
    hasGutter: function hasGutter() {
      return !this.fixed && this.layout.gutterWidth;
    }
  },

  methods: {
    isCellHidden: function isCellHidden(index, columns) {
      if (this.fixed === true || this.fixed === 'left') {
        return index >= this.leftFixedCount;
      } else if (this.fixed === 'right') {
        var before = 0;
        for (var i = 0; i < index; i++) {
          before += columns[i].colSpan;
        }
        return before < this.columnsCount - this.rightFixedCount;
      } else {
        return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
      }
    }
  }
};

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-table",class:[{
    'el-table--fit': _vm.fit,
    'el-table--striped': _vm.stripe,
    'el-table--border': _vm.border || _vm.isGroup,
    'el-table--hidden': _vm.isHidden,
    'el-table--group': _vm.isGroup,
    'el-table--fluid-height': _vm.maxHeight,
    'el-table--enable-row-hover': !_vm.store.states.isComplex,
    'el-table--enable-row-transition': (_vm.store.states.data || []).length !== 0 && (_vm.store.states.data || []).length < 100
  }, _vm.tableSize ? ("el-table--" + _vm.tableSize) : ''],on:{"mouseleave":function($event){_vm.handleMouseLeave($event)}}},[_c('div',{ref:"hiddenColumns",staticClass:"hidden-columns"},[_vm._t("default")],2),(_vm.showHeader)?_c('div',{ref:"headerWrapper",staticClass:"el-table__header-wrapper"},[_c('table-header',{ref:"tableHeader",style:({ width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : '' }),attrs:{"store":_vm.store,"layout":_vm.layout,"border":_vm.border,"default-sort":_vm.defaultSort}})],1):_vm._e(),_c('div',{ref:"bodyWrapper",staticClass:"el-table__body-wrapper",class:[("is-scroll-" + _vm.scrollPosition)],style:([_vm.bodyHeight])},[_c('table-body',{style:({ width: _vm.bodyWidth }),attrs:{"context":_vm.context,"store":_vm.store,"stripe":_vm.stripe,"layout":_vm.layout,"row-class-name":_vm.rowClassName,"row-style":_vm.rowStyle,"highlight":_vm.highlightCurrentRow}}),(!_vm.data || _vm.data.length === 0)?_c('div',{staticClass:"el-table__empty-block",style:({ width: _vm.bodyWidth })},[_c('span',{staticClass:"el-table__empty-text"},[_vm._t("empty",[_vm._v(_vm._s(_vm.emptyText || _vm.t('el.table.emptyText')))])],2)]):_vm._e(),(_vm.$slots.append)?_c('div',{ref:"appendWrapper",staticClass:"el-table__append-wrapper"},[_vm._t("append")],2):_vm._e()],1),(_vm.showSummary)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.data && _vm.data.length > 0),expression:"data && data.length > 0"}],ref:"footerWrapper",staticClass:"el-table__footer-wrapper"},[_c('table-footer',{style:({ width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : '' }),attrs:{"store":_vm.store,"layout":_vm.layout,"border":_vm.border,"sum-text":_vm.sumText || _vm.t('el.table.sumText'),"summary-method":_vm.summaryMethod,"default-sort":_vm.defaultSort}})],1):_vm._e(),(_vm.fixedColumns.length > 0)?_c('div',{ref:"fixedWrapper",staticClass:"el-table__fixed",style:([
      { width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : '' },
      _vm.fixedHeight
    ])},[(_vm.showHeader)?_c('div',{ref:"fixedHeaderWrapper",staticClass:"el-table__fixed-header-wrapper"},[_c('table-header',{ref:"fixedTableHeader",style:({ width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : '' }),attrs:{"fixed":"left","border":_vm.border,"store":_vm.store,"layout":_vm.layout}})],1):_vm._e(),_c('div',{ref:"fixedBodyWrapper",staticClass:"el-table__fixed-body-wrapper",style:([
        { top: _vm.layout.headerHeight + 'px' },
        _vm.fixedBodyHeight
      ])},[_c('table-body',{style:({ width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : '' }),attrs:{"fixed":"left","store":_vm.store,"stripe":_vm.stripe,"layout":_vm.layout,"highlight":_vm.highlightCurrentRow,"row-class-name":_vm.rowClassName,"row-style":_vm.rowStyle}}),(_vm.$slots.append)?_c('div',{staticClass:"el-table__append-gutter",style:({ height: _vm.layout.appendHeight + 'px' })}):_vm._e()],1),(_vm.showSummary)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.data && _vm.data.length > 0),expression:"data && data.length > 0"}],ref:"fixedFooterWrapper",staticClass:"el-table__fixed-footer-wrapper"},[_c('table-footer',{style:({ width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : '' }),attrs:{"fixed":"left","border":_vm.border,"sum-text":_vm.sumText || _vm.t('el.table.sumText'),"summary-method":_vm.summaryMethod,"store":_vm.store,"layout":_vm.layout}})],1):_vm._e()]):_vm._e(),(_vm.rightFixedColumns.length > 0)?_c('div',{ref:"rightFixedWrapper",staticClass:"el-table__fixed-right",style:([
      { width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : '' },
      { right: _vm.layout.scrollY ? (_vm.border ? _vm.layout.gutterWidth : (_vm.layout.gutterWidth || 0)) + 'px' : '' },
      _vm.fixedHeight
    ])},[(_vm.showHeader)?_c('div',{ref:"rightFixedHeaderWrapper",staticClass:"el-table__fixed-header-wrapper"},[_c('table-header',{ref:"rightFixedTableHeader",style:({ width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : '' }),attrs:{"fixed":"right","border":_vm.border,"store":_vm.store,"layout":_vm.layout}})],1):_vm._e(),_c('div',{ref:"rightFixedBodyWrapper",staticClass:"el-table__fixed-body-wrapper",style:([
        { top: _vm.layout.headerHeight + 'px' },
        _vm.fixedBodyHeight
      ])},[_c('table-body',{style:({ width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : '' }),attrs:{"fixed":"right","store":_vm.store,"stripe":_vm.stripe,"layout":_vm.layout,"row-class-name":_vm.rowClassName,"row-style":_vm.rowStyle,"highlight":_vm.highlightCurrentRow}})],1),(_vm.showSummary)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.data && _vm.data.length > 0),expression:"data && data.length > 0"}],ref:"rightFixedFooterWrapper",staticClass:"el-table__fixed-footer-wrapper"},[_c('table-footer',{style:({ width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : '' }),attrs:{"fixed":"right","border":_vm.border,"sum-text":_vm.sumText || _vm.t('el.table.sumText'),"summary-method":_vm.summaryMethod,"store":_vm.store,"layout":_vm.layout}})],1):_vm._e()]):_vm._e(),(_vm.rightFixedColumns.length > 0)?_c('div',{staticClass:"el-table__fixed-right-patch",style:({ width: _vm.layout.scrollY ? _vm.layout.gutterWidth + 'px' : '0', height: _vm.layout.headerHeight + 'px' })}):_vm._e(),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.resizeProxyVisible),expression:"resizeProxyVisible"}],ref:"resizeProxy",staticClass:"el-table__column-resize-proxy"})])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tableColumn = __webpack_require__(168);

var _tableColumn2 = _interopRequireDefault(_tableColumn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_tableColumn2.default.install = function (Vue) {
  Vue.component(_tableColumn2.default.name, _tableColumn2.default);
};

exports.default = _tableColumn2.default;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _tag = __webpack_require__(23);

var _tag2 = _interopRequireDefault(_tag);

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }

var columnIdSeed = 1;

var defaults = {
  default: {
    order: ''
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: '',
    className: 'el-table-column--selection'
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ''
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ''
  }
};

var forced = {
  selection: {
    renderHeader: function renderHeader(h) {
      return h(
        'el-checkbox',
        {
          nativeOn: {
            'click': this.toggleAllSelection
          },
          attrs: {
            value: this.isAllSelected }
        },
        []
      );
    },
    renderCell: function renderCell(h, _ref) {
      var row = _ref.row,
          column = _ref.column,
          store = _ref.store,
          $index = _ref.$index;

      return h(
        'el-checkbox',
        {
          attrs: {
            value: store.isSelected(row),
            disabled: column.selectable ? !column.selectable.call(null, row, $index) : false
          },
          on: {
            'input': function input() {
              store.commit('rowSelectedChanged', row);
            }
          }
        },
        []
      );
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader: function renderHeader(h, _ref2) {
      var column = _ref2.column;

      return column.label || '#';
    },
    renderCell: function renderCell(h, _ref3) {
      var $index = _ref3.$index,
          column = _ref3.column;

      var i = $index + 1;
      var index = column.index;

      if (typeof index === 'number') {
        i = $index + index;
      } else if (typeof index === 'function') {
        i = index($index);
      }

      return h(
        'div',
        null,
        [i]
      );
    },
    sortable: false
  },
  expand: {
    renderHeader: function renderHeader(h, _ref4) {
      _objectDestructuringEmpty(_ref4);

      return '';
    },
    renderCell: function renderCell(h, _ref5, proxy) {
      var row = _ref5.row,
          store = _ref5.store;

      var expanded = store.states.expandRows.indexOf(row) > -1;
      return h(
        'div',
        { 'class': 'el-table__expand-icon ' + (expanded ? 'el-table__expand-icon--expanded' : ''),
          on: {
            'click': function click() {
              return proxy.handleExpandClick(row);
            }
          }
        },
        [h(
          'i',
          { 'class': 'el-icon el-icon-arrow-right' },
          []
        )]
      );
    },
    sortable: false,
    resizable: false,
    className: 'el-table__expand-column'
  }
};

var getDefaultColumn = function getDefaultColumn(type, options) {
  var column = {};

  (0, _merge2.default)(column, defaults[type || 'default']);

  for (var name in options) {
    if (options.hasOwnProperty(name)) {
      var value = options[name];
      if (typeof value !== 'undefined') {
        column[name] = value;
      }
    }
  }

  if (!column.minWidth) {
    column.minWidth = 80;
  }

  column.realWidth = column.width || column.minWidth;

  return column;
};

var DEFAULT_RENDER_CELL = function DEFAULT_RENDER_CELL(h, _ref6) {
  var row = _ref6.row,
      column = _ref6.column;

  var property = column.property;
  var value = property && (0, _util.getPropByPath)(row, property).v;
  if (column && column.formatter) {
    return column.formatter(row, column, value);
  }
  return value;
};

exports.default = {
  name: 'ElTableColumn',

  props: {
    type: {
      type: String,
      default: 'default'
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {},
    minWidth: {},
    renderHeader: Function,
    sortable: {
      type: [String, Boolean],
      default: false
    },
    sortMethod: Function,
    sortBy: [String, Function, Array],
    resizable: {
      type: Boolean,
      default: true
    },
    context: {},
    columnKey: String,
    align: String,
    headerAlign: String,
    showTooltipWhenOverflow: Boolean,
    showOverflowTooltip: Boolean,
    fixed: [Boolean, String],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
      type: Boolean,
      default: true
    },
    index: [Number, Function]
  },

  data: function data() {
    return {
      isSubColumn: false,
      columns: []
    };
  },
  beforeCreate: function beforeCreate() {
    this.row = {};
    this.column = {};
    this.$index = 0;
  },


  components: {
    ElCheckbox: _checkbox2.default,
    ElTag: _tag2.default
  },

  computed: {
    owner: function owner() {
      var parent = this.$parent;
      while (parent && !parent.tableId) {
        parent = parent.$parent;
      }
      return parent;
    }
  },

  created: function created() {
    var _this = this;

    this.customRender = this.$options.render;
    this.$options.render = function (h) {
      return h('div', _this.$slots.default);
    };
    this.columnId = (this.$parent.tableId || this.$parent.columnId + '_') + 'column_' + columnIdSeed++;

    var parent = this.$parent;
    var owner = this.owner;
    this.isSubColumn = owner !== parent;

    var type = this.type;

    var width = this.width;
    if (width !== undefined) {
      width = parseInt(width, 10);
      if (isNaN(width)) {
        width = null;
      }
    }

    var minWidth = this.minWidth;
    if (minWidth !== undefined) {
      minWidth = parseInt(minWidth, 10);
      if (isNaN(minWidth)) {
        minWidth = 80;
      }
    }

    var isColumnGroup = false;

    var column = getDefaultColumn(type, {
      id: this.columnId,
      columnKey: this.columnKey,
      label: this.label,
      className: this.className,
      labelClassName: this.labelClassName,
      property: this.prop || this.property,
      type: type,
      renderCell: null,
      renderHeader: this.renderHeader,
      minWidth: minWidth,
      width: width,
      isColumnGroup: isColumnGroup,
      context: this.context,
      align: this.align ? 'is-' + this.align : null,
      headerAlign: this.headerAlign ? 'is-' + this.headerAlign : this.align ? 'is-' + this.align : null,
      sortable: this.sortable === '' ? true : this.sortable,
      sortMethod: this.sortMethod,
      sortBy: this.sortBy,
      resizable: this.resizable,
      showOverflowTooltip: this.showOverflowTooltip || this.showTooltipWhenOverflow,
      formatter: this.formatter,
      selectable: this.selectable,
      reserveSelection: this.reserveSelection,
      fixed: this.fixed === '' ? true : this.fixed,
      filterMethod: this.filterMethod,
      filters: this.filters,
      filterable: this.filters || this.filterMethod,
      filterMultiple: this.filterMultiple,
      filterOpened: false,
      filteredValue: this.filteredValue || [],
      filterPlacement: this.filterPlacement || '',
      index: this.index
    });

    (0, _merge2.default)(column, forced[type] || {});

    this.columnConfig = column;

    var renderCell = column.renderCell;
    var _self = this;

    if (type === 'expand') {
      owner.renderExpanded = function (h, data) {
        return _self.$scopedSlots.default ? _self.$scopedSlots.default(data) : _self.$slots.default;
      };

      column.renderCell = function (h, data) {
        return h(
          'div',
          { 'class': 'cell' },
          [renderCell(h, data, this._renderProxy)]
        );
      };

      return;
    }

    column.renderCell = function (h, data) {
      if (_self.$scopedSlots.default) {
        renderCell = function renderCell() {
          return _self.$scopedSlots.default(data);
        };
      }

      if (!renderCell) {
        renderCell = DEFAULT_RENDER_CELL;
      }

      return _self.showOverflowTooltip || _self.showTooltipWhenOverflow ? h(
        'div',
        { 'class': 'cell el-tooltip', style: 'width:' + (data.column.realWidth || data.column.width) + 'px' },
        [renderCell(h, data)]
      ) : h(
        'div',
        { 'class': 'cell' },
        [renderCell(h, data)]
      );
    };
  },
  destroyed: function destroyed() {
    if (!this.$parent) return;
    this.owner.store.commit('removeColumn', this.columnConfig);
  },


  watch: {
    label: function label(newVal) {
      if (this.columnConfig) {
        this.columnConfig.label = newVal;
      }
    },
    prop: function prop(newVal) {
      if (this.columnConfig) {
        this.columnConfig.property = newVal;
      }
    },
    property: function property(newVal) {
      if (this.columnConfig) {
        this.columnConfig.property = newVal;
      }
    },
    filters: function filters(newVal) {
      if (this.columnConfig) {
        this.columnConfig.filters = newVal;
      }
    },
    filterMultiple: function filterMultiple(newVal) {
      if (this.columnConfig) {
        this.columnConfig.filterMultiple = newVal;
      }
    },
    align: function align(newVal) {
      if (this.columnConfig) {
        this.columnConfig.align = newVal ? 'is-' + newVal : null;

        if (!this.headerAlign) {
          this.columnConfig.headerAlign = newVal ? 'is-' + newVal : null;
        }
      }
    },
    headerAlign: function headerAlign(newVal) {
      if (this.columnConfig) {
        this.columnConfig.headerAlign = 'is-' + (newVal ? newVal : this.align);
      }
    },
    width: function width(newVal) {
      if (this.columnConfig) {
        this.columnConfig.width = newVal;
        this.owner.store.scheduleLayout();
      }
    },
    minWidth: function minWidth(newVal) {
      if (this.columnConfig) {
        this.columnConfig.minWidth = newVal;
        this.owner.store.scheduleLayout();
      }
    },
    fixed: function fixed(newVal) {
      if (this.columnConfig) {
        this.columnConfig.fixed = newVal;
        this.owner.store.scheduleLayout();
      }
    },
    sortable: function sortable(newVal) {
      if (this.columnConfig) {
        this.columnConfig.sortable = newVal;
      }
    },
    index: function index(newVal) {
      if (this.columnConfig) {
        this.columnConfig.index = newVal;
      }
    }
  },

  mounted: function mounted() {
    var owner = this.owner;
    var parent = this.$parent;
    var columnIndex = void 0;

    if (!this.isSubColumn) {
      columnIndex = [].indexOf.call(parent.$refs.hiddenColumns.children, this.$el);
    } else {
      columnIndex = [].indexOf.call(parent.$el.children, this.$el);
    }

    owner.store.commit('insertColumn', this.columnConfig, columnIndex, this.isSubColumn ? parent.columnConfig : null);
  }
};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _datePicker = __webpack_require__(170);

var _datePicker2 = _interopRequireDefault(_datePicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_datePicker2.default.install = function install(Vue) {
  Vue.component(_datePicker2.default.name, _datePicker2.default);
};

exports.default = _datePicker2.default;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _picker = __webpack_require__(26);

var _picker2 = _interopRequireDefault(_picker);

var _date = __webpack_require__(174);

var _date2 = _interopRequireDefault(_date);

var _dateRange = __webpack_require__(189);

var _dateRange2 = _interopRequireDefault(_dateRange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getPanel = function getPanel(type) {
  if (type === 'daterange' || type === 'datetimerange') {
    return _dateRange2.default;
  }
  return _date2.default;
};

exports.default = {
  mixins: [_picker2.default],

  name: 'ElDatePicker',

  props: {
    type: {
      type: String,
      default: 'date'
    },
    timeArrowControl: Boolean
  },

  watch: {
    type: function type(_type) {
      if (this.picker) {
        this.unmountPicker();
        this.panel = getPanel(_type);
        this.mountPicker();
      } else {
        this.panel = getPanel(_type);
      }
    }
  },

  created: function created() {
    this.panel = getPanel(this.type);
  }
};

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _util = __webpack_require__(9);

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _focus = __webpack_require__(14);

var _focus2 = _interopRequireDefault(_focus);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var NewPopper = {
  props: {
    appendToBody: _vuePopper2.default.props.appendToBody,
    offset: _vuePopper2.default.props.offset,
    boundariesPadding: _vuePopper2.default.props.boundariesPadding
  },
  methods: _vuePopper2.default.methods,
  data: function data() {
    return (0, _merge2.default)({ visibleArrow: true }, _vuePopper2.default.data);
  },

  beforeDestroy: _vuePopper2.default.beforeDestroy
};

var DEFAULT_FORMATS = {
  date: 'yyyy-MM-dd',
  month: 'yyyy-MM',
  datetime: 'yyyy-MM-dd HH:mm:ss',
  time: 'HH:mm:ss',
  week: 'yyyywWW',
  timerange: 'HH:mm:ss',
  daterange: 'yyyy-MM-dd',
  datetimerange: 'yyyy-MM-dd HH:mm:ss',
  year: 'yyyy'
};
var HAVE_TRIGGER_TYPES = ['date', 'datetime', 'time', 'time-select', 'week', 'month', 'year', 'daterange', 'timerange', 'datetimerange'];
var DATE_FORMATTER = function DATE_FORMATTER(value, format) {
  return (0, _util.formatDate)(value, format);
};
var DATE_PARSER = function DATE_PARSER(text, format) {
  return (0, _util.parseDate)(text, format);
};
var RANGE_FORMATTER = function RANGE_FORMATTER(value, format) {
  if (Array.isArray(value) && value.length === 2) {
    var start = value[0];
    var end = value[1];

    if (start && end) {
      return [(0, _util.formatDate)(start, format), (0, _util.formatDate)(end, format)];
    }
  }
  return '';
};
var RANGE_PARSER = function RANGE_PARSER(array, format, separator) {
  if (!Array.isArray(array)) {
    array = array.split(separator);
  }
  if (array.length === 2) {
    var range1 = array[0];
    var range2 = array[1];

    return [(0, _util.parseDate)(range1, format), (0, _util.parseDate)(range2, format)];
  }
  return [];
};
var TYPE_VALUE_RESOLVER_MAP = {
  default: {
    formatter: function formatter(value) {
      if (!value) return '';
      return '' + value;
    },
    parser: function parser(text) {
      if (text === undefined || text === '') return null;
      return text;
    }
  },
  week: {
    formatter: function formatter(value, format) {
      var week = (0, _util.getWeekNumber)(value);
      var month = value.getMonth();
      var trueDate = new Date(value);
      if (week === 1 && month === 11) {
        trueDate.setHours(0, 0, 0, 0);
        trueDate.setDate(trueDate.getDate() + 3 - (trueDate.getDay() + 6) % 7);
      }
      var date = (0, _util.formatDate)(trueDate, format);

      date = /WW/.test(date) ? date.replace(/WW/, week < 10 ? '0' + week : week) : date.replace(/W/, week);
      return date;
    },
    parser: function parser(text) {
      var array = (text || '').split('w');
      if (array.length === 2) {
        var year = Number(array[0]);
        var month = Number(array[1]);

        if (!isNaN(year) && !isNaN(month) && month < 54) {
          return text;
        }
      }
      return null;
    }
  },
  date: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  datetime: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  daterange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  datetimerange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  timerange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  time: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  month: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  year: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  number: {
    formatter: function formatter(value) {
      if (!value) return '';
      return '' + value;
    },
    parser: function parser(text) {
      var result = Number(text);

      if (!isNaN(text)) {
        return result;
      } else {
        return null;
      }
    }
  }
};
var PLACEMENT_MAP = {
  left: 'bottom-start',
  center: 'bottom',
  right: 'bottom-end'
};

var parseAsFormatAndType = function parseAsFormatAndType(value, customFormat, type) {
  var rangeSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';

  if (!value) return null;
  var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).parser;
  var format = customFormat || DEFAULT_FORMATS[type];
  return parser(value, format, rangeSeparator);
};

var formatAsFormatAndType = function formatAsFormatAndType(value, customFormat, type) {
  if (!value) return null;
  var formatter = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).formatter;
  var format = customFormat || DEFAULT_FORMATS[type];
  return formatter(value, format);
};

// only considers date-picker's value: Date or [Date, Date]
var valueEquals = function valueEquals(a, b) {
  var aIsArray = a instanceof Array;
  var bIsArray = b instanceof Array;
  if (aIsArray && bIsArray) {
    return new Date(a[0]).getTime() === new Date(b[0]).getTime() && new Date(a[1]).getTime() === new Date(b[1]).getTime();
  }
  if (!aIsArray && !bIsArray) {
    return new Date(a).getTime() === new Date(b).getTime();
  }
  return false;
};

var isString = function isString(val) {
  return typeof val === 'string' || val instanceof String;
};

var validator = function validator(val) {
  // either: String, Array of String, null / undefined
  return val === null || val === undefined || isString(val) || Array.isArray(val) && val.length === 2 && val.every(isString);
};

exports.default = {
  mixins: [_emitter2.default, NewPopper, (0, _focus2.default)('reference')],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  props: {
    size: String,
    format: String,
    valueFormat: String,
    readonly: Boolean,
    placeholder: String,
    startPlaceholder: String,
    endPlaceholder: String,
    name: {
      default: '',
      validator: validator
    },
    disabled: Boolean,
    clearable: {
      type: Boolean,
      default: true
    },
    id: {
      default: '',
      validator: validator
    },
    popperClass: String,
    editable: {
      type: Boolean,
      default: true
    },
    align: {
      type: String,
      default: 'left'
    },
    value: {},
    defaultValue: {},
    rangeSeparator: {
      default: '-'
    },
    pickerOptions: {},
    unlinkPanels: Boolean
  },

  components: { ElInput: _input2.default },

  directives: { Clickoutside: _clickoutside2.default },

  data: function data() {
    return {
      pickerVisible: false,
      showClose: false,
      userInput: null,
      valueOnOpen: null, // value when picker opens, used to determine whether to emit change
      unwatchPickerOptions: null
    };
  },


  watch: {
    pickerVisible: function pickerVisible(val) {
      if (this.readonly || this.disabled) return;
      if (val) {
        this.showPicker();
        this.valueOnOpen = this.value;
      } else {
        this.hidePicker();
        this.emitChange(this.value);
        // flush user input if it is parsable
        // this.displayValue here is not a typo, it merges text for both panels in range mode
        var parsedValue = this.parseString(this.displayValue);
        if (this.userInput && parsedValue && this.isValidValue(parsedValue)) {
          this.userInput = null;
        }
        this.dispatch('ElFormItem', 'el.form.blur');
        this.blur();
      }
    },

    parsedValue: {
      immediate: true,
      handler: function handler(val) {
        if (this.picker) {
          this.picker.value = val;
        }
      }
    },
    defaultValue: function defaultValue(val) {
      // NOTE: should eventually move to jsx style picker + panel ?
      if (this.picker) {
        this.picker.defaultValue = val;
      }
    }
  },

  computed: {
    ranged: function ranged() {
      return this.type.indexOf('range') > -1;
    },
    reference: function reference() {
      var reference = this.$refs.reference;
      return reference.$el || reference;
    },
    refInput: function refInput() {
      if (this.reference) {
        return [].slice.call(this.reference.querySelectorAll('input'));
      }
      return [];
    },
    valueIsEmpty: function valueIsEmpty() {
      var val = this.value;
      if (Array.isArray(val)) {
        for (var i = 0, len = val.length; i < len; i++) {
          if (val[i]) {
            return false;
          }
        }
      } else {
        if (val) {
          return false;
        }
      }
      return true;
    },
    triggerClass: function triggerClass() {
      return this.type.indexOf('time') !== -1 ? 'el-icon-time' : 'el-icon-date';
    },
    selectionMode: function selectionMode() {
      if (this.type === 'week') {
        return 'week';
      } else if (this.type === 'month') {
        return 'month';
      } else if (this.type === 'year') {
        return 'year';
      }

      return 'day';
    },
    haveTrigger: function haveTrigger() {
      if (typeof this.showTrigger !== 'undefined') {
        return this.showTrigger;
      }
      return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;
    },
    displayValue: function displayValue() {
      var formattedValue = formatAsFormatAndType(this.parsedValue, this.format, this.type, this.rangeSeparator);
      if (Array.isArray(this.userInput)) {
        return [this.userInput[0] || formattedValue && formattedValue[0] || '', this.userInput[1] || formattedValue && formattedValue[1] || ''];
      } else {
        return this.userInput !== null ? this.userInput : formattedValue || '';
      }
    },
    parsedValue: function parsedValue() {
      var isParsed = (0, _util.isDateObject)(this.value) || Array.isArray(this.value) && this.value.every(_util.isDateObject);
      if (this.valueFormat && !isParsed) {
        return parseAsFormatAndType(this.value, this.valueFormat, this.type, this.rangeSeparator) || this.value;
      } else {
        return this.value;
      }
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    pickerSize: function pickerSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  created: function created() {
    // vue-popper
    this.popperOptions = {
      boundariesPadding: 0,
      gpuAcceleration: false
    };
    this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;
  },


  methods: {
    blur: function blur() {
      this.refInput.forEach(function (input) {
        return input.blur();
      });
    },


    // {parse, formatTo} Value deals maps component value with internal Date
    parseValue: function parseValue(value) {
      var isParsed = (0, _util.isDateObject)(value) || Array.isArray(value) && value.every(_util.isDateObject);
      if (this.valueFormat && !isParsed) {
        return parseAsFormatAndType(value, this.valueFormat, this.type, this.rangeSeparator) || value;
      } else {
        return value;
      }
    },
    formatToValue: function formatToValue(date) {
      var isFormattable = (0, _util.isDateObject)(date) || Array.isArray(date) && date.every(_util.isDateObject);
      if (this.valueFormat && isFormattable) {
        return formatAsFormatAndType(date, this.valueFormat, this.type, this.rangeSeparator);
      } else {
        return date;
      }
    },


    // {parse, formatTo} String deals with user input
    parseString: function parseString(value) {
      var type = Array.isArray(value) ? this.type : this.type.replace('range', '');
      return parseAsFormatAndType(value, this.format, type);
    },
    formatToString: function formatToString(value) {
      var type = Array.isArray(value) ? this.type : this.type.replace('range', '');
      return formatAsFormatAndType(value, this.format, type);
    },
    handleMouseEnter: function handleMouseEnter() {
      if (this.readonly || this.disabled) return;
      if (!this.valueIsEmpty && this.clearable) {
        this.showClose = true;
      }
    },
    handleChange: function handleChange() {
      if (this.userInput) {
        var value = this.parseString(this.displayValue);
        if (value) {
          this.picker.value = value;
          if (this.isValidValue(value)) {
            this.emitInput(value);
            this.userInput = null;
          }
        }
      }
    },
    handleStartInput: function handleStartInput(event) {
      if (this.userInput) {
        this.userInput = [event.target.value, this.userInput[1]];
      } else {
        this.userInput = [event.target.value, null];
      }
    },
    handleEndInput: function handleEndInput(event) {
      if (this.userInput) {
        this.userInput = [this.userInput[0], event.target.value];
      } else {
        this.userInput = [null, event.target.value];
      }
    },
    handleStartChange: function handleStartChange(event) {
      var value = this.parseString(this.userInput && this.userInput[0]);
      if (value) {
        this.userInput = [this.formatToString(value), this.displayValue[1]];
        var newValue = [value, this.picker.value && this.picker.value[1]];
        this.picker.value = newValue;
        if (this.isValidValue(newValue)) {
          this.emitInput(newValue);
          this.userInput = null;
        }
      }
    },
    handleEndChange: function handleEndChange(event) {
      var value = this.parseString(this.userInput && this.userInput[1]);
      if (value) {
        this.userInput = [this.displayValue[0], this.formatToString(value)];
        var newValue = [this.picker.value && this.picker.value[0], value];
        this.picker.value = newValue;
        if (this.isValidValue(newValue)) {
          this.emitInput(newValue);
          this.userInput = null;
        }
      }
    },
    handleClickIcon: function handleClickIcon(event) {
      if (this.readonly || this.disabled) return;
      if (this.showClose) {
        event.stopPropagation();
        this.emitInput(null);
        this.emitChange(null);
        this.showClose = false;
        if (this.picker && typeof this.picker.handleClear === 'function') {
          this.picker.handleClear();
        }
      } else {
        this.pickerVisible = !this.pickerVisible;
      }
    },
    handleClose: function handleClose() {
      this.pickerVisible = false;
      if (this.ranged) {
        this.$emit('blur', this);
      }
    },
    handleFocus: function handleFocus() {
      var type = this.type;

      if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
        this.pickerVisible = true;
      }
      this.$emit('focus', this);
    },
    handleBlur: function handleBlur() {
      this.$emit('blur', this);
    },
    handleKeydown: function handleKeydown(event) {
      var _this = this;

      var keyCode = event.keyCode;

      // ESC
      if (keyCode === 27) {
        this.pickerVisible = false;
        event.stopPropagation();
        return;
      }

      // Tab
      if (keyCode === 9) {
        if (!this.ranged) {
          this.handleChange();
          this.pickerVisible = this.picker.visible = false;
          this.blur();
          event.stopPropagation();
        } else {
          // user may change focus between two input
          setTimeout(function () {
            if (_this.refInput.indexOf(document.activeElement) === -1) {
              _this.pickerVisible = false;
              _this.blur();
              event.stopPropagation();
            }
          }, 0);
        }
        return;
      }

      // Enter
      if (keyCode === 13 && this.displayValue) {
        var value = this.parseString(this.displayValue);
        if (this.isValidValue(value)) {
          this.handleChange();
          this.pickerVisible = this.picker.visible = false;
          this.blur();
        }
        event.stopPropagation();
        return;
      }

      // if user is typing, do not let picker handle key input
      if (this.userInput) {
        event.stopPropagation();
        return;
      }

      // delegate other keys to panel
      if (this.picker && this.picker.handleKeydown) {
        this.picker.handleKeydown(event);
      }
    },
    handleRangeClick: function handleRangeClick() {
      var type = this.type;

      if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
        this.pickerVisible = true;
      }
      this.$emit('focus', this);
    },
    hidePicker: function hidePicker() {
      if (this.picker) {
        this.picker.resetView && this.picker.resetView();
        this.pickerVisible = this.picker.visible = false;
        this.destroyPopper();
      }
    },
    showPicker: function showPicker() {
      var _this2 = this;

      if (this.$isServer) return;
      if (!this.picker) {
        this.mountPicker();
      }
      this.pickerVisible = this.picker.visible = true;

      this.updatePopper();

      this.picker.value = this.parsedValue;
      this.picker.resetView && this.picker.resetView();

      this.$nextTick(function () {
        _this2.picker.adjustSpinners && _this2.picker.adjustSpinners();
      });
    },
    mountPicker: function mountPicker() {
      var _this3 = this;

      this.picker = new _vue2.default(this.panel).$mount();
      this.picker.defaultValue = this.defaultValue;
      this.picker.popperClass = this.popperClass;
      this.popperElm = this.picker.$el;
      this.picker.width = this.reference.getBoundingClientRect().width;
      this.picker.showTime = this.type === 'datetime' || this.type === 'datetimerange';
      this.picker.selectionMode = this.selectionMode;
      this.picker.unlinkPanels = this.unlinkPanels;
      this.picker.arrowControl = this.arrowControl || this.timeArrowControl || false;
      if (this.format) {
        this.picker.format = this.format;
      }

      var updateOptions = function updateOptions() {
        var options = _this3.pickerOptions;

        if (options && options.selectableRange) {
          (function () {
            var ranges = options.selectableRange;
            var parser = TYPE_VALUE_RESOLVER_MAP.datetimerange.parser;
            var format = DEFAULT_FORMATS.timerange;

            ranges = Array.isArray(ranges) ? ranges : [ranges];
            _this3.picker.selectableRange = ranges.map(function (range) {
              return parser(range, format, _this3.rangeSeparator);
            });
          })();
        }

        for (var option in options) {
          if (options.hasOwnProperty(option) &&
          // 忽略 time-picker 的该配置项
          option !== 'selectableRange') {
            _this3.picker[option] = options[option];
          }
        }
      };
      updateOptions();
      this.unwatchPickerOptions = this.$watch('pickerOptions', function () {
        return updateOptions();
      }, { deep: true });

      this.$el.appendChild(this.picker.$el);
      this.picker.resetView && this.picker.resetView();

      this.picker.$on('dodestroy', this.doDestroy);
      this.picker.$on('pick', function () {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        _this3.userInput = null;
        _this3.pickerVisible = _this3.picker.visible = visible;
        _this3.emitInput(date);
        _this3.picker.resetView && _this3.picker.resetView();
      });

      this.picker.$on('select-range', function (start, end, pos) {
        if (_this3.refInput.length === 0) return;
        if (!pos || pos === 'min') {
          _this3.refInput[0].setSelectionRange(start, end);
          _this3.refInput[0].focus();
        } else if (pos === 'max') {
          _this3.refInput[1].setSelectionRange(start, end);
          _this3.refInput[1].focus();
        }
      });
    },
    unmountPicker: function unmountPicker() {
      if (this.picker) {
        this.picker.$destroy();
        this.picker.$off();
        if (typeof this.unwatchPickerOptions === 'function') {
          this.unwatchPickerOptions();
        }
        this.picker.$el.parentNode.removeChild(this.picker.$el);
      }
    },
    emitChange: function emitChange(val) {
      this.$emit('change', val);
      this.dispatch('ElFormItem', 'el.form.change', val);
      this.valueOnOpen = val;
    },
    emitInput: function emitInput(val) {
      var formatted = this.formatToValue(val);
      if (!valueEquals(this.value, formatted)) {
        this.$emit('input', formatted);
      }
    },
    isValidValue: function isValidValue(value) {
      if (!this.picker) {
        this.mountPicker();
      }
      if (this.picker.isValidValue) {
        return value && this.picker.isValidValue(value);
      } else {
        return true;
      }
    }
  }
};

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("rs4r");

/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.ranged)?_c('el-input',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],ref:"reference",staticClass:"el-date-editor",class:'el-date-editor--' + _vm.type,attrs:{"readonly":!_vm.editable || _vm.readonly,"disabled":_vm.disabled,"size":_vm.pickerSize,"id":_vm.id,"name":_vm.name,"placeholder":_vm.placeholder,"value":_vm.displayValue,"validateEvent":false,"prefix-icon":_vm.triggerClass},on:{"focus":_vm.handleFocus,"blur":_vm.handleBlur,"input":function (value) { return _vm.userInput = value; }},nativeOn:{"keydown":function($event){_vm.handleKeydown($event)},"mouseenter":function($event){_vm.handleMouseEnter($event)},"mouseleave":function($event){_vm.showClose = false},"change":function($event){_vm.handleChange($event)}}},[(_vm.haveTrigger)?_c('i',{staticClass:"el-input__icon",class:{ 'el-icon-circle-close': _vm.showClose },attrs:{"slot":"suffix"},on:{"click":_vm.handleClickIcon},slot:"suffix"}):_vm._e()]):_c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],ref:"reference",staticClass:"el-date-editor el-range-editor el-input__inner",class:[
    'el-date-editor--' + _vm.type,
    _vm.pickerSize ? ("el-range-editor--" + _vm.pickerSize) : '',
    _vm.disabled ? 'is-disabled' : '',
    _vm.pickerVisible ? 'is-active' : ''
  ],on:{"click":_vm.handleRangeClick,"mouseenter":_vm.handleMouseEnter,"mouseleave":function($event){_vm.showClose = false},"keydown":_vm.handleKeydown}},[_c('i',{class:['el-input__icon', 'el-range__icon', _vm.triggerClass]}),_c('input',{staticClass:"el-range-input",attrs:{"placeholder":_vm.startPlaceholder,"disabled":_vm.disabled,"id":_vm.id && _vm.id[0],"readonly":!_vm.editable || _vm.readonly,"name":_vm.name && _vm.name[0]},domProps:{"value":_vm.displayValue && _vm.displayValue[0]},on:{"input":_vm.handleStartInput,"change":_vm.handleStartChange,"focus":_vm.handleFocus}}),_c('span',{staticClass:"el-range-separator"},[_vm._v(_vm._s(_vm.rangeSeparator))]),_c('input',{staticClass:"el-range-input",attrs:{"placeholder":_vm.endPlaceholder,"disabled":_vm.disabled,"id":_vm.id && _vm.id[1],"readonly":!_vm.editable || _vm.readonly,"name":_vm.name && _vm.name[1]},domProps:{"value":_vm.displayValue && _vm.displayValue[1]},on:{"input":_vm.handleEndInput,"change":_vm.handleEndChange,"focus":_vm.handleFocus}}),(_vm.haveTrigger)?_c('i',{staticClass:"el-input__icon el-range__close-icon",class:{ 'el-icon-circle-close': _vm.showClose },on:{"click":_vm.handleClickIcon}}):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_vue__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_27e32efb_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_date_vue__ = __webpack_require__(188);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_27e32efb_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_date_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _util = __webpack_require__(9);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _button = __webpack_require__(15);

var _button2 = _interopRequireDefault(_button);

var _time = __webpack_require__(27);

var _time2 = _interopRequireDefault(_time);

var _yearTable = __webpack_require__(180);

var _yearTable2 = _interopRequireDefault(_yearTable);

var _monthTable = __webpack_require__(183);

var _monthTable2 = _interopRequireDefault(_monthTable);

var _dateTable = __webpack_require__(37);

var _dateTable2 = _interopRequireDefault(_dateTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  mixins: [_locale2.default],

  watch: {
    showTime: function showTime(val) {
      var _this = this;

      /* istanbul ignore if */
      if (!val) return;
      this.$nextTick(function (_) {
        var inputElm = _this.$refs.input.$el;
        if (inputElm) {
          _this.pickerWidth = inputElm.getBoundingClientRect().width + 10;
        }
      });
    },
    value: function value(val) {
      if ((0, _util.isDate)(val)) {
        this.date = new Date(val);
      } else {
        this.date = this.defaultValue ? new Date(this.defaultValue) : new Date();
      }
    },
    defaultValue: function defaultValue(val) {
      if (!(0, _util.isDate)(this.value)) {
        this.date = val ? new Date(val) : new Date();
      }
    },
    timePickerVisible: function timePickerVisible(val) {
      var _this2 = this;

      if (val) this.$nextTick(function () {
        return _this2.$refs.timepicker.adjustSpinners();
      });
    },
    selectionMode: function selectionMode(newVal) {
      if (newVal === 'month') {
        /* istanbul ignore next */
        if (this.currentView !== 'year' || this.currentView !== 'month') {
          this.currentView = 'month';
        }
      }
    }
  },

  methods: {
    proxyTimePickerDataProperties: function proxyTimePickerDataProperties() {
      var _this3 = this;

      var format = function format(timeFormat) {
        _this3.$refs.timepicker.format = timeFormat;
      };
      var value = function value(_value) {
        _this3.$refs.timepicker.value = _value;
      };
      var date = function date(_date) {
        _this3.$refs.timepicker.date = _date;
      };

      this.$watch('format', format);
      this.$watch('value', value);
      this.$watch('date', date);

      format(this.timeFormat);
      value(this.value);
      date(this.date);
    },
    handleClear: function handleClear() {
      this.date = this.defaultValue ? new Date(this.defaultValue) : new Date();
      this.$emit('pick', null);
    },
    emit: function emit(value) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (!value) {
        this.$emit.apply(this, ['pick', value].concat(args));
        return;
      }
      if (this.showTime) {
        this.$emit.apply(this, ['pick', (0, _util.clearMilliseconds)(value)].concat(args));
      } else {
        this.$emit.apply(this, ['pick', (0, _util.clearTime)(value)].concat(args));
      }
    },


    // resetDate() {
    //   this.date = new Date(this.date);
    // },

    showMonthPicker: function showMonthPicker() {
      this.currentView = 'month';
    },
    showYearPicker: function showYearPicker() {
      this.currentView = 'year';
    },


    // XXX: 没用到
    // handleLabelClick() {
    //   if (this.currentView === 'date') {
    //     this.showMonthPicker();
    //   } else if (this.currentView === 'month') {
    //     this.showYearPicker();
    //   }
    // },

    prevMonth: function prevMonth() {
      this.date = (0, _util.prevMonth)(this.date);
    },
    nextMonth: function nextMonth() {
      this.date = (0, _util.nextMonth)(this.date);
    },
    prevYear: function prevYear() {
      if (this.currentView === 'year') {
        this.date = (0, _util.prevYear)(this.date, 10);
      } else {
        this.date = (0, _util.prevYear)(this.date);
      }
    },
    nextYear: function nextYear() {
      if (this.currentView === 'year') {
        this.date = (0, _util.nextYear)(this.date, 10);
      } else {
        this.date = (0, _util.nextYear)(this.date);
      }
    },
    handleShortcutClick: function handleShortcutClick(shortcut) {
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
    },
    handleTimePick: function handleTimePick(value, visible, first) {
      if ((0, _util.isDate)(value)) {
        var newDate = (0, _util.modifyTime)(this.date, value.getHours(), value.getMinutes(), value.getSeconds());
        this.date = newDate;
        this.emit(this.date, true);
      } else {
        this.emit(value, true);
      }
      if (!first) {
        this.timePickerVisible = visible;
      }
    },
    handleMonthPick: function handleMonthPick(month) {
      if (this.selectionMode === 'month') {
        this.date = (0, _util.modifyDate)(this.date, this.year, month, 1);
        this.emit(this.date);
      } else {
        this.date = (0, _util.modifyDate)(this.date, this.year, month, this.monthDate);
        // TODO: should emit intermediate value ??
        // this.emit(this.date);
        this.currentView = 'date';
      }
    },
    handleDatePick: function handleDatePick(value) {
      if (this.selectionMode === 'day') {
        this.date = (0, _util.modifyDate)(this.date, value.getFullYear(), value.getMonth(), value.getDate());
        this.emit(this.date, this.showTime);
      } else if (this.selectionMode === 'week') {
        this.emit(value.date);
      }
    },
    handleYearPick: function handleYearPick(year) {
      if (this.selectionMode === 'year') {
        this.date = (0, _util.modifyDate)(this.date, year, 0, 1);
        this.emit(this.date);
      } else {
        this.date = (0, _util.modifyDate)(this.date, year, this.month, this.monthDate);
        // TODO: should emit intermediate value ??
        // this.emit(this.date, true);
        this.currentView = 'month';
      }
    },
    changeToNow: function changeToNow() {
      this.date = new Date();
      this.emit(this.date);
    },
    confirm: function confirm() {
      this.emit(this.date);
    },
    resetView: function resetView() {
      if (this.selectionMode === 'month') {
        this.currentView = 'month';
      } else if (this.selectionMode === 'year') {
        this.currentView = 'year';
      } else {
        this.currentView = 'date';
      }
    },
    handleEnter: function handleEnter() {
      document.body.addEventListener('keydown', this.handleKeydown);
    },
    handleLeave: function handleLeave() {
      this.$emit('dodestroy');
      document.body.removeEventListener('keydown', this.handleKeydown);
    },
    handleKeydown: function handleKeydown(e) {
      var keyCode = e.keyCode;
      var list = [38, 40, 37, 39];
      if (this.visible && !this.timePickerVisible) {
        if (list.indexOf(keyCode) !== -1) {
          this.handleKeyControl(keyCode);
          event.stopPropagation();
          event.preventDefault();
        }
        if (keyCode === 13) {
          // Enter
          this.$emit('pick', this.date, false);
        }
      }
    },
    handleKeyControl: function handleKeyControl(keyCode) {
      var mapping = {
        'year': {
          38: -4, 40: 4, 37: -1, 39: 1, offset: function offset(date, step) {
            return date.setFullYear(date.getFullYear() + step);
          }
        },
        'month': {
          38: -4, 40: 4, 37: -1, 39: 1, offset: function offset(date, step) {
            return date.setMonth(date.getMonth() + step);
          }
        },
        'week': {
          38: -1, 40: 1, 37: -1, 39: 1, offset: function offset(date, step) {
            return date.setDate(date.getDate() + step * 7);
          }
        },
        'day': {
          38: -7, 40: 7, 37: -1, 39: 1, offset: function offset(date, step) {
            return date.setDate(date.getDate() + step);
          }
        }
      };
      var mode = this.selectionMode;
      var year = 3.1536e10;
      var now = this.date.getTime();
      var newDate = new Date(this.date.getTime());
      while (Math.abs(now - newDate.getTime()) <= year) {
        var map = mapping[mode];
        map.offset(newDate, map[keyCode]);
        if (typeof this.disabledDate === 'function' && this.disabledDate(newDate)) {
          continue;
        }
        this.date = newDate;
        this.$emit('pick', newDate, true);
        break;
      }
    },
    handleVisibleTimeChange: function handleVisibleTimeChange(event) {
      var time = (0, _util.parseDate)(event.target.value, this.timeFormat);
      if (time) {
        this.date = (0, _util.modifyDate)(time, this.year, this.month, this.monthDate);
        this.$refs.timepicker.value = this.date;
        this.timePickerVisible = false;
        this.$emit('pick', this.date, true);
      }
    },
    handleVisibleDateChange: function handleVisibleDateChange(event) {
      var date = (0, _util.parseDate)(event.target.value, this.dateFormat);
      if (date) {
        if (typeof this.disabledDate === 'function' && this.disabledDate(date)) {
          return;
        }
        this.date = (0, _util.modifyTime)(date, this.date.getHours(), this.date.getMinutes(), this.date.getSeconds());
        this.resetView();
        this.$emit('pick', this.date, true);
      }
    },
    isValidValue: function isValidValue(value) {
      return value && !isNaN(value) && (typeof this.disabledDate === 'function' ? !this.disabledDate(value) : true);
    }
  },

  components: {
    TimePicker: _time2.default, YearTable: _yearTable2.default, MonthTable: _monthTable2.default, DateTable: _dateTable2.default, ElInput: _input2.default, ElButton: _button2.default
  },

  data: function data() {
    return {
      popperClass: '',
      date: new Date(),
      value: '',
      defaultValue: null,
      showTime: false,
      selectionMode: 'day',
      shortcuts: '',
      visible: false,
      currentView: 'date',
      disabledDate: '',
      firstDayOfWeek: 7,
      showWeekNumber: false,
      timePickerVisible: false,
      format: '',
      arrowControl: false
    };
  },


  computed: {
    year: function year() {
      return this.date.getFullYear();
    },
    month: function month() {
      return this.date.getMonth();
    },
    week: function week() {
      return (0, _util.getWeekNumber)(this.date);
    },
    monthDate: function monthDate() {
      return this.date.getDate();
    },
    footerVisible: function footerVisible() {
      return this.showTime;
    },
    visibleTime: function visibleTime() {
      var date = this.value || this.defaultValue;
      return date ? (0, _util.formatDate)(date, this.timeFormat) : '';
    },
    visibleDate: function visibleDate() {
      var date = this.value || this.defaultValue;
      return date ? (0, _util.formatDate)(date, this.dateFormat) : '';
    },
    yearLabel: function yearLabel() {
      var yearTranslation = this.t('el.datepicker.year');
      if (this.currentView === 'year') {
        var startYear = Math.floor(this.year / 10) * 10;
        if (yearTranslation) {
          return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
        }
        return startYear + ' - ' + (startYear + 9);
      }
      return this.year + ' ' + yearTranslation;
    },
    timeFormat: function timeFormat() {
      if (this.format && this.format.indexOf('ss') === -1) {
        return 'HH:mm';
      } else {
        return 'HH:mm:ss';
      }
    },
    dateFormat: function dateFormat() {
      if (this.format) {
        return this.format.replace('HH', '').replace(':mm', '').replace(':ss', '').trim();
      } else {
        return 'yyyy-MM-dd';
      }
    }
  }
};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _util = __webpack_require__(9);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _timeSpinner = __webpack_require__(36);

var _timeSpinner2 = _interopRequireDefault(_timeSpinner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_locale2.default],

  components: {
    TimeSpinner: _timeSpinner2.default
  },

  props: {
    visible: Boolean,
    timeArrowControl: Boolean
  },

  watch: {
    visible: function visible(val) {
      var _this = this;

      if (val) {
        this.oldValue = this.value;
        this.$nextTick(function () {
          return _this.$refs.spinner.emitSelectRange('hours');
        });
      } else {
        this.needInitAdjust = true;
      }
    },
    value: function value(newVal) {
      var _this2 = this;

      var date = void 0;
      if (newVal instanceof Date) {
        date = (0, _util.limitTimeRange)(newVal, this.selectableRange, this.format);
      } else if (!newVal) {
        date = this.defaultValue ? new Date(this.defaultValue) : new Date();
      }

      this.date = date;
      if (this.visible && this.needInitAdjust) {
        this.$nextTick(function (_) {
          return _this2.adjustSpinners();
        });
        this.needInitAdjust = false;
      }
    },
    selectableRange: function selectableRange(val) {
      this.$refs.spinner.selectableRange = val;
    },
    defaultValue: function defaultValue(val) {
      if (!(0, _util.isDate)(this.value)) {
        this.date = val ? new Date(val) : new Date();
      }
    }
  },

  data: function data() {
    return {
      popperClass: '',
      format: 'HH:mm:ss',
      value: '',
      defaultValue: null,
      date: new Date(),
      oldValue: new Date(),
      selectableRange: [],
      selectionRange: [0, 2],
      disabled: false,
      arrowControl: false,
      needInitAdjust: true
    };
  },


  computed: {
    showSeconds: function showSeconds() {
      return (this.format || '').indexOf('ss') !== -1;
    },
    useArrow: function useArrow() {
      return this.arrowControl || this.timeArrowControl || false;
    }
  },

  methods: {
    handleCancel: function handleCancel() {
      this.$emit('pick', this.oldValue, false);
    },
    handleChange: function handleChange(date) {
      // this.visible avoids edge cases, when use scrolls during panel closing animation
      if (this.visible) {
        this.date = (0, _util.clearMilliseconds)(date);
        // if date is out of range, do not emit
        if (this.isValidValue(this.date)) {
          this.$emit('pick', this.date, true);
        }
      }
    },
    setSelectionRange: function setSelectionRange(start, end) {
      this.$emit('select-range', start, end);
      this.selectionRange = [start, end];
    },
    handleConfirm: function handleConfirm() {
      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var first = arguments[1];

      if (first) return;
      var date = (0, _util.clearMilliseconds)((0, _util.limitTimeRange)(this.date, this.selectableRange, this.format));
      this.$emit('pick', date, visible, first);
    },
    handleKeydown: function handleKeydown(event) {
      var keyCode = event.keyCode;
      var mapping = { 38: -1, 40: 1, 37: -1, 39: 1 };

      // Left or Right
      if (keyCode === 37 || keyCode === 39) {
        var step = mapping[keyCode];
        this.changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      // Up or Down
      if (keyCode === 38 || keyCode === 40) {
        var _step = mapping[keyCode];
        this.$refs.spinner.scrollDown(_step);
        event.preventDefault();
        return;
      }
    },
    isValidValue: function isValidValue(date) {
      return (0, _util.timeWithinRange)(date, this.selectableRange, this.format);
    },
    adjustSpinners: function adjustSpinners() {
      return this.$refs.spinner.adjustSpinners();
    },
    changeSelectionRange: function changeSelectionRange(step) {
      var list = [0, 3].concat(this.showSeconds ? [6] : []);
      var mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
      var index = list.indexOf(this.selectionRange[0]);
      var next = (index + step + list.length) % list.length;
      this.$refs.spinner.emitSelectRange(mapping[next]);
    }
  },

  mounted: function mounted() {
    var _this3 = this;

    this.$nextTick(function () {
      return _this3.handleConfirm(true, true);
    });
    this.$emit('mounted');
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _util = __webpack_require__(9);

var _scrollbar = __webpack_require__(19);

var _scrollbar2 = _interopRequireDefault(_scrollbar);

var _repeatClick = __webpack_require__(31);

var _repeatClick2 = _interopRequireDefault(_repeatClick);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { ElScrollbar: _scrollbar2.default },

  directives: {
    repeatClick: _repeatClick2.default
  },

  props: {
    date: {},
    defaultValue: {}, // reserved for future use
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: Boolean
  },

  computed: {
    hours: function hours() {
      return this.date.getHours();
    },
    minutes: function minutes() {
      return this.date.getMinutes();
    },
    seconds: function seconds() {
      return this.date.getSeconds();
    },
    hoursList: function hoursList() {
      return (0, _util.getRangeHours)(this.selectableRange);
    },
    arrowHourList: function arrowHourList() {
      var hours = this.hours;
      return [hours > 0 ? hours - 1 : undefined, hours, hours < 23 ? hours + 1 : undefined];
    },
    arrowMinuteList: function arrowMinuteList() {
      var minutes = this.minutes;
      return [minutes > 0 ? minutes - 1 : undefined, minutes, minutes < 59 ? minutes + 1 : undefined];
    },
    arrowSecondList: function arrowSecondList() {
      var seconds = this.seconds;
      return [seconds > 0 ? seconds - 1 : undefined, seconds, seconds < 59 ? seconds + 1 : undefined];
    }
  },

  data: function data() {
    return {
      selectableRange: [],
      currentScrollbar: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      !_this.arrowControl && _this.bindScrollEvent();
    });
  },


  methods: {
    increase: function increase() {
      this.scrollDown(1);
    },
    decrease: function decrease() {
      this.scrollDown(-1);
    },
    modifyDateField: function modifyDateField(type, value) {
      switch (type) {
        case 'hours':
          this.$emit('change', (0, _util.modifyTime)(this.date, value, this.minutes, this.seconds));break;
        case 'minutes':
          this.$emit('change', (0, _util.modifyTime)(this.date, this.hours, value, this.seconds));break;
        case 'seconds':
          this.$emit('change', (0, _util.modifyTime)(this.date, this.hours, this.minutes, value));break;
      }
    },
    handleClick: function handleClick(type, _ref) {
      var value = _ref.value,
          disabled = _ref.disabled;

      if (!disabled) {
        this.modifyDateField(type, value);
        this.emitSelectRange(type);
        this.adjustSpinner(type, value);
      }
    },
    emitSelectRange: function emitSelectRange(type) {
      if (type === 'hours') {
        this.$emit('select-range', 0, 2);
      } else if (type === 'minutes') {
        this.$emit('select-range', 3, 5);
      } else if (type === 'seconds') {
        this.$emit('select-range', 6, 8);
      }
      this.currentScrollbar = type;
    },
    bindScrollEvent: function bindScrollEvent() {
      var _this2 = this;

      var bindFuntion = function bindFuntion(type) {
        _this2.$refs[type].wrap.onscroll = function (e) {
          // TODO: scroll is emitted when set scrollTop programatically
          // should find better solutions in the future!
          _this2.handleScroll(type, e);
        };
      };
      bindFuntion('hours');
      bindFuntion('minutes');
      bindFuntion('seconds');
    },
    handleScroll: function handleScroll(type) {
      var value = Math.min(Math.floor((this.$refs[type].wrap.scrollTop - 80) / 32 + 3), type === 'hours' ? 23 : 59);
      this.modifyDateField(type, value);
    },


    // NOTE: used by datetime / date-range panel
    //       renamed from adjustScrollTop
    //       should try to refactory it
    adjustSpinners: function adjustSpinners() {
      this.adjustSpinner('hours', this.hours);
      this.adjustSpinner('minutes', this.minutes);
      this.adjustSpinner('seconds', this.seconds);
    },
    adjustCurrentSpinner: function adjustCurrentSpinner(type) {
      this.adjustSpinner(type, this[type]);
    },
    adjustSpinner: function adjustSpinner(type, value) {
      if (this.arrowControl) return;
      var el = this.$refs[type].wrap;
      if (el) {
        el.scrollTop = Math.max(0, (value - 2.5) * 32 + 80);
      }
    },
    scrollDown: function scrollDown(step) {
      if (!this.currentScrollbar) {
        this.emitSelectRange('hours');
      }

      var label = this.currentScrollbar;
      var hoursList = this.hoursList;
      var now = this[label];

      if (this.currentScrollbar === 'hours') {
        var total = Math.abs(step);
        step = step > 0 ? 1 : -1;
        var length = hoursList.length;
        while (length-- && total) {
          now = (now + step + hoursList.length) % hoursList.length;
          if (hoursList[now]) {
            continue;
          }
          total--;
        }
        if (hoursList[now]) return;
      } else {
        now = (now + step + 60) % 60;
      }

      this.modifyDateField(label, now);
      this.adjustSpinner(label, now);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-time-spinner",class:{ 'has-seconds': _vm.showSeconds }},[(!_vm.arrowControl)?[_c('el-scrollbar',{ref:"hours",staticClass:"el-time-spinner__wrapper",attrs:{"wrap-style":"max-height: inherit;","view-class":"el-time-spinner__list","noresize":"","tag":"ul"},nativeOn:{"mouseenter":function($event){_vm.emitSelectRange('hours')},"mousemove":function($event){_vm.adjustCurrentSpinner('hours')}}},_vm._l((_vm.hoursList),function(disabled,hour){return _c('li',{staticClass:"el-time-spinner__item",class:{ 'active': hour === _vm.hours, 'disabled': disabled },attrs:{"track-by":"hour"},on:{"click":function($event){_vm.handleClick('hours', { value: hour, disabled: disabled })}}},[_vm._v(_vm._s(('0' + hour).slice(-2)))])})),_c('el-scrollbar',{ref:"minutes",staticClass:"el-time-spinner__wrapper",attrs:{"wrap-style":"max-height: inherit;","view-class":"el-time-spinner__list","noresize":"","tag":"ul"},nativeOn:{"mouseenter":function($event){_vm.emitSelectRange('minutes')},"mousemove":function($event){_vm.adjustCurrentSpinner('minutes')}}},_vm._l((60),function(minute,key){return _c('li',{staticClass:"el-time-spinner__item",class:{ 'active': key === _vm.minutes },on:{"click":function($event){_vm.handleClick('minutes', { value: key, disabled: false })}}},[_vm._v(_vm._s(('0' + key).slice(-2)))])})),_c('el-scrollbar',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSeconds),expression:"showSeconds"}],ref:"seconds",staticClass:"el-time-spinner__wrapper",attrs:{"wrap-style":"max-height: inherit;","view-class":"el-time-spinner__list","noresize":"","tag":"ul"},nativeOn:{"mouseenter":function($event){_vm.emitSelectRange('seconds')},"mousemove":function($event){_vm.adjustCurrentSpinner('seconds')}}},_vm._l((60),function(second,key){return _c('li',{staticClass:"el-time-spinner__item",class:{ 'active': key === _vm.seconds },on:{"click":function($event){_vm.handleClick('seconds', { value: key, disabled: false })}}},[_vm._v(_vm._s(('0' + key).slice(-2)))])}))]:_vm._e(),(_vm.arrowControl)?[_c('div',{staticClass:"el-time-spinner__wrapper is-arrow",on:{"mouseenter":function($event){_vm.emitSelectRange('hours')}}},[_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-time-spinner__arrow el-icon-arrow-up"}),_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-time-spinner__arrow el-icon-arrow-down"}),_c('ul',{ref:"hours",staticClass:"el-time-spinner__list"},_vm._l((_vm.arrowHourList),function(hour){return _c('li',{staticClass:"el-time-spinner__item",class:{ 'active': hour === _vm.hours, 'disabled': _vm.hoursList[hour] }},[_vm._v("\n          "+_vm._s(hour === undefined ? '' : ('0' + hour).slice(-2))+"\n        ")])}))]),_c('div',{staticClass:"el-time-spinner__wrapper is-arrow",on:{"mouseenter":function($event){_vm.emitSelectRange('minutes')}}},[_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-time-spinner__arrow el-icon-arrow-up"}),_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-time-spinner__arrow el-icon-arrow-down"}),_c('ul',{ref:"minutes",staticClass:"el-time-spinner__list"},_vm._l((_vm.arrowMinuteList),function(minute){return _c('li',{staticClass:"el-time-spinner__item",class:{ 'active': minute === _vm.minutes }},[_vm._v("\n          "+_vm._s(minute === undefined ? '' : ('0' + minute).slice(-2))+"\n        ")])}))]),(_vm.showSeconds)?_c('div',{staticClass:"el-time-spinner__wrapper is-arrow",on:{"mouseenter":function($event){_vm.emitSelectRange('seconds')}}},[_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-time-spinner__arrow el-icon-arrow-up"}),_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-time-spinner__arrow el-icon-arrow-down"}),_c('ul',{ref:"seconds",staticClass:"el-time-spinner__list"},_vm._l((_vm.arrowSecondList),function(second){return _c('li',{staticClass:"el-time-spinner__item",class:{ 'active': second === _vm.seconds }},[_vm._v("\n          "+_vm._s(second === undefined ? '' : ('0' + second).slice(-2))+"\n        ")])}))]):_vm._e()]:_vm._e()],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":function($event){_vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-time-panel el-popper",class:_vm.popperClass},[_c('div',{staticClass:"el-time-panel__content",class:{ 'has-seconds': _vm.showSeconds }},[_c('time-spinner',{ref:"spinner",attrs:{"arrow-control":_vm.useArrow,"show-seconds":_vm.showSeconds,"date":_vm.date},on:{"change":_vm.handleChange,"select-range":_vm.setSelectionRange}})],1),_c('div',{staticClass:"el-time-panel__footer"},[_c('button',{staticClass:"el-time-panel__btn cancel",attrs:{"type":"button"},on:{"click":_vm.handleCancel}},[_vm._v(_vm._s(_vm.t('el.datepicker.cancel')))]),_c('button',{staticClass:"el-time-panel__btn",class:{confirm: !_vm.disabled},attrs:{"type":"button"},on:{"click":function($event){_vm.handleConfirm()}}},[_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))])])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_year_table_vue__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_year_table_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_year_table_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_520b6e61_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_year_table_vue__ = __webpack_require__(182);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_year_table_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_520b6e61_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_year_table_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

var _util = __webpack_require__(9);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var datesInYear = function datesInYear(year) {
  var numOfDays = (0, _util.getDayCountOfYear)(year);
  var firstDay = new Date(year, 0, 1);
  return (0, _util.range)(numOfDays).map(function (n) {
    return (0, _util.nextDate)(firstDay, n);
  });
};

exports.default = {
  props: {
    disabledDate: {},
    value: {},
    defaultValue: {
      validator: function validator(val) {
        // null or valid Date Object
        return val === null || val instanceof Date && (0, _util.isDate)(val);
      }
    },
    date: {}
  },

  computed: {
    startYear: function startYear() {
      return Math.floor(this.date.getFullYear() / 10) * 10;
    }
  },

  methods: {
    getCellStyle: function getCellStyle(year) {
      var style = {};
      var today = new Date();

      style.disabled = typeof this.disabledDate === 'function' ? datesInYear(year).every(this.disabledDate) : false;
      style.current = this.value.getFullYear() === year;
      style.today = today.getFullYear() === year;
      style.default = this.defaultValue && this.defaultValue.getFullYear() === year;

      return style;
    },
    handleYearTableClick: function handleYearTableClick(event) {
      var target = event.target;
      if (target.tagName === 'A') {
        if ((0, _dom.hasClass)(target.parentNode, 'disabled')) return;
        var year = target.textContent || target.innerText;
        this.$emit('pick', Number(year));
      }
    }
  }
};

/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('table',{staticClass:"el-year-table",on:{"click":_vm.handleYearTableClick}},[_c('tbody',[_c('tr',[_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 0)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 1)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 1))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 2)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 2))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 3)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 3))])])]),_c('tr',[_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 4)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 4))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 5)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 5))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 6)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 6))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 7)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 7))])])]),_c('tr',[_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 8)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 8))])]),_c('td',{staticClass:"available",class:_vm.getCellStyle(_vm.startYear + 9)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.startYear + 9))])]),_c('td'),_c('td')])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_month_table_vue__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_month_table_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_month_table_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_419c8da4_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_month_table_vue__ = __webpack_require__(185);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_month_table_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_419c8da4_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_month_table_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _util = __webpack_require__(9);

var _dom = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var datesInMonth = function datesInMonth(year, month) {
  var numOfDays = (0, _util.getDayCountOfMonth)(year, month);
  var firstDay = new Date(year, month, 1);
  return (0, _util.range)(numOfDays).map(function (n) {
    return (0, _util.nextDate)(firstDay, n);
  });
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    disabledDate: {},
    value: {},
    defaultValue: {
      validator: function validator(val) {
        // null or valid Date Object
        return val === null || val instanceof Date && (0, _util.isDate)(val);
      }
    },
    date: {}
  },
  mixins: [_locale2.default],
  methods: {
    getCellStyle: function getCellStyle(month) {
      var style = {};
      var year = this.date.getFullYear();
      var today = new Date();

      style.disabled = typeof this.disabledDate === 'function' ? datesInMonth(year, month).every(this.disabledDate) : false;
      style.current = this.value.getFullYear() === year && this.value.getMonth() === month;
      style.today = today.getFullYear() === year && today.getMonth() === month;
      style.default = this.defaultValue && this.defaultValue.getFullYear() === year && this.defaultValue.getMonth() === month;

      return style;
    },
    handleMonthTableClick: function handleMonthTableClick(event) {
      var target = event.target;
      if (target.tagName !== 'A') return;
      if ((0, _dom.hasClass)(target.parentNode, 'disabled')) return;
      var column = target.parentNode.cellIndex;
      var row = target.parentNode.parentNode.rowIndex;
      var month = row * 4 + column;

      this.$emit('pick', month);
    }
  }
};

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('table',{staticClass:"el-month-table",on:{"click":_vm.handleMonthTableClick}},[_c('tbody',[_c('tr',[_c('td',{class:_vm.getCellStyle(0)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.jan')))])]),_c('td',{class:_vm.getCellStyle(1)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.feb')))])]),_c('td',{class:_vm.getCellStyle(2)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.mar')))])]),_c('td',{class:_vm.getCellStyle(3)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.apr')))])])]),_c('tr',[_c('td',{class:_vm.getCellStyle(4)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.may')))])]),_c('td',{class:_vm.getCellStyle(5)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.jun')))])]),_c('td',{class:_vm.getCellStyle(6)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.jul')))])]),_c('td',{class:_vm.getCellStyle(7)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.aug')))])])]),_c('tr',[_c('td',{class:_vm.getCellStyle(8)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.sep')))])]),_c('td',{class:_vm.getCellStyle(9)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.oct')))])]),_c('td',{class:_vm.getCellStyle(10)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.nov')))])]),_c('td',{class:_vm.getCellStyle(11)},[_c('a',{staticClass:"cell"},[_vm._v(_vm._s(_vm.t('el.datepicker.months.dec')))])])])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _util = __webpack_require__(9);

var _dom = __webpack_require__(4);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var clearHours = function clearHours(time) {
  var cloneDate = new Date(time);
  cloneDate.setHours(0, 0, 0, 0);
  return cloneDate.getTime();
};

exports.default = {
  mixins: [_locale2.default],

  props: {
    firstDayOfWeek: {
      default: 7,
      type: Number,
      validator: function validator(val) {
        return val >= 1 && val <= 7;
      }
    },

    value: {},

    defaultValue: {
      validator: function validator(val) {
        // either: null, valid Date object, Array of valid Date objects
        return val === null || (0, _util.isDate)(val) || Array.isArray(val) && val.every(_util.isDate);
      }
    },

    date: {},

    selectionMode: {
      default: 'day'
    },

    showWeekNumber: {
      type: Boolean,
      default: false
    },

    disabledDate: {},

    minDate: {},

    maxDate: {},

    rangeState: {
      default: function _default() {
        return {
          endDate: null,
          selecting: false,
          row: null,
          column: null
        };
      }
    }
  },

  computed: {
    offsetDay: function offsetDay() {
      var week = this.firstDayOfWeek;
      // 周日为界限，左右偏移的天数，3217654 例如周一就是 -1，目的是调整前两行日期的位置
      return week > 3 ? 7 - week : -week;
    },
    WEEKS: function WEEKS() {
      var week = this.firstDayOfWeek;
      return _WEEKS.concat(_WEEKS).slice(week, week + 7);
    },
    year: function year() {
      return this.date.getFullYear();
    },
    month: function month() {
      return this.date.getMonth();
    },
    startDate: function startDate() {
      return (0, _util.getStartDateOfMonth)(this.year, this.month);
    },
    rows: function rows() {
      // TODO: refactory rows / getCellClasses
      var date = new Date(this.year, this.month, 1);
      var day = (0, _util.getFirstDayOfMonth)(date); // day of first day
      var dateCountOfMonth = (0, _util.getDayCountOfMonth)(date.getFullYear(), date.getMonth());
      var dateCountOfLastMonth = (0, _util.getDayCountOfMonth)(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);

      day = day === 0 ? 7 : day;

      var offset = this.offsetDay;
      var rows = this.tableRows;
      var count = 1;
      var firstDayPosition = void 0;

      var startDate = this.startDate;
      var disabledDate = this.disabledDate;
      var now = clearHours(new Date());

      for (var i = 0; i < 6; i++) {
        var row = rows[i];

        if (this.showWeekNumber) {
          if (!row[0]) {
            row[0] = { type: 'week', text: (0, _util.getWeekNumber)((0, _util.nextDate)(startDate, i * 7 + 1)) };
          }
        }

        for (var j = 0; j < 7; j++) {
          var cell = row[this.showWeekNumber ? j + 1 : j];
          if (!cell) {
            cell = { row: i, column: j, type: 'normal', inRange: false, start: false, end: false };
          }

          cell.type = 'normal';

          var index = i * 7 + j;
          var time = (0, _util.nextDate)(startDate, index - offset).getTime();
          cell.inRange = time >= clearHours(this.minDate) && time <= clearHours(this.maxDate);
          cell.start = this.minDate && time === clearHours(this.minDate);
          cell.end = this.maxDate && time === clearHours(this.maxDate);
          var isToday = time === now;

          if (isToday) {
            cell.type = 'today';
          }

          if (i >= 0 && i <= 1) {
            if (j + i * 7 >= day + offset) {
              cell.text = count++;
              if (count === 2) {
                firstDayPosition = i * 7 + j;
              }
            } else {
              cell.text = dateCountOfLastMonth - (day + offset - j % 7) + 1 + i * 7;
              cell.type = 'prev-month';
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count++;
              if (count === 2) {
                firstDayPosition = i * 7 + j;
              }
            } else {
              cell.text = count++ - dateCountOfMonth;
              cell.type = 'next-month';
            }
          }

          cell.disabled = typeof disabledDate === 'function' && disabledDate(new Date(time));

          this.$set(row, this.showWeekNumber ? j + 1 : j, cell);
        }

        if (this.selectionMode === 'week') {
          var start = this.showWeekNumber ? 1 : 0;
          var end = this.showWeekNumber ? 7 : 6;
          var isWeekActive = this.isWeekActive(row[start + 1]);

          row[start].inRange = isWeekActive;
          row[start].start = isWeekActive;
          row[end].inRange = isWeekActive;
          row[end].end = isWeekActive;
        }
      }

      rows.firstDayPosition = firstDayPosition;

      return rows;
    }
  },

  watch: {
    'rangeState.endDate': function rangeStateEndDate(newVal) {
      this.markRange(newVal);
    },
    minDate: function minDate(newVal, oldVal) {
      if (newVal && !oldVal) {
        this.rangeState.selecting = true;
        this.markRange(newVal);
      } else if (!newVal) {
        this.rangeState.selecting = false;
        this.markRange(newVal);
      } else {
        this.markRange();
      }
    },
    maxDate: function maxDate(newVal, oldVal) {
      if (newVal && !oldVal) {
        this.rangeState.selecting = false;
        this.markRange(newVal);
        this.$emit('pick', {
          minDate: this.minDate,
          maxDate: this.maxDate
        });
      }
    }
  },

  data: function data() {
    return {
      tableRows: [[], [], [], [], [], []]
    };
  },


  methods: {
    cellMatchesDate: function cellMatchesDate(cell, date) {
      var value = new Date(date);
      return this.year === value.getFullYear() && this.month === value.getMonth() && Number(cell.text) === value.getDate();
    },
    getCellClasses: function getCellClasses(cell) {
      var _this = this;

      var selectionMode = this.selectionMode;
      var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];

      var classes = [];
      if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {
        classes.push('available');
        if (cell.type === 'today') {
          classes.push('today');
        }
      } else {
        classes.push(cell.type);
      }

      if (cell.type === 'normal' && defaultValue.some(function (date) {
        return _this.cellMatchesDate(cell, date);
      })) {
        classes.push('default');
      }

      if (selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') && this.cellMatchesDate(cell, this.value)) {
        classes.push('current');
      }

      if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || this.selectionMode === 'week')) {
        classes.push('in-range');

        if (cell.start) {
          classes.push('start-date');
        }

        if (cell.end) {
          classes.push('end-date');
        }
      }

      if (cell.disabled) {
        classes.push('disabled');
      }

      return classes.join(' ');
    },
    getDateOfCell: function getDateOfCell(row, column) {
      var offsetFromStart = row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay;
      return (0, _util.nextDate)(this.startDate, offsetFromStart);
    },
    isWeekActive: function isWeekActive(cell) {
      if (this.selectionMode !== 'week') return false;
      var newDate = new Date(this.year, this.month, 1);
      var year = newDate.getFullYear();
      var month = newDate.getMonth();

      if (cell.type === 'prev-month') {
        newDate.setMonth(month === 0 ? 11 : month - 1);
        newDate.setFullYear(month === 0 ? year - 1 : year);
      }

      if (cell.type === 'next-month') {
        newDate.setMonth(month === 11 ? 0 : month + 1);
        newDate.setFullYear(month === 11 ? year + 1 : year);
      }

      newDate.setDate(parseInt(cell.text, 10));

      return (0, _util.getWeekNumber)(newDate) === (0, _util.getWeekNumber)(this.date);
    },
    markRange: function markRange(maxDate) {
      var startDate = this.startDate;
      if (!maxDate) {
        maxDate = this.maxDate;
      }

      var rows = this.rows;
      var minDate = this.minDate;
      for (var i = 0, k = rows.length; i < k; i++) {
        var row = rows[i];
        for (var j = 0, l = row.length; j < l; j++) {
          if (this.showWeekNumber && j === 0) continue;

          var cell = row[j];
          var index = i * 7 + j + (this.showWeekNumber ? -1 : 0);
          var time = (0, _util.nextDate)(startDate, index - this.offsetDay).getTime();

          cell.inRange = minDate && time >= clearHours(minDate) && time <= clearHours(maxDate);
          cell.start = minDate && time === clearHours(minDate.getTime());
          cell.end = maxDate && time === clearHours(maxDate.getTime());
        }
      }
    },
    handleMouseMove: function handleMouseMove(event) {
      if (!this.rangeState.selecting) return;

      this.$emit('changerange', {
        minDate: this.minDate,
        maxDate: this.maxDate,
        rangeState: this.rangeState
      });

      var target = event.target;
      if (target.tagName === 'SPAN') {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === 'DIV') {
        target = target.parentNode;
      }
      if (target.tagName !== 'TD') return;

      var column = target.cellIndex;
      var row = target.parentNode.rowIndex - 1;
      var _rangeState = this.rangeState,
          oldRow = _rangeState.row,
          oldColumn = _rangeState.column;


      if (oldRow !== row || oldColumn !== column) {
        this.rangeState.row = row;
        this.rangeState.column = column;

        this.rangeState.endDate = this.getDateOfCell(row, column);
      }
    },
    handleClick: function handleClick(event) {
      var _this2 = this;

      var target = event.target;
      if (target.tagName === 'SPAN') {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === 'DIV') {
        target = target.parentNode;
      }

      if (target.tagName !== 'TD') return;
      if ((0, _dom.hasClass)(target, 'disabled') || (0, _dom.hasClass)(target, 'week')) return;

      var selectionMode = this.selectionMode;

      if (selectionMode === 'week') {
        target = target.parentNode.cells[1];
      }

      var year = Number(this.year);
      var month = Number(this.month);

      var cellIndex = target.cellIndex;
      var rowIndex = target.parentNode.rowIndex;

      var cell = this.rows[rowIndex - 1][cellIndex];
      var text = cell.text;
      var className = target.className;

      var newDate = new Date(year, month, 1);

      if (className.indexOf('prev') !== -1) {
        if (month === 0) {
          year = year - 1;
          month = 11;
        } else {
          month = month - 1;
        }
        newDate.setFullYear(year);
        newDate.setMonth(month);
      } else if (className.indexOf('next') !== -1) {
        if (month === 11) {
          year = year + 1;
          month = 0;
        } else {
          month = month + 1;
        }
        newDate.setFullYear(year);
        newDate.setMonth(month);
      }

      newDate.setDate(parseInt(text, 10));

      if (this.selectionMode === 'range') {
        if (this.minDate && this.maxDate) {
          var minDate = new Date(newDate.getTime());
          var maxDate = null;

          this.$emit('pick', { minDate: minDate, maxDate: maxDate }, false);
          this.rangeState.selecting = true;
          this.markRange(this.minDate);
          this.$nextTick(function () {
            _this2.handleMouseMove(event);
          });
        } else if (this.minDate && !this.maxDate) {
          if (newDate >= this.minDate) {
            var _maxDate = new Date(newDate.getTime());
            this.rangeState.selecting = false;

            this.$emit('pick', {
              minDate: this.minDate,
              maxDate: _maxDate
            });
          } else {
            var _minDate = new Date(newDate.getTime());

            this.$emit('pick', { minDate: _minDate, maxDate: this.maxDate }, false);
          }
        } else if (!this.minDate) {
          var _minDate2 = new Date(newDate.getTime());

          this.$emit('pick', { minDate: _minDate2, maxDate: this.maxDate }, false);
          this.rangeState.selecting = true;
          this.markRange(this.minDate);
        }
      } else if (selectionMode === 'day') {
        this.$emit('pick', newDate);
      } else if (selectionMode === 'week') {
        var weekNumber = (0, _util.getWeekNumber)(newDate);

        var value = newDate.getFullYear() + 'w' + weekNumber;
        this.$emit('pick', {
          year: newDate.getFullYear(),
          week: weekNumber,
          value: value,
          date: newDate
        });
      }
    }
  }
};

/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('table',{staticClass:"el-date-table",class:{ 'is-week-mode': _vm.selectionMode === 'week' },attrs:{"cellspacing":"0","cellpadding":"0"},on:{"click":_vm.handleClick,"mousemove":_vm.handleMouseMove}},[_c('tbody',[_c('tr',[(_vm.showWeekNumber)?_c('th',[_vm._v(_vm._s(_vm.t('el.datepicker.week')))]):_vm._e(),_vm._l((_vm.WEEKS),function(week){return _c('th',[_vm._v(_vm._s(_vm.t('el.datepicker.weeks.' + week)))])})],2),_vm._l((_vm.rows),function(row){return _c('tr',{staticClass:"el-date-table__row",class:{ current: _vm.isWeekActive(row[1]) }},_vm._l((row),function(cell){return _c('td',{class:_vm.getCellClasses(cell)},[_c('div',[_c('span',[_vm._v("\n          "+_vm._s(cell.text)+"\n        ")])])])}))})],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-enter":_vm.handleEnter,"after-leave":_vm.handleLeave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-picker-panel el-date-picker el-popper",class:[{
      'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
      'has-time': _vm.showTime
    }, _vm.popperClass]},[_c('div',{staticClass:"el-picker-panel__body-wrapper"},[_vm._t("sidebar"),(_vm.shortcuts)?_c('div',{staticClass:"el-picker-panel__sidebar"},_vm._l((_vm.shortcuts),function(shortcut){return _c('button',{staticClass:"el-picker-panel__shortcut",attrs:{"type":"button"},on:{"click":function($event){_vm.handleShortcutClick(shortcut)}}},[_vm._v(_vm._s(shortcut.text))])})):_vm._e(),_c('div',{staticClass:"el-picker-panel__body"},[(_vm.showTime)?_c('div',{staticClass:"el-date-picker__time-header"},[_c('span',{staticClass:"el-date-picker__editor-wrap"},[_c('el-input',{attrs:{"placeholder":_vm.t('el.datepicker.selectDate'),"value":_vm.visibleDate,"size":"small"},nativeOn:{"change":function($event){_vm.handleVisibleDateChange($event)}}})],1),_c('span',{staticClass:"el-date-picker__editor-wrap"},[_c('el-input',{ref:"input",attrs:{"placeholder":_vm.t('el.datepicker.selectTime'),"value":_vm.visibleTime,"size":"small"},on:{"focus":function($event){_vm.timePickerVisible = !_vm.timePickerVisible}},nativeOn:{"change":function($event){_vm.handleVisibleTimeChange($event)}}}),_c('time-picker',{ref:"timepicker",attrs:{"time-arrow-control":_vm.arrowControl,"visible":_vm.timePickerVisible},on:{"pick":_vm.handleTimePick,"mounted":_vm.proxyTimePickerDataProperties}})],1)]):_vm._e(),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView !== 'time'),expression:"currentView !== 'time'"}],staticClass:"el-date-picker__header",class:{ 'el-date-picker__header--bordered': _vm.currentView === 'year' || _vm.currentView === 'month' }},[_c('button',{staticClass:"el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-d-arrow-left",attrs:{"type":"button","aria-label":_vm.t("el.datepicker.prevYear")},on:{"click":_vm.prevYear}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date'),expression:"currentView === 'date'"}],staticClass:"el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-arrow-left",attrs:{"type":"button","aria-label":_vm.t("el.datepicker.prevMonth")},on:{"click":_vm.prevMonth}}),_c('span',{staticClass:"el-date-picker__header-label",attrs:{"role":"button"},on:{"click":_vm.showYearPicker}},[_vm._v(_vm._s(_vm.yearLabel))]),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date'),expression:"currentView === 'date'"}],staticClass:"el-date-picker__header-label",class:{ active: _vm.currentView === 'month' },attrs:{"role":"button"},on:{"click":_vm.showMonthPicker}},[_vm._v(_vm._s(_vm.t(("el.datepicker.month" + (_vm.month + 1)))))]),_c('button',{staticClass:"el-picker-panel__icon-btn el-date-picker__next-btn el-icon-d-arrow-right",attrs:{"type":"button","aria-label":_vm.t("el.datepicker.nextYear")},on:{"click":_vm.nextYear}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date'),expression:"currentView === 'date'"}],staticClass:"el-picker-panel__icon-btn el-date-picker__next-btn el-icon-arrow-right",attrs:{"type":"button","aria-label":_vm.t("el.datepicker.nextMonth")},on:{"click":_vm.nextMonth}})]),_c('div',{staticClass:"el-picker-panel__content"},[_c('date-table',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date'),expression:"currentView === 'date'"}],attrs:{"selection-mode":_vm.selectionMode,"first-day-of-week":_vm.firstDayOfWeek,"value":new Date(_vm.value),"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"date":_vm.date,"disabled-date":_vm.disabledDate},on:{"pick":_vm.handleDatePick}}),_c('year-table',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'year'),expression:"currentView === 'year'"}],attrs:{"value":new Date(_vm.value),"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"date":_vm.date,"disabled-date":_vm.disabledDate},on:{"pick":_vm.handleYearPick}}),_c('month-table',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'month'),expression:"currentView === 'month'"}],attrs:{"value":new Date(_vm.value),"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"date":_vm.date,"disabled-date":_vm.disabledDate},on:{"pick":_vm.handleMonthPick}})],1)])],2),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.footerVisible && _vm.currentView === 'date'),expression:"footerVisible && currentView === 'date'"}],staticClass:"el-picker-panel__footer"},[_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"size":"mini","type":"text"},on:{"click":_vm.changeToNow}},[_vm._v("\n        "+_vm._s(_vm.t('el.datepicker.now'))+"\n      ")]),_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"plain":"","size":"mini"},on:{"click":_vm.confirm}},[_vm._v("\n        "+_vm._s(_vm.t('el.datepicker.confirm'))+"\n      ")])],1)])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_range_vue__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_range_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_range_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_46d9642a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_date_range_vue__ = __webpack_require__(191);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_date_range_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_46d9642a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_date_range_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _util = __webpack_require__(9);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _time = __webpack_require__(27);

var _time2 = _interopRequireDefault(_time);

var _dateTable = __webpack_require__(37);

var _dateTable2 = _interopRequireDefault(_dateTable);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _button = __webpack_require__(15);

var _button2 = _interopRequireDefault(_button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var advanceDate = function advanceDate(date, amount) {
  return new Date(new Date(date).getTime() + amount);
};

var calcDefaultValue = function calcDefaultValue(defaultValue) {
  if (Array.isArray(defaultValue)) {
    return [new Date(defaultValue[0]), new Date(defaultValue[1])];
  } else if (defaultValue) {
    return [new Date(defaultValue), advanceDate(defaultValue, 24 * 60 * 60 * 1000)];
  } else {
    return [new Date(), advanceDate(Date.now(), 24 * 60 * 60 * 1000)];
  }
};

exports.default = {
  mixins: [_locale2.default],

  computed: {
    btnDisabled: function btnDisabled() {
      return !(this.minDate && this.maxDate && !this.selecting);
    },
    leftLabel: function leftLabel() {
      return this.leftDate.getFullYear() + ' ' + this.t('el.datepicker.year') + ' ' + this.t('el.datepicker.month' + (this.leftDate.getMonth() + 1));
    },
    rightLabel: function rightLabel() {
      return this.rightDate.getFullYear() + ' ' + this.t('el.datepicker.year') + ' ' + this.t('el.datepicker.month' + (this.rightDate.getMonth() + 1));
    },
    leftYear: function leftYear() {
      return this.leftDate.getFullYear();
    },
    leftMonth: function leftMonth() {
      return this.leftDate.getMonth();
    },
    leftMonthDate: function leftMonthDate() {
      return this.leftDate.getDate();
    },
    rightYear: function rightYear() {
      return this.rightDate.getFullYear();
    },
    rightMonth: function rightMonth() {
      return this.rightDate.getMonth();
    },
    rightMonthDate: function rightMonthDate() {
      return this.rightDate.getDate();
    },
    minVisibleDate: function minVisibleDate() {
      return this.minDate ? (0, _util.formatDate)(this.minDate) : '';
    },
    maxVisibleDate: function maxVisibleDate() {
      return this.maxDate || this.minDate ? (0, _util.formatDate)(this.maxDate || this.minDate) : '';
    },
    minVisibleTime: function minVisibleTime() {
      return this.minDate ? (0, _util.formatDate)(this.minDate, 'HH:mm:ss') : '';
    },
    maxVisibleTime: function maxVisibleTime() {
      return this.maxDate || this.minDate ? (0, _util.formatDate)(this.maxDate || this.minDate, 'HH:mm:ss') : '';
    },
    dateFormat: function dateFormat() {
      if (this.format) {
        return this.format.replace('HH:mm', '').replace(':ss', '').trim();
      } else {
        return 'yyyy-MM-dd';
      }
    },
    timeFormat: function timeFormat() {
      if (this.format && this.format.indexOf('ss') === -1) {
        return 'HH:mm';
      } else {
        return 'HH:mm:ss';
      }
    },
    enableMonthArrow: function enableMonthArrow() {
      var nextMonth = (this.leftMonth + 1) % 12;
      var yearOffset = this.leftMonth + 1 >= 12 ? 1 : 0;
      return this.unlinkPanels && new Date(this.leftYear + yearOffset + '-' + (nextMonth + 1)) < new Date(this.rightYear + '-' + (this.rightMonth + 1));
    },
    enableYearArrow: function enableYearArrow() {
      return this.unlinkPanels && this.rightYear * 12 + this.rightMonth - (this.leftYear * 12 + this.leftMonth + 1) >= 12;
    }
  },

  data: function data() {
    return {
      popperClass: '',
      value: [],
      defaultValue: null,
      minDate: '',
      maxDate: '',
      leftDate: new Date(),
      rightDate: (0, _util.nextMonth)(new Date()),
      rangeState: {
        endDate: null,
        selecting: false,
        row: null,
        column: null
      },
      showTime: false,
      shortcuts: '',
      visible: '',
      disabledDate: '',
      firstDayOfWeek: 7,
      minTimePickerVisible: false,
      maxTimePickerVisible: false,
      format: '',
      arrowControl: false,
      unlinkPanels: false
    };
  },


  watch: {
    minDate: function minDate(val) {
      var _this = this;

      this.$nextTick(function () {
        if (_this.$refs.maxTimePicker && _this.maxDate && _this.maxDate < _this.minDate) {
          var format = 'HH:mm:ss';
          _this.$refs.maxTimePicker.selectableRange = [[(0, _util.parseDate)((0, _util.formatDate)(_this.minDate, format), format), (0, _util.parseDate)('23:59:59', format)]];
        }
      });
      if (val && this.$refs.minTimePicker) {
        this.$refs.minTimePicker.date = val;
        this.$refs.minTimePicker.value = val;
      }
    },
    maxDate: function maxDate(val) {
      if (val && this.$refs.maxTimePicker) {
        this.$refs.maxTimePicker.date = val;
        this.$refs.maxTimePicker.value = val;
      }
    },
    minTimePickerVisible: function minTimePickerVisible(val) {
      var _this2 = this;

      if (val) {
        this.$nextTick(function () {
          _this2.$refs.minTimePicker.date = _this2.minDate;
          _this2.$refs.minTimePicker.value = _this2.minDate;
          _this2.$refs.minTimePicker.adjustSpinners();
        });
      }
    },
    maxTimePickerVisible: function maxTimePickerVisible(val) {
      var _this3 = this;

      if (val) {
        this.$nextTick(function () {
          _this3.$refs.maxTimePicker.date = _this3.maxDate;
          _this3.$refs.maxTimePicker.value = _this3.maxDate;
          _this3.$refs.maxTimePicker.adjustSpinners();
        });
      }
    },
    value: function value(newVal) {
      if (!newVal) {
        this.minDate = null;
        this.maxDate = null;
      } else if (Array.isArray(newVal)) {
        this.minDate = (0, _util.isDate)(newVal[0]) ? new Date(newVal[0]) : null;
        this.maxDate = (0, _util.isDate)(newVal[1]) ? new Date(newVal[1]) : null;
        // NOTE: currently, maxDate = minDate + 1 month
        //       should allow them to be set individually in the future
        if (this.minDate) {
          this.leftDate = this.minDate;
          this.rightDate = this.unlinkPanels && this.maxDate ? this.maxDate : (0, _util.nextMonth)(this.leftDate);
        } else {
          this.leftDate = calcDefaultValue(this.defaultValue)[0];
          this.rightDate = (0, _util.nextMonth)(this.leftDate);
        }
      }
    },
    defaultValue: function defaultValue(val) {
      if (!Array.isArray(this.value)) {
        var _calcDefaultValue = calcDefaultValue(val),
            left = _calcDefaultValue[0],
            right = _calcDefaultValue[1];

        this.leftDate = left;
        this.rightDate = val && val[1] && this.unlinkPanels ? right : (0, _util.nextMonth)(this.leftDate);
      }
    }
  },

  methods: {
    handleClear: function handleClear() {
      this.minDate = null;
      this.maxDate = null;
      this.leftDate = calcDefaultValue(this.defaultValue)[0];
      this.rightDate = (0, _util.nextMonth)(this.leftDate);
      this.$emit('pick', null);
    },
    handleChangeRange: function handleChangeRange(val) {
      this.minDate = val.minDate;
      this.maxDate = val.maxDate;
      this.rangeState = val.rangeState;
    },
    handleDateInput: function handleDateInput(event, type) {
      var value = event.target.value;
      if (value.length !== this.dateFormat.length) return;
      var parsedValue = (0, _util.parseDate)(value, this.dateFormat);

      if (parsedValue) {
        if (typeof this.disabledDate === 'function' && this.disabledDate(new Date(parsedValue))) {
          return;
        }
        if (type === 'min') {
          this.minDate = new Date(parsedValue);
          this.leftDate = new Date(parsedValue);
          this.rightDate = (0, _util.nextMonth)(this.leftDate);
        } else {
          this.maxDate = new Date(parsedValue);
          this.leftDate = (0, _util.prevMonth)(parsedValue);
          this.rightDate = new Date(parsedValue);
        }
      }
    },
    handleDateChange: function handleDateChange(event, type) {
      var value = event.target.value;
      var parsedValue = (0, _util.parseDate)(value, this.dateFormat);
      if (parsedValue) {
        if (type === 'min') {
          this.minDate = (0, _util.modifyDate)(this.minDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
          if (this.minDate > this.maxDate) {
            this.maxDate = this.minDate;
          }
        } else {
          this.maxDate = (0, _util.modifyDate)(this.maxDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
          if (this.maxDate < this.minDate) {
            this.minDate = this.maxDate;
          }
        }
      }
    },
    handleTimeChange: function handleTimeChange(event, type) {
      var value = event.target.value;
      var parsedValue = (0, _util.parseDate)(value, this.timeFormat);
      if (parsedValue) {
        if (type === 'min') {
          this.minDate = (0, _util.modifyTime)(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
          if (this.minDate > this.maxDate) {
            this.maxDate = this.minDate;
          }
          this.$refs.minTimePicker.value = this.minDate;
          this.minTimePickerVisible = false;
        } else {
          this.maxDate = (0, _util.modifyTime)(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
          if (this.maxDate < this.minDate) {
            this.minDate = this.maxDate;
          }
          this.$refs.maxTimePicker.value = this.minDate;
          this.maxTimePickerVisible = false;
        }
      }
    },
    handleRangePick: function handleRangePick(val) {
      var _this4 = this;

      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (this.maxDate === val.maxDate && this.minDate === val.minDate) {
        return;
      }
      this.onPick && this.onPick(val);
      this.maxDate = val.maxDate;
      this.minDate = val.minDate;

      // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don't have to care about Chromium 55 - 57
      setTimeout(function () {
        _this4.maxDate = val.maxDate;
        _this4.minDate = val.minDate;
      }, 10);
      if (!close || this.showTime) return;
      this.handleConfirm();
    },
    handleShortcutClick: function handleShortcutClick(shortcut) {
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
    },
    handleMinTimePick: function handleMinTimePick(value, visible, first) {
      this.minDate = this.minDate || new Date();
      if (value) {
        this.minDate = (0, _util.modifyTime)(this.minDate, value.getHours(), value.getMinutes(), value.getSeconds());
      }

      if (!first) {
        this.minTimePickerVisible = visible;
      }

      if (this.maxDate && this.maxDate.getTime() < this.minDate.getTime()) {
        this.maxDate = new Date(this.minDate);
      }
    },
    handleMaxTimePick: function handleMaxTimePick(value, visible, first) {
      if (this.maxDate && value) {
        this.maxDate = (0, _util.modifyTime)(this.maxDate, value.getHours(), value.getMinutes(), value.getSeconds());
      }

      if (!first) {
        this.maxTimePickerVisible = visible;
      }

      if (this.maxDate && this.minDate && this.minDate.getTime() > this.maxDate.getTime()) {
        this.minDate = new Date(this.maxDate);
      }
    },
    leftPrevYear: function leftPrevYear() {
      this.leftDate = (0, _util.modifyDate)(this.leftDate, this.leftYear - 1, this.leftMonth, this.leftMonthDate);
      if (!this.unlinkPanels) {
        this.rightDate = (0, _util.nextMonth)(this.leftDate);
      }
    },
    leftNextYear: function leftNextYear() {
      this.leftDate = (0, _util.modifyDate)(this.leftDate, this.leftYear + 1, this.leftMonth, this.leftMonthDate);
    },
    leftPrevMonth: function leftPrevMonth() {
      this.leftDate = (0, _util.prevMonth)(this.leftDate);
      if (!this.unlinkPanels) {
        this.rightDate = (0, _util.nextMonth)(this.leftDate);
      }
    },
    leftNextMonth: function leftNextMonth() {
      this.leftDate = (0, _util.nextMonth)(this.leftDate);
    },
    rightPrevYear: function rightPrevYear() {
      this.rightDate = (0, _util.modifyDate)(this.rightDate, this.rightYear - 1, this.rightMonth, this.rightMonthDate);
    },
    rightNextYear: function rightNextYear() {
      if (!this.unlinkPanels) {
        this.leftDate = (0, _util.modifyDate)(this.leftDate, this.leftYear + 1, this.leftMonth, this.leftMonthDate);
        this.rightDate = (0, _util.nextMonth)(this.leftDate);
      } else {
        this.rightDate = (0, _util.modifyDate)(this.rightDate, this.rightYear + 1, this.rightMonth, this.rightMonthDate);
      }
    },
    rightPrevMonth: function rightPrevMonth() {
      this.rightDate = (0, _util.prevMonth)(this.rightDate);
    },
    rightNextMonth: function rightNextMonth() {
      if (!this.unlinkPanels) {
        this.leftDate = (0, _util.nextMonth)(this.leftDate);
        this.rightDate = (0, _util.nextMonth)(this.leftDate);
      } else {
        this.rightDate = (0, _util.nextMonth)(this.rightDate);
      }
    },
    handleConfirm: function handleConfirm() {
      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      this.$emit('pick', [this.minDate, this.maxDate], visible);
    },
    isValidValue: function isValidValue(value) {
      return Array.isArray(value) && value && value[0] && value[1] && (0, _util.isDate)(value[0]) && (0, _util.isDate)(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === 'function' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);
    }
  },

  components: { TimePicker: _time2.default, DateTable: _dateTable2.default, ElInput: _input2.default, ElButton: _button2.default }
};

/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":function($event){_vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-picker-panel el-date-range-picker el-popper",class:[{
      'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
      'has-time': _vm.showTime
    }, _vm.popperClass]},[_c('div',{staticClass:"el-picker-panel__body-wrapper"},[_vm._t("sidebar"),(_vm.shortcuts)?_c('div',{staticClass:"el-picker-panel__sidebar"},_vm._l((_vm.shortcuts),function(shortcut){return _c('button',{staticClass:"el-picker-panel__shortcut",attrs:{"type":"button"},on:{"click":function($event){_vm.handleShortcutClick(shortcut)}}},[_vm._v(_vm._s(shortcut.text))])})):_vm._e(),_c('div',{staticClass:"el-picker-panel__body"},[(_vm.showTime)?_c('div',{staticClass:"el-date-range-picker__time-header"},[_c('span',{staticClass:"el-date-range-picker__editors-wrap"},[_c('span',{staticClass:"el-date-range-picker__time-picker-wrap"},[_c('el-input',{ref:"minInput",staticClass:"el-date-range-picker__editor",attrs:{"size":"small","placeholder":_vm.t('el.datepicker.startDate'),"value":_vm.minVisibleDate},nativeOn:{"input":function($event){_vm.handleDateInput($event, 'min')},"change":function($event){_vm.handleDateChange($event, 'min')}}})],1),_c('span',{staticClass:"el-date-range-picker__time-picker-wrap"},[_c('el-input',{staticClass:"el-date-range-picker__editor",attrs:{"size":"small","placeholder":_vm.t('el.datepicker.startTime'),"value":_vm.minVisibleTime},on:{"focus":function($event){_vm.minTimePickerVisible = !_vm.minTimePickerVisible}},nativeOn:{"change":function($event){_vm.handleTimeChange($event, 'min')}}}),_c('time-picker',{ref:"minTimePicker",attrs:{"time-arrow-control":_vm.arrowControl,"visible":_vm.minTimePickerVisible},on:{"pick":_vm.handleMinTimePick,"mounted":function($event){_vm.$refs.minTimePicker.format=_vm.timeFormat}}})],1)]),_c('span',{staticClass:"el-icon-arrow-right"}),_c('span',{staticClass:"el-date-range-picker__editors-wrap is-right"},[_c('span',{staticClass:"el-date-range-picker__time-picker-wrap"},[_c('el-input',{staticClass:"el-date-range-picker__editor",attrs:{"size":"small","placeholder":_vm.t('el.datepicker.endDate'),"value":_vm.maxVisibleDate,"readonly":!_vm.minDate},nativeOn:{"input":function($event){_vm.handleDateInput($event, 'max')},"change":function($event){_vm.handleDateChange($event, 'max')}}})],1),_c('span',{staticClass:"el-date-range-picker__time-picker-wrap"},[_c('el-input',{ref:"maxInput",staticClass:"el-date-range-picker__editor",attrs:{"size":"small","placeholder":_vm.t('el.datepicker.endTime'),"value":_vm.maxVisibleTime,"readonly":!_vm.minDate},on:{"focus":function($event){_vm.minDate && (_vm.maxTimePickerVisible = !_vm.maxTimePickerVisible)}},nativeOn:{"change":function($event){_vm.handleTimeChange($event, 'max')}}}),_c('time-picker',{ref:"maxTimePicker",attrs:{"time-arrow-control":_vm.arrowControl,"visible":_vm.maxTimePickerVisible},on:{"pick":_vm.handleMaxTimePick,"mounted":function($event){_vm.$refs.maxTimePicker.format=_vm.timeFormat}}})],1)])]):_vm._e(),_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-left"},[_c('div',{staticClass:"el-date-range-picker__header"},[_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-d-arrow-left",attrs:{"type":"button"},on:{"click":_vm.leftPrevYear}}),_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-arrow-left",attrs:{"type":"button"},on:{"click":_vm.leftPrevMonth}}),(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-d-arrow-right",class:{ 'is-disabled': !_vm.enableYearArrow },attrs:{"type":"button","disabled":!_vm.enableYearArrow},on:{"click":_vm.leftNextYear}}):_vm._e(),(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-arrow-right",class:{ 'is-disabled': !_vm.enableMonthArrow },attrs:{"type":"button","disabled":!_vm.enableMonthArrow},on:{"click":_vm.leftNextMonth}}):_vm._e(),_c('div',[_vm._v(_vm._s(_vm.leftLabel))])]),_c('date-table',{attrs:{"selection-mode":"range","date":_vm.leftDate,"default-value":_vm.defaultValue,"min-date":_vm.minDate,"max-date":_vm.maxDate,"range-state":_vm.rangeState,"disabled-date":_vm.disabledDate,"first-day-of-week":_vm.firstDayOfWeek},on:{"changerange":_vm.handleChangeRange,"pick":_vm.handleRangePick}})],1),_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-right"},[_c('div',{staticClass:"el-date-range-picker__header"},[(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-d-arrow-left",class:{ 'is-disabled': !_vm.enableYearArrow },attrs:{"type":"button","disabled":!_vm.enableYearArrow},on:{"click":_vm.rightPrevYear}}):_vm._e(),(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-arrow-left",class:{ 'is-disabled': !_vm.enableMonthArrow },attrs:{"type":"button","disabled":!_vm.enableMonthArrow},on:{"click":_vm.rightPrevMonth}}):_vm._e(),_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-d-arrow-right",attrs:{"type":"button"},on:{"click":_vm.rightNextYear}}),_c('button',{staticClass:"el-picker-panel__icon-btn el-icon-arrow-right",attrs:{"type":"button"},on:{"click":_vm.rightNextMonth}}),_c('div',[_vm._v(_vm._s(_vm.rightLabel))])]),_c('date-table',{attrs:{"selection-mode":"range","date":_vm.rightDate,"default-value":_vm.defaultValue,"min-date":_vm.minDate,"max-date":_vm.maxDate,"range-state":_vm.rangeState,"disabled-date":_vm.disabledDate,"first-day-of-week":_vm.firstDayOfWeek},on:{"changerange":_vm.handleChangeRange,"pick":_vm.handleRangePick}})],1)])],2),(_vm.showTime)?_c('div',{staticClass:"el-picker-panel__footer"},[_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"size":"mini","type":"text"},on:{"click":_vm.handleClear}},[_vm._v("\n        "+_vm._s(_vm.t('el.datepicker.clear'))+"\n      ")]),_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"plain":"","size":"mini","disabled":_vm.btnDisabled},on:{"click":function($event){_vm.handleConfirm()}}},[_vm._v("\n        "+_vm._s(_vm.t('el.datepicker.confirm'))+"\n      ")])],1):_vm._e()])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _timeSelect = __webpack_require__(193);

var _timeSelect2 = _interopRequireDefault(_timeSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_timeSelect2.default.install = function (Vue) {
  Vue.component(_timeSelect2.default.name, _timeSelect2.default);
};

exports.default = _timeSelect2.default;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _picker = __webpack_require__(26);

var _picker2 = _interopRequireDefault(_picker);

var _timeSelect = __webpack_require__(194);

var _timeSelect2 = _interopRequireDefault(_timeSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_picker2.default],

  name: 'ElTimeSelect',

  beforeCreate: function beforeCreate() {
    this.type = 'time-select';
    this.panel = _timeSelect2.default;
  }
};

/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_select_vue__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_select_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_select_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2dfad182_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_select_vue__ = __webpack_require__(196);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_select_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2dfad182_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_select_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _scrollbar = __webpack_require__(19);

var _scrollbar2 = _interopRequireDefault(_scrollbar);

var _scrollIntoView = __webpack_require__(24);

var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var parseTime = function parseTime(time) {
  var values = (time || '').split(':');
  if (values.length >= 2) {
    var hours = parseInt(values[0], 10);
    var minutes = parseInt(values[1], 10);

    return {
      hours: hours,
      minutes: minutes
    };
  }
  /* istanbul ignore next */
  return null;
};

var compareTime = function compareTime(time1, time2) {
  var value1 = parseTime(time1);
  var value2 = parseTime(time2);

  var minutes1 = value1.minutes + value1.hours * 60;
  var minutes2 = value2.minutes + value2.hours * 60;

  if (minutes1 === minutes2) {
    return 0;
  }

  return minutes1 > minutes2 ? 1 : -1;
};

var formatTime = function formatTime(time) {
  return (time.hours < 10 ? '0' + time.hours : time.hours) + ':' + (time.minutes < 10 ? '0' + time.minutes : time.minutes);
};

var nextTime = function nextTime(time, step) {
  var timeValue = parseTime(time);
  var stepValue = parseTime(step);

  var next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes
  };

  next.minutes += stepValue.minutes;
  next.hours += stepValue.hours;

  next.hours += Math.floor(next.minutes / 60);
  next.minutes = next.minutes % 60;

  return formatTime(next);
};

exports.default = {
  components: { ElScrollbar: _scrollbar2.default },

  watch: {
    value: function value(val) {
      var _this = this;

      if (!val) return;
      this.$nextTick(function () {
        return _this.scrollToOption();
      });
    }
  },

  methods: {
    handleClick: function handleClick(item) {
      if (!item.disabled) {
        this.$emit('pick', item.value);
      }
    },
    handleClear: function handleClear() {
      this.$emit('pick', null);
    },
    scrollToOption: function scrollToOption() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.selected';

      var menu = this.$refs.popper.querySelector('.el-picker-panel__content');
      (0, _scrollIntoView2.default)(menu, menu.querySelector(selector));
    },
    handleMenuEnter: function handleMenuEnter() {
      var _this2 = this;

      var selected = this.items.map(function (item) {
        return item.value;
      }).indexOf(this.value) !== -1;
      var hasDefault = this.items.map(function (item) {
        return item.value;
      }).indexOf(this.defaultValue) !== -1;
      var option = selected && '.selected' || hasDefault && '.default' || '.time-select-item:not(.disabled)';
      this.$nextTick(function () {
        return _this2.scrollToOption(option);
      });
    },
    scrollDown: function scrollDown(step) {
      var items = this.items;
      var length = items.length;
      var total = items.length;
      var index = items.map(function (item) {
        return item.value;
      }).indexOf(this.value);
      while (total--) {
        index = (index + step + length) % length;
        if (!items[index].disabled) {
          this.$emit('pick', items[index].value, true);
          return;
        }
      }
    },
    isValidValue: function isValidValue(date) {
      return this.items.filter(function (item) {
        return !item.disabled;
      }).map(function (item) {
        return item.value;
      }).indexOf(date) !== -1;
    },
    handleKeydown: function handleKeydown(event) {
      var keyCode = event.keyCode;
      if (keyCode === 38 || keyCode === 40) {
        var mapping = { 40: 1, 38: -1 };
        var offset = mapping[keyCode.toString()];
        this.scrollDown(offset);
        event.stopPropagation();
        return;
      }
    }
  },

  data: function data() {
    return {
      popperClass: '',
      start: '09:00',
      end: '18:00',
      step: '00:30',
      value: '',
      defaultValue: '',
      visible: false,
      minTime: '',
      maxTime: '',
      width: 0
    };
  },


  computed: {
    items: function items() {
      var start = this.start;
      var end = this.end;
      var step = this.step;

      var result = [];

      if (start && end && step) {
        var current = start;
        while (compareTime(current, end) <= 0) {
          result.push({
            value: current,
            disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0
          });
          current = nextTime(current, step);
        }
      }

      return result;
    }
  }
};

/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"before-enter":_vm.handleMenuEnter,"after-leave":function($event){_vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],ref:"popper",staticClass:"el-picker-panel time-select el-popper",class:_vm.popperClass,style:({ width: _vm.width + 'px' })},[_c('el-scrollbar',{attrs:{"noresize":"","wrap-class":"el-picker-panel__content"}},_vm._l((_vm.items),function(item){return _c('div',{staticClass:"time-select-item",class:{ selected: _vm.value === item.value, disabled: item.disabled, default: item.value === _vm.defaultValue },attrs:{"disabled":item.disabled},on:{"click":function($event){_vm.handleClick(item)}}},[_vm._v(_vm._s(item.value))])}))],1)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _timePicker = __webpack_require__(198);

var _timePicker2 = _interopRequireDefault(_timePicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_timePicker2.default.install = function (Vue) {
  Vue.component(_timePicker2.default.name, _timePicker2.default);
};

exports.default = _timePicker2.default;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _picker = __webpack_require__(26);

var _picker2 = _interopRequireDefault(_picker);

var _time = __webpack_require__(27);

var _time2 = _interopRequireDefault(_time);

var _timeRange = __webpack_require__(199);

var _timeRange2 = _interopRequireDefault(_timeRange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_picker2.default],

  name: 'ElTimePicker',

  props: {
    isRange: Boolean,
    arrowControl: Boolean
  },

  data: function data() {
    return {
      type: ''
    };
  },


  watch: {
    isRange: function isRange(_isRange) {
      if (this.picker) {
        this.unmountPicker();
        this.type = _isRange ? 'timerange' : 'time';
        this.panel = _isRange ? _timeRange2.default : _time2.default;
        this.mountPicker();
      } else {
        this.type = _isRange ? 'timerange' : 'time';
        this.panel = _isRange ? _timeRange2.default : _time2.default;
      }
    }
  },

  created: function created() {
    this.type = this.isRange ? 'timerange' : 'time';
    this.panel = this.isRange ? _timeRange2.default : _time2.default;
  }
};

/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_range_vue__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_range_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_range_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_38ac964a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_range_vue__ = __webpack_require__(201);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_time_range_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_38ac964a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_time_range_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _util = __webpack_require__(9);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _timeSpinner = __webpack_require__(36);

var _timeSpinner2 = _interopRequireDefault(_timeSpinner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIN_TIME = (0, _util.parseDate)('00:00:00', 'HH:mm:ss'); //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var MAX_TIME = (0, _util.parseDate)('23:59:59', 'HH:mm:ss');

var minTimeOfDay = function minTimeOfDay(date) {
  return (0, _util.modifyDate)(MIN_TIME, date.getFullYear(), date.getMonth(), date.getDate());
};

var maxTimeOfDay = function maxTimeOfDay(date) {
  return (0, _util.modifyDate)(MAX_TIME, date.getFullYear(), date.getMonth(), date.getDate());
};

// increase time by amount of milliseconds, but within the range of day
var advanceTime = function advanceTime(date, amount) {
  return new Date(Math.min(date.getTime() + amount, maxTimeOfDay(date).getTime()));
};

exports.default = {
  mixins: [_locale2.default],

  components: { TimeSpinner: _timeSpinner2.default },

  computed: {
    showSeconds: function showSeconds() {
      return (this.format || '').indexOf('ss') !== -1;
    },
    offset: function offset() {
      return this.showSeconds ? 11 : 8;
    },
    spinner: function spinner() {
      return this.selectionRange[0] < this.offset ? this.$refs.minSpinner : this.$refs.maxSpinner;
    },
    btnDisabled: function btnDisabled() {
      return this.minDate.getTime() > this.maxDate.getTime();
    }
  },

  data: function data() {
    return {
      popperClass: '',
      minDate: new Date(),
      maxDate: new Date(),
      value: [],
      oldValue: [new Date(), new Date()],
      defaultValue: null,
      format: 'HH:mm:ss',
      visible: false,
      selectionRange: [0, 2],
      arrowControl: false
    };
  },


  watch: {
    value: function value(_value) {
      if (Array.isArray(_value)) {
        this.minDate = new Date(_value[0]);
        this.maxDate = new Date(_value[1]);
      } else {
        if (Array.isArray(this.defaultValue)) {
          this.minDate = new Date(this.defaultValue[0]);
          this.maxDate = new Date(this.defaultValue[1]);
        } else if (this.defaultValue) {
          this.minDate = new Date(this.defaultValue);
          this.maxDate = advanceTime(new Date(this.defaultValue), 60 * 60 * 1000);
        } else {
          this.minDate = new Date();
          this.maxDate = advanceTime(new Date(), 60 * 60 * 1000);
        }
      }
    },
    visible: function visible(val) {
      var _this = this;

      if (val) {
        this.oldValue = this.value;
        this.$nextTick(function () {
          return _this.$refs.minSpinner.emitSelectRange('hours');
        });
      }
    }
  },

  methods: {
    handleClear: function handleClear() {
      this.$emit('pick', null);
    },
    handleCancel: function handleCancel() {
      this.$emit('pick', this.oldValue);
    },
    handleMinChange: function handleMinChange(date) {
      this.minDate = (0, _util.clearMilliseconds)(date);
      this.handleChange();
    },
    handleMaxChange: function handleMaxChange(date) {
      this.maxDate = (0, _util.clearMilliseconds)(date);
      this.handleChange();
    },
    handleChange: function handleChange() {
      if (this.isValidValue([this.minDate, this.maxDate])) {
        this.$refs.minSpinner.selectableRange = [[minTimeOfDay(this.minDate), this.maxDate]];
        this.$refs.maxSpinner.selectableRange = [[this.minDate, maxTimeOfDay(this.maxDate)]];
        this.$emit('pick', [this.minDate, this.maxDate], true);
      }
    },
    setMinSelectionRange: function setMinSelectionRange(start, end) {
      this.$emit('select-range', start, end, 'min');
      this.selectionRange = [start, end];
    },
    setMaxSelectionRange: function setMaxSelectionRange(start, end) {
      this.$emit('select-range', start, end, 'max');
      this.selectionRange = [start + this.offset, end + this.offset];
    },
    handleConfirm: function handleConfirm() {
      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var minSelectableRange = this.$refs.minSpinner.selectableRange;
      var maxSelectableRange = this.$refs.maxSpinner.selectableRange;

      this.minDate = (0, _util.limitTimeRange)(this.minDate, minSelectableRange, this.format);
      this.maxDate = (0, _util.limitTimeRange)(this.maxDate, maxSelectableRange, this.format);

      this.$emit('pick', [this.minDate, this.maxDate], visible);
    },
    adjustSpinners: function adjustSpinners() {
      this.$refs.minSpinner.adjustSpinners();
      this.$refs.maxSpinner.adjustSpinners();
    },
    changeSelectionRange: function changeSelectionRange(step) {
      var list = this.showSeconds ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
      var mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
      var index = list.indexOf(this.selectionRange[0]);
      var next = (index + step + list.length) % list.length;
      var half = list.length / 2;
      if (next < half) {
        this.$refs.minSpinner.emitSelectRange(mapping[next]);
      } else {
        this.$refs.maxSpinner.emitSelectRange(mapping[next - half]);
      }
    },
    isValidValue: function isValidValue(date) {
      return Array.isArray(date) && (0, _util.timeWithinRange)(this.minDate, this.$refs.minSpinner.selectableRange) && (0, _util.timeWithinRange)(this.maxDate, this.$refs.maxSpinner.selectableRange);
    },
    handleKeydown: function handleKeydown(event) {
      var keyCode = event.keyCode;
      var mapping = { 38: -1, 40: 1, 37: -1, 39: 1 };

      // Left or Right
      if (keyCode === 37 || keyCode === 39) {
        var step = mapping[keyCode];
        this.changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      // Up or Down
      if (keyCode === 38 || keyCode === 40) {
        var _step = mapping[keyCode];
        this.spinner.scrollDown(_step);
        event.preventDefault();
        return;
      }
    }
  }
};

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":function($event){_vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-time-range-picker el-picker-panel el-popper",class:_vm.popperClass},[_c('div',{staticClass:"el-time-range-picker__content"},[_c('div',{staticClass:"el-time-range-picker__cell"},[_c('div',{staticClass:"el-time-range-picker__header"},[_vm._v(_vm._s(_vm.t('el.datepicker.startTime')))]),_c('div',{staticClass:"el-time-range-picker__body el-time-panel__content",class:{ 'has-seconds': _vm.showSeconds, 'is-arrow': _vm.arrowControl }},[_c('time-spinner',{ref:"minSpinner",attrs:{"show-seconds":_vm.showSeconds,"arrow-control":_vm.arrowControl,"date":_vm.minDate},on:{"change":_vm.handleMinChange,"select-range":_vm.setMinSelectionRange}})],1)]),_c('div',{staticClass:"el-time-range-picker__cell"},[_c('div',{staticClass:"el-time-range-picker__header"},[_vm._v(_vm._s(_vm.t('el.datepicker.endTime')))]),_c('div',{staticClass:"el-time-range-picker__body el-time-panel__content",class:{ 'has-seconds': _vm.showSeconds, 'is-arrow': _vm.arrowControl }},[_c('time-spinner',{ref:"maxSpinner",attrs:{"show-seconds":_vm.showSeconds,"arrow-control":_vm.arrowControl,"date":_vm.maxDate},on:{"change":_vm.handleMaxChange,"select-range":_vm.setMaxSelectionRange}})],1)])]),_c('div',{staticClass:"el-time-panel__footer"},[_c('button',{staticClass:"el-time-panel__btn cancel",attrs:{"type":"button"},on:{"click":function($event){_vm.handleCancel()}}},[_vm._v(_vm._s(_vm.t('el.datepicker.cancel')))]),_c('button',{staticClass:"el-time-panel__btn confirm",attrs:{"type":"button","disabled":_vm.btnDisabled},on:{"click":function($event){_vm.handleConfirm()}}},[_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))])])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(203);

var _main2 = _interopRequireDefault(_main);

var _directive = __webpack_require__(206);

var _directive2 = _interopRequireDefault(_directive);

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.directive('popover', _directive2.default);

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.directive('popover', _directive2.default);
  Vue.component(_main2.default.name, _main2.default);
};
_main2.default.directive = _directive2.default;

exports.default = _main2.default;

/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_14fd8dc3_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(205);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_14fd8dc3_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _dom = __webpack_require__(4);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElPopover',

  mixins: [_vuePopper2.default],

  props: {
    trigger: {
      type: String,
      default: 'click',
      validator: function validator(value) {
        return ['click', 'focus', 'hover', 'manual'].indexOf(value) > -1;
      }
    },
    openDelay: {
      type: Number,
      default: 0
    },
    title: String,
    disabled: Boolean,
    content: String,
    reference: {},
    popperClass: String,
    width: {},
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'fade-in-linear'
    }
  },

  computed: {
    tooltipId: function tooltipId() {
      return 'el-popover-' + (0, _util.generateId)();
    }
  },
  watch: {
    showPopper: function showPopper(newVal, oldVal) {
      newVal ? this.$emit('show') : this.$emit('hide');
    },

    '$refs.reference': {
      deep: true,
      handler: function handler(val) {
        console.log(val);
      }
    }
  },

  mounted: function mounted() {
    var reference = this.referenceElm = this.reference || this.$refs.reference;
    var popper = this.popper || this.$refs.popper;

    if (!reference && this.$slots.reference && this.$slots.reference[0]) {
      reference = this.referenceElm = this.$slots.reference[0].elm;
    }
    // 可访问性
    if (reference) {
      reference.className += ' el-tooltip';
      reference.setAttribute('aria-describedby', this.tooltipId);
      reference.setAttribute('tabindex', 0); // tab序列

      (0, _dom.on)(reference, 'focus', this.handleFocus);
      (0, _dom.on)(reference, 'blur', this.handleBlur);
      (0, _dom.on)(reference, 'keydown', this.handleKeydown);
      (0, _dom.on)(reference, 'click', this.handleClick);
    }
    if (this.trigger === 'click') {
      (0, _dom.on)(reference, 'click', this.doToggle);
      (0, _dom.on)(document, 'click', this.handleDocumentClick);
    } else if (this.trigger === 'hover') {
      (0, _dom.on)(reference, 'mouseenter', this.handleMouseEnter);
      (0, _dom.on)(popper, 'mouseenter', this.handleMouseEnter);
      (0, _dom.on)(reference, 'mouseleave', this.handleMouseLeave);
      (0, _dom.on)(popper, 'mouseleave', this.handleMouseLeave);
    } else if (this.trigger === 'focus') {
      var found = false;

      if ([].slice.call(reference.children).length) {
        var children = reference.childNodes;
        var len = children.length;
        for (var i = 0; i < len; i++) {
          if (children[i].nodeName === 'INPUT' || children[i].nodeName === 'TEXTAREA') {
            (0, _dom.on)(children[i], 'focus', this.doShow);
            (0, _dom.on)(children[i], 'blur', this.doClose);
            found = true;
            break;
          }
        }
      }
      if (found) return;
      if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
        (0, _dom.on)(reference, 'focus', this.doShow);
        (0, _dom.on)(reference, 'blur', this.doClose);
      } else {
        (0, _dom.on)(reference, 'mousedown', this.doShow);
        (0, _dom.on)(reference, 'mouseup', this.doClose);
      }
    }
  },


  methods: {
    doToggle: function doToggle() {
      this.showPopper = !this.showPopper;
    },
    doShow: function doShow() {
      this.showPopper = true;
    },
    doClose: function doClose() {
      this.showPopper = false;
    },
    handleFocus: function handleFocus() {
      var reference = this.referenceElm;
      reference.className += ' focusing';
      this.showPopper = true;
    },
    handleClick: function handleClick() {
      var reference = this.referenceElm;
      reference.className = reference.className.replace(/\s*focusing\s*/, ' ');
    },
    handleBlur: function handleBlur() {
      var reference = this.referenceElm;
      reference.className = reference.className.replace(/\s*focusing\s*/, ' ');
      this.showPopper = false;
    },
    handleMouseEnter: function handleMouseEnter() {
      var _this = this;

      clearTimeout(this._timer);
      if (this.openDelay) {
        this._timer = setTimeout(function () {
          _this.showPopper = true;
        }, this.openDelay);
      } else {
        this.showPopper = true;
      }
    },
    handleKeydown: function handleKeydown(ev) {
      if (ev.keyCode === 27) {
        // esc
        this.doClose();
      }
    },
    handleMouseLeave: function handleMouseLeave() {
      var _this2 = this;

      clearTimeout(this._timer);
      this._timer = setTimeout(function () {
        _this2.showPopper = false;
      }, 200);
    },
    handleDocumentClick: function handleDocumentClick(e) {
      var reference = this.reference || this.$refs.reference;
      var popper = this.popper || this.$refs.popper;

      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }
      if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target)) return;
      this.showPopper = false;
    }
  },

  destroyed: function destroyed() {
    var reference = this.reference;

    (0, _dom.off)(reference, 'click', this.doToggle);
    (0, _dom.off)(reference, 'mouseup', this.doClose);
    (0, _dom.off)(reference, 'mousedown', this.doShow);
    (0, _dom.off)(reference, 'focus', this.doShow);
    (0, _dom.off)(reference, 'blur', this.doClose);
    (0, _dom.off)(reference, 'mouseleave', this.handleMouseLeave);
    (0, _dom.off)(reference, 'mouseenter', this.handleMouseEnter);
    (0, _dom.off)(document, 'click', this.handleDocumentClick);
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',[_c('transition',{attrs:{"name":_vm.transition},on:{"after-leave":_vm.doDestroy}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.disabled && _vm.showPopper),expression:"!disabled && showPopper"}],ref:"popper",staticClass:"el-popover el-popper",class:[_vm.popperClass, _vm.content && 'el-popover--plain'],style:({ width: _vm.width + 'px' }),attrs:{"role":"tooltip","id":_vm.tooltipId,"aria-hidden":(_vm.disabled || !_vm.showPopper) ? 'true' : 'false'}},[(_vm.title)?_c('div',{staticClass:"el-popover__title",domProps:{"textContent":_vm._s(_vm.title)}}):_vm._e(),_vm._t("default",[_vm._v(_vm._s(_vm.content))])],2)]),_vm._t("reference")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  bind: function bind(el, binding, vnode) {
    vnode.context.$refs[binding.arg].$refs.reference = el;
  }
};

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(208);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _vdom = __webpack_require__(21);

var _util = __webpack_require__(3);

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElTooltip',

  mixins: [_vuePopper2.default],

  props: {
    openDelay: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    manual: Boolean,
    effect: {
      type: String,
      default: 'dark'
    },
    popperClass: String,
    content: String,
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'el-fade-in-linear'
    },
    popperOptions: {
      default: function _default() {
        return {
          boundariesPadding: 10,
          gpuAcceleration: false
        };
      }
    },
    enterable: {
      type: Boolean,
      default: true
    },
    hideAfter: {
      type: Number,
      default: 0
    }
  },

  data: function data() {
    return {
      timeoutPending: null,
      focusing: false
    };
  },

  computed: {
    tooltipId: function tooltipId() {
      return 'el-tooltip-' + (0, _util.generateId)();
    }
  },
  beforeCreate: function beforeCreate() {
    var _this = this;

    if (this.$isServer) return;

    this.popperVM = new _vue2.default({
      data: { node: '' },
      render: function render(h) {
        return this.node;
      }
    }).$mount();

    this.debounceClose = (0, _debounce2.default)(200, function () {
      return _this.handleClosePopper();
    });
  },
  render: function render(h) {
    var _this2 = this;

    if (this.popperVM) {
      this.popperVM.node = h(
        'transition',
        {
          attrs: {
            name: this.transition
          },
          on: {
            'afterLeave': this.doDestroy
          }
        },
        [h(
          'div',
          {
            on: {
              'mouseleave': function mouseleave() {
                _this2.setExpectedState(false);_this2.debounceClose();
              },
              'mouseenter': function mouseenter() {
                _this2.setExpectedState(true);
              }
            },

            ref: 'popper',
            attrs: { role: 'tooltip',
              id: this.tooltipId,
              'aria-hidden': this.disabled || !this.showPopper ? 'true' : 'false'
            },
            directives: [{
              name: 'show',
              value: !this.disabled && this.showPopper
            }],

            'class': ['el-tooltip__popper', 'is-' + this.effect, this.popperClass] },
          [this.$slots.content || this.content]
        )]
      );
    }

    if (!this.$slots.default || !this.$slots.default.length) return this.$slots.default;

    var vnode = (0, _vdom.getFirstComponentChild)(this.$slots.default);

    if (!vnode) return vnode;

    var data = vnode.data = vnode.data || {};
    var on = vnode.data.on = vnode.data.on || {};
    var nativeOn = vnode.data.nativeOn = vnode.data.nativeOn || {};

    data.staticClass = this.concatClass(data.staticClass, 'el-tooltip');
    nativeOn.mouseenter = on.mouseenter = this.addEventHandle(on.mouseenter, this.show);
    nativeOn.mouseleave = on.mouseleave = this.addEventHandle(on.mouseleave, this.hide);
    nativeOn.focus = on.focus = this.addEventHandle(on.focus, this.handleFocus);
    nativeOn.blur = on.blur = this.addEventHandle(on.blur, this.handleBlur);
    nativeOn.click = on.click = this.addEventHandle(on.click, function () {
      _this2.focusing = false;
    });
    return vnode;
  },
  mounted: function mounted() {
    this.referenceElm = this.$el;
    if (this.$el.nodeType === 1) {
      this.$el.setAttribute('aria-describedby', this.tooltipId);
      this.$el.setAttribute('tabindex', 0);
    }
  },

  watch: {
    focusing: function focusing(val) {
      if (val) {
        this.referenceElm.className += ' focusing';
      } else {
        this.referenceElm.className = this.referenceElm.className.replace('focusing', '');
      }
    }
  },
  methods: {
    show: function show() {
      this.setExpectedState(true);
      this.handleShowPopper();
    },
    hide: function hide() {
      this.setExpectedState(false);
      this.debounceClose();
    },
    handleFocus: function handleFocus() {
      this.focusing = true;
      this.show();
    },
    handleBlur: function handleBlur() {
      this.focusing = false;
      this.hide();
    },
    addEventHandle: function addEventHandle(old, fn) {
      if (!old) {
        return fn;
      } else if (Array.isArray(old)) {
        return old.indexOf(fn) > -1 ? old : old.concat(fn);
      } else {
        return old === fn ? old : [old, fn];
      }
    },
    concatClass: function concatClass(a, b) {
      if (a && a.indexOf(b) > -1) return a;
      return a ? b ? a + ' ' + b : a : b || '';
    },
    handleShowPopper: function handleShowPopper() {
      var _this3 = this;

      if (!this.expectedState || this.manual) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this3.showPopper = true;
      }, this.openDelay);

      if (this.hideAfter > 0) {
        this.timeoutPending = setTimeout(function () {
          _this3.showPopper = false;
        }, this.hideAfter);
      }
    },
    handleClosePopper: function handleClosePopper() {
      if (this.enterable && this.expectedState || this.manual) return;
      clearTimeout(this.timeout);

      if (this.timeoutPending) {
        clearTimeout(this.timeoutPending);
      }
      this.showPopper = false;
    },
    setExpectedState: function setExpectedState(expectedState) {
      if (expectedState === false) {
        clearTimeout(this.timeoutPending);
      }
      this.expectedState = expectedState;
    }
  }
};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(210);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _main2.default;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.MessageBox = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _main = __webpack_require__(211);

var _main2 = _interopRequireDefault(_main);

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

var _vdom = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaults = {
  title: undefined,
  message: '',
  type: '',
  showInput: false,
  showClose: true,
  modalFade: true,
  lockScroll: true,
  closeOnClickModal: true,
  closeOnPressEscape: true,
  closeOnHashChange: true,
  inputValue: null,
  inputPlaceholder: '',
  inputType: 'text',
  inputPattern: null,
  inputValidator: null,
  inputErrorMessage: '',
  showConfirmButton: true,
  showCancelButton: false,
  confirmButtonPosition: 'right',
  confirmButtonHighlight: false,
  cancelButtonHighlight: false,
  confirmButtonText: '',
  cancelButtonText: '',
  confirmButtonClass: '',
  cancelButtonClass: '',
  customClass: '',
  beforeClose: null,
  dangerouslyUseHTMLString: false,
  center: false,
  roundButton: false
};

var MessageBoxConstructor = _vue2.default.extend(_main2.default);

var currentMsg = void 0,
    instance = void 0;
var msgQueue = [];

var defaultCallback = function defaultCallback(action) {
  if (currentMsg) {
    var callback = currentMsg.callback;
    if (typeof callback === 'function') {
      if (instance.showInput) {
        callback(instance.inputValue, action);
      } else {
        callback(action);
      }
    }
    if (currentMsg.resolve) {
      if (action === 'confirm') {
        if (instance.showInput) {
          currentMsg.resolve({ value: instance.inputValue, action: action });
        } else {
          currentMsg.resolve(action);
        }
      } else if (action === 'cancel' && currentMsg.reject) {
        currentMsg.reject(action);
      }
    }
  }
};

var initInstance = function initInstance() {
  instance = new MessageBoxConstructor({
    el: document.createElement('div')
  });

  instance.callback = defaultCallback;
};

var showNextMsg = function showNextMsg() {
  if (!instance) {
    initInstance();
  }
  instance.action = '';

  if (!instance.visible || instance.closeTimer) {
    if (msgQueue.length > 0) {
      (function () {
        currentMsg = msgQueue.shift();

        var options = currentMsg.options;
        for (var prop in options) {
          if (options.hasOwnProperty(prop)) {
            instance[prop] = options[prop];
          }
        }
        if (options.callback === undefined) {
          instance.callback = defaultCallback;
        }

        var oldCb = instance.callback;
        instance.callback = function (action, instance) {
          oldCb(action, instance);
          showNextMsg();
        };
        if ((0, _vdom.isVNode)(instance.message)) {
          instance.$slots.default = [instance.message];
          instance.message = null;
        } else {
          delete instance.$slots.default;
        }
        ['modal', 'showClose', 'closeOnClickModal', 'closeOnPressEscape', 'closeOnHashChange'].forEach(function (prop) {
          if (instance[prop] === undefined) {
            instance[prop] = true;
          }
        });
        document.body.appendChild(instance.$el);

        _vue2.default.nextTick(function () {
          instance.visible = true;
        });
      })();
    }
  }
};

var MessageBox = function MessageBox(options, callback) {
  if (_vue2.default.prototype.$isServer) return;
  if (typeof options === 'string' || (0, _vdom.isVNode)(options)) {
    options = {
      message: options
    };
    if (typeof arguments[1] === 'string') {
      options.title = arguments[1];
    }
  } else if (options.callback && !callback) {
    callback = options.callback;
  }

  if (typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      // eslint-disable-line
      msgQueue.push({
        options: (0, _merge2.default)({}, defaults, MessageBox.defaults, options),
        callback: callback,
        resolve: resolve,
        reject: reject
      });

      showNextMsg();
    });
  } else {
    msgQueue.push({
      options: (0, _merge2.default)({}, defaults, MessageBox.defaults, options),
      callback: callback
    });

    showNextMsg();
  }
};

MessageBox.setDefaults = function (defaults) {
  MessageBox.defaults = defaults;
};

MessageBox.alert = function (message, title, options) {
  if ((typeof title === 'undefined' ? 'undefined' : _typeof(title)) === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }
  return MessageBox((0, _merge2.default)({
    title: title,
    message: message,
    $type: 'alert',
    closeOnPressEscape: false,
    closeOnClickModal: false
  }, options));
};

MessageBox.confirm = function (message, title, options) {
  if ((typeof title === 'undefined' ? 'undefined' : _typeof(title)) === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }
  return MessageBox((0, _merge2.default)({
    title: title,
    message: message,
    $type: 'confirm',
    showCancelButton: true
  }, options));
};

MessageBox.prompt = function (message, title, options) {
  if ((typeof title === 'undefined' ? 'undefined' : _typeof(title)) === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }
  return MessageBox((0, _merge2.default)({
    title: title,
    message: message,
    showCancelButton: true,
    showInput: true,
    $type: 'prompt'
  }, options));
};

MessageBox.close = function () {
  instance.visible = false;
  msgQueue = [];
  currentMsg = null;
};

exports.default = MessageBox;
exports.MessageBox = MessageBox;

/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f44daa3a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(214);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f44daa3a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _popup = __webpack_require__(17);

var _popup2 = _interopRequireDefault(_popup);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _button = __webpack_require__(15);

var _button2 = _interopRequireDefault(_button);

var _dom = __webpack_require__(4);

var _locale3 = __webpack_require__(16);

var _ariaDialog = __webpack_require__(213);

var _ariaDialog2 = _interopRequireDefault(_ariaDialog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var messageBox = void 0; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var typeMap = {
  success: 'success',
  info: 'info',
  warning: 'warning',
  error: 'error'
};

exports.default = {
  mixins: [_popup2.default, _locale2.default],

  props: {
    modal: {
      default: true
    },
    lockScroll: {
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      default: true
    },
    closeOnPressEscape: {
      default: true
    },
    closeOnHashChange: {
      default: true
    },
    center: {
      default: false,
      type: Boolean
    },
    roundButton: {
      default: false,
      type: Boolean
    }
  },

  components: {
    ElInput: _input2.default,
    ElButton: _button2.default
  },

  computed: {
    typeClass: function typeClass() {
      return this.type && typeMap[this.type] ? 'el-icon-' + typeMap[this.type] : '';
    },
    confirmButtonClasses: function confirmButtonClasses() {
      return 'el-button--primary ' + this.confirmButtonClass;
    },
    cancelButtonClasses: function cancelButtonClasses() {
      return '' + this.cancelButtonClass;
    }
  },

  methods: {
    handleComposition: function handleComposition(event) {
      var _this = this;

      if (event.type === 'compositionend') {
        setTimeout(function () {
          _this.isOnComposition = false;
        }, 100);
      } else {
        this.isOnComposition = true;
      }
    },
    handleKeyup: function handleKeyup() {
      !this.isOnComposition && this.handleAction('confirm');
    },
    getSafeClose: function getSafeClose() {
      var _this2 = this;

      var currentId = this.uid;
      return function () {
        _this2.$nextTick(function () {
          if (currentId === _this2.uid) _this2.doClose();
        });
      };
    },
    doClose: function doClose() {
      var _this3 = this;

      if (!this.visible) return;
      this.visible = false;
      this._closing = true;

      this.onClose && this.onClose();
      messageBox.closeDialog(); // 解绑
      if (this.lockScroll) {
        setTimeout(function () {
          if (_this3.modal && _this3.bodyOverflow !== 'hidden') {
            document.body.style.overflow = _this3.bodyOverflow;
            document.body.style.paddingRight = _this3.bodyPaddingRight;
          }
          _this3.bodyOverflow = null;
          _this3.bodyPaddingRight = null;
        }, 200);
      }
      this.opened = false;

      if (!this.transition) {
        this.doAfterClose();
      }
      setTimeout(function () {
        if (_this3.action) _this3.callback(_this3.action, _this3);
      });
    },
    handleWrapperClick: function handleWrapperClick() {
      if (this.closeOnClickModal) {
        this.handleAction('cancel');
      }
    },
    handleAction: function handleAction(action) {
      if (this.$type === 'prompt' && action === 'confirm' && !this.validate()) {
        return;
      }
      this.action = action;
      if (typeof this.beforeClose === 'function') {
        this.close = this.getSafeClose();
        this.beforeClose(action, this, this.close);
      } else {
        this.doClose();
      }
    },
    validate: function validate() {
      if (this.$type === 'prompt') {
        var inputPattern = this.inputPattern;
        if (inputPattern && !inputPattern.test(this.inputValue || '')) {
          this.editorErrorMessage = this.inputErrorMessage || (0, _locale3.t)('el.messagebox.error');
          (0, _dom.addClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
          return false;
        }
        var inputValidator = this.inputValidator;
        if (typeof inputValidator === 'function') {
          var validateResult = inputValidator(this.inputValue);
          if (validateResult === false) {
            this.editorErrorMessage = this.inputErrorMessage || (0, _locale3.t)('el.messagebox.error');
            (0, _dom.addClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
            return false;
          }
          if (typeof validateResult === 'string') {
            this.editorErrorMessage = validateResult;
            return false;
          }
        }
      }
      this.editorErrorMessage = '';
      (0, _dom.removeClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
      return true;
    },
    getFistFocus: function getFistFocus() {
      var $btns = this.$el.querySelector('.el-message-box__btns .el-button');
      var $title = this.$el.querySelector('.el-message-box__btns .el-message-box__title');
      return $btns && $btns[0] || $title;
    }
  },

  watch: {
    inputValue: {
      immediate: true,
      handler: function handler(val) {
        var _this4 = this;

        this.$nextTick(function (_) {
          if (_this4.$type === 'prompt' && val !== null) {
            _this4.validate();
          }
        });
      }
    },

    visible: function visible(val) {
      var _this5 = this;

      if (val) {
        this.uid++;
        if (this.$type === 'alert' || this.$type === 'confirm') {
          this.$nextTick(function () {
            _this5.$refs.confirm.$el.focus();
          });
        }
        this.focusAfterClosed = document.activeElement;
        messageBox = new _ariaDialog2.default(this.$el, this.focusAfterClosed, this.getFistFocus());
      };

      // prompt
      if (this.$type !== 'prompt') return;
      if (val) {
        setTimeout(function () {
          if (_this5.$refs.input && _this5.$refs.input.$el) {
            _this5.$refs.input.$el.querySelector('input').focus();
          }
        }, 500);
      } else {
        this.editorErrorMessage = '';
        (0, _dom.removeClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
      }
    }
  },

  mounted: function mounted() {
    if (this.closeOnHashChange) {
      window.addEventListener('hashchange', this.close);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.closeOnHashChange) {
      window.removeEventListener('hashchange', this.close);
    }
    setTimeout(function () {
      messageBox.closeDialog();
    });
  },
  data: function data() {
    return {
      uid: 1,
      title: undefined,
      message: '',
      type: '',
      customClass: '',
      showInput: false,
      inputValue: null,
      inputPlaceholder: '',
      inputType: 'text',
      inputPattern: null,
      inputValidator: null,
      inputErrorMessage: '',
      showConfirmButton: true,
      showCancelButton: false,
      action: '',
      confirmButtonText: '',
      cancelButtonText: '',
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonClass: '',
      confirmButtonDisabled: false,
      cancelButtonClass: '',
      editorErrorMessage: null,
      callback: null,
      dangerouslyUseHTMLString: false,
      focusAfterClosed: null,
      isOnComposition: false
    };
  }
};

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("n3D3");

/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"msgbox-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-message-box__wrapper",attrs:{"tabindex":"-1","role":"dialog","aria-modal":"true","aria-label":_vm.title || 'dialog'},on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }_vm.handleWrapperClick($event)}}},[_c('div',{staticClass:"el-message-box",class:[_vm.customClass, _vm.center && 'el-message-box--center']},[(_vm.title !== undefined)?_c('div',{staticClass:"el-message-box__header"},[_c('div',{staticClass:"el-message-box__title"},[(_vm.typeClass && _vm.center)?_c('div',{staticClass:"el-message-box__status",class:[ _vm.typeClass ]}):_vm._e(),_c('span',[_vm._v(_vm._s(_vm.title))])]),(_vm.showClose)?_c('button',{staticClass:"el-message-box__headerbtn",attrs:{"type":"button","aria-label":"Close"},on:{"click":function($event){_vm.handleAction('cancel')},"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.handleAction('cancel')}}},[_c('i',{staticClass:"el-message-box__close el-icon-close"})]):_vm._e()]):_vm._e(),(_vm.message !== '')?_c('div',{staticClass:"el-message-box__content"},[(_vm.typeClass && !_vm.center)?_c('div',{staticClass:"el-message-box__status",class:[ _vm.typeClass ]}):_vm._e(),_c('div',{staticClass:"el-message-box__message"},[_vm._t("default",[(!_vm.dangerouslyUseHTMLString)?_c('p',[_vm._v(_vm._s(_vm.message))]):_c('p',{domProps:{"innerHTML":_vm._s(_vm.message)}})])],2),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showInput),expression:"showInput"}],staticClass:"el-message-box__input"},[_c('el-input',{ref:"input",attrs:{"type":_vm.inputType,"placeholder":_vm.inputPlaceholder},nativeOn:{"compositionstart":function($event){_vm.handleComposition($event)},"compositionupdate":function($event){_vm.handleComposition($event)},"compositionend":function($event){_vm.handleComposition($event)},"keyup":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.handleKeyup($event)}},model:{value:(_vm.inputValue),callback:function ($$v) {_vm.inputValue=$$v},expression:"inputValue"}}),_c('div',{staticClass:"el-message-box__errormsg",style:({ visibility: !!_vm.editorErrorMessage ? 'visible' : 'hidden' })},[_vm._v(_vm._s(_vm.editorErrorMessage))])],1)]):_vm._e(),_c('div',{staticClass:"el-message-box__btns"},[_c('el-button',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCancelButton),expression:"showCancelButton"}],class:[ _vm.cancelButtonClasses ],attrs:{"loading":_vm.cancelButtonLoading,"round":_vm.roundButton,"size":"small"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.handleAction('cancel')}},nativeOn:{"click":function($event){_vm.handleAction('cancel')}}},[_vm._v("\n          "+_vm._s(_vm.cancelButtonText || _vm.t('el.messagebox.cancel'))+"\n        ")]),_c('el-button',{directives:[{name:"show",rawName:"v-show",value:(_vm.showConfirmButton),expression:"showConfirmButton"}],ref:"confirm",class:[ _vm.confirmButtonClasses ],attrs:{"loading":_vm.confirmButtonLoading,"round":_vm.roundButton,"size":"small"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.handleAction('confirm')}},nativeOn:{"click":function($event){_vm.handleAction('confirm')}}},[_vm._v("\n          "+_vm._s(_vm.confirmButtonText || _vm.t('el.messagebox.confirm'))+"\n        ")])],1)])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _breadcrumb = __webpack_require__(216);

var _breadcrumb2 = _interopRequireDefault(_breadcrumb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_breadcrumb2.default.install = function (Vue) {
  Vue.component(_breadcrumb2.default.name, _breadcrumb2.default);
};

exports.default = _breadcrumb2.default;

/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_vue__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_19d7ebd5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_breadcrumb_vue__ = __webpack_require__(218);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_19d7ebd5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_breadcrumb_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//

exports.default = {
  name: 'ElBreadcrumb',

  props: {
    separator: {
      type: String,
      default: '/'
    },
    separatorClass: {
      type: String,
      default: ''
    }
  },

  provide: function provide() {
    return {
      elBreadcrumb: this
    };
  },
  mounted: function mounted() {
    var items = this.$el.querySelectorAll('.el-breadcrumb__item');
    items[items.length - 1].setAttribute('aria-current', 'page');
  }
};

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-breadcrumb",attrs:{"aria-label":"Breadcrumb","role":"navigation"}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _breadcrumbItem = __webpack_require__(220);

var _breadcrumbItem2 = _interopRequireDefault(_breadcrumbItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_breadcrumbItem2.default.install = function (Vue) {
  Vue.component(_breadcrumbItem2.default.name, _breadcrumbItem2.default);
};

exports.default = _breadcrumbItem2.default;

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_item_vue__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_item_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4d50178a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_breadcrumb_item_vue__ = __webpack_require__(222);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_breadcrumb_item_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4d50178a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_breadcrumb_item_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElBreadcrumbItem',
  props: {
    to: {},
    replace: Boolean
  },
  data: function data() {
    return {
      separator: '',
      separatorClass: ''
    };
  },


  inject: ['elBreadcrumb'],

  mounted: function mounted() {
    var _this = this;

    this.separator = this.elBreadcrumb.separator;
    this.separatorClass = this.elBreadcrumb.separatorClass;
    var self = this;
    if (this.to) {
      var link = this.$refs.link;
      link.setAttribute('role', 'link');
      link.addEventListener('click', function (_) {
        var to = _this.to;
        self.replace ? self.$router.replace(to) : self.$router.push(to);
      });
    }
  }
};

/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"el-breadcrumb__item"},[_c('span',{ref:"link",staticClass:"el-breadcrumb__inner",attrs:{"role":"link"}},[_vm._t("default")],2),(_vm.separatorClass)?_c('i',{staticClass:"el-breadcrumb__separator",class:_vm.separatorClass}):_c('span',{staticClass:"el-breadcrumb__separator",attrs:{"role":"presentation"}},[_vm._v(_vm._s(_vm.separator))])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _form = __webpack_require__(224);

var _form2 = _interopRequireDefault(_form);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_form2.default.install = function (Vue) {
  Vue.component(_form2.default.name, _form2.default);
};

exports.default = _form2.default;

/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_vue__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0876c296_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_form_vue__ = __webpack_require__(226);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0876c296_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_form_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElForm',

  componentName: 'ElForm',

  provide: function provide() {
    return {
      elForm: this
    };
  },


  props: {
    model: Object,
    rules: Object,
    labelPosition: String,
    labelWidth: String,
    labelSuffix: {
      type: String,
      default: ''
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String
  },
  watch: {
    rules: function rules() {
      this.validate();
    }
  },
  data: function data() {
    return {
      fields: []
    };
  },
  created: function created() {
    var _this = this;

    this.$on('el.form.addField', function (field) {
      if (field) {
        _this.fields.push(field);
      }
    });
    /* istanbul ignore next */
    this.$on('el.form.removeField', function (field) {
      if (field.prop) {
        _this.fields.splice(_this.fields.indexOf(field), 1);
      }
    });
  },

  methods: {
    resetFields: function resetFields() {
      if (!this.model) {
        "production" !== 'production' && console.warn('[Element Warn][Form]model is required for resetFields to work.');
        return;
      }
      this.fields.forEach(function (field) {
        field.resetField();
      });
    },
    clearValidate: function clearValidate() {
      this.fields.forEach(function (field) {
        field.clearValidate();
      });
    },
    validate: function validate(callback) {
      var _this2 = this;

      if (!this.model) {
        console.warn('[Element Warn][Form]model is required for validate to work!');
        return;
      }

      var promise = void 0;
      // if no callback, return promise
      if (typeof callback !== 'function' && window.Promise) {
        promise = new window.Promise(function (resolve, reject) {
          callback = function callback(valid) {
            valid ? resolve(valid) : reject(valid);
          };
        });
      }

      var valid = true;
      var count = 0;
      // 如果需要验证的fields为空，调用验证时立刻返回callback
      if (this.fields.length === 0 && callback) {
        callback(true);
      }
      this.fields.forEach(function (field, index) {
        field.validate('', function (errors) {
          if (errors) {
            valid = false;
          }
          if (typeof callback === 'function' && ++count === _this2.fields.length) {
            callback(valid);
          }
        });
      });

      if (promise) {
        return promise;
      }
    },
    validateField: function validateField(prop, cb) {
      var field = this.fields.filter(function (field) {
        return field.prop === prop;
      })[0];
      if (!field) {
        throw new Error('must call validateField with valid prop string!');
      }

      field.validate('', cb);
    }
  }
};

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('form',{staticClass:"el-form",class:[
  _vm.labelPosition ? 'el-form--label-' + _vm.labelPosition : '',
  { 'el-form--inline': _vm.inline }
]},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _formItem = __webpack_require__(228);

var _formItem2 = _interopRequireDefault(_formItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_formItem2.default.install = function (Vue) {
  Vue.component(_formItem2.default.name, _formItem2.default);
};

exports.default = _formItem2.default;

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_item_vue__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_item_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f06fe54a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_form_item_vue__ = __webpack_require__(231);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_form_item_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f06fe54a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_form_item_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _asyncValidator = __webpack_require__(230);

var _asyncValidator2 = _interopRequireDefault(_asyncValidator);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElFormItem',

  componentName: 'ElFormItem',

  mixins: [_emitter2.default],

  provide: function provide() {
    return {
      elFormItem: this
    };
  },


  inject: ['elForm'],

  props: {
    label: String,
    labelWidth: String,
    prop: String,
    required: {
      type: Boolean,
      default: undefined
    },
    rules: [Object, Array],
    error: String,
    validateStatus: String,
    for: String,
    inlineMessage: {
      type: [String, Boolean],
      default: ''
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String
  },
  watch: {
    error: function error(value) {
      this.validateMessage = value;
      this.validateState = value ? 'error' : '';
    },
    validateStatus: function validateStatus(value) {
      this.validateState = value;
    }
  },
  computed: {
    labelFor: function labelFor() {
      return this.for || this.prop;
    },
    labelStyle: function labelStyle() {
      var ret = {};
      if (this.form.labelPosition === 'top') return ret;
      var labelWidth = this.labelWidth || this.form.labelWidth;
      if (labelWidth) {
        ret.width = labelWidth;
      }
      return ret;
    },
    contentStyle: function contentStyle() {
      var ret = {};
      var label = this.label;
      if (this.form.labelPosition === 'top' || this.form.inline) return ret;
      if (!label && !this.labelWidth && this.isNested) return ret;
      var labelWidth = this.labelWidth || this.form.labelWidth;
      if (labelWidth) {
        ret.marginLeft = labelWidth;
      }
      return ret;
    },
    form: function form() {
      var parent = this.$parent;
      var parentName = parent.$options.componentName;
      while (parentName !== 'ElForm') {
        if (parentName === 'ElFormItem') {
          this.isNested = true;
        }
        parent = parent.$parent;
        parentName = parent.$options.componentName;
      }
      return parent;
    },

    fieldValue: {
      cache: false,
      get: function get() {
        var model = this.form.model;
        if (!model || !this.prop) {
          return;
        }

        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }

        return (0, _util.getPropByPath)(model, path, true).v;
      }
    },
    isRequired: function isRequired() {
      var rules = this.getRules();
      var isRequired = false;

      if (rules && rules.length) {
        rules.every(function (rule) {
          if (rule.required) {
            isRequired = true;
            return false;
          }
          return true;
        });
      }
      return isRequired;
    },
    _formSize: function _formSize() {
      return this.elForm.size;
    },
    elFormItemSize: function elFormItemSize() {
      return this.size || this._formSize;
    },
    sizeClass: function sizeClass() {
      return (this.$ELEMENT || {}).size || this.elFormItemSize;
    }
  },
  data: function data() {
    return {
      validateState: '',
      validateMessage: '',
      validateDisabled: false,
      validator: {},
      isNested: false
    };
  },

  methods: {
    validate: function validate(trigger) {
      var _this = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.noop;

      this.validateDisabled = false;
      var rules = this.getFilteredRule(trigger);
      if ((!rules || rules.length === 0) && this.required === undefined) {
        callback();
        return true;
      }

      this.validateState = 'validating';

      var descriptor = {};
      descriptor[this.prop] = rules;

      var validator = new _asyncValidator2.default(descriptor);
      var model = {};

      model[this.prop] = this.fieldValue;

      validator.validate(model, { firstFields: true }, function (errors, fields) {
        _this.validateState = !errors ? 'success' : 'error';
        _this.validateMessage = errors ? errors[0].message : '';

        callback(_this.validateMessage);
      });
    },
    clearValidate: function clearValidate() {
      this.validateState = '';
      this.validateMessage = '';
      this.validateDisabled = false;
    },
    resetField: function resetField() {
      this.validateState = '';
      this.validateMessage = '';

      var model = this.form.model;
      var value = this.fieldValue;
      var path = this.prop;
      if (path.indexOf(':') !== -1) {
        path = path.replace(/:/, '.');
      }

      var prop = (0, _util.getPropByPath)(model, path, true);

      if (Array.isArray(value)) {
        this.validateDisabled = true;
        prop.o[prop.k] = [].concat(this.initialValue);
      } else {
        this.validateDisabled = true;
        prop.o[prop.k] = this.initialValue;
      }
    },
    getRules: function getRules() {
      var formRules = this.form.rules;
      var selfRules = this.rules;
      var requiredRule = this.required !== undefined ? { required: !!this.required } : [];

      formRules = formRules ? formRules[this.prop] : [];

      return [].concat(selfRules || formRules || []).concat(requiredRule);
    },
    getFilteredRule: function getFilteredRule(trigger) {
      var rules = this.getRules();

      return rules.filter(function (rule) {
        return !rule.trigger || rule.trigger.indexOf(trigger) !== -1;
      });
    },
    onFieldBlur: function onFieldBlur() {
      this.validate('blur');
    },
    onFieldChange: function onFieldChange() {
      if (this.validateDisabled) {
        this.validateDisabled = false;
        return;
      }

      this.validate('change');
    }
  },
  mounted: function mounted() {
    if (this.prop) {
      this.dispatch('ElForm', 'el.form.addField', [this]);

      var initialValue = this.fieldValue;
      if (Array.isArray(initialValue)) {
        initialValue = [].concat(initialValue);
      }
      Object.defineProperty(this, 'initialValue', {
        value: initialValue
      });

      var rules = this.getRules();

      if (rules.length || this.required !== undefined) {
        this.$on('el.form.blur', this.onFieldBlur);
        this.$on('el.form.change', this.onFieldChange);
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.dispatch('ElForm', 'el.form.removeField', [this]);
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("V0fI");

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-form-item",class:[{
    'el-form-item--feedback': _vm.elForm && _vm.elForm.statusIcon,
    'is-error': _vm.validateState === 'error',
    'is-validating': _vm.validateState === 'validating',
    'is-success': _vm.validateState === 'success',
    'is-required': _vm.isRequired || _vm.required
  },
  _vm.sizeClass ? 'el-form-item--' + _vm.sizeClass : ''
]},[(_vm.label || _vm.$slots.label)?_c('label',{staticClass:"el-form-item__label",style:(_vm.labelStyle),attrs:{"for":_vm.labelFor}},[_vm._t("label",[_vm._v(_vm._s(_vm.label + _vm.form.labelSuffix))])],2):_vm._e(),_c('div',{staticClass:"el-form-item__content",style:(_vm.contentStyle)},[_vm._t("default"),_c('transition',{attrs:{"name":"el-zoom-in-top"}},[(_vm.validateState === 'error' && _vm.showMessage && _vm.form.showMessage)?_c('div',{staticClass:"el-form-item__error",class:{
          'el-form-item__error--inline': typeof _vm.inlineMessage === 'boolean'
            ? _vm.inlineMessage
            : (_vm.elForm && _vm.elForm.inlineMessage || false)
        }},[_vm._v("\n        "+_vm._s(_vm.validateMessage)+"\n      ")]):_vm._e()])],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tabs = __webpack_require__(233);

var _tabs2 = _interopRequireDefault(_tabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_tabs2.default.install = function (Vue) {
  Vue.component(_tabs2.default.name, _tabs2.default);
};

exports.default = _tabs2.default;

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tabs_vue__ = __webpack_require__(234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tabs_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tabs_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tabs_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tabNav = __webpack_require__(235);

var _tabNav2 = _interopRequireDefault(_tabNav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElTabs',

  components: {
    TabNav: _tabNav2.default
  },

  props: {
    type: String,
    activeName: String,
    closable: Boolean,
    addable: Boolean,
    value: {},
    editable: Boolean,
    tabPosition: {
      type: String,
      default: 'top'
    }
  },

  provide: function provide() {
    return {
      rootTabs: this
    };
  },
  data: function data() {
    return {
      currentName: this.value || this.activeName,
      panes: []
    };
  },


  watch: {
    activeName: function activeName(value) {
      this.setCurrentName(value);
    },
    value: function value(_value) {
      this.setCurrentName(_value);
    },
    currentName: function currentName(value) {
      var _this = this;

      if (this.$refs.nav) {
        this.$nextTick(function (_) {
          _this.$refs.nav.scrollToActiveTab();
        });
      }
    }
  },

  methods: {
    handleTabClick: function handleTabClick(tab, tabName, event) {
      if (tab.disabled) return;
      this.setCurrentName(tabName);
      this.$emit('tab-click', tab, event);
    },
    handleTabRemove: function handleTabRemove(pane, ev) {
      if (pane.disabled) return;
      ev.stopPropagation();
      this.$emit('edit', pane.name, 'remove');
      this.$emit('tab-remove', pane.name);
    },
    handleTabAdd: function handleTabAdd() {
      this.$emit('edit', null, 'add');
      this.$emit('tab-add');
    },
    setCurrentName: function setCurrentName(value) {
      this.currentName = value;
      this.$emit('input', value);
    },
    addPanes: function addPanes(item) {
      var index = this.$slots.default.filter(function (item) {
        return item.elm.nodeType === 1 && /\bel-tab-pane\b/.test(item.elm.className);
      }).indexOf(item.$vnode);
      this.panes.splice(index, 0, item);
    },
    removePanes: function removePanes(item) {
      var panes = this.panes;
      var index = panes.indexOf(item);
      if (index > -1) {
        panes.splice(index, 1);
      }
    }
  },
  render: function render(h) {
    var _ref;

    var type = this.type,
        handleTabClick = this.handleTabClick,
        handleTabRemove = this.handleTabRemove,
        handleTabAdd = this.handleTabAdd,
        currentName = this.currentName,
        panes = this.panes,
        editable = this.editable,
        addable = this.addable,
        tabPosition = this.tabPosition;


    var newButton = editable || addable ? h(
      'span',
      {
        'class': 'el-tabs__new-tab',
        on: {
          'click': handleTabAdd,
          'keydown': function keydown(ev) {
            if (ev.keyCode === 13) {
              handleTabAdd();
            }
          }
        },
        attrs: {
          tabindex: '0'
        }
      },
      [h(
        'i',
        { 'class': 'el-icon-plus' },
        []
      )]
    ) : null;

    var navData = {
      props: {
        currentName: currentName,
        onTabClick: handleTabClick,
        onTabRemove: handleTabRemove,
        editable: editable,
        type: type,
        panes: panes
      },
      ref: 'nav'
    };
    var header = h(
      'div',
      { 'class': 'el-tabs__header' },
      [newButton, h(
        'tab-nav',
        navData,
        []
      )]
    );
    var panels = h(
      'div',
      { 'class': 'el-tabs__content' },
      [this.$slots.default]
    );

    return h(
      'div',
      { 'class': (_ref = {
          'el-tabs': true,
          'el-tabs--card': type === 'card'
        }, _ref['el-tabs--' + tabPosition] = true, _ref['el-tabs--border-card'] = type === 'border-card', _ref) },
      [tabPosition !== 'bottom' ? [header, panels] : [panels, header]]
    );
  },
  created: function created() {
    if (!this.currentName) {
      this.setCurrentName('0');
    }
  }
};

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_nav_vue__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_nav_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_nav_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_nav_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tabBar = __webpack_require__(237);

var _tabBar2 = _interopRequireDefault(_tabBar);

var _resizeEvent = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function noop() {}
var firstUpperCase = function firstUpperCase(str) {
  return str.toLowerCase().replace(/( |^)[a-z]/g, function (L) {
    return L.toUpperCase();
  });
};

exports.default = {
  name: 'TabNav',

  components: {
    TabBar: _tabBar2.default
  },

  inject: ['rootTabs'],

  props: {
    panes: Array,
    currentName: String,
    editable: Boolean,
    onTabClick: {
      type: Function,
      default: noop
    },
    onTabRemove: {
      type: Function,
      default: noop
    },
    type: String
  },

  data: function data() {
    return {
      scrollable: false,
      navOffset: 0,
      isFocus: false
    };
  },


  computed: {
    navStyle: function navStyle() {
      var dir = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'X' : 'Y';
      return {
        transform: 'translate' + dir + '(-' + this.navOffset + 'px)'
      };
    },
    sizeName: function sizeName() {
      return ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';
    }
  },

  methods: {
    scrollPrev: function scrollPrev() {
      var containerSize = this.$refs.navScroll['offset' + firstUpperCase(this.sizeName)];
      var currentOffset = this.navOffset;

      if (!currentOffset) return;

      var newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;

      this.navOffset = newOffset;
    },
    scrollNext: function scrollNext() {
      var navSize = this.$refs.nav['offset' + firstUpperCase(this.sizeName)];
      var containerSize = this.$refs.navScroll['offset' + firstUpperCase(this.sizeName)];
      var currentOffset = this.navOffset;

      if (navSize - currentOffset <= containerSize) return;

      var newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;

      this.navOffset = newOffset;
    },
    scrollToActiveTab: function scrollToActiveTab() {
      if (!this.scrollable) return;
      var nav = this.$refs.nav;
      var activeTab = this.$el.querySelector('.is-active');
      var navScroll = this.$refs.navScroll;
      var activeTabBounding = activeTab.getBoundingClientRect();
      var navScrollBounding = navScroll.getBoundingClientRect();
      var navBounding = nav.getBoundingClientRect();
      var currentOffset = this.navOffset;
      var newOffset = currentOffset;

      if (activeTabBounding.left < navScrollBounding.left) {
        newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
      }
      if (activeTabBounding.right > navScrollBounding.right) {
        newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
      }
      if (navBounding.right < navScrollBounding.right) {
        newOffset = nav.offsetWidth - navScrollBounding.width;
      }
      this.navOffset = Math.max(newOffset, 0);
    },
    update: function update() {
      if (!this.$refs.nav) return;
      var sizeName = this.sizeName;
      var navSize = this.$refs.nav['offset' + firstUpperCase(sizeName)];
      var containerSize = this.$refs.navScroll['offset' + firstUpperCase(sizeName)];
      var currentOffset = this.navOffset;

      if (containerSize < navSize) {
        var _currentOffset = this.navOffset;
        this.scrollable = this.scrollable || {};
        this.scrollable.prev = _currentOffset;
        this.scrollable.next = _currentOffset + containerSize < navSize;
        if (navSize - _currentOffset < containerSize) {
          this.navOffset = navSize - containerSize;
        }
      } else {
        this.scrollable = false;
        if (currentOffset > 0) {
          this.navOffset = 0;
        }
      }
    },
    changeTab: function changeTab(e) {
      var keyCode = e.keyCode;
      var nextIndex = void 0;
      var currentIndex = void 0,
          tabList = void 0;
      if ([37, 38, 39, 40].indexOf(keyCode) !== -1) {
        // 左右上下键更换tab
        tabList = e.currentTarget.querySelectorAll('[role=tab]');
        currentIndex = Array.prototype.indexOf.call(tabList, e.target);
      } else {
        return;
      }
      if (keyCode === 37 || keyCode === 38) {
        // left
        if (currentIndex === 0) {
          // first
          nextIndex = tabList.length - 1;
        } else {
          nextIndex = currentIndex - 1;
        }
      } else {
        // right
        if (currentIndex < tabList.length - 1) {
          // not last
          nextIndex = currentIndex + 1;
        } else {
          nextIndex = 0;
        }
      }
      tabList[nextIndex].focus(); // 改变焦点元素
      tabList[nextIndex].click(); // 选中下一个tab
    },
    setFocus: function setFocus() {
      this.isFocus = true;
    },
    removeFocus: function removeFocus() {
      this.isFocus = false;
    }
  },

  updated: function updated() {
    this.update();
  },
  render: function render(h) {
    var _this = this;

    var type = this.type,
        panes = this.panes,
        editable = this.editable,
        onTabClick = this.onTabClick,
        onTabRemove = this.onTabRemove,
        navStyle = this.navStyle,
        scrollable = this.scrollable,
        scrollNext = this.scrollNext,
        scrollPrev = this.scrollPrev,
        changeTab = this.changeTab,
        setFocus = this.setFocus,
        removeFocus = this.removeFocus;

    var scrollBtn = scrollable ? [h(
      'span',
      { 'class': ['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'], on: {
          'click': scrollPrev
        }
      },
      [h(
        'i',
        { 'class': 'el-icon-arrow-left' },
        []
      )]
    ), h(
      'span',
      { 'class': ['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled'], on: {
          'click': scrollNext
        }
      },
      [h(
        'i',
        { 'class': 'el-icon-arrow-right' },
        []
      )]
    )] : null;

    var tabs = this._l(panes, function (pane, index) {
      var tabName = pane.name || pane.index || index;
      var closable = pane.isClosable || editable;

      pane.index = '' + index;

      var btnClose = closable ? h(
        'span',
        { 'class': 'el-icon-close', on: {
            'click': function click(ev) {
              onTabRemove(pane, ev);
            }
          }
        },
        []
      ) : null;

      var tabLabelContent = pane.$slots.label || pane.label;
      var tabindex = pane.active ? 0 : -1;
      return h(
        'div',
        {
          'class': {
            'el-tabs__item': true,
            'is-active': pane.active,
            'is-disabled': pane.disabled,
            'is-closable': closable,
            'is-focus': _this.isFocus
          },
          attrs: { id: 'tab-' + tabName,
            'aria-controls': 'pane-' + tabName,
            role: 'tab',
            'aria-selected': pane.active,

            tabindex: tabindex
          },
          ref: 'tabs', refInFor: true,
          on: {
            'focus': function focus() {
              setFocus();
            },
            'blur': function blur() {
              removeFocus();
            },
            'click': function click(ev) {
              removeFocus();onTabClick(pane, tabName, ev);
            },
            'keydown': function keydown(ev) {
              if (closable && (ev.keyCode === 46 || ev.keyCode === 8)) {
                onTabRemove(pane, ev);
              }
            }
          }
        },
        [tabLabelContent, btnClose]
      );
    });
    return h(
      'div',
      { 'class': ['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : ''] },
      [scrollBtn, h(
        'div',
        { 'class': ['el-tabs__nav-scroll'], ref: 'navScroll' },
        [h(
          'div',
          { 'class': 'el-tabs__nav', ref: 'nav', style: navStyle, attrs: { role: 'tablist' },
            on: {
              'keydown': changeTab
            }
          },
          [!type ? h(
            'tab-bar',
            {
              attrs: { tabs: panes }
            },
            []
          ) : null, tabs]
        )]
      )]
    );
  },
  mounted: function mounted() {
    (0, _resizeEvent.addResizeListener)(this.$el, this.update);
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$el && this.update) (0, _resizeEvent.removeResizeListener)(this.$el, this.update);
  }
};

/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_bar_vue__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_bar_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_bar_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_9a42dc98_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tab_bar_vue__ = __webpack_require__(239);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_bar_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_9a42dc98_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tab_bar_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//

exports.default = {
  name: 'TabBar',

  props: {
    tabs: Array
  },

  inject: ['rootTabs'],

  computed: {
    barStyle: {
      cache: false,
      get: function get() {
        var _this = this;

        if (!this.$parent.$refs.tabs) return {};
        var style = {};
        var offset = 0;
        var tabSize = 0;
        var sizeName = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';
        var sizeDir = sizeName === 'width' ? 'x' : 'y';
        var firstUpperCase = function firstUpperCase(str) {
          return str.toLowerCase().replace(/( |^)[a-z]/g, function (L) {
            return L.toUpperCase();
          });
        };
        this.tabs.every(function (tab, index) {
          var $el = _this.$parent.$refs.tabs[index];
          if (!$el) {
            return false;
          }

          if (!tab.active) {
            offset += $el['client' + firstUpperCase(sizeName)];
            return true;
          } else {
            tabSize = $el['client' + firstUpperCase(sizeName)];
            if (sizeName === 'width') {
              tabSize -= index === 0 ? 20 : 40;
            }
            return false;
          }
        });

        if (sizeName === 'width' && offset !== 0) {
          offset += 20;
        }
        var transform = 'translate' + firstUpperCase(sizeDir) + '(' + offset + 'px)';
        style[sizeName] = tabSize + 'px';
        style.transform = transform;
        style.msTransform = transform;
        style.webkitTransform = transform;

        return style;
      }
    }
  }
};

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-tabs__active-bar",style:(_vm.barStyle)})}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tabPane = __webpack_require__(241);

var _tabPane2 = _interopRequireDefault(_tabPane);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_tabPane2.default.install = function (Vue) {
  Vue.component(_tabPane2.default.name, _tabPane2.default);
};

exports.default = _tabPane2.default;

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_pane_vue__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_pane_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_pane_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_53570e97_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tab_pane_vue__ = __webpack_require__(243);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tab_pane_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_53570e97_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tab_pane_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElTabPane',

  componentName: 'ElTabPane',

  props: {
    label: String,
    labelContent: Function,
    name: String,
    closable: Boolean,
    disabled: Boolean
  },

  data: function data() {
    return {
      index: null
    };
  },


  computed: {
    isClosable: function isClosable() {
      return this.closable || this.$parent.closable;
    },
    active: function active() {
      return this.$parent.currentName === (this.name || this.index);
    },
    paneName: function paneName() {
      return this.name || this.index;
    }
  },

  mounted: function mounted() {
    this.$parent.addPanes(this);
  },
  destroyed: function destroyed() {
    if (this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
    this.$parent.removePanes(this);
  },


  watch: {
    label: function label() {
      this.$parent.$forceUpdate();
    }
  }
};

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.active),expression:"active"}],staticClass:"el-tab-pane",attrs:{"role":"tabpanel","aria-hidden":!_vm.active,"id":("pane-" + _vm.paneName),"aria-labelledby":("tab-" + _vm.paneName)}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tag = __webpack_require__(245);

var _tag2 = _interopRequireDefault(_tag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_tag2.default.install = function (Vue) {
  Vue.component(_tag2.default.name, _tag2.default);
};

exports.default = _tag2.default;

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_466877f5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tag_vue__ = __webpack_require__(247);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_466877f5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tag_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElTag',
  props: {
    text: String,
    closable: Boolean,
    type: String,
    hit: Boolean,
    disableTransitions: Boolean,
    color: String,
    size: String
  },
  methods: {
    handleClose: function handleClose(event) {
      this.$emit('close', event);
    }
  },
  computed: {
    tagSize: function tagSize() {
      return this.size || (this.$ELEMENT || {}).size;
    }
  }
};

/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.disableTransitions ? '' : 'el-zoom-in-center'}},[_c('span',{staticClass:"el-tag",class:[
      _vm.type ? 'el-tag--' + _vm.type : '',
      _vm.tagSize && ("el-tag--" + _vm.tagSize),
      {'is-hit': _vm.hit}
    ],style:({backgroundColor: _vm.color})},[_vm._t("default"),(_vm.closable)?_c('i',{staticClass:"el-tag__close el-icon-close",on:{"click":_vm.handleClose}}):_vm._e()],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tree = __webpack_require__(249);

var _tree2 = _interopRequireDefault(_tree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_tree2.default.install = function (Vue) {
  Vue.component(_tree2.default.name, _tree2.default);
};

exports.default = _tree2.default;

/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_vue__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_bdd5d816_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tree_vue__ = __webpack_require__(256);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_bdd5d816_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tree_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _treeStore = __webpack_require__(251);

var _treeStore2 = _interopRequireDefault(_treeStore);

var _treeNode = __webpack_require__(253);

var _treeNode2 = _interopRequireDefault(_treeNode);

var _locale = __webpack_require__(16);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElTree',

  mixins: [_emitter2.default],

  components: {
    ElTreeNode: _treeNode2.default
  },

  data: function data() {
    return {
      store: null,
      root: null,
      currentNode: null,
      treeItems: null,
      checkboxItems: []
    };
  },


  props: {
    data: {
      type: Array
    },
    emptyText: {
      type: String,
      default: function _default() {
        return (0, _locale.t)('el.tree.emptyText');
      }
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    props: {
      default: function _default() {
        return {
          children: 'children',
          label: 'label',
          icon: 'icon',
          disabled: 'disabled'
        };
      }
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    }
  },

  computed: {
    children: {
      set: function set(value) {
        this.data = value;
      },
      get: function get() {
        return this.data;
      }
    },
    treeItemArray: function treeItemArray() {
      return Array.prototype.slice.call(this.treeItems);
    }
  },

  watch: {
    defaultCheckedKeys: function defaultCheckedKeys(newVal) {
      this.store.defaultCheckedKeys = newVal;
      this.store.setDefaultCheckedKey(newVal);
    },
    defaultExpandedKeys: function defaultExpandedKeys(newVal) {
      this.store.defaultExpandedKeys = newVal;
      this.store.setDefaultExpandedKeys(newVal);
    },
    data: function data(newVal) {
      this.store.setData(newVal);
    },
    checkboxItems: function checkboxItems(val) {
      Array.prototype.forEach.call(val, function (checkbox) {
        checkbox.setAttribute('tabindex', -1);
      });
    }
  },

  methods: {
    filter: function filter(value) {
      if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');
      this.store.filter(value);
    },
    getNodeKey: function getNodeKey(node, index) {
      var nodeKey = this.nodeKey;
      if (nodeKey && node) {
        return node.data[nodeKey];
      }
      return index;
    },
    getCheckedNodes: function getCheckedNodes(leafOnly) {
      return this.store.getCheckedNodes(leafOnly);
    },
    getCheckedKeys: function getCheckedKeys(leafOnly) {
      return this.store.getCheckedKeys(leafOnly);
    },
    getCurrentNode: function getCurrentNode() {
      var currentNode = this.store.getCurrentNode();
      return currentNode ? currentNode.data : null;
    },
    getCurrentKey: function getCurrentKey() {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getCurrentKey');
      var currentNode = this.getCurrentNode();
      return currentNode ? currentNode[this.nodeKey] : null;
    },
    setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
      this.store.setCheckedNodes(nodes, leafOnly);
    },
    setCheckedKeys: function setCheckedKeys(keys, leafOnly) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');
      this.store.setCheckedKeys(keys, leafOnly);
    },
    setChecked: function setChecked(data, checked, deep) {
      this.store.setChecked(data, checked, deep);
    },
    setCurrentNode: function setCurrentNode(node) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentNode');
      this.store.setUserCurrentNode(node);
    },
    setCurrentKey: function setCurrentKey(key) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentKey');
      this.store.setCurrentNodeKey(key);
    },
    handleNodeExpand: function handleNodeExpand(nodeData, node, instance) {
      this.broadcast('ElTreeNode', 'tree-node-expand', node);
      this.$emit('node-expand', nodeData, node, instance);
    },
    updateKeyChildren: function updateKeyChildren(key, data) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in updateKeyChild');
      this.store.updateChildren(key, data);
    },
    initTabindex: function initTabindex() {
      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
      this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
      var checkedItem = this.$el.querySelectorAll('.is-checked[role=treeitem]');
      if (checkedItem.length) {
        checkedItem[0].setAttribute('tabindex', 0);
        return;
      }
      this.treeItems[0].setAttribute('tabindex', 0);
    },
    handelKeydown: function handelKeydown(ev) {
      var currentItem = ev.target;
      var keyCode = ev.keyCode;
      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
      var currentIndex = this.treeItemArray.indexOf(currentItem);
      var nextIndex = void 0;
      if ([38, 40].includes(keyCode)) {
        // up、down
        if (keyCode === 38) {
          // up
          nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
        } else {
          nextIndex = currentIndex < this.treeItemArray.length - 1 ? currentIndex + 1 : 0;
        }
        this.treeItemArray[nextIndex].focus(); // 选中
      }
      var hasInput = currentItem.querySelector('[type="checkbox"]');
      if ([37, 39].includes(keyCode)) {
        // left、right 展开
        currentItem.click(); // 选中
      }
      if ([13, 32].includes(keyCode)) {
        // space enter选中checkbox
        if (hasInput) {
          hasInput.click();
        }
        ev.stopPropagation();
        ev.preventDefault();
      }
    }
  },

  created: function created() {
    this.isTree = true;

    this.store = new _treeStore2.default({
      key: this.nodeKey,
      data: this.data,
      lazy: this.lazy,
      props: this.props,
      load: this.load,
      currentNodeKey: this.currentNodeKey,
      checkStrictly: this.checkStrictly,
      checkDescendants: this.checkDescendants,
      defaultCheckedKeys: this.defaultCheckedKeys,
      defaultExpandedKeys: this.defaultExpandedKeys,
      autoExpandParent: this.autoExpandParent,
      defaultExpandAll: this.defaultExpandAll,
      filterNodeMethod: this.filterNodeMethod
    });

    this.root = this.store.root;
  },
  mounted: function mounted() {
    this.initTabindex();
    this.$el.addEventListener('keydown', this.handelKeydown);
  },
  updated: function updated() {
    this.treeItems = this.$el.querySelectorAll('[role=treeitem]');
    this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
  }
};

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _node = __webpack_require__(252);

var _node2 = _interopRequireDefault(_node);

var _util = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TreeStore = function () {
  function TreeStore(options) {
    var _this = this;

    _classCallCheck(this, TreeStore);

    this.currentNode = null;
    this.currentNodeKey = null;

    for (var option in options) {
      if (options.hasOwnProperty(option)) {
        this[option] = options[option];
      }
    }

    this.nodesMap = {};

    this.root = new _node2.default({
      data: this.data,
      store: this
    });

    if (this.lazy && this.load) {
      var loadFn = this.load;
      loadFn(this.root, function (data) {
        _this.root.doCreateChildren(data);
        _this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }

  TreeStore.prototype.filter = function filter(value) {
    var filterNodeMethod = this.filterNodeMethod;
    var traverse = function traverse(node) {
      var childNodes = node.root ? node.root.childNodes : node.childNodes;

      childNodes.forEach(function (child) {
        child.visible = filterNodeMethod.call(child, value, child.data, child);

        traverse(child);
      });

      if (!node.visible && childNodes.length) {
        var allHidden = true;

        childNodes.forEach(function (child) {
          if (child.visible) allHidden = false;
        });

        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (!value) return;

      if (node.visible && !node.isLeaf) node.expand();
    };

    traverse(this);
  };

  TreeStore.prototype.setData = function setData(newVal) {
    var instanceChanged = newVal !== this.root.data;
    this.root.setData(newVal);
    if (instanceChanged) {
      this._initDefaultCheckedNodes();
    }
  };

  TreeStore.prototype.getNode = function getNode(data) {
    var key = (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' ? data : (0, _util.getNodeKey)(this.key, data);
    return this.nodesMap[key];
  };

  TreeStore.prototype.insertBefore = function insertBefore(data, refData) {
    var refNode = this.getNode(refData);
    refNode.parent.insertBefore({ data: data }, refNode);
  };

  TreeStore.prototype.insertAfter = function insertAfter(data, refData) {
    var refNode = this.getNode(refData);
    refNode.parent.insertAfter({ data: data }, refNode);
  };

  TreeStore.prototype.remove = function remove(data) {
    var node = this.getNode(data);
    if (node) {
      node.parent.removeChild(node);
    }
  };

  TreeStore.prototype.append = function append(data, parentData) {
    var parentNode = parentData ? this.getNode(parentData) : this.root;

    if (parentNode) {
      parentNode.insertChild({ data: data });
    }
  };

  TreeStore.prototype._initDefaultCheckedNodes = function _initDefaultCheckedNodes() {
    var _this2 = this;

    var defaultCheckedKeys = this.defaultCheckedKeys || [];
    var nodesMap = this.nodesMap;

    defaultCheckedKeys.forEach(function (checkedKey) {
      var node = nodesMap[checkedKey];

      if (node) {
        node.setChecked(true, !_this2.checkStrictly);
      }
    });
  };

  TreeStore.prototype._initDefaultCheckedNode = function _initDefaultCheckedNode(node) {
    var defaultCheckedKeys = this.defaultCheckedKeys || [];

    if (defaultCheckedKeys.indexOf(node.key) !== -1) {
      node.setChecked(true, !this.checkStrictly);
    }
  };

  TreeStore.prototype.setDefaultCheckedKey = function setDefaultCheckedKey(newVal) {
    if (newVal !== this.defaultCheckedKeys) {
      this.defaultCheckedKeys = newVal;
      this._initDefaultCheckedNodes();
    }
  };

  TreeStore.prototype.registerNode = function registerNode(node) {
    var key = this.key;
    if (!key || !node || !node.data) return;

    var nodeKey = node.key;
    if (nodeKey !== undefined) this.nodesMap[node.key] = node;
  };

  TreeStore.prototype.deregisterNode = function deregisterNode(node) {
    var key = this.key;
    if (!key || !node || !node.data) return;

    var childNodes = node.childNodes;
    for (var i = 0, j = childNodes.length; i < j; i++) {
      var child = childNodes[i];
      this.deregisterNode(child);
    }

    delete this.nodesMap[node.key];
  };

  TreeStore.prototype.getCheckedNodes = function getCheckedNodes() {
    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var checkedNodes = [];
    var traverse = function traverse(node) {
      var childNodes = node.root ? node.root.childNodes : node.childNodes;

      childNodes.forEach(function (child) {
        if (!leafOnly && child.checked || leafOnly && child.isLeaf && child.checked) {
          checkedNodes.push(child.data);
        }

        traverse(child);
      });
    };

    traverse(this);

    return checkedNodes;
  };

  TreeStore.prototype.getCheckedKeys = function getCheckedKeys() {
    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var key = this.key;
    var allNodes = this._getAllNodes();
    var keys = [];
    allNodes.forEach(function (node) {
      if (!leafOnly || leafOnly && node.isLeaf) {
        if (node.checked) {
          keys.push((node.data || {})[key]);
        }
      }
    });
    return keys;
  };

  TreeStore.prototype._getAllNodes = function _getAllNodes() {
    var allNodes = [];
    var nodesMap = this.nodesMap;
    for (var nodeKey in nodesMap) {
      if (nodesMap.hasOwnProperty(nodeKey)) {
        allNodes.push(nodesMap[nodeKey]);
      }
    }

    return allNodes;
  };

  TreeStore.prototype.updateChildren = function updateChildren(key, data) {
    var node = this.nodesMap[key];
    if (!node) return;
    var childNodes = node.childNodes;
    for (var i = childNodes.length - 1; i >= 0; i--) {
      var child = childNodes[i];
      this.remove(child.data);
    }
    for (var _i = 0, j = data.length; _i < j; _i++) {
      var _child = data[_i];
      this.append(_child, node.data);
    }
  };

  TreeStore.prototype._setCheckedKeys = function _setCheckedKeys(key) {
    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var checkedKeys = arguments[2];

    var allNodes = this._getAllNodes().sort(function (a, b) {
      return b.level - a.level;
    });
    var cache = Object.create(null);
    var keys = Object.keys(checkedKeys);
    allNodes.forEach(function (node) {
      return node.setChecked(false, false);
    });
    for (var i = 0, j = allNodes.length; i < j; i++) {
      var node = allNodes[i];
      var nodeKey = node.data[key].toString();
      var checked = keys.indexOf(nodeKey) > -1;
      if (!checked) {
        if (node.checked && !cache[nodeKey]) {
          node.setChecked(false, false);
        }
        continue;
      }

      var parent = node.parent;
      while (parent && parent.level > 0) {
        cache[parent.data[key]] = true;
        parent = parent.parent;
      }

      if (node.isLeaf || this.checkStrictly) {
        node.setChecked(true, false);
        continue;
      }
      node.setChecked(true, true);

      if (leafOnly) {
        (function () {
          node.setChecked(false, false);
          var traverse = function traverse(node) {
            var childNodes = node.childNodes;
            childNodes.forEach(function (child) {
              if (!child.isLeaf) {
                child.setChecked(false, false);
              }
              traverse(child);
            });
          };
          traverse(node);
        })();
      }
    }
  };

  TreeStore.prototype.setCheckedNodes = function setCheckedNodes(array) {
    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var key = this.key;
    var checkedKeys = {};
    array.forEach(function (item) {
      checkedKeys[(item || {})[key]] = true;
    });

    this._setCheckedKeys(key, leafOnly, checkedKeys);
  };

  TreeStore.prototype.setCheckedKeys = function setCheckedKeys(keys) {
    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this.defaultCheckedKeys = keys;
    var key = this.key;
    var checkedKeys = {};
    keys.forEach(function (key) {
      checkedKeys[key] = true;
    });

    this._setCheckedKeys(key, leafOnly, checkedKeys);
  };

  TreeStore.prototype.setDefaultExpandedKeys = function setDefaultExpandedKeys(keys) {
    var _this3 = this;

    keys = keys || [];
    this.defaultExpandedKeys = keys;

    keys.forEach(function (key) {
      var node = _this3.getNode(key);
      if (node) node.expand(null, _this3.autoExpandParent);
    });
  };

  TreeStore.prototype.setChecked = function setChecked(data, checked, deep) {
    var node = this.getNode(data);

    if (node) {
      node.setChecked(!!checked, deep);
    }
  };

  TreeStore.prototype.getCurrentNode = function getCurrentNode() {
    return this.currentNode;
  };

  TreeStore.prototype.setCurrentNode = function setCurrentNode(node) {
    this.currentNode = node;
  };

  TreeStore.prototype.setUserCurrentNode = function setUserCurrentNode(node) {
    var key = node[this.key];
    var currNode = this.nodesMap[key];
    this.setCurrentNode(currNode);
  };

  TreeStore.prototype.setCurrentNodeKey = function setCurrentNodeKey(key) {
    var node = this.getNode(key);
    if (node) {
      this.currentNode = node;
    }
  };

  return TreeStore;
}();

exports.default = TreeStore;
;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getChildState = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

var _util = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getChildState = exports.getChildState = function getChildState(node) {
  var all = true;
  var none = true;
  var allWithoutDisable = true;
  for (var i = 0, j = node.length; i < j; i++) {
    var n = node[i];
    if (n.checked !== true || n.indeterminate) {
      all = false;
      if (!n.disabled) {
        allWithoutDisable = false;
      }
    }
    if (n.checked !== false || n.indeterminate) {
      none = false;
    }
  }

  return { all: all, none: none, allWithoutDisable: allWithoutDisable, half: !all && !none };
};

var reInitChecked = function reInitChecked(node) {
  if (node.childNodes.length === 0) return;

  var _getChildState = getChildState(node.childNodes),
      all = _getChildState.all,
      none = _getChildState.none,
      half = _getChildState.half;

  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }

  var parent = node.parent;
  if (!parent || parent.level === 0) return;

  if (!node.store.checkStrictly) {
    reInitChecked(parent);
  }
};

var getPropertyFromData = function getPropertyFromData(node, prop) {
  var props = node.store.props;
  var data = node.data || {};
  var config = props[prop];

  if (typeof config === 'function') {
    return config(data, node);
  } else if (typeof config === 'string') {
    return data[config];
  } else if (typeof config === 'undefined') {
    var dataProp = data[prop];
    return dataProp === undefined ? '' : dataProp;
  }
};

var nodeIdSeed = 0;

var Node = function () {
  function Node(options) {
    _classCallCheck(this, Node);

    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;

    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      }
    }

    // internal
    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;

    if (this.parent) {
      this.level = this.parent.level + 1;
    }

    var store = this.store;
    if (!store) {
      throw new Error('[Node]store is required!');
    }
    store.registerNode(this);

    var props = store.props;
    if (props && typeof props.isLeaf !== 'undefined') {
      var isLeaf = getPropertyFromData(this, 'isLeaf');
      if (typeof isLeaf === 'boolean') {
        this.isLeafByUser = isLeaf;
      }
    }

    if (store.lazy !== true && this.data) {
      this.setData(this.data);

      if (store.defaultExpandAll) {
        this.expanded = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }

    if (!this.data) return;
    var defaultExpandedKeys = store.defaultExpandedKeys;
    var key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
      this.expand(null, store.autoExpandParent);
    }

    if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {
      store.currentNode = this;
    }

    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }

    this.updateLeafState();
  }

  Node.prototype.setData = function setData(data) {
    if (!Array.isArray(data)) {
      (0, _util.markNodeData)(this, data);
    }

    this.data = data;
    this.childNodes = [];

    var children = void 0;
    if (this.level === 0 && this.data instanceof Array) {
      children = this.data;
    } else {
      children = getPropertyFromData(this, 'children') || [];
    }

    for (var i = 0, j = children.length; i < j; i++) {
      this.insertChild({ data: children[i] });
    }
  };

  Node.prototype.insertChild = function insertChild(child, index) {
    if (!child) throw new Error('insertChild error: child is required.');

    if (!(child instanceof Node)) {
      (0, _merge2.default)(child, {
        parent: this,
        store: this.store
      });
      child = new Node(child);
    }

    child.level = this.level + 1;

    if (typeof index === 'undefined' || index < 0) {
      this.childNodes.push(child);
    } else {
      this.childNodes.splice(index, 0, child);
    }

    this.updateLeafState();
  };

  Node.prototype.insertBefore = function insertBefore(child, ref) {
    var index = void 0;
    if (ref) {
      index = this.childNodes.indexOf(ref);
    }
    this.insertChild(child, index);
  };

  Node.prototype.insertAfter = function insertAfter(child, ref) {
    var index = void 0;
    if (ref) {
      index = this.childNodes.indexOf(ref);
      if (index !== -1) index += 1;
    }
    this.insertChild(child, index);
  };

  Node.prototype.removeChild = function removeChild(child) {
    var index = this.childNodes.indexOf(child);

    if (index > -1) {
      this.store && this.store.deregisterNode(child);
      child.parent = null;
      this.childNodes.splice(index, 1);
    }

    this.updateLeafState();
  };

  Node.prototype.removeChildByData = function removeChildByData(data) {
    var targetNode = null;
    this.childNodes.forEach(function (node) {
      if (node.data === data) {
        targetNode = node;
      }
    });

    if (targetNode) {
      this.removeChild(targetNode);
    }
  };

  Node.prototype.expand = function expand(callback, expandParent) {
    var _this = this;

    var done = function done() {
      if (expandParent) {
        var parent = _this.parent;
        while (parent.level > 0) {
          parent.expanded = true;
          parent = parent.parent;
        }
      }
      _this.expanded = true;
      if (callback) callback();
    };

    if (this.shouldLoadData()) {
      this.loadData(function (data) {
        if (data instanceof Array) {
          if (_this.checked) {
            _this.setChecked(true, true);
          } else {
            reInitChecked(_this);
          }
          done();
        }
      });
    } else {
      done();
    }
  };

  Node.prototype.doCreateChildren = function doCreateChildren(array) {
    var _this2 = this;

    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    array.forEach(function (item) {
      _this2.insertChild((0, _merge2.default)({ data: item }, defaultProps));
    });
  };

  Node.prototype.collapse = function collapse() {
    this.expanded = false;
  };

  Node.prototype.shouldLoadData = function shouldLoadData() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  };

  Node.prototype.updateLeafState = function updateLeafState() {
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    var childNodes = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    this.isLeaf = false;
  };

  Node.prototype.setChecked = function setChecked(value, deep, recursion, passValue) {
    var _this3 = this;

    this.indeterminate = value === 'half';
    this.checked = value === true;

    if (this.store.checkStrictly) return;

    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      var _ret = function () {
        var _getChildState2 = getChildState(_this3.childNodes),
            all = _getChildState2.all,
            allWithoutDisable = _getChildState2.allWithoutDisable;

        if (!_this3.isLeaf && !all && allWithoutDisable) {
          _this3.checked = false;
          value = false;
        }

        var handleDescendants = function handleDescendants() {
          if (deep) {
            var childNodes = _this3.childNodes;
            for (var i = 0, j = childNodes.length; i < j; i++) {
              var child = childNodes[i];
              passValue = passValue || value !== false;
              var isCheck = child.disabled ? child.checked : passValue;
              child.setChecked(isCheck, deep, true, passValue);
            }

            var _getChildState3 = getChildState(childNodes),
                half = _getChildState3.half,
                _all = _getChildState3.all;

            if (!_all) {
              _this3.checked = _all;
              _this3.indeterminate = half;
            }
          }
        };

        if (_this3.shouldLoadData()) {
          // Only work on lazy load data.
          _this3.loadData(function () {
            handleDescendants();
            reInitChecked(_this3);
          }, {
            checked: value !== false
          });
          return {
            v: void 0
          };
        } else {
          handleDescendants();
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    var parent = this.parent;
    if (!parent || parent.level === 0) return;

    if (!recursion) {
      reInitChecked(parent);
    }
  };

  Node.prototype.getChildren = function getChildren() {
    // this is data
    var data = this.data;
    if (!data) return null;

    var props = this.store.props;
    var children = 'children';
    if (props) {
      children = props.children || 'children';
    }

    if (data[children] === undefined) {
      data[children] = null;
    }

    return data[children];
  };

  Node.prototype.updateChildren = function updateChildren() {
    var _this4 = this;

    var newData = this.getChildren() || [];
    var oldData = this.childNodes.map(function (node) {
      return node.data;
    });

    var newDataMap = {};
    var newNodes = [];

    newData.forEach(function (item, index) {
      if (item[_util.NODE_KEY]) {
        newDataMap[item[_util.NODE_KEY]] = { index: index, data: item };
      } else {
        newNodes.push({ index: index, data: item });
      }
    });

    oldData.forEach(function (item) {
      if (!newDataMap[item[_util.NODE_KEY]]) _this4.removeChildByData(item);
    });

    newNodes.forEach(function (_ref) {
      var index = _ref.index,
          data = _ref.data;

      _this4.insertChild({ data: data }, index);
    });

    this.updateLeafState();
  };

  Node.prototype.loadData = function loadData(callback) {
    var _this5 = this;

    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
      this.loading = true;

      var resolve = function resolve(children) {
        _this5.loaded = true;
        _this5.loading = false;
        _this5.childNodes = [];

        _this5.doCreateChildren(children, defaultProps);

        _this5.updateLeafState();
        if (callback) {
          callback.call(_this5, children);
        }
      };

      this.store.load(this, resolve);
    } else {
      if (callback) {
        callback.call(this);
      }
    }
  };

  _createClass(Node, [{
    key: 'label',
    get: function get() {
      return getPropertyFromData(this, 'label');
    }
  }, {
    key: 'icon',
    get: function get() {
      return getPropertyFromData(this, 'icon');
    }
  }, {
    key: 'key',
    get: function get() {
      var nodeKey = this.store.key;
      if (this.data) return this.data[nodeKey];
      return null;
    }
  }, {
    key: 'disabled',
    get: function get() {
      return getPropertyFromData(this, 'disabled');
    }
  }]);

  return Node;
}();

exports.default = Node;

/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_node_vue__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_node_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_node_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_751ff8ec_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tree_node_vue__ = __webpack_require__(255);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tree_node_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_751ff8ec_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tree_node_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _collapseTransition = __webpack_require__(20);

var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElTreeNode',

  componentName: 'ElTreeNode',

  mixins: [_emitter2.default],

  props: {
    node: {
      default: function _default() {
        return {};
      }
    },
    props: {},
    renderContent: Function
  },

  components: {
    ElCollapseTransition: _collapseTransition2.default,
    ElCheckbox: _checkbox2.default,
    NodeContent: {
      props: {
        node: {
          required: true
        }
      },
      render: function render(h) {
        var parent = this.$parent;
        var node = this.node;
        var data = node.data;
        var store = node.store;
        return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, { _self: parent.tree.$vnode.context, node: node, data: data, store: store }) : h(
          'span',
          { 'class': 'el-tree-node__label' },
          [this.node.label]
        );
      }
    }
  },

  data: function data() {
    return {
      tree: null,
      expanded: false,
      childNodeRendered: false,
      showCheckbox: false,
      oldChecked: null,
      oldIndeterminate: null
    };
  },


  watch: {
    'node.indeterminate': function nodeIndeterminate(val) {
      this.handleSelectChange(this.node.checked, val);
    },
    'node.checked': function nodeChecked(val) {
      this.handleSelectChange(val, this.node.indeterminate);
    },
    'node.expanded': function nodeExpanded(val) {
      var _this = this;

      this.$nextTick(function () {
        return _this.expanded = val;
      });
      if (val) {
        this.childNodeRendered = true;
      }
    }
  },

  methods: {
    getNodeKey: function getNodeKey(node, index) {
      var nodeKey = this.tree.nodeKey;
      if (nodeKey && node) {
        return node.data[nodeKey];
      }
      return index;
    },
    handleSelectChange: function handleSelectChange(checked, indeterminate) {
      if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
        this.tree.$emit('check-change', this.node.data, checked, indeterminate);
      }
      this.oldChecked = checked;
      this.indeterminate = indeterminate;
    },
    handleClick: function handleClick() {
      var store = this.tree.store;
      store.setCurrentNode(this.node);
      this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
      this.tree.currentNode = this;
      if (this.tree.expandOnClickNode) {
        this.handleExpandIconClick();
      }
      this.tree.$emit('node-click', this.node.data, this.node, this);
    },
    handleExpandIconClick: function handleExpandIconClick() {
      if (this.node.isLeaf) return;
      if (this.expanded) {
        this.tree.$emit('node-collapse', this.node.data, this.node, this);
        this.node.collapse();
      } else {
        this.node.expand();
        this.$emit('node-expand', this.node.data, this.node, this);
      }
    },
    handleCheckChange: function handleCheckChange(value, ev) {
      this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
    },
    handleChildNodeExpand: function handleChildNodeExpand(nodeData, node, instance) {
      this.broadcast('ElTreeNode', 'tree-node-expand', node);
      this.tree.$emit('node-expand', nodeData, node, instance);
    }
  },

  created: function created() {
    var _this2 = this;

    var parent = this.$parent;

    if (parent.isTree) {
      this.tree = parent;
    } else {
      this.tree = parent.tree;
    }

    var tree = this.tree;
    if (!tree) {
      console.warn('Can not find node\'s tree.');
    }

    var props = tree.props || {};
    var childrenKey = props['children'] || 'children';

    this.$watch('node.data.' + childrenKey, function () {
      _this2.node.updateChildren();
    });

    this.showCheckbox = tree.showCheckbox;

    if (this.node.expanded) {
      this.expanded = true;
      this.childNodeRendered = true;
    }

    if (this.tree.accordion) {
      this.$on('tree-node-expand', function (node) {
        if (_this2.node !== node) {
          _this2.node.collapse();
        }
      });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.node.visible),expression:"node.visible"}],staticClass:"el-tree-node",class:{
    'is-expanded': _vm.expanded,
    'is-current': _vm.tree.store.currentNode === _vm.node,
    'is-hidden': !_vm.node.visible,
    'is-focusable': !_vm.node.disabled,
    'is-checked': !_vm.node.disabled && _vm.node.checked
  },attrs:{"role":"treeitem","tabindex":"-1","aria-expanded":_vm.expanded,"aria-disabled":_vm.node.disabled,"aria-checked":_vm.node.checked},on:{"click":function($event){$event.stopPropagation();_vm.handleClick($event)}}},[_c('div',{staticClass:"el-tree-node__content",style:({ 'padding-left': (_vm.node.level - 1) * _vm.tree.indent + 'px' })},[_c('span',{staticClass:"el-tree-node__expand-icon el-icon-caret-right",class:{ 'is-leaf': _vm.node.isLeaf, expanded: !_vm.node.isLeaf && _vm.expanded },on:{"click":function($event){$event.stopPropagation();_vm.handleExpandIconClick($event)}}}),(_vm.showCheckbox)?_c('el-checkbox',{attrs:{"indeterminate":_vm.node.indeterminate,"disabled":!!_vm.node.disabled},on:{"change":_vm.handleCheckChange},nativeOn:{"click":function($event){$event.stopPropagation();}},model:{value:(_vm.node.checked),callback:function ($$v) {_vm.$set(_vm.node, "checked", $$v)},expression:"node.checked"}}):_vm._e(),(_vm.node.loading)?_c('span',{staticClass:"el-tree-node__loading-icon el-icon-loading"}):_vm._e(),_c('node-content',{attrs:{"node":_vm.node}})],1),_c('el-collapse-transition',[(_vm.childNodeRendered)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.expanded),expression:"expanded"}],staticClass:"el-tree-node__children",attrs:{"role":"group","aria-expanded":_vm.expanded}},_vm._l((_vm.node.childNodes),function(child){return _c('el-tree-node',{key:_vm.getNodeKey(child),attrs:{"render-content":_vm.renderContent,"node":child},on:{"node-expand":_vm.handleChildNodeExpand}})})):_vm._e()])],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-tree",class:{ 'el-tree--highlight-current': _vm.highlightCurrent },attrs:{"role":"tree"}},[_vm._l((_vm.root.childNodes),function(child){return _c('el-tree-node',{key:_vm.getNodeKey(child),attrs:{"node":child,"props":_vm.props,"render-content":_vm.renderContent},on:{"node-expand":_vm.handleNodeExpand}})}),(!_vm.root.childNodes || _vm.root.childNodes.length === 0)?_c('div',{staticClass:"el-tree__empty-block"},[_c('span',{staticClass:"el-tree__empty-text"},[_vm._v(_vm._s(_vm.emptyText))])]):_vm._e()],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(258);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_94b140a8_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(260);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_94b140a8_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var TYPE_CLASSES_MAP = {
  'success': 'el-icon-success',
  'warning': 'el-icon-warning',
  'error': 'el-icon-error'
};
exports.default = {
  name: 'ElAlert',

  props: {
    title: {
      type: String,
      default: '',
      required: true
    },
    description: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: 'info'
    },
    closable: {
      type: Boolean,
      default: true
    },
    closeText: {
      type: String,
      default: ''
    },
    showIcon: Boolean,
    center: Boolean
  },

  data: function data() {
    return {
      visible: true
    };
  },


  methods: {
    close: function close() {
      this.visible = false;
      this.$emit('close');
    }
  },

  computed: {
    typeClass: function typeClass() {
      return 'el-alert--' + this.type;
    },
    iconClass: function iconClass() {
      return TYPE_CLASSES_MAP[this.type] || 'el-icon-info';
    },
    isBigIcon: function isBigIcon() {
      return this.description || this.$slots.default ? 'is-big' : '';
    },
    isBoldTitle: function isBoldTitle() {
      return this.description || this.$slots.default ? 'is-bold' : '';
    }
  }
};

/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-alert-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-alert",class:[_vm.typeClass, _vm.center ? 'is-center' : ''],attrs:{"role":"alert"}},[(_vm.showIcon)?_c('i',{staticClass:"el-alert__icon",class:[ _vm.iconClass, _vm.isBigIcon ]}):_vm._e(),_c('div',{staticClass:"el-alert__content"},[(_vm.title)?_c('span',{staticClass:"el-alert__title",class:[ _vm.isBoldTitle ]},[_vm._v(_vm._s(_vm.title))]):_vm._e(),_vm._t("default",[(_vm.description)?_c('p',{staticClass:"el-alert__description"},[_vm._v(_vm._s(_vm.description))]):_vm._e()]),_c('i',{directives:[{name:"show",rawName:"v-show",value:(_vm.closable),expression:"closable"}],staticClass:"el-alert__closebtn",class:{ 'is-customed': _vm.closeText !== '', 'el-icon-close': _vm.closeText === '' },on:{"click":function($event){_vm.close()}}},[_vm._v(_vm._s(_vm.closeText))])],2)])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(262);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _main2.default;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _main = __webpack_require__(263);

var _main2 = _interopRequireDefault(_main);

var _popup = __webpack_require__(17);

var _vdom = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NotificationConstructor = _vue2.default.extend(_main2.default);

var instance = void 0;
var instances = [];
var seed = 1;

var Notification = function Notification(options) {
  if (_vue2.default.prototype.$isServer) return;
  options = options || {};
  var userOnClose = options.onClose;
  var id = 'notification_' + seed++;
  var position = options.position || 'top-right';

  options.onClose = function () {
    Notification.close(id, userOnClose);
  };

  instance = new NotificationConstructor({
    data: options
  });

  if ((0, _vdom.isVNode)(options.message)) {
    instance.$slots.default = [options.message];
    options.message = '';
  }
  instance.id = id;
  instance.vm = instance.$mount();
  document.body.appendChild(instance.vm.$el);
  instance.vm.visible = true;
  instance.dom = instance.vm.$el;
  instance.dom.style.zIndex = _popup.PopupManager.nextZIndex();

  var verticalOffset = options.offset || 0;
  instances.filter(function (item) {
    return item.position === position;
  }).forEach(function (item) {
    verticalOffset += item.$el.offsetHeight + 16;
  });
  verticalOffset += 16;
  instance.verticalOffset = verticalOffset;
  instances.push(instance);
  return instance.vm;
};

['success', 'warning', 'info', 'error'].forEach(function (type) {
  Notification[type] = function (options) {
    if (typeof options === 'string' || (0, _vdom.isVNode)(options)) {
      options = {
        message: options
      };
    }
    options.type = type;
    return Notification(options);
  };
});

Notification.close = function (id, userOnClose) {
  var index = -1;
  var len = instances.length;
  var instance = instances.filter(function (instance, i) {
    if (instance.id === id) {
      index = i;
      return true;
    }
    return false;
  })[0];
  if (!instance) return;

  if (typeof userOnClose === 'function') {
    userOnClose(instance);
  }
  instances.splice(index, 1);

  if (len <= 1) return;
  var position = instance.position;
  var removedHeight = instance.dom.offsetHeight;
  for (var i = index; i < len - 1; i++) {
    if (instances[i].position === position) {
      instances[i].dom.style[instance.verticalProperty] = parseInt(instances[i].dom.style[instance.verticalProperty], 10) - removedHeight - 16 + 'px';
    }
  }
};

exports.default = Notification;

/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1951fd63_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(265);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1951fd63_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var typeMap = {
  success: 'success',
  info: 'info',
  warning: 'warning',
  error: 'error'
};

exports.default = {
  data: function data() {
    return {
      visible: false,
      title: '',
      message: '',
      duration: 4500,
      type: '',
      showClose: true,
      customClass: '',
      iconClass: '',
      onClose: null,
      onClick: null,
      closed: false,
      verticalOffset: 0,
      timer: null,
      dangerouslyUseHTMLString: false,
      position: 'top-right'
    };
  },


  computed: {
    typeClass: function typeClass() {
      return this.type && typeMap[this.type] ? 'el-icon-' + typeMap[this.type] : '';
    },
    horizontalClass: function horizontalClass() {
      return this.position.indexOf('right') > -1 ? 'right' : 'left';
    },
    verticalProperty: function verticalProperty() {
      return (/^top-/.test(this.position) ? 'top' : 'bottom'
      );
    },
    positionStyle: function positionStyle() {
      var _ref;

      return _ref = {}, _ref[this.verticalProperty] = this.verticalOffset + 'px', _ref;
    }
  },

  watch: {
    closed: function closed(newVal) {
      if (newVal) {
        this.visible = false;
        this.$el.addEventListener('transitionend', this.destroyElement);
      }
    }
  },

  methods: {
    destroyElement: function destroyElement() {
      this.$el.removeEventListener('transitionend', this.destroyElement);
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    click: function click() {
      if (typeof this.onClick === 'function') {
        this.onClick();
      }
    },
    close: function close() {
      this.closed = true;
      if (typeof this.onClose === 'function') {
        this.onClose();
      }
    },
    clearTimer: function clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer: function startTimer() {
      var _this = this;

      if (this.duration > 0) {
        this.timer = setTimeout(function () {
          if (!_this.closed) {
            _this.close();
          }
        }, this.duration);
      }
    },
    keydown: function keydown(e) {
      if (e.keyCode === 46 || e.keyCode === 8) {
        this.clearTimer(); // detele 取消倒计时
      } else if (e.keyCode === 27) {
        // esc关闭消息
        if (!this.closed) {
          this.close();
        }
      } else {
        this.startTimer(); // 恢复倒计时
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.duration > 0) {
      this.timer = setTimeout(function () {
        if (!_this2.closed) {
          _this2.close();
        }
      }, this.duration);
    }
    document.addEventListener('keydown', this.keydown);
  },
  beforeDestroy: function beforeDestroy() {
    document.removeEventListener('keydown', this.keydown);
  }
};

/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-notification-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],class:['el-notification', _vm.customClass, _vm.horizontalClass],style:(_vm.positionStyle),attrs:{"role":"alert"},on:{"mouseenter":function($event){_vm.clearTimer()},"mouseleave":function($event){_vm.startTimer()},"click":_vm.click}},[(_vm.type || _vm.iconClass)?_c('i',{staticClass:"el-notification__icon",class:[ _vm.typeClass, _vm.iconClass ]}):_vm._e(),_c('div',{staticClass:"el-notification__group",class:{ 'is-with-icon': _vm.typeClass || _vm.iconClass }},[_c('h2',{staticClass:"el-notification__title",domProps:{"textContent":_vm._s(_vm.title)}}),_c('div',{staticClass:"el-notification__content"},[_vm._t("default",[(!_vm.dangerouslyUseHTMLString)?_c('p',[_vm._v(_vm._s(_vm.message))]):_c('p',{domProps:{"innerHTML":_vm._s(_vm.message)}})])],2),(_vm.showClose)?_c('div',{staticClass:"el-notification__closeBtn el-icon-close",on:{"click":function($event){$event.stopPropagation();_vm.close($event)}}}):_vm._e()])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(267);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ec0df926_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(273);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ec0df926_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _inputNumber = __webpack_require__(269);

var _inputNumber2 = _interopRequireDefault(_inputNumber);

var _button = __webpack_require__(270);

var _button2 = _interopRequireDefault(_button);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElSlider',

  mixins: [_emitter2.default],

  props: {
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    value: {
      type: [Number, Array],
      default: 0
    },
    showInput: {
      type: Boolean,
      default: false
    },
    showInputControls: {
      type: Boolean,
      default: true
    },
    showStops: {
      type: Boolean,
      default: false
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    formatTooltip: Function,
    disabled: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String
    },
    debounce: {
      type: Number,
      default: 300
    },
    label: {
      type: String
    }
  },

  components: {
    ElInputNumber: _inputNumber2.default,
    SliderButton: _button2.default
  },

  data: function data() {
    return {
      firstValue: null,
      secondValue: null,
      oldValue: null,
      dragging: false,
      sliderSize: 1
    };
  },


  watch: {
    value: function value(val, oldVal) {
      if (this.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every(function (item, index) {
        return item === oldVal[index];
      })) {
        return;
      }
      this.setValues();
    },
    dragging: function dragging(val) {
      if (!val) {
        this.setValues();
      }
    },
    firstValue: function firstValue(val) {
      if (this.range) {
        this.$emit('input', [this.minValue, this.maxValue]);
      } else {
        this.$emit('input', val);
      }
    },
    secondValue: function secondValue() {
      if (this.range) {
        this.$emit('input', [this.minValue, this.maxValue]);
      }
    },
    min: function min() {
      this.setValues();
    },
    max: function max() {
      this.setValues();
    }
  },

  methods: {
    valueChanged: function valueChanged() {
      var _this = this;

      if (this.range) {
        return ![this.minValue, this.maxValue].every(function (item, index) {
          return item === _this.oldValue[index];
        });
      } else {
        return this.value !== this.oldValue;
      }
    },
    setValues: function setValues() {
      var val = this.value;
      if (this.range && Array.isArray(val)) {
        if (val[1] < this.min) {
          this.$emit('input', [this.min, this.min]);
        } else if (val[0] > this.max) {
          this.$emit('input', [this.max, this.max]);
        } else if (val[0] < this.min) {
          this.$emit('input', [this.min, val[1]]);
        } else if (val[1] > this.max) {
          this.$emit('input', [val[0], this.max]);
        } else {
          this.firstValue = val[0];
          this.secondValue = val[1];
          if (this.valueChanged()) {
            this.dispatch('ElFormItem', 'el.form.change', [this.minValue, this.maxValue]);
            this.oldValue = val.slice();
          }
        }
      } else if (!this.range && typeof val === 'number' && !isNaN(val)) {
        if (val < this.min) {
          this.$emit('input', this.min);
        } else if (val > this.max) {
          this.$emit('input', this.max);
        } else {
          this.firstValue = val;
          if (this.valueChanged()) {
            this.dispatch('ElFormItem', 'el.form.change', val);
            this.oldValue = val;
          }
        }
      }
    },
    setPosition: function setPosition(percent) {
      var targetValue = this.min + percent * (this.max - this.min) / 100;
      if (!this.range) {
        this.$refs.button1.setPosition(percent);
        return;
      }
      var button = void 0;
      if (Math.abs(this.minValue - targetValue) < Math.abs(this.maxValue - targetValue)) {
        button = this.firstValue < this.secondValue ? 'button1' : 'button2';
      } else {
        button = this.firstValue > this.secondValue ? 'button1' : 'button2';
      }
      this.$refs[button].setPosition(percent);
    },
    onSliderClick: function onSliderClick(event) {
      if (this.disabled || this.dragging) return;
      this.resetSize();
      if (this.vertical) {
        var sliderOffsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
        this.setPosition((sliderOffsetBottom - event.clientY) / this.sliderSize * 100);
      } else {
        var sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
        this.setPosition((event.clientX - sliderOffsetLeft) / this.sliderSize * 100);
      }
      this.emitChange();
    },
    resetSize: function resetSize() {
      if (this.$refs.slider) {
        this.sliderSize = this.$refs.slider['client' + (this.vertical ? 'Height' : 'Width')];
      }
    },
    emitChange: function emitChange() {
      var _this2 = this;

      this.$nextTick(function () {
        _this2.$emit('change', _this2.range ? [_this2.minValue, _this2.maxValue] : _this2.value);
      });
    }
  },

  computed: {
    stops: function stops() {
      var _this3 = this;

      if (this.step === 0) {
        "production" !== 'production' && console.warn('[Element Warn][Slider]step should not be 0.');
        return [];
      }
      var stopCount = (this.max - this.min) / this.step;
      var stepWidth = 100 * this.step / (this.max - this.min);
      var result = [];
      for (var i = 1; i < stopCount; i++) {
        result.push(i * stepWidth);
      }
      if (this.range) {
        return result.filter(function (step) {
          return step < 100 * (_this3.minValue - _this3.min) / (_this3.max - _this3.min) || step > 100 * (_this3.maxValue - _this3.min) / (_this3.max - _this3.min);
        });
      } else {
        return result.filter(function (step) {
          return step > 100 * (_this3.firstValue - _this3.min) / (_this3.max - _this3.min);
        });
      }
    },
    minValue: function minValue() {
      return Math.min(this.firstValue, this.secondValue);
    },
    maxValue: function maxValue() {
      return Math.max(this.firstValue, this.secondValue);
    },
    barSize: function barSize() {
      return this.range ? 100 * (this.maxValue - this.minValue) / (this.max - this.min) + '%' : 100 * (this.firstValue - this.min) / (this.max - this.min) + '%';
    },
    barStart: function barStart() {
      return this.range ? 100 * (this.minValue - this.min) / (this.max - this.min) + '%' : '0%';
    },
    precision: function precision() {
      var precisions = [this.min, this.max, this.step].map(function (item) {
        var decimal = ('' + item).split('.')[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    },
    runwayStyle: function runwayStyle() {
      return this.vertical ? { height: this.height } : {};
    },
    barStyle: function barStyle() {
      return this.vertical ? {
        height: this.barSize,
        bottom: this.barStart
      } : {
        width: this.barSize,
        left: this.barStart
      };
    }
  },

  mounted: function mounted() {
    var valuetext = void 0;
    if (this.range) {
      if (Array.isArray(this.value)) {
        this.firstValue = Math.max(this.min, this.value[0]);
        this.secondValue = Math.min(this.max, this.value[1]);
      } else {
        this.firstValue = this.min;
        this.secondValue = this.max;
      }
      this.oldValue = [this.firstValue, this.secondValue];
      valuetext = this.firstValue + '-' + this.secondValue;
    } else {
      if (typeof this.value !== 'number' || isNaN(this.value)) {
        this.firstValue = this.min;
      } else {
        this.firstValue = Math.min(this.max, Math.max(this.min, this.value));
      }
      this.oldValue = this.firstValue;
      valuetext = this.firstValue;
    }
    this.$el.setAttribute('aria-valuetext', valuetext);

    // label screen reader
    this.$el.setAttribute('aria-label', this.label ? this.label : 'slider between ' + this.min + ' and ' + this.max);

    this.resetSize();
    window.addEventListener('resize', this.resetSize);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('resize', this.resetSize);
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 269 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("Snuj");

/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__ = __webpack_require__(271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_28634966_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__ = __webpack_require__(272);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_28634966_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tooltip = __webpack_require__(22);

var _tooltip2 = _interopRequireDefault(_tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElSliderButton',

  components: {
    ElTooltip: _tooltip2.default
  },

  props: {
    value: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      hovering: false,
      dragging: false,
      isClick: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: null,
      oldValue: this.value
    };
  },


  computed: {
    disabled: function disabled() {
      return this.$parent.disabled;
    },
    max: function max() {
      return this.$parent.max;
    },
    min: function min() {
      return this.$parent.min;
    },
    step: function step() {
      return this.$parent.step;
    },
    showTooltip: function showTooltip() {
      return this.$parent.showTooltip;
    },
    precision: function precision() {
      return this.$parent.precision;
    },
    currentPosition: function currentPosition() {
      return (this.value - this.min) / (this.max - this.min) * 100 + '%';
    },
    enableFormat: function enableFormat() {
      return this.$parent.formatTooltip instanceof Function;
    },
    formatValue: function formatValue() {
      return this.enableFormat && this.$parent.formatTooltip(this.value) || this.value;
    },
    wrapperStyle: function wrapperStyle() {
      return this.vertical ? { bottom: this.currentPosition } : { left: this.currentPosition };
    }
  },

  watch: {
    dragging: function dragging(val) {
      this.$parent.dragging = val;
    }
  },

  methods: {
    displayTooltip: function displayTooltip() {
      this.$refs.tooltip && (this.$refs.tooltip.showPopper = true);
    },
    hideTooltip: function hideTooltip() {
      this.$refs.tooltip && (this.$refs.tooltip.showPopper = false);
    },
    handleMouseEnter: function handleMouseEnter() {
      this.hovering = true;
      this.displayTooltip();
    },
    handleMouseLeave: function handleMouseLeave() {
      this.hovering = false;
      this.hideTooltip();
    },
    onButtonDown: function onButtonDown(event) {
      if (this.disabled) return;
      event.preventDefault();
      this.onDragStart(event);
      window.addEventListener('mousemove', this.onDragging);
      window.addEventListener('mouseup', this.onDragEnd);
      window.addEventListener('contextmenu', this.onDragEnd);
    },
    onLeftKeyDown: function onLeftKeyDown() {
      if (this.disabled) return;
      this.newPosition = parseFloat(this.currentPosition) - this.step / (this.max - this.min) * 100;
      this.setPosition(this.newPosition);
    },
    onRightKeyDown: function onRightKeyDown() {
      if (this.disabled) return;
      this.newPosition = parseFloat(this.currentPosition) + this.step / (this.max - this.min) * 100;
      this.setPosition(this.newPosition);
    },
    onDragStart: function onDragStart(event) {
      this.dragging = true;
      this.isClick = true;
      if (this.vertical) {
        this.startY = event.clientY;
      } else {
        this.startX = event.clientX;
      }
      this.startPosition = parseFloat(this.currentPosition);
      this.newPosition = this.startPosition;
    },
    onDragging: function onDragging(event) {
      if (this.dragging) {
        this.isClick = false;
        this.displayTooltip();
        this.$parent.resetSize();
        var diff = 0;
        if (this.vertical) {
          this.currentY = event.clientY;
          diff = (this.startY - this.currentY) / this.$parent.sliderSize * 100;
        } else {
          this.currentX = event.clientX;
          diff = (this.currentX - this.startX) / this.$parent.sliderSize * 100;
        }
        this.newPosition = this.startPosition + diff;
        this.setPosition(this.newPosition);
      }
    },
    onDragEnd: function onDragEnd() {
      var _this = this;

      if (this.dragging) {
        /*
         * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
         * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
         */
        setTimeout(function () {
          _this.dragging = false;
          _this.hideTooltip();
          if (!_this.isClick) {
            _this.setPosition(_this.newPosition);
            _this.$parent.emitChange();
          }
        }, 0);
        window.removeEventListener('mousemove', this.onDragging);
        window.removeEventListener('mouseup', this.onDragEnd);
        window.removeEventListener('contextmenu', this.onDragEnd);
      }
    },
    setPosition: function setPosition(newPosition) {
      var _this2 = this;

      if (newPosition === null) return;
      if (newPosition < 0) {
        newPosition = 0;
      } else if (newPosition > 100) {
        newPosition = 100;
      }
      var lengthPerStep = 100 / ((this.max - this.min) / this.step);
      var steps = Math.round(newPosition / lengthPerStep);
      var value = steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min;
      value = parseFloat(value.toFixed(this.precision));
      this.$emit('input', value);
      this.$nextTick(function () {
        _this2.$refs.tooltip && _this2.$refs.tooltip.updatePopper();
      });
      if (!this.dragging && this.value !== this.oldValue) {
        this.oldValue = this.value;
      }
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"button",staticClass:"el-slider__button-wrapper",class:{ 'hover': _vm.hovering, 'dragging': _vm.dragging },style:(_vm.wrapperStyle),attrs:{"tabindex":"0"},on:{"mouseenter":_vm.handleMouseEnter,"mouseleave":_vm.handleMouseLeave,"mousedown":_vm.onButtonDown,"focus":_vm.handleMouseEnter,"blur":_vm.handleMouseLeave,"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"left",37,$event.key)){ return null; }if('button' in $event && $event.button !== 0){ return null; }_vm.onLeftKeyDown($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"right",39,$event.key)){ return null; }if('button' in $event && $event.button !== 2){ return null; }_vm.onRightKeyDown($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key)){ return null; }$event.preventDefault();_vm.onLeftKeyDown($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key)){ return null; }$event.preventDefault();_vm.onRightKeyDown($event)}]}},[_c('el-tooltip',{ref:"tooltip",attrs:{"placement":"top","disabled":!_vm.showTooltip}},[_c('span',{attrs:{"slot":"content"},slot:"content"},[_vm._v(_vm._s(_vm.formatValue))]),_c('div',{staticClass:"el-slider__button",class:{ 'hover': _vm.hovering, 'dragging': _vm.dragging }})])],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-slider",class:{ 'is-vertical': _vm.vertical, 'el-slider--with-input': _vm.showInput },attrs:{"role":"slider","aria-valuemin":_vm.min,"aria-valuemax":_vm.max,"aria-orientation":_vm.vertical ? 'vertical': 'horizontal',"aria-disabled":_vm.disabled}},[(_vm.showInput && !_vm.range)?_c('el-input-number',{ref:"input",staticClass:"el-slider__input",attrs:{"step":_vm.step,"disabled":_vm.disabled,"controls":_vm.showInputControls,"min":_vm.min,"max":_vm.max,"debounce":_vm.debounce,"size":"small"},on:{"change":function($event){_vm.$nextTick(_vm.emitChange)}},model:{value:(_vm.firstValue),callback:function ($$v) {_vm.firstValue=$$v},expression:"firstValue"}}):_vm._e(),_c('div',{ref:"slider",staticClass:"el-slider__runway",class:{ 'show-input': _vm.showInput, 'disabled': _vm.disabled },style:(_vm.runwayStyle),on:{"click":_vm.onSliderClick}},[_c('div',{staticClass:"el-slider__bar",style:(_vm.barStyle)}),_c('slider-button',{ref:"button1",attrs:{"vertical":_vm.vertical},model:{value:(_vm.firstValue),callback:function ($$v) {_vm.firstValue=$$v},expression:"firstValue"}}),(_vm.range)?_c('slider-button',{ref:"button2",attrs:{"vertical":_vm.vertical},model:{value:(_vm.secondValue),callback:function ($$v) {_vm.secondValue=$$v},expression:"secondValue"}}):_vm._e(),_vm._l((_vm.stops),function(item){return (_vm.showStops)?_c('div',{staticClass:"el-slider__stop",style:(_vm.vertical ? { 'bottom': item + '%' } : { 'left': item + '%' })}):_vm._e()})],2)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _directive = __webpack_require__(275);

var _directive2 = _interopRequireDefault(_directive);

var _index = __webpack_require__(278);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  install: function install(Vue) {
    Vue.use(_directive2.default);
    Vue.prototype.$loading = _index2.default;
  },

  directive: _directive2.default,
  service: _index2.default
};

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _loading = __webpack_require__(39);

var _loading2 = _interopRequireDefault(_loading);

var _dom = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Mask = _vue2.default.extend(_loading2.default);

exports.install = function (Vue) {
  if (Vue.prototype.$isServer) return;
  var toggleLoading = function toggleLoading(el, binding) {
    if (binding.value) {
      Vue.nextTick(function () {
        if (binding.modifiers.fullscreen) {
          el.originalPosition = (0, _dom.getStyle)(document.body, 'position');
          el.originalOverflow = (0, _dom.getStyle)(document.body, 'overflow');

          (0, _dom.addClass)(el.mask, 'is-fullscreen');
          insertDom(document.body, el, binding);
        } else {
          (0, _dom.removeClass)(el.mask, 'is-fullscreen');

          if (binding.modifiers.body) {
            el.originalPosition = (0, _dom.getStyle)(document.body, 'position');

            ['top', 'left'].forEach(function (property) {
              var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
              el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
            });
            ['height', 'width'].forEach(function (property) {
              el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';
            });

            insertDom(document.body, el, binding);
          } else {
            el.originalPosition = (0, _dom.getStyle)(el, 'position');
            insertDom(el, el, binding);
          }
        }
      });
    } else {
      if (el.domVisible) {
        el.instance.$on('after-leave', function (_) {
          el.domVisible = false;
          var target = binding.modifiers.fullscreen || binding.modifiers.body ? document.body : el;
          (0, _dom.removeClass)(target, 'el-loading-parent--relative');
          (0, _dom.removeClass)(target, 'el-loading-parent--hidden');
        });
        el.instance.visible = false;
      }
    }
  };
  var insertDom = function insertDom(parent, el, binding) {
    if (!el.domVisible && (0, _dom.getStyle)(el, 'display') !== 'none' && (0, _dom.getStyle)(el, 'visibility') !== 'hidden') {
      Object.keys(el.maskStyle).forEach(function (property) {
        el.mask.style[property] = el.maskStyle[property];
      });

      if (el.originalPosition !== 'absolute' && el.originalPosition !== 'fixed') {
        (0, _dom.addClass)(parent, 'el-loading-parent--relative');
      }
      if (binding.modifiers.fullscreen && binding.modifiers.lock) {
        (0, _dom.addClass)(parent, 'el-loading-parent--hidden');
      }
      el.domVisible = true;

      parent.appendChild(el.mask);
      Vue.nextTick(function () {
        el.instance.visible = true;
      });
      el.domInserted = true;
    }
  };

  Vue.directive('loading', {
    bind: function bind(el, binding, vnode) {
      var textExr = el.getAttribute('element-loading-text');
      var spinnerExr = el.getAttribute('element-loading-spinner');
      var backgroundExr = el.getAttribute('element-loading-background');
      var vm = vnode.context;
      var mask = new Mask({
        el: document.createElement('div'),
        data: {
          text: vm && vm[textExr] || textExr,
          spinner: vm && vm[spinnerExr] || spinnerExr,
          background: vm && vm[backgroundExr] || backgroundExr,
          fullscreen: !!binding.modifiers.fullscreen
        }
      });
      el.instance = mask;
      el.mask = mask.$el;
      el.maskStyle = {};

      toggleLoading(el, binding);
    },

    update: function update(el, binding) {
      el.instance.setText(el.getAttribute('element-loading-text'));
      if (binding.oldValue !== binding.value) {
        toggleLoading(el, binding);
      }
    },

    unbind: function unbind(el, binding) {
      if (el.domInserted) {
        el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);
      }
    }
  });
};

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  data: function data() {
    return {
      text: null,
      spinner: null,
      background: null,
      fullscreen: true,
      visible: false,
      customClass: ''
    };
  },


  methods: {
    handleAfterLeave: function handleAfterLeave() {
      this.$emit('after-leave');
    },
    setText: function setText(text) {
      this.text = text;
    }
  }
};

/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-loading-fade"},on:{"after-leave":_vm.handleAfterLeave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-loading-mask",class:[_vm.customClass, { 'is-fullscreen': _vm.fullscreen }],style:({ backgroundColor: _vm.background || '' })},[_c('div',{staticClass:"el-loading-spinner"},[(!_vm.spinner)?_c('svg',{staticClass:"circular",attrs:{"viewBox":"25 25 50 50"}},[_c('circle',{staticClass:"path",attrs:{"cx":"50","cy":"50","r":"20","fill":"none"}})]):_c('i',{class:_vm.spinner}),(_vm.text)?_c('p',{staticClass:"el-loading-text"},[_vm._v(_vm._s(_vm.text))]):_vm._e()])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _loading = __webpack_require__(39);

var _loading2 = _interopRequireDefault(_loading);

var _dom = __webpack_require__(4);

var _merge = __webpack_require__(12);

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LoadingConstructor = _vue2.default.extend(_loading2.default);

var defaults = {
  text: null,
  fullscreen: true,
  body: false,
  lock: false,
  customClass: ''
};

var fullscreenLoading = void 0;

LoadingConstructor.prototype.originalPosition = '';
LoadingConstructor.prototype.originalOverflow = '';

LoadingConstructor.prototype.close = function () {
  var _this = this;

  if (this.fullscreen) {
    fullscreenLoading = undefined;
  }
  this.$on('after-leave', function (_) {
    var target = _this.fullscreen || _this.body ? document.body : _this.target;
    (0, _dom.removeClass)(target, 'el-loading-parent--relative');
    (0, _dom.removeClass)(target, 'el-loading-parent--hidden');
    if (_this.$el && _this.$el.parentNode) {
      _this.$el.parentNode.removeChild(_this.$el);
    }
    _this.$destroy();
  });
  this.visible = false;
};

var addStyle = function addStyle(options, parent, instance) {
  var maskStyle = {};
  if (options.fullscreen) {
    instance.originalPosition = (0, _dom.getStyle)(document.body, 'position');
    instance.originalOverflow = (0, _dom.getStyle)(document.body, 'overflow');
  } else if (options.body) {
    instance.originalPosition = (0, _dom.getStyle)(document.body, 'position');
    ['top', 'left'].forEach(function (property) {
      var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
      maskStyle[property] = options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
    });
    ['height', 'width'].forEach(function (property) {
      maskStyle[property] = options.target.getBoundingClientRect()[property] + 'px';
    });
  } else {
    instance.originalPosition = (0, _dom.getStyle)(parent, 'position');
  }
  Object.keys(maskStyle).forEach(function (property) {
    instance.$el.style[property] = maskStyle[property];
  });
};

var Loading = function Loading() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (_vue2.default.prototype.$isServer) return;
  options = (0, _merge2.default)({}, defaults, options);
  if (typeof options.target === 'string') {
    options.target = document.querySelector(options.target);
  }
  options.target = options.target || document.body;
  if (options.target !== document.body) {
    options.fullscreen = false;
  } else {
    options.body = true;
  }
  if (options.fullscreen && fullscreenLoading) {
    return fullscreenLoading;
  }

  var parent = options.body ? document.body : options.target;
  var instance = new LoadingConstructor({
    el: document.createElement('div'),
    data: options
  });

  addStyle(options, parent, instance);
  if (instance.originalPosition !== 'absolute' && instance.originalPosition !== 'fixed') {
    (0, _dom.addClass)(parent, 'el-loading-parent--relative');
  }
  if (options.fullscreen && options.lock) {
    (0, _dom.addClass)(parent, 'el-loading-parent--hidden');
  }
  parent.appendChild(instance.$el);
  _vue2.default.nextTick(function () {
    instance.visible = true;
  });
  if (options.fullscreen) {
    fullscreenLoading = instance;
  }
  return instance;
};

exports.default = Loading;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _icon = __webpack_require__(280);

var _icon2 = _interopRequireDefault(_icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_icon2.default.install = function (Vue) {
  Vue.component(_icon2.default.name, _icon2.default);
};

exports.default = _icon2.default;

/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_icon_vue__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_icon_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3200ab56_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_icon_vue__ = __webpack_require__(282);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_icon_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3200ab56_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_icon_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//

exports.default = {
  name: 'ElIcon',

  props: {
    name: String
  }
};

/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{class:'el-icon-' + _vm.name})}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _row = __webpack_require__(284);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_row2.default.install = function (Vue) {
  Vue.component(_row2.default.name, _row2.default);
};

exports.default = _row2.default;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  name: 'ElRow',

  componentName: 'ElRow',

  props: {
    tag: {
      type: String,
      default: 'div'
    },
    gutter: Number,
    type: String,
    justify: {
      type: String,
      default: 'start'
    },
    align: {
      type: String,
      default: 'top'
    }
  },

  computed: {
    style: function style() {
      var ret = {};

      if (this.gutter) {
        ret.marginLeft = '-' + this.gutter / 2 + 'px';
        ret.marginRight = ret.marginLeft;
      }

      return ret;
    }
  },

  render: function render(h) {
    return h(this.tag, {
      class: ['el-row', this.justify !== 'start' ? 'is-justify-' + this.justify : '', this.align !== 'top' ? 'is-align-' + this.align : '', { 'el-row--flex': this.type === 'flex' }],
      style: this.style
    }, this.$slots.default);
  }
};

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _col = __webpack_require__(286);

var _col2 = _interopRequireDefault(_col);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_col2.default.install = function (Vue) {
  Vue.component(_col2.default.name, _col2.default);
};

exports.default = _col2.default;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = {
  name: 'ElCol',

  props: {
    span: {
      type: Number,
      default: 24
    },
    tag: {
      type: String,
      default: 'div'
    },
    offset: Number,
    pull: Number,
    push: Number,
    xs: [Number, Object],
    sm: [Number, Object],
    md: [Number, Object],
    lg: [Number, Object],
    xl: [Number, Object]
  },

  computed: {
    gutter: function gutter() {
      var parent = this.$parent;
      while (parent && parent.$options.componentName !== 'ElRow') {
        parent = parent.$parent;
      }
      return parent ? parent.gutter : 0;
    }
  },
  render: function render(h) {
    var _this = this;

    var classList = [];
    var style = {};

    if (this.gutter) {
      style.paddingLeft = this.gutter / 2 + 'px';
      style.paddingRight = style.paddingLeft;
    }

    ['span', 'offset', 'pull', 'push'].forEach(function (prop) {
      if (_this[prop] || _this[prop] === 0) {
        classList.push(prop !== 'span' ? 'el-col-' + prop + '-' + _this[prop] : 'el-col-' + _this[prop]);
      }
    });

    ['xs', 'sm', 'md', 'lg', 'xl'].forEach(function (size) {
      if (typeof _this[size] === 'number') {
        classList.push('el-col-' + size + '-' + _this[size]);
      } else if (_typeof(_this[size]) === 'object') {
        (function () {
          var props = _this[size];
          Object.keys(props).forEach(function (prop) {
            classList.push(prop !== 'span' ? 'el-col-' + size + '-' + prop + '-' + props[prop] : 'el-col-' + size + '-' + props[prop]);
          });
        })();
      }
    });

    return h(this.tag, {
      class: ['el-col', classList],
      style: style
    }, this.$slots.default);
  }
};

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _src = __webpack_require__(288);

var _src2 = _interopRequireDefault(_src);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_src2.default.install = function (Vue) {
  Vue.component(_src2.default.name, _src2.default);
};

exports.default = _src2.default;

/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _uploadList = __webpack_require__(290);

var _uploadList2 = _interopRequireDefault(_uploadList);

var _upload = __webpack_require__(293);

var _upload2 = _interopRequireDefault(_upload);

var _iframeUpload = __webpack_require__(298);

var _iframeUpload2 = _interopRequireDefault(_iframeUpload);

var _progress = __webpack_require__(40);

var _progress2 = _interopRequireDefault(_progress);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function noop() {}

exports.default = {
  name: 'ElUpload',

  mixins: [_migrating2.default],

  components: {
    ElProgress: _progress2.default,
    UploadList: _uploadList2.default,
    Upload: _upload2.default,
    IframeUpload: _iframeUpload2.default
  },

  provide: {
    uploader: undefined
  },

  props: {
    action: {
      type: String,
      required: true
    },
    headers: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    data: Object,
    multiple: Boolean,
    name: {
      type: String,
      default: 'file'
    },
    drag: Boolean,
    dragger: Boolean,
    withCredentials: Boolean,
    showFileList: {
      type: Boolean,
      default: true
    },
    accept: String,
    type: {
      type: String,
      default: 'select'
    },
    beforeUpload: Function,
    onRemove: {
      type: Function,
      default: noop
    },
    onChange: {
      type: Function,
      default: noop
    },
    onPreview: {
      type: Function
    },
    onSuccess: {
      type: Function,
      default: noop
    },
    onProgress: {
      type: Function,
      default: noop
    },
    onError: {
      type: Function,
      default: noop
    },
    fileList: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: 'text' // text,picture,picture-card
    },
    httpRequest: Function,
    disabled: Boolean,
    limit: Number,
    onExceed: {
      type: Function,
      default: noop
    }
  },

  data: function data() {
    return {
      uploadFiles: [],
      dragOver: false,
      draging: false,
      tempIndex: 1
    };
  },


  watch: {
    fileList: {
      immediate: true,
      handler: function handler(fileList) {
        var _this = this;

        this.uploadFiles = fileList.map(function (item) {
          item.uid = item.uid || Date.now() + _this.tempIndex++;
          item.status = 'success';
          return item;
        });
      }
    }
  },

  methods: {
    handleStart: function handleStart(rawFile) {
      rawFile.uid = Date.now() + this.tempIndex++;
      var file = {
        status: 'ready',
        name: rawFile.name,
        size: rawFile.size,
        percentage: 0,
        uid: rawFile.uid,
        raw: rawFile
      };

      try {
        file.url = URL.createObjectURL(rawFile);
      } catch (err) {
        console.error(err);
        return;
      }

      this.uploadFiles.push(file);
      this.onChange(file, this.uploadFiles);
    },
    handleProgress: function handleProgress(ev, rawFile) {
      var file = this.getFile(rawFile);
      this.onProgress(ev, file, this.uploadFiles);
      file.status = 'uploading';
      file.percentage = ev.percent || 0;
    },
    handleSuccess: function handleSuccess(res, rawFile) {
      var file = this.getFile(rawFile);

      if (file) {
        file.status = 'success';
        file.response = res;

        this.onSuccess(res, file, this.uploadFiles);
        this.onChange(file, this.uploadFiles);
      }
    },
    handleError: function handleError(err, rawFile) {
      var file = this.getFile(rawFile);
      var fileList = this.uploadFiles;

      file.status = 'fail';

      fileList.splice(fileList.indexOf(file), 1);

      this.onError(err, file, this.uploadFiles);
      this.onChange(file, this.uploadFiles);
    },
    handleRemove: function handleRemove(file, raw) {
      if (raw) {
        file = this.getFile(raw);
      }
      this.abort(file);
      var fileList = this.uploadFiles;
      fileList.splice(fileList.indexOf(file), 1);
      this.onRemove(file, fileList);
    },
    getFile: function getFile(rawFile) {
      var fileList = this.uploadFiles;
      var target = void 0;
      fileList.every(function (item) {
        target = rawFile.uid === item.uid ? item : null;
        return !target;
      });
      return target;
    },
    abort: function abort(file) {
      this.$refs['upload-inner'].abort(file);
    },
    clearFiles: function clearFiles() {
      this.uploadFiles = [];
    },
    submit: function submit() {
      var _this2 = this;

      this.uploadFiles.filter(function (file) {
        return file.status === 'ready';
      }).forEach(function (file) {
        _this2.$refs['upload-inner'].upload(file.raw);
      });
    },
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'default-file-list': 'default-file-list is renamed to file-list.',
          'show-upload-list': 'show-upload-list is renamed to show-file-list.',
          'thumbnail-mode': 'thumbnail-mode has been deprecated, you can implement the same effect according to this case: http://element.eleme.io/#/zh-CN/component/upload#yong-hu-tou-xiang-shang-chuan'
        }
      };
    }
  },

  render: function render(h) {
    var uploadList = void 0;

    if (this.showFileList) {
      uploadList = h(
        _uploadList2.default,
        {
          attrs: {
            disabled: this.disabled,
            listType: this.listType,
            files: this.uploadFiles,

            handlePreview: this.onPreview },
          on: {
            'remove': this.handleRemove
          }
        },
        []
      );
    }

    var uploadData = {
      props: {
        type: this.type,
        drag: this.drag,
        action: this.action,
        multiple: this.multiple,
        'before-upload': this.beforeUpload,
        'with-credentials': this.withCredentials,
        headers: this.headers,
        name: this.name,
        data: this.data,
        accept: this.accept,
        fileList: this.uploadFiles,
        autoUpload: this.autoUpload,
        listType: this.listType,
        disabled: this.disabled,
        limit: this.limit,
        'on-exceed': this.onExceed,
        'on-start': this.handleStart,
        'on-progress': this.handleProgress,
        'on-success': this.handleSuccess,
        'on-error': this.handleError,
        'on-preview': this.onPreview,
        'on-remove': this.handleRemove,
        'http-request': this.httpRequest
      },
      ref: 'upload-inner'
    };

    var trigger = this.$slots.trigger || this.$slots.default;
    var uploadComponent = typeof FormData !== 'undefined' || this.$isServer ? h(
      'upload',
      uploadData,
      [trigger]
    ) : h(
      'iframeUpload',
      uploadData,
      [trigger]
    );

    return h(
      'div',
      null,
      [this.listType === 'picture-card' ? uploadList : '', this.$slots.trigger ? [uploadComponent, this.$slots.default] : uploadComponent, this.$slots.tip, this.listType !== 'picture-card' ? uploadList : '']
    );
  }
};

/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_list_vue__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_list_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_list_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_43fbf886_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_upload_list_vue__ = __webpack_require__(292);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_list_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_43fbf886_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_upload_list_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _progress = __webpack_require__(40);

var _progress2 = _interopRequireDefault(_progress);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  mixins: [_locale2.default],

  data: function data() {
    return {
      focusing: false
    };
  },

  components: { ElProgress: _progress2.default },

  props: {
    files: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    handlePreview: Function,
    listType: String
  },
  methods: {
    parsePercentage: function parsePercentage(val) {
      return parseInt(val, 10);
    },
    handleClick: function handleClick(file) {
      this.handlePreview && this.handlePreview(file);
    }
  }
};

/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition-group',{class:[
    'el-upload-list',
    'el-upload-list--' + _vm.listType,
    { 'is-disabled': _vm.disabled }
  ],attrs:{"tag":"ul","name":"el-list"}},_vm._l((_vm.files),function(file,index){return _c('li',{key:index,class:['el-upload-list__item', 'is-' + file.status, _vm.focusing ? 'focusing' : ''],attrs:{"tabindex":"0"},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"delete",[8,46],$event.key)){ return null; }!_vm.disabled && _vm.$emit('remove', file)},"focus":function($event){_vm.focusing = true},"blur":function($event){_vm.focusing = false},"click":function($event){_vm.focusing = false}}},[(file.status !== 'uploading' && ['picture-card', 'picture'].indexOf(_vm.listType) > -1)?_c('img',{staticClass:"el-upload-list__item-thumbnail",attrs:{"src":file.url,"alt":""}}):_vm._e(),_c('a',{staticClass:"el-upload-list__item-name",on:{"click":function($event){_vm.handleClick(file)}}},[_c('i',{staticClass:"el-icon-document"}),_vm._v(_vm._s(file.name)+"\n    ")]),_c('label',{staticClass:"el-upload-list__item-status-label"},[_c('i',{class:{
        'el-icon-upload-success': true,
        'el-icon-circle-check': _vm.listType === 'text',
        'el-icon-check': ['picture-card', 'picture'].indexOf(_vm.listType) > -1
      }})]),(!_vm.disabled)?_c('i',{staticClass:"el-icon-close",on:{"click":function($event){_vm.$emit('remove', file)}}}):_vm._e(),(!_vm.disabled)?_c('i',{staticClass:"el-icon-close-tip"},[_vm._v(_vm._s(_vm.t('el.upload.deleteTip')))]):_vm._e(),(file.status === 'uploading')?_c('el-progress',{attrs:{"type":_vm.listType === 'picture-card' ? 'circle' : 'line',"stroke-width":_vm.listType === 'picture-card' ? 6 : 2,"percentage":_vm.parsePercentage(file.percentage)}}):_vm._e(),(_vm.listType === 'picture-card')?_c('span',{staticClass:"el-upload-list__item-actions"},[(_vm.handlePreview && _vm.listType === 'picture-card')?_c('span',{staticClass:"el-upload-list__item-preview",on:{"click":function($event){_vm.handlePreview(file)}}},[_c('i',{staticClass:"el-icon-zoom-in"})]):_vm._e(),(!_vm.disabled)?_c('span',{staticClass:"el-upload-list__item-delete",on:{"click":function($event){_vm.$emit('remove', file)}}},[_c('i',{staticClass:"el-icon-delete"})]):_vm._e()]):_vm._e()],1)}))}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_vue__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _babelHelperVueJsxMergeProps = __webpack_require__(41);

var _babelHelperVueJsxMergeProps2 = _interopRequireDefault(_babelHelperVueJsxMergeProps);

var _ajax = __webpack_require__(295);

var _ajax2 = _interopRequireDefault(_ajax);

var _uploadDragger = __webpack_require__(42);

var _uploadDragger2 = _interopRequireDefault(_uploadDragger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  inject: ['uploader'],
  components: {
    UploadDragger: _uploadDragger2.default
  },
  props: {
    type: String,
    action: {
      type: String,
      required: true
    },
    name: {
      type: String,
      default: 'file'
    },
    data: Object,
    headers: Object,
    withCredentials: Boolean,
    multiple: Boolean,
    accept: String,
    onStart: Function,
    onProgress: Function,
    onSuccess: Function,
    onError: Function,
    beforeUpload: Function,
    drag: Boolean,
    onPreview: {
      type: Function,
      default: function _default() {}
    },
    onRemove: {
      type: Function,
      default: function _default() {}
    },
    fileList: Array,
    autoUpload: Boolean,
    listType: String,
    httpRequest: {
      type: Function,
      default: _ajax2.default
    },
    disabled: Boolean,
    limit: Number,
    onExceed: Function
  },

  data: function data() {
    return {
      mouseover: false,
      reqs: {}
    };
  },


  methods: {
    isImage: function isImage(str) {
      return str.indexOf('image') !== -1;
    },
    handleChange: function handleChange(ev) {
      var files = ev.target.files;

      if (!files) return;
      this.uploadFiles(files);
    },
    uploadFiles: function uploadFiles(files) {
      var _this = this;

      if (this.limit && this.fileList.length + files.length > this.limit) {
        this.onExceed && this.onExceed(files, this.fileList);
        return;
      }

      var postFiles = Array.prototype.slice.call(files);
      if (!this.multiple) {
        postFiles = postFiles.slice(0, 1);
      }

      if (postFiles.length === 0) {
        return;
      }

      postFiles.forEach(function (rawFile) {
        _this.onStart(rawFile);
        if (_this.autoUpload) _this.upload(rawFile);
      });
    },
    upload: function upload(rawFile, file) {
      var _this2 = this;

      this.$refs.input.value = null;

      if (!this.beforeUpload) {
        return this.post(rawFile);
      }

      var before = this.beforeUpload(rawFile);
      if (before && before.then) {
        before.then(function (processedFile) {
          var fileType = Object.prototype.toString.call(processedFile);
          if (fileType === '[object File]' || fileType === '[object Blob]') {
            _this2.post(processedFile);
          } else {
            _this2.post(rawFile);
          }
        }, function () {
          _this2.onRemove(null, rawFile);
        });
      } else if (before !== false) {
        this.post(rawFile);
      } else {
        this.onRemove(null, rawFile);
      }
    },
    abort: function abort(file) {
      var reqs = this.reqs;

      if (file) {
        var uid = file;
        if (file.uid) uid = file.uid;
        if (reqs[uid]) {
          reqs[uid].abort();
        }
      } else {
        Object.keys(reqs).forEach(function (uid) {
          if (reqs[uid]) reqs[uid].abort();
          delete reqs[uid];
        });
      }
    },
    post: function post(rawFile) {
      var _this3 = this;

      var uid = rawFile.uid;

      var options = {
        headers: this.headers,
        withCredentials: this.withCredentials,
        file: rawFile,
        data: this.data,
        filename: this.name,
        action: this.action,
        onProgress: function onProgress(e) {
          _this3.onProgress(e, rawFile);
        },
        onSuccess: function onSuccess(res) {
          _this3.onSuccess(res, rawFile);
          delete _this3.reqs[uid];
        },
        onError: function onError(err) {
          _this3.onError(err, rawFile);
          delete _this3.reqs[uid];
        }
      };
      var req = this.httpRequest(options);
      this.reqs[uid] = req;
      if (req && req.then) {
        req.then(options.onSuccess, options.onError);
      }
    },
    handleClick: function handleClick() {
      if (!this.disabled) {
        this.$refs.input.value = null;
        this.$refs.input.click();
      }
    },
    handleKeydown: function handleKeydown(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        this.handleClick();
      }
    }
  },

  render: function render(h) {
    var handleClick = this.handleClick,
        drag = this.drag,
        name = this.name,
        handleChange = this.handleChange,
        multiple = this.multiple,
        accept = this.accept,
        listType = this.listType,
        uploadFiles = this.uploadFiles,
        disabled = this.disabled,
        handleKeydown = this.handleKeydown;

    var data = {
      class: {
        'el-upload': true
      },
      on: {
        click: handleClick,
        keydown: handleKeydown
      }
    };
    data.class['el-upload--' + listType] = true;
    return h(
      'div',
      (0, _babelHelperVueJsxMergeProps2.default)([data, {
        attrs: { tabindex: '0' }
      }]),
      [drag ? h(
        'upload-dragger',
        {
          attrs: { disabled: disabled },
          on: {
            'file': uploadFiles
          }
        },
        [this.$slots.default]
      ) : this.$slots.default, h(
        'input',
        { 'class': 'el-upload__input', attrs: { type: 'file', name: name, multiple: multiple, accept: accept },
          ref: 'input', on: {
            'change': handleChange
          }
        },
        []
      )]
    );
  }
};

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = upload;
function getError(action, option, xhr) {
  var msg = void 0;
  if (xhr.response) {
    msg = '' + (xhr.response.error || xhr.response);
  } else if (xhr.responseText) {
    msg = '' + xhr.responseText;
  } else {
    msg = 'fail to post ' + action + ' ' + xhr.status;
  }

  var err = new Error(msg);
  err.status = xhr.status;
  err.method = 'post';
  err.url = action;
  return err;
}

function getBody(xhr) {
  var text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}

function upload(option) {
  if (typeof XMLHttpRequest === 'undefined') {
    return;
  }

  var xhr = new XMLHttpRequest();
  var action = option.action;

  if (xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      option.onProgress(e);
    };
  }

  var formData = new FormData();

  if (option.data) {
    Object.keys(option.data).forEach(function (key) {
      formData.append(key, option.data[key]);
    });
  }

  formData.append(option.filename, option.file);

  xhr.onerror = function error(e) {
    option.onError(e);
  };

  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr));
    }

    option.onSuccess(getBody(xhr));
  };

  xhr.open('post', action, true);

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  var headers = option.headers || {};

  for (var item in headers) {
    if (headers.hasOwnProperty(item) && headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  }
  xhr.send(formData);
  return xhr;
}

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElUploadDrag',
  props: {
    disabled: Boolean
  },
  data: function data() {
    return {
      dragover: false
    };
  },

  methods: {
    onDragover: function onDragover() {
      if (!this.disabled) {
        this.dragover = true;
      }
    },
    onDrop: function onDrop(e) {
      if (!this.disabled) {
        this.dragover = false;
        this.$emit('file', e.dataTransfer.files);
      }
    }
  }
};

/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-upload-dragger",class:{
    'is-dragover': _vm.dragover
  },on:{"drop":function($event){$event.preventDefault();_vm.onDrop($event)},"dragover":function($event){$event.preventDefault();_vm.onDragover($event)},"dragleave":function($event){$event.preventDefault();_vm.dragover = false}}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_iframe_upload_vue__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_iframe_upload_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_iframe_upload_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_iframe_upload_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _uploadDragger = __webpack_require__(42);

var _uploadDragger2 = _interopRequireDefault(_uploadDragger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    UploadDragger: _uploadDragger2.default
  },
  props: {
    type: String,
    data: {},
    action: {
      type: String,
      required: true
    },
    name: {
      type: String,
      default: 'file'
    },
    withCredentials: Boolean,
    accept: String,
    onStart: Function,
    onProgress: Function,
    onSuccess: Function,
    onError: Function,
    beforeUpload: Function,
    onPreview: {
      type: Function,
      default: function _default() {}
    },
    onRemove: {
      type: Function,
      default: function _default() {}
    },
    drag: Boolean,
    listType: String,
    disabled: Boolean,
    limit: Number,
    onExceed: Function
  },

  data: function data() {
    return {
      mouseover: false,
      domain: '',
      file: null,
      submitting: false
    };
  },


  methods: {
    isImage: function isImage(str) {
      return str.indexOf('image') !== -1;
    },
    handleClick: function handleClick() {
      if (!this.disabled) {
        this.$refs.input.click();
      }
    },
    handleChange: function handleChange(ev) {
      var file = ev.target.value;
      if (file) {
        this.uploadFiles(file);
      }
    },
    uploadFiles: function uploadFiles(file) {
      if (this.limit && this.$parent.uploadFiles.length + file.length > this.limit) {
        this.onExceed && this.onExceed(this.fileList);
        return;
      }

      if (this.submitting) return;
      this.submitting = true;
      this.file = file;
      this.onStart(file);

      var formNode = this.getFormNode();
      var dataSpan = this.getFormDataNode();
      var data = this.data;
      if (typeof data === 'function') {
        data = data(file);
      }
      var inputs = [];
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          inputs.push('<input name="' + key + '" value="' + data[key] + '"/>');
        }
      }
      dataSpan.innerHTML = inputs.join('');
      formNode.submit();
      dataSpan.innerHTML = '';
    },
    getFormNode: function getFormNode() {
      return this.$refs.form;
    },
    getFormDataNode: function getFormDataNode() {
      return this.$refs.data;
    }
  },

  created: function created() {
    this.frameName = 'frame-' + Date.now();
  },
  mounted: function mounted() {
    var self = this;
    !this.$isServer && window.addEventListener('message', function (event) {
      if (!self.file) return;
      var targetOrigin = new URL(self.action).origin;
      if (event.origin !== targetOrigin) return;
      var response = event.data;
      if (response.result === 'success') {
        self.onSuccess(response, self.file);
      } else if (response.result === 'failed') {
        self.onError(response, self.file);
      }
      self.submitting = false;
      self.file = null;
    }, false);
  },
  render: function render(h) {
    var drag = this.drag,
        uploadFiles = this.uploadFiles,
        listType = this.listType,
        frameName = this.frameName,
        disabled = this.disabled;

    var oClass = { 'el-upload': true };
    oClass['el-upload--' + listType] = true;

    return h(
      'div',
      {
        'class': oClass,
        on: {
          'click': this.handleClick
        },
        nativeOn: {
          'drop': this.onDrop,
          'dragover': this.handleDragover,
          'dragleave': this.handleDragleave
        }
      },
      [h(
        'iframe',
        {
          on: {
            'load': this.onload
          },

          ref: 'iframe',
          attrs: { name: frameName
          }
        },
        []
      ), h(
        'form',
        { ref: 'form', attrs: { action: this.action, target: frameName, enctype: 'multipart/form-data', method: 'POST' }
        },
        [h(
          'input',
          {
            'class': 'el-upload__input',
            attrs: { type: 'file',

              name: 'file',

              accept: this.accept },
            ref: 'input', on: {
              'change': this.handleChange
            }
          },
          []
        ), h(
          'input',
          {
            attrs: { type: 'hidden', name: 'documentDomain', value: this.$isServer ? '' : document.domain }
          },
          []
        ), h(
          'span',
          { ref: 'data' },
          []
        )]
      ), drag ? h(
        'upload-dragger',
        {
          on: {
            'file': uploadFiles
          },
          attrs: { disabled: disabled }
        },
        [this.$slots.default]
      ) : this.$slots.default]
    );
  }
};

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _progress = __webpack_require__(301);

var _progress2 = _interopRequireDefault(_progress);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_progress2.default.install = function (Vue) {
  Vue.component(_progress2.default.name, _progress2.default);
};

exports.default = _progress2.default;

/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ddec355_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_progress_vue__ = __webpack_require__(303);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ddec355_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_progress_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElProgress',
  props: {
    type: {
      type: String,
      default: 'line',
      validator: function validator(val) {
        return ['line', 'circle'].indexOf(val) > -1;
      }
    },
    percentage: {
      type: Number,
      default: 0,
      required: true,
      validator: function validator(val) {
        return val >= 0 && val <= 100;
      }
    },
    status: {
      type: String
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    barStyle: function barStyle() {
      var style = {};
      style.width = this.percentage + '%';
      return style;
    },
    relativeStrokeWidth: function relativeStrokeWidth() {
      return (this.strokeWidth / this.width * 100).toFixed(1);
    },
    trackPath: function trackPath() {
      var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);

      return 'M 50 50 m 0 -' + radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 ' + radius * 2 + ' a ' + radius + ' ' + radius + ' 0 1 1 0 -' + radius * 2;
    },
    perimeter: function perimeter() {
      var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
      return 2 * Math.PI * radius;
    },
    circlePathStyle: function circlePathStyle() {
      var perimeter = this.perimeter;
      return {
        strokeDasharray: perimeter + 'px,' + perimeter + 'px',
        strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
        transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
      };
    },
    stroke: function stroke() {
      var ret;
      switch (this.status) {
        case 'success':
          ret = '#13ce66';
          break;
        case 'exception':
          ret = '#ff4949';
          break;
        default:
          ret = '#20a0ff';
      }
      return ret;
    },
    iconClass: function iconClass() {
      if (this.type === 'line') {
        return this.status === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-cross';
      } else {
        return this.status === 'success' ? 'el-icon-check' : 'el-icon-close';
      }
    },
    progressTextSize: function progressTextSize() {
      return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.111111 + 2;
    }
  }
};

/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-progress",class:[
    'el-progress--' + _vm.type,
    _vm.status ? 'is-' + _vm.status : '',
    {
      'el-progress--without-text': !_vm.showText,
      'el-progress--text-inside': _vm.textInside,
    }
  ],attrs:{"role":"progressbar","aria-valuenow":_vm.percentage,"aria-valuemin":"0","aria-valuemax":"100"}},[(_vm.type === 'line')?_c('div',{staticClass:"el-progress-bar"},[_c('div',{staticClass:"el-progress-bar__outer",style:({height: _vm.strokeWidth + 'px'})},[_c('div',{staticClass:"el-progress-bar__inner",style:(_vm.barStyle)},[(_vm.showText && _vm.textInside)?_c('div',{staticClass:"el-progress-bar__innerText"},[_vm._v(_vm._s(_vm.percentage)+"%")]):_vm._e()])])]):_c('div',{staticClass:"el-progress-circle",style:({height: _vm.width + 'px', width: _vm.width + 'px'})},[_c('svg',{attrs:{"viewBox":"0 0 100 100"}},[_c('path',{staticClass:"el-progress-circle__track",attrs:{"d":_vm.trackPath,"stroke":"#e5e9f2","stroke-width":_vm.relativeStrokeWidth,"fill":"none"}}),_c('path',{staticClass:"el-progress-circle__path",style:(_vm.circlePathStyle),attrs:{"d":_vm.trackPath,"stroke-linecap":"round","stroke":_vm.stroke,"stroke-width":_vm.relativeStrokeWidth,"fill":"none"}})])]),(_vm.showText && !_vm.textInside)?_c('div',{staticClass:"el-progress__text",style:({fontSize: _vm.progressTextSize + 'px'})},[(!_vm.status)?[_vm._v(_vm._s(_vm.percentage)+"%")]:_c('i',{class:_vm.iconClass})],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _spinner = __webpack_require__(305);

var _spinner2 = _interopRequireDefault(_spinner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_spinner2.default.install = function (Vue) {
  Vue.component(_spinner2.default.name, _spinner2.default);
};

exports.default = _spinner2.default;

/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_spinner_vue__ = __webpack_require__(306);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_spinner_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_spinner_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_503fa473_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_spinner_vue__ = __webpack_require__(307);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_spinner_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_503fa473_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_spinner_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//

exports.default = {
  name: 'ElSpinner',
  props: {
    type: String,
    radius: {
      type: Number,
      default: 100
    },
    strokeWidth: {
      type: Number,
      default: 5
    },
    strokeColor: {
      type: String,
      default: '#efefef'
    }
  }
};

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"el-spinner"},[_c('svg',{staticClass:"el-spinner-inner",style:({ width: _vm.radius/2 + 'px', height: _vm.radius/2 + 'px' }),attrs:{"viewBox":"0 0 50 50"}},[_c('circle',{staticClass:"path",attrs:{"cx":"25","cy":"25","r":"20","fill":"none","stroke":_vm.strokeColor,"stroke-width":_vm.strokeWidth}})])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(309);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _main2.default;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _main = __webpack_require__(310);

var _main2 = _interopRequireDefault(_main);

var _popup = __webpack_require__(17);

var _vdom = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MessageConstructor = _vue2.default.extend(_main2.default);

var instance = void 0;
var instances = [];
var seed = 1;

var Message = function Message(options) {
  if (_vue2.default.prototype.$isServer) return;
  options = options || {};
  if (typeof options === 'string') {
    options = {
      message: options
    };
  }
  var userOnClose = options.onClose;
  var id = 'message_' + seed++;

  options.onClose = function () {
    Message.close(id, userOnClose);
  };
  instance = new MessageConstructor({
    data: options
  });
  instance.id = id;
  if ((0, _vdom.isVNode)(instance.message)) {
    instance.$slots.default = [instance.message];
    instance.message = null;
  }
  instance.vm = instance.$mount();
  document.body.appendChild(instance.vm.$el);
  instance.vm.visible = true;
  instance.dom = instance.vm.$el;
  instance.dom.style.zIndex = _popup.PopupManager.nextZIndex();
  instances.push(instance);
  return instance.vm;
};

['success', 'warning', 'info', 'error'].forEach(function (type) {
  Message[type] = function (options) {
    if (typeof options === 'string') {
      options = {
        message: options
      };
    }
    options.type = type;
    return Message(options);
  };
});

Message.close = function (id, userOnClose) {
  for (var i = 0, len = instances.length; i < len; i++) {
    if (id === instances[i].id) {
      if (typeof userOnClose === 'function') {
        userOnClose(instances[i]);
      }
      instances.splice(i, 1);
      break;
    }
  }
};

Message.closeAll = function () {
  for (var i = instances.length - 1; i >= 0; i--) {
    instances[i].close();
  }
};

exports.default = Message;

/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_bf6c88be_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(312);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_bf6c88be_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var typeMap = {
  success: 'success',
  info: 'info',
  warning: 'warning',
  error: 'error'
};

exports.default = {
  data: function data() {
    return {
      visible: false,
      message: '',
      duration: 3000,
      type: 'info',
      iconClass: '',
      customClass: '',
      onClose: null,
      showClose: false,
      closed: false,
      timer: null,
      dangerouslyUseHTMLString: false,
      center: false
    };
  },


  computed: {
    iconWrapClass: function iconWrapClass() {
      var classes = ['el-message__icon'];
      if (this.type && !this.iconClass) {
        classes.push('el-message__icon--' + this.type);
      }
      return classes;
    },
    typeClass: function typeClass() {
      return this.type && !this.iconClass ? 'el-message__icon el-icon-' + typeMap[this.type] : '';
    }
  },

  watch: {
    closed: function closed(newVal) {
      if (newVal) {
        this.visible = false;
        this.$el.addEventListener('transitionend', this.destroyElement);
      }
    }
  },

  methods: {
    destroyElement: function destroyElement() {
      this.$el.removeEventListener('transitionend', this.destroyElement);
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    close: function close() {
      this.closed = true;
      if (typeof this.onClose === 'function') {
        this.onClose(this);
      }
    },
    clearTimer: function clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer: function startTimer() {
      var _this = this;

      if (this.duration > 0) {
        this.timer = setTimeout(function () {
          if (!_this.closed) {
            _this.close();
          }
        }, this.duration);
      }
    },
    keydown: function keydown(e) {
      if (e.keyCode === 27) {
        // esc关闭消息
        if (!this.closed) {
          this.close();
        }
      }
    }
  },
  mounted: function mounted() {
    this.startTimer();
    document.addEventListener('keydown', this.keydown);
  },
  beforeDestroy: function beforeDestroy() {
    document.removeEventListener('keydown', this.keydown);
  }
};

/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-message-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],class:[
      'el-message',
      _vm.type && !_vm.iconClass ? ("el-message--" + _vm.type) : '',
      _vm.center ? 'is-center' : '',
      _vm.customClass],attrs:{"role":"alert"},on:{"mouseenter":_vm.clearTimer,"mouseleave":_vm.startTimer}},[(_vm.iconClass)?_c('i',{class:_vm.iconClass}):_c('i',{class:_vm.typeClass}),_vm._t("default",[(!_vm.dangerouslyUseHTMLString)?_c('p',{staticClass:"el-message__content"},[_vm._v(_vm._s(_vm.message))]):_c('p',{staticClass:"el-message__content",domProps:{"innerHTML":_vm._s(_vm.message)}})]),(_vm.showClose)?_c('i',{staticClass:"el-message__closeBtn el-icon-close",on:{"click":_vm.close}}):_vm._e()],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(314);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_08ee78c5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(316);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_08ee78c5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElBadge',

  props: {
    value: {},
    max: Number,
    isDot: Boolean,
    hidden: Boolean
  },

  computed: {
    content: function content() {
      if (this.isDot) return;

      var value = this.value;
      var max = this.max;

      if (typeof value === 'number' && typeof max === 'number') {
        return max < value ? max + '+' : value;
      }

      return value;
    }
  }
};

/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-badge"},[_vm._t("default"),_c('transition',{attrs:{"name":"el-zoom-in-center"}},[_c('sup',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hidden && ( _vm.content || _vm.isDot )),expression:"!hidden && ( content || isDot )"}],staticClass:"el-badge__content",class:{ 'is-fixed': _vm.$slots.default, 'is-dot': _vm.isDot },domProps:{"textContent":_vm._s(_vm.content)}})])],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(318);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(319);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b3777b44_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(320);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b3777b44_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElCard',

  props: ['header', 'bodyStyle']
};

/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-card"},[(_vm.$slots.header || _vm.header)?_c('div',{staticClass:"el-card__header"},[_vm._t("header",[_vm._v(_vm._s(_vm.header))])],2):_vm._e(),_c('div',{staticClass:"el-card__body",style:(_vm.bodyStyle)},[_vm._t("default")],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(322);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_14663ae4_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(324);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_14663ae4_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElRate',

  mixins: [_migrating2.default],

  data: function data() {
    return {
      classMap: {},
      pointerAtLeftHalf: true,
      currentValue: this.value,
      hoverIndex: -1
    };
  },


  props: {
    value: {
      type: Number,
      default: 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: Array,
      default: function _default() {
        return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
      }
    },
    voidColor: {
      type: String,
      default: '#C6D1DE'
    },
    disabledVoidColor: {
      type: String,
      default: '#EFF2F7'
    },
    iconClasses: {
      type: Array,
      default: function _default() {
        return ['el-icon-star-on', 'el-icon-star-on', 'el-icon-star-on'];
      }
    },
    voidIconClass: {
      type: String,
      default: 'el-icon-star-off'
    },
    disabledVoidIconClass: {
      type: String,
      default: 'el-icon-star-on'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    showText: {
      type: Boolean,
      default: false
    },
    showScore: {
      type: Boolean,
      default: false
    },
    textColor: {
      type: String,
      default: '#1f2d3d'
    },
    texts: {
      type: Array,
      default: function _default() {
        return ['极差', '失望', '一般', '满意', '惊喜'];
      }
    },
    scoreTemplate: {
      type: String,
      default: '{value}'
    }
  },

  computed: {
    text: function text() {
      var result = '';
      if (this.showScore) {
        result = this.scoreTemplate.replace(/\{\s*value\s*\}/, this.disabled ? this.value : this.currentValue);
      } else if (this.showText) {
        result = this.texts[Math.ceil(this.currentValue) - 1];
      }
      return result;
    },
    decimalStyle: function decimalStyle() {
      var width = '';
      if (this.disabled) {
        width = (this.valueDecimal < 50 ? 0 : 50) + '%';
      }
      if (this.allowHalf) {
        width = '50%';
      }
      return {
        color: this.activeColor,
        width: width
      };
    },
    valueDecimal: function valueDecimal() {
      return this.value * 100 - Math.floor(this.value) * 100;
    },
    decimalIconClass: function decimalIconClass() {
      return this.getValueFromMap(this.value, this.classMap);
    },
    voidClass: function voidClass() {
      return this.disabled ? this.classMap.disabledVoidClass : this.classMap.voidClass;
    },
    activeClass: function activeClass() {
      return this.getValueFromMap(this.currentValue, this.classMap);
    },
    colorMap: function colorMap() {
      return {
        lowColor: this.colors[0],
        mediumColor: this.colors[1],
        highColor: this.colors[2],
        voidColor: this.voidColor,
        disabledVoidColor: this.disabledVoidColor
      };
    },
    activeColor: function activeColor() {
      return this.getValueFromMap(this.currentValue, this.colorMap);
    },
    classes: function classes() {
      var result = [];
      var i = 0;
      var threshold = this.currentValue;
      if (this.allowHalf && this.currentValue !== Math.floor(this.currentValue)) {
        threshold--;
      }
      for (; i < threshold; i++) {
        result.push(this.activeClass);
      }
      for (; i < this.max; i++) {
        result.push(this.voidClass);
      }
      return result;
    }
  },

  watch: {
    value: function value(val) {
      this.currentValue = val;
      this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'text-template': 'text-template is renamed to score-template.'
        }
      };
    },
    getValueFromMap: function getValueFromMap(value, map) {
      var result = '';
      if (value <= this.lowThreshold) {
        result = map.lowColor || map.lowClass;
      } else if (value >= this.highThreshold) {
        result = map.highColor || map.highClass;
      } else {
        result = map.mediumColor || map.mediumClass;
      }
      return result;
    },
    showDecimalIcon: function showDecimalIcon(item) {
      var showWhenDisabled = this.disabled && this.valueDecimal > 0 && item - 1 < this.value && item > this.value;
      /* istanbul ignore next */
      var showWhenAllowHalf = this.allowHalf && this.pointerAtLeftHalf && item - 0.5 <= this.currentValue && item > this.currentValue;
      return showWhenDisabled || showWhenAllowHalf;
    },
    getIconStyle: function getIconStyle(item) {
      var voidColor = this.disabled ? this.colorMap.disabledVoidColor : this.colorMap.voidColor;
      return {
        color: item <= this.currentValue ? this.activeColor : voidColor
      };
    },
    selectValue: function selectValue(value) {
      if (this.disabled) {
        return;
      }
      if (this.allowHalf && this.pointerAtLeftHalf) {
        this.$emit('input', this.currentValue);
        this.$emit('change', this.currentValue);
      } else {
        this.$emit('input', value);
        this.$emit('change', value);
      }
    },
    handelKey: function handelKey(e) {
      var currentValue = this.currentValue;
      var keyCode = e.keyCode;
      if (keyCode === 38 || keyCode === 39) {
        // left / down
        if (this.allowHalf) {
          currentValue += 0.5;
        } else {
          currentValue += 1;
        }
        e.stopPropagation();
        e.preventDefault();
      } else if (keyCode === 37 || keyCode === 40) {
        if (this.allowHalf) {
          currentValue -= 0.5;
        } else {
          currentValue -= 1;
        }
        e.stopPropagation();
        e.preventDefault();
      }
      currentValue = currentValue < 0 ? 0 : currentValue;
      currentValue = currentValue > this.max ? this.max : currentValue;

      this.$emit('input', currentValue);
      this.$emit('change', currentValue);
    },
    setCurrentValue: function setCurrentValue(value, event) {
      if (this.disabled) {
        return;
      }
      /* istanbul ignore if */
      if (this.allowHalf) {
        var target = event.target;
        if ((0, _dom.hasClass)(target, 'el-rate__item')) {
          target = target.querySelector('.el-rate__icon');
        }
        if ((0, _dom.hasClass)(target, 'el-rate__decimal')) {
          target = target.parentNode;
        }
        this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
        this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
      } else {
        this.currentValue = value;
      }
      this.hoverIndex = value;
    },
    resetCurrentValue: function resetCurrentValue() {
      if (this.disabled) {
        return;
      }
      if (this.allowHalf) {
        this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
      }
      this.currentValue = this.value;
      this.hoverIndex = -1;
    }
  },

  created: function created() {
    if (!this.value) {
      this.$emit('input', 0);
    }
    this.classMap = {
      lowClass: this.iconClasses[0],
      mediumClass: this.iconClasses[1],
      highClass: this.iconClasses[2],
      voidClass: this.voidIconClass,
      disabledVoidClass: this.disabledVoidIconClass
    };
  }
};

/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-rate",attrs:{"role":"slider","aria-valuenow":_vm.currentValue,"aria-valuetext":_vm.text,"aria-valuemin":"0","aria-valuemax":_vm.max,"tabindex":"0"},on:{"keydown":_vm.handelKey}},[_vm._l((_vm.max),function(item){return _c('span',{staticClass:"el-rate__item",style:({ cursor: _vm.disabled ? 'auto' : 'pointer' }),on:{"mousemove":function($event){_vm.setCurrentValue(item, $event)},"mouseleave":_vm.resetCurrentValue,"click":function($event){_vm.selectValue(item)}}},[_c('i',{staticClass:"el-rate__icon",class:[_vm.classes[item - 1], { 'hover': _vm.hoverIndex === item }],style:(_vm.getIconStyle(item))},[(_vm.showDecimalIcon(item))?_c('i',{staticClass:"el-rate__decimal",class:_vm.decimalIconClass,style:(_vm.decimalStyle)}):_vm._e()])])}),(_vm.showText || _vm.showScore)?_c('span',{staticClass:"el-rate__text",style:({ color: _vm.textColor })},[_vm._v(_vm._s(_vm.text))]):_vm._e()],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _steps = __webpack_require__(326);

var _steps2 = _interopRequireDefault(_steps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_steps2.default.install = function (Vue) {
  Vue.component(_steps2.default.name, _steps2.default);
};

exports.default = _steps2.default;

/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_steps_vue__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_steps_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_steps_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_40c69762_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_steps_vue__ = __webpack_require__(328);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_steps_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_40c69762_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_steps_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElSteps',

  mixins: [_migrating2.default],

  props: {
    space: [Number, String],
    active: Number,
    direction: {
      type: String,
      default: 'horizontal'
    },
    alignCenter: Boolean,
    simple: Boolean,
    finishStatus: {
      type: String,
      default: 'finish'
    },
    processStatus: {
      type: String,
      default: 'process'
    }
  },

  data: function data() {
    return {
      steps: [],
      stepOffset: 0
    };
  },


  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'center': 'center is removed.'
        }
      };
    }
  },

  watch: {
    active: function active(newVal, oldVal) {
      this.$emit('change', newVal, oldVal);
    },
    steps: function steps(_steps) {
      _steps.forEach(function (child, index) {
        child.index = index;
      });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-steps",class:[
     !_vm.simple && 'el-steps--' + _vm.direction,
     _vm.simple && 'el-steps--simple'
   ]},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _step = __webpack_require__(330);

var _step2 = _interopRequireDefault(_step);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_step2.default.install = function (Vue) {
  Vue.component(_step2.default.name, _step2.default);
};

exports.default = _step2.default;

/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_step_vue__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_step_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_step_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_656c5158_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_step_vue__ = __webpack_require__(332);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_step_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_656c5158_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_step_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElStep',

  props: {
    title: String,
    icon: String,
    description: String,
    status: String
  },

  data: function data() {
    return {
      index: -1,
      lineStyle: {},
      internalStatus: ''
    };
  },
  beforeCreate: function beforeCreate() {
    this.$parent.steps.push(this);
  },
  beforeDestroy: function beforeDestroy() {
    var steps = this.$parent.steps;
    var index = steps.indexOf(this);
    if (index >= 0) {
      steps.splice(index, 1);
    }
  },


  computed: {
    currentStatus: function currentStatus() {
      return this.status || this.internalStatus;
    },
    prevStatus: function prevStatus() {
      var prevStep = this.$parent.steps[this.index - 1];
      return prevStep ? prevStep.currentStatus : 'wait';
    },
    isCenter: function isCenter() {
      return this.$parent.alignCenter;
    },
    isVertical: function isVertical() {
      return this.$parent.direction === 'vertical';
    },
    isSimple: function isSimple() {
      return this.$parent.simple;
    },
    isLast: function isLast() {
      var parent = this.$parent;
      return parent.steps[parent.steps.length - 1] === this;
    },
    stepsCount: function stepsCount() {
      return this.$parent.steps.length;
    },
    space: function space() {
      var isSimple = this.isSimple,
          space = this.$parent.space;

      return isSimple ? '' : space;
    },

    style: function style() {
      var style = {};
      var parent = this.$parent;
      var len = parent.steps.length;

      var space = typeof this.space === 'number' ? this.space + 'px' : this.space ? this.space : 100 / (len - 1) + '%';
      style.flexBasis = space;
      if (this.isVertical) return style;
      if (this.isLast) {
        style.maxWidth = 100 / this.stepsCount + '%';
      } else {
        style.marginRight = -this.$parent.stepOffset + 'px';
      }

      return style;
    }
  },

  methods: {
    updateStatus: function updateStatus(val) {
      var prevChild = this.$parent.$children[this.index - 1];

      if (val > this.index) {
        this.internalStatus = this.$parent.finishStatus;
      } else if (val === this.index && this.prevStatus !== 'error') {
        this.internalStatus = this.$parent.processStatus;
      } else {
        this.internalStatus = 'wait';
      }

      if (prevChild) prevChild.calcProgress(this.internalStatus);
    },
    calcProgress: function calcProgress(status) {
      var step = 100;
      var style = {};

      style.transitionDelay = 150 * this.index + 'ms';
      if (status === this.$parent.processStatus) {
        step = this.currentStatus !== 'error' ? 0 : 0;
      } else if (status === 'wait') {
        step = 0;
        style.transitionDelay = -150 * this.index + 'ms';
      }

      style.borderWidth = step ? '1px' : 0;
      this.$parent.direction === 'vertical' ? style.height = step + '%' : style.width = step + '%';

      this.lineStyle = style;
    }
  },

  mounted: function mounted() {
    var _this = this;

    var unwatch = this.$watch('index', function (val) {
      _this.$watch('$parent.active', _this.updateStatus, { immediate: true });
      unwatch();
    });
  }
};

/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-step",class:[
    !_vm.isSimple && ("is-" + (_vm.$parent.direction)),
    _vm.isSimple && 'is-simple',
    _vm.isLast && !_vm.space && !_vm.isCenter && 'is-flex',
    _vm.isCenter && !_vm.isVertical && !_vm.isSimple && 'is-center'
   ],style:(_vm.style)},[_c('div',{staticClass:"el-step__head",class:("is-" + _vm.currentStatus)},[_c('div',{staticClass:"el-step__line",style:(_vm.isLast ? '' : { marginRight: _vm.$parent.stepOffset + 'px' })},[_c('i',{staticClass:"el-step__line-inner",style:(_vm.lineStyle)})]),_c('div',{staticClass:"el-step__icon",class:("is-" + (_vm.icon ? 'icon' : 'text'))},[(_vm.currentStatus !== 'success' && _vm.currentStatus !== 'error')?_vm._t("icon",[(_vm.icon)?_c('i',{staticClass:"el-step__icon-inner",class:[_vm.icon]}):_vm._e(),(!_vm.icon && !_vm.isSimple)?_c('div',{staticClass:"el-step__icon-inner"},[_vm._v(_vm._s(_vm.index + 1))]):_vm._e()]):_c('i',{staticClass:"el-step__icon-inner is-status",class:['el-icon-' + (_vm.currentStatus === 'success' ? 'check' : 'close')]})],2)]),_c('div',{staticClass:"el-step__main"},[_c('div',{ref:"title",staticClass:"el-step__title",class:['is-' + _vm.currentStatus]},[_vm._t("title",[_vm._v(_vm._s(_vm.title))])],2),(_vm.isSimple)?_c('div',{staticClass:"el-step__arrow"}):_c('div',{staticClass:"el-step__description",class:['is-' + _vm.currentStatus]},[_vm._t("description",[_vm._v(_vm._s(_vm.description))])],2)])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(334);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6d4b548e_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(336);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6d4b548e_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _throttle = __webpack_require__(33);

var _throttle2 = _interopRequireDefault(_throttle);

var _resizeEvent = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElCarousel',

  props: {
    initialIndex: {
      type: Number,
      default: 0
    },
    height: String,
    trigger: {
      type: String,
      default: 'hover'
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    interval: {
      type: Number,
      default: 3000
    },
    indicatorPosition: String,
    indicator: {
      type: Boolean,
      default: true
    },
    arrow: {
      type: String,
      default: 'hover'
    },
    type: String
  },

  data: function data() {
    return {
      items: [],
      activeIndex: -1,
      containerWidth: 0,
      timer: null,
      hover: false
    };
  },


  computed: {
    hasLabel: function hasLabel() {
      return this.items.some(function (item) {
        return item.label.toString().length > 0;
      });
    }
  },

  watch: {
    items: function items(val) {
      if (val.length > 0) this.setActiveItem(this.initialIndex);
    },
    activeIndex: function activeIndex(val, oldVal) {
      this.resetItemPosition(oldVal);
      this.$emit('change', val, oldVal);
    },
    autoplay: function autoplay(val) {
      val ? this.startTimer() : this.pauseTimer();
    }
  },

  methods: {
    handleMouseEnter: function handleMouseEnter() {
      this.hover = true;
      this.pauseTimer();
    },
    handleMouseLeave: function handleMouseLeave() {
      this.hover = false;
      this.startTimer();
    },
    itemInStage: function itemInStage(item, index) {
      var length = this.items.length;
      if (index === length - 1 && item.inStage && this.items[0].active || item.inStage && this.items[index + 1] && this.items[index + 1].active) {
        return 'left';
      } else if (index === 0 && item.inStage && this.items[length - 1].active || item.inStage && this.items[index - 1] && this.items[index - 1].active) {
        return 'right';
      }
      return false;
    },
    handleButtonEnter: function handleButtonEnter(arrow) {
      var _this = this;

      this.items.forEach(function (item, index) {
        if (arrow === _this.itemInStage(item, index)) {
          item.hover = true;
        }
      });
    },
    handleButtonLeave: function handleButtonLeave() {
      this.items.forEach(function (item) {
        item.hover = false;
      });
    },
    updateItems: function updateItems() {
      this.items = this.$children.filter(function (child) {
        return child.$options.name === 'ElCarouselItem';
      });
    },
    resetItemPosition: function resetItemPosition(oldIndex) {
      var _this2 = this;

      this.items.forEach(function (item, index) {
        item.translateItem(index, _this2.activeIndex, oldIndex);
      });
    },
    playSlides: function playSlides() {
      if (this.activeIndex < this.items.length - 1) {
        this.activeIndex++;
      } else {
        this.activeIndex = 0;
      }
    },
    pauseTimer: function pauseTimer() {
      clearInterval(this.timer);
    },
    startTimer: function startTimer() {
      if (this.interval <= 0 || !this.autoplay) return;
      this.timer = setInterval(this.playSlides, this.interval);
    },
    setActiveItem: function setActiveItem(index) {
      if (typeof index === 'string') {
        var filteredItems = this.items.filter(function (item) {
          return item.name === index;
        });
        if (filteredItems.length > 0) {
          index = this.items.indexOf(filteredItems[0]);
        }
      }
      index = Number(index);
      if (isNaN(index) || index !== Math.floor(index)) {
        "production" !== 'production' && console.warn('[Element Warn][Carousel]index must be an integer.');
        return;
      }
      var length = this.items.length;
      if (index < 0) {
        this.activeIndex = length - 1;
      } else if (index >= length) {
        this.activeIndex = 0;
      } else {
        this.activeIndex = index;
      }
    },
    prev: function prev() {
      this.setActiveItem(this.activeIndex - 1);
    },
    next: function next() {
      this.setActiveItem(this.activeIndex + 1);
    },
    handleIndicatorClick: function handleIndicatorClick(index) {
      this.activeIndex = index;
    },
    handleIndicatorHover: function handleIndicatorHover(index) {
      if (this.trigger === 'hover' && index !== this.activeIndex) {
        this.activeIndex = index;
      }
    }
  },

  created: function created() {
    var _this3 = this;

    this.throttledArrowClick = (0, _throttle2.default)(300, true, function (index) {
      _this3.setActiveItem(index);
    });
    this.throttledIndicatorHover = (0, _throttle2.default)(300, function (index) {
      _this3.handleIndicatorHover(index);
    });
  },
  mounted: function mounted() {
    var _this4 = this;

    this.updateItems();
    this.$nextTick(function () {
      (0, _resizeEvent.addResizeListener)(_this4.$el, _this4.resetItemPosition);
      if (_this4.initialIndex < _this4.items.length && _this4.initialIndex >= 0) {
        _this4.activeIndex = _this4.initialIndex;
      }
      _this4.startTimer();
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$el) (0, _resizeEvent.removeResizeListener)(this.$el, this.resetItemPosition);
  }
};

/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-carousel",class:{ 'el-carousel--card': _vm.type === 'card' },on:{"mouseenter":function($event){$event.stopPropagation();_vm.handleMouseEnter($event)},"mouseleave":function($event){$event.stopPropagation();_vm.handleMouseLeave($event)}}},[_c('div',{staticClass:"el-carousel__container",style:({ height: _vm.height })},[_c('transition',{attrs:{"name":"carousel-arrow-left"}},[(_vm.arrow !== 'never')?_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.arrow === 'always' || _vm.hover),expression:"arrow === 'always' || hover"}],staticClass:"el-carousel__arrow el-carousel__arrow--left",on:{"mouseenter":function($event){_vm.handleButtonEnter('left')},"mouseleave":_vm.handleButtonLeave,"click":function($event){$event.stopPropagation();_vm.throttledArrowClick(_vm.activeIndex - 1)}}},[_c('i',{staticClass:"el-icon-arrow-left"})]):_vm._e()]),_c('transition',{attrs:{"name":"carousel-arrow-right"}},[(_vm.arrow !== 'never')?_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.arrow === 'always' || _vm.hover),expression:"arrow === 'always' || hover"}],staticClass:"el-carousel__arrow el-carousel__arrow--right",on:{"mouseenter":function($event){_vm.handleButtonEnter('right')},"mouseleave":_vm.handleButtonLeave,"click":function($event){$event.stopPropagation();_vm.throttledArrowClick(_vm.activeIndex + 1)}}},[_c('i',{staticClass:"el-icon-arrow-right"})]):_vm._e()]),_vm._t("default")],2),(_vm.indicatorPosition !== 'none')?_c('ul',{staticClass:"el-carousel__indicators",class:{ 'el-carousel__indicators--labels': _vm.hasLabel, 'el-carousel__indicators--outside': _vm.indicatorPosition === 'outside' || _vm.type === 'card' }},_vm._l((_vm.items),function(item,index){return _c('li',{staticClass:"el-carousel__indicator",class:{ 'is-active': index === _vm.activeIndex },on:{"mouseenter":function($event){_vm.throttledIndicatorHover(index)},"click":function($event){$event.stopPropagation();_vm.handleIndicatorClick(index)}}},[_c('button',{staticClass:"el-carousel__button"},[(_vm.hasLabel)?_c('span',[_vm._v(_vm._s(item.label))]):_vm._e()])])})):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(338);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _resizeEvent = __webpack_require__(18);

var _scrollbarWidth = __webpack_require__(34);

var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

var _util = __webpack_require__(3);

var _bar = __webpack_require__(339);

var _bar2 = _interopRequireDefault(_bar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
// reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

exports.default = {
  name: 'ElScrollbar',

  components: { Bar: _bar2.default },

  props: {
    native: Boolean,
    wrapStyle: {},
    wrapClass: {},
    viewClass: {},
    viewStyle: {},
    noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
    tag: {
      type: String,
      default: 'div'
    }
  },

  data: function data() {
    return {
      sizeWidth: '0',
      sizeHeight: '0',
      moveX: 0,
      moveY: 0
    };
  },


  computed: {
    wrap: function wrap() {
      return this.$refs.wrap;
    }
  },

  render: function render(h) {
    var gutter = (0, _scrollbarWidth2.default)();
    var style = this.wrapStyle;

    if (gutter) {
      var gutterWith = '-' + gutter + 'px';
      var gutterStyle = 'margin-bottom: ' + gutterWith + '; margin-right: ' + gutterWith + ';';

      if (Array.isArray(this.wrapStyle)) {
        style = (0, _util.toObject)(this.wrapStyle);
        style.marginRight = style.marginBottom = gutterWith;
      } else if (typeof this.wrapStyle === 'string') {
        style += gutterStyle;
      } else {
        style = gutterStyle;
      }
    }
    var view = h(this.tag, {
      class: ['el-scrollbar__view', this.viewClass],
      style: this.viewStyle,
      ref: 'resize'
    }, this.$slots.default);
    var wrap = h(
      'div',
      {
        ref: 'wrap',
        style: style,
        on: {
          'scroll': this.handleScroll
        },

        'class': [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default'] },
      [[view]]
    );
    var nodes = void 0;

    if (!this.native) {
      nodes = [wrap, h(
        _bar2.default,
        {
          attrs: {
            move: this.moveX,
            size: this.sizeWidth }
        },
        []
      ), h(
        _bar2.default,
        {
          attrs: {
            vertical: true,
            move: this.moveY,
            size: this.sizeHeight }
        },
        []
      )];
    } else {
      nodes = [h(
        'div',
        {
          ref: 'wrap',
          'class': [this.wrapClass, 'el-scrollbar__wrap'],
          style: style },
        [[view]]
      )];
    }
    return h('div', { class: 'el-scrollbar' }, nodes);
  },


  methods: {
    handleScroll: function handleScroll() {
      var wrap = this.wrap;

      this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
      this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
    },
    update: function update() {
      var heightPercentage = void 0,
          widthPercentage = void 0;
      var wrap = this.wrap;
      if (!wrap) return;

      heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
      widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;

      this.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
      this.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
    }
  },

  mounted: function mounted() {
    if (this.native) return;
    this.$nextTick(this.update);
    !this.noresize && (0, _resizeEvent.addResizeListener)(this.$refs.resize, this.update);
  },
  beforeDestroy: function beforeDestroy() {
    if (this.native) return;
    !this.noresize && (0, _resizeEvent.removeResizeListener)(this.$refs.resize, this.update);
  }
};

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

var _util = __webpack_require__(340);

/* istanbul ignore next */
exports.default = {
  name: 'Bar',

  props: {
    vertical: Boolean,
    size: String,
    move: Number
  },

  computed: {
    bar: function bar() {
      return _util.BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
    },
    wrap: function wrap() {
      return this.$parent.wrap;
    }
  },

  render: function render(h) {
    var size = this.size,
        move = this.move,
        bar = this.bar;


    return h(
      'div',
      {
        'class': ['el-scrollbar__bar', 'is-' + bar.key],
        on: {
          'mousedown': this.clickTrackHandler
        }
      },
      [h(
        'div',
        {
          ref: 'thumb',
          'class': 'el-scrollbar__thumb',
          on: {
            'mousedown': this.clickThumbHandler
          },

          style: (0, _util.renderThumbStyle)({ size: size, move: move, bar: bar }) },
        []
      )]
    );
  },


  methods: {
    clickThumbHandler: function clickThumbHandler(e) {
      this.startDrag(e);
      this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
    },
    clickTrackHandler: function clickTrackHandler(e) {
      var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
      var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
      var thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];

      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
    },
    startDrag: function startDrag(e) {
      e.stopImmediatePropagation();
      this.cursorDown = true;

      (0, _dom.on)(document, 'mousemove', this.mouseMoveDocumentHandler);
      (0, _dom.on)(document, 'mouseup', this.mouseUpDocumentHandler);
      document.onselectstart = function () {
        return false;
      };
    },
    mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
      if (this.cursorDown === false) return;
      var prevPage = this[this.bar.axis];

      if (!prevPage) return;

      var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
      var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];

      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
    },
    mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
      this.cursorDown = false;
      this[this.bar.axis] = 0;
      (0, _dom.off)(document, 'mousemove', this.mouseMoveDocumentHandler);
      document.onselectstart = null;
    }
  },

  destroyed: function destroyed() {
    (0, _dom.off)(document, 'mouseup', this.mouseUpDocumentHandler);
  }
};

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.renderThumbStyle = renderThumbStyle;
var BAR_MAP = exports.BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top'
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left'
  }
};

function renderThumbStyle(_ref) {
  var move = _ref.move,
      size = _ref.size,
      bar = _ref.bar;

  var style = {};
  var translate = 'translate' + bar.axis + '(' + move + '%)';

  style[bar.size] = size;
  style.transform = translate;
  style.msTransform = translate;
  style.webkitTransform = translate;

  return style;
};

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _item = __webpack_require__(342);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_item2.default.install = function (Vue) {
  Vue.component(_item2.default.name, _item2.default);
};

exports.default = _item2.default;

/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_item_vue__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_item_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_9808e630_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_item_vue__ = __webpack_require__(344);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_item_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_9808e630_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_item_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var CARD_SCALE = 0.83;
exports.default = {
  name: 'ElCarouselItem',

  props: {
    name: String,
    label: {
      type: [String, Number],
      default: ''
    }
  },

  data: function data() {
    return {
      hover: false,
      translate: 0,
      scale: 1,
      active: false,
      ready: false,
      inStage: false,
      animating: false
    };
  },


  methods: {
    processIndex: function processIndex(index, activeIndex, length) {
      if (activeIndex === 0 && index === length - 1) {
        return -1;
      } else if (activeIndex === length - 1 && index === 0) {
        return length;
      } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
        return length + 1;
      } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
        return -2;
      }
      return index;
    },
    calculateTranslate: function calculateTranslate(index, activeIndex, parentWidth) {
      if (this.inStage) {
        return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
      } else if (index < activeIndex) {
        return -(1 + CARD_SCALE) * parentWidth / 4;
      } else {
        return (3 + CARD_SCALE) * parentWidth / 4;
      }
    },
    translateItem: function translateItem(index, activeIndex, oldIndex) {
      var parentWidth = this.$parent.$el.offsetWidth;
      var length = this.$parent.items.length;
      if (this.$parent.type !== 'card' && oldIndex !== undefined) {
        this.animating = index === activeIndex || index === oldIndex;
      }
      if (index !== activeIndex && length > 2) {
        index = this.processIndex(index, activeIndex, length);
      }
      if (this.$parent.type === 'card') {
        this.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
        this.active = index === activeIndex;
        this.translate = this.calculateTranslate(index, activeIndex, parentWidth);
        this.scale = this.active ? 1 : CARD_SCALE;
      } else {
        this.active = index === activeIndex;
        this.translate = parentWidth * (index - activeIndex);
      }
      this.ready = true;
    },
    handleItemClick: function handleItemClick() {
      var parent = this.$parent;
      if (parent && parent.type === 'card') {
        var index = parent.items.indexOf(this);
        parent.setActiveItem(index);
      }
    }
  },

  created: function created() {
    this.$parent && this.$parent.updateItems();
  },
  destroyed: function destroyed() {
    this.$parent && this.$parent.updateItems();
  }
};

/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.ready),expression:"ready"}],staticClass:"el-carousel__item",class:{
    'is-active': _vm.active,
    'el-carousel__item--card': _vm.$parent.type === 'card',
    'is-in-stage': _vm.inStage,
    'is-hover': _vm.hover,
    'is-animating': _vm.animating
  },style:({
    msTransform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")"),
    webkitTransform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")"),
    transform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")")
  }),on:{"click":_vm.handleItemClick}},[(_vm.$parent.type === 'card')?_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.active),expression:"!active"}],staticClass:"el-carousel__mask"}):_vm._e(),_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _collapse = __webpack_require__(346);

var _collapse2 = _interopRequireDefault(_collapse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_collapse2.default.install = function (Vue) {
  Vue.component(_collapse2.default.name, _collapse2.default);
};

exports.default = _collapse2.default;

/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_vue__ = __webpack_require__(347);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_18313355_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_collapse_vue__ = __webpack_require__(348);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_18313355_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_collapse_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//

exports.default = {
  name: 'ElCollapse',

  componentName: 'ElCollapse',

  props: {
    accordion: Boolean,
    value: {
      type: [Array, String, Number],
      default: function _default() {
        return [];
      }
    }
  },

  data: function data() {
    return {
      activeNames: [].concat(this.value)
    };
  },
  provide: function provide() {
    return {
      collapse: this
    };
  },


  watch: {
    value: function value(_value) {
      this.activeNames = [].concat(_value);
    }
  },

  methods: {
    setActiveNames: function setActiveNames(activeNames) {
      activeNames = [].concat(activeNames);
      var value = this.accordion ? activeNames[0] : activeNames;
      this.activeNames = activeNames;
      this.$emit('input', value);
      this.$emit('change', value);
    },
    handleItemClick: function handleItemClick(item) {
      if (this.accordion) {
        this.setActiveNames((this.activeNames[0] || this.activeNames[0] === 0) && this.activeNames[0] === item.name ? '' : item.name);
      } else {
        var activeNames = this.activeNames.slice(0);
        var index = activeNames.indexOf(item.name);

        if (index > -1) {
          activeNames.splice(index, 1);
        } else {
          activeNames.push(item.name);
        }
        this.setActiveNames(activeNames);
      }
    }
  },

  created: function created() {
    this.$on('item-click', this.handleItemClick);
  }
};

/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-collapse",attrs:{"role":"tablist","aria-multiselectable":"true"}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _collapseItem = __webpack_require__(350);

var _collapseItem2 = _interopRequireDefault(_collapseItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_collapseItem2.default.install = function (Vue) {
  Vue.component(_collapseItem2.default.name, _collapseItem2.default);
};

exports.default = _collapseItem2.default;

/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_item_vue__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_item_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_25c1468a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_collapse_item_vue__ = __webpack_require__(352);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_collapse_item_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_25c1468a_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_collapse_item_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _collapseTransition = __webpack_require__(20);

var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElCollapseItem',

  componentName: 'ElCollapseItem',

  mixins: [_emitter2.default],

  components: { ElCollapseTransition: _collapseTransition2.default },

  data: function data() {
    return {
      contentWrapStyle: {
        height: 'auto',
        display: 'block'
      },
      contentHeight: 0,
      focusing: false,
      isClick: false
    };
  },


  inject: ['collapse'],

  props: {
    title: String,
    name: {
      type: [String, Number],
      default: function _default() {
        return this._uid;
      }
    }
  },

  computed: {
    isActive: function isActive() {
      return this.collapse.activeNames.indexOf(this.name) > -1;
    },
    id: function id() {
      return (0, _util.generateId)();
    }
  },

  methods: {
    handleFocus: function handleFocus() {
      var _this = this;

      setTimeout(function () {
        if (!_this.isClick) {
          _this.focusing = true;
        } else {
          _this.isClick = false;
        }
      }, 50);
    },
    handleHeaderClick: function handleHeaderClick() {
      this.dispatch('ElCollapse', 'item-click', this);
      this.focusing = false;
      this.isClick = true;
    },
    handleEnterClick: function handleEnterClick() {
      this.dispatch('ElCollapse', 'item-click', this);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-collapse-item",class:{'is-active': _vm.isActive}},[_c('div',{attrs:{"role":"tab","aria-expanded":_vm.isActive,"aria-controls":("el-collapse-content-" + _vm.id),"aria-describedby":("el-collapse-content-" + _vm.id)}},[_c('div',{staticClass:"el-collapse-item__header",class:{'focusing': _vm.focusing},attrs:{"role":"button","id":("el-collapse-head-" + _vm.id),"tabindex":"0"},on:{"click":_vm.handleHeaderClick,"keyup":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"space",32,$event.key)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }$event.stopPropagation();_vm.handleEnterClick($event)},"focus":_vm.handleFocus,"blur":function($event){_vm.focusing = false}}},[_c('i',{staticClass:"el-collapse-item__arrow el-icon-arrow-right"}),_vm._t("title",[_vm._v(_vm._s(_vm.title))])],2)]),_c('el-collapse-transition',[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"el-collapse-item__wrap",attrs:{"role":"tabpanel","aria-hidden":!_vm.isActive,"aria-labelledby":("el-collapse-head-" + _vm.id),"id":("el-collapse-content-" + _vm.id)}},[_c('div',{staticClass:"el-collapse-item__content"},[_vm._t("default")],2)])])],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(354);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(355);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6aff0320_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(359);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6aff0320_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

var _menu = __webpack_require__(356);

var _menu2 = _interopRequireDefault(_menu);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _locale3 = __webpack_require__(16);

var _debounce = __webpack_require__(10);

var _debounce2 = _interopRequireDefault(_debounce);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var popperMixin = {
  props: {
    placement: {
      type: String,
      default: 'bottom-start'
    },
    appendToBody: _vuePopper2.default.props.appendToBody,
    offset: _vuePopper2.default.props.offset,
    boundariesPadding: _vuePopper2.default.props.boundariesPadding,
    popperOptions: _vuePopper2.default.props.popperOptions
  },
  methods: _vuePopper2.default.methods,
  data: _vuePopper2.default.data,
  beforeDestroy: _vuePopper2.default.beforeDestroy
};

exports.default = {
  name: 'ElCascader',

  directives: { Clickoutside: _clickoutside2.default },

  mixins: [popperMixin, _emitter2.default, _locale2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  components: {
    ElInput: _input2.default
  },

  props: {
    options: {
      type: Array,
      required: true
    },
    props: {
      type: Object,
      default: function _default() {
        return {
          children: 'children',
          label: 'label',
          value: 'value',
          disabled: 'disabled'
        };
      }
    },
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    placeholder: {
      type: String,
      default: function _default() {
        return (0, _locale3.t)('el.cascader.placeholder');
      }
    },
    disabled: Boolean,
    clearable: {
      type: Boolean,
      default: false
    },
    changeOnSelect: Boolean,
    popperClass: String,
    expandTrigger: {
      type: String,
      default: 'click'
    },
    filterable: Boolean,
    size: String,
    showAllLevels: {
      type: Boolean,
      default: true
    },
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: function _default() {
        return function () {};
      }
    },
    hoverThreshold: {
      type: Number,
      default: 500
    }
  },

  data: function data() {
    return {
      currentValue: this.value || [],
      menu: null,
      debouncedInputChange: function debouncedInputChange() {},

      menuVisible: false,
      inputHover: false,
      inputValue: '',
      flatOptions: null
    };
  },


  computed: {
    labelKey: function labelKey() {
      return this.props.label || 'label';
    },
    valueKey: function valueKey() {
      return this.props.value || 'value';
    },
    childrenKey: function childrenKey() {
      return this.props.children || 'children';
    },
    currentLabels: function currentLabels() {
      var _this = this;

      var options = this.options;
      var labels = [];
      this.currentValue.forEach(function (value) {
        var targetOption = options && options.filter(function (option) {
          return option[_this.valueKey] === value;
        })[0];
        if (targetOption) {
          labels.push(targetOption[_this.labelKey]);
          options = targetOption[_this.childrenKey];
        }
      });
      return labels;
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    cascaderSize: function cascaderSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    id: function id() {
      return (0, _util.generateId)();
    }
  },

  watch: {
    menuVisible: function menuVisible(value) {
      this.$refs.input.$refs.input.setAttribute('aria-expanded', value);
      value ? this.showMenu() : this.hideMenu();
    },
    value: function value(_value) {
      this.currentValue = _value;
    },
    currentValue: function currentValue(value) {
      this.dispatch('ElFormItem', 'el.form.change', [value]);
    },
    currentLabels: function currentLabels(value) {
      var inputLabel = this.showAllLevels ? value.join('/') : value[value.length - 1];
      this.$refs.input.$refs.input.setAttribute('value', inputLabel);
    },

    options: {
      deep: true,
      handler: function handler(value) {
        if (!this.menu) {
          this.initMenu();
        }
        this.flatOptions = this.flattenOptions(this.options);
        this.menu.options = value;
      }
    }
  },

  methods: {
    initMenu: function initMenu() {
      this.menu = new _vue2.default(_menu2.default).$mount();
      this.menu.options = this.options;
      this.menu.props = this.props;
      this.menu.expandTrigger = this.expandTrigger;
      this.menu.changeOnSelect = this.changeOnSelect;
      this.menu.popperClass = this.popperClass;
      this.menu.hoverThreshold = this.hoverThreshold;
      this.popperElm = this.menu.$el;
      this.menu.$refs.menus[0].setAttribute('id', 'cascader-menu-' + this.id);
      this.menu.$on('pick', this.handlePick);
      this.menu.$on('activeItemChange', this.handleActiveItemChange);
      this.menu.$on('menuLeave', this.doDestroy);
      this.menu.$on('closeInside', this.handleClickoutside);
    },
    showMenu: function showMenu() {
      var _this2 = this;

      if (!this.menu) {
        this.initMenu();
      }

      this.menu.value = this.currentValue.slice(0);
      this.menu.visible = true;
      this.menu.options = this.options;
      this.$nextTick(function (_) {
        _this2.updatePopper();
        _this2.menu.inputWidth = _this2.$refs.input.$el.offsetWidth - 2;
      });
    },
    hideMenu: function hideMenu() {
      this.inputValue = '';
      this.menu.visible = false;
      this.$refs.input.focus();
    },
    handleActiveItemChange: function handleActiveItemChange(value) {
      var _this3 = this;

      this.$nextTick(function (_) {
        _this3.updatePopper();
      });
      this.$emit('active-item-change', value);
    },
    handleKeydown: function handleKeydown(e) {
      var _this4 = this;

      var keyCode = e.keyCode;
      if (keyCode === 13) {
        this.handleClick();
      } else if (keyCode === 40) {
        // down
        this.menuVisible = true; // 打开
        setTimeout(function () {
          var firstMenu = _this4.popperElm.querySelectorAll('.el-cascader-menu')[0];
          firstMenu.querySelectorAll("[tabindex='-1']")[0].focus();
        });
        e.stopPropagation();
        e.preventDefault();
      } else if (keyCode === 27 || keyCode === 9) {
        // esc  tab
        this.inputValue = '';
        if (this.menu) this.menu.visible = false;
      }
    },
    handlePick: function handlePick(value) {
      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.currentValue = value;
      this.$emit('input', value);
      this.$emit('change', value);

      if (close) {
        this.menuVisible = false;
      } else {
        this.$nextTick(this.updatePopper);
      }
    },
    handleInputChange: function handleInputChange(value) {
      var _this5 = this;

      if (!this.menuVisible) return;
      var flatOptions = this.flatOptions;

      if (!value) {
        this.menu.options = this.options;
        this.$nextTick(this.updatePopper);
        return;
      }

      var filteredFlatOptions = flatOptions.filter(function (optionsStack) {
        return optionsStack.some(function (option) {
          return new RegExp(value, 'i').test(option[_this5.labelKey]);
        });
      });

      if (filteredFlatOptions.length > 0) {
        filteredFlatOptions = filteredFlatOptions.map(function (optionStack) {
          return {
            __IS__FLAT__OPTIONS: true,
            value: optionStack.map(function (item) {
              return item[_this5.valueKey];
            }),
            label: _this5.renderFilteredOptionLabel(value, optionStack)
          };
        });
      } else {
        filteredFlatOptions = [{
          __IS__FLAT__OPTIONS: true,
          label: this.t('el.cascader.noMatch'),
          value: '',
          disabled: true
        }];
      }
      this.menu.options = filteredFlatOptions;
      this.$nextTick(this.updatePopper);
    },
    renderFilteredOptionLabel: function renderFilteredOptionLabel(inputValue, optionsStack) {
      var _this6 = this;

      return optionsStack.map(function (option, index) {
        var label = option[_this6.labelKey];
        var keywordIndex = label.toLowerCase().indexOf(inputValue.toLowerCase());
        var labelPart = label.slice(keywordIndex, inputValue.length + keywordIndex);
        var node = keywordIndex > -1 ? _this6.highlightKeyword(label, labelPart) : label;
        return index === 0 ? node : [' / ', node];
      });
    },
    highlightKeyword: function highlightKeyword(label, keyword) {
      var _this7 = this;

      var h = this._c;
      return label.split(keyword).map(function (node, index) {
        return index === 0 ? node : [h('span', { class: { 'el-cascader-menu__item__keyword': true } }, [_this7._v(keyword)]), node];
      });
    },
    flattenOptions: function flattenOptions(options) {
      var _this8 = this;

      var ancestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var flatOptions = [];
      options.forEach(function (option) {
        var optionsStack = ancestor.concat(option);
        if (!option[_this8.childrenKey]) {
          flatOptions.push(optionsStack);
        } else {
          if (_this8.changeOnSelect) {
            flatOptions.push(optionsStack);
          }
          flatOptions = flatOptions.concat(_this8.flattenOptions(option[_this8.childrenKey], optionsStack));
        }
      });
      return flatOptions;
    },
    clearValue: function clearValue(ev) {
      ev.stopPropagation();
      this.handlePick([], true);
    },
    handleClickoutside: function handleClickoutside() {
      this.menuVisible = false;
    },
    handleClick: function handleClick() {
      if (this.disabled) return;
      this.$refs.input.focus();
      if (this.filterable) {
        this.menuVisible = true;
        return;
      }
      this.menuVisible = !this.menuVisible;
    }
  },

  created: function created() {
    var _this9 = this;

    this.debouncedInputChange = (0, _debounce2.default)(this.debounce, function (value) {
      var before = _this9.beforeFilter(value);

      if (before && before.then) {
        _this9.menu.options = [{
          __IS__FLAT__OPTIONS: true,
          label: _this9.t('el.cascader.loading'),
          value: '',
          disabled: true
        }];
        before.then(function () {
          _this9.$nextTick(function () {
            _this9.handleInputChange(value);
          });
        });
      } else if (before !== false) {
        _this9.$nextTick(function () {
          _this9.handleInputChange(value);
        });
      }
    });
  },
  mounted: function mounted() {
    this.flatOptions = this.flattenOptions(this.options);
  }
};

/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue__);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _babelHelperVueJsxMergeProps = __webpack_require__(41);

var _babelHelperVueJsxMergeProps2 = _interopRequireDefault(_babelHelperVueJsxMergeProps);

var _shared = __webpack_require__(358);

var _scrollIntoView = __webpack_require__(24);

var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

var _util = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var copyArray = function copyArray(arr, props) {
  if (!arr || !Array.isArray(arr) || !props) return arr;
  var result = [];
  var configurableProps = ['__IS__FLAT__OPTIONS', 'label', 'value', 'disabled'];
  var childrenProp = props.children || 'children';
  arr.forEach(function (item) {
    var itemCopy = {};
    configurableProps.forEach(function (prop) {
      var name = props[prop];
      var value = item[name];
      if (value === undefined) {
        name = prop;
        value = item[name];
      }
      if (value !== undefined) itemCopy[name] = value;
    });
    if (Array.isArray(item[childrenProp])) {
      itemCopy[childrenProp] = copyArray(item[childrenProp], props);
    }
    result.push(itemCopy);
  });
  return result;
};

exports.default = {
  name: 'ElCascaderMenu',

  data: function data() {
    return {
      inputWidth: 0,
      options: [],
      props: {},
      visible: false,
      activeValue: [],
      value: [],
      expandTrigger: 'click',
      changeOnSelect: false,
      popperClass: '',
      hoverTimer: 0
    };
  },


  watch: {
    visible: function visible(value) {
      if (value) {
        this.activeValue = this.value;
      }
    },

    value: {
      immediate: true,
      handler: function handler(value) {
        this.activeValue = value;
      }
    }
  },

  computed: {
    activeOptions: {
      cache: false,
      get: function get() {
        var _this = this;

        var activeValue = this.activeValue;
        var configurableProps = ['label', 'value', 'children', 'disabled'];

        var formatOptions = function formatOptions(options) {
          options.forEach(function (option) {
            if (option.__IS__FLAT__OPTIONS) return;
            configurableProps.forEach(function (prop) {
              var value = option[_this.props[prop] || prop];
              if (value !== undefined) option[prop] = value;
            });
            if (Array.isArray(option.children)) {
              formatOptions(option.children);
            }
          });
        };

        var loadActiveOptions = function loadActiveOptions(options) {
          var activeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          var level = activeOptions.length;
          activeOptions[level] = options;
          var active = activeValue[level];
          if ((0, _shared.isDef)(active)) {
            options = options.filter(function (option) {
              return option.value === active;
            })[0];
            if (options && options.children) {
              loadActiveOptions(options.children, activeOptions);
            }
          }
          return activeOptions;
        };

        var optionsCopy = copyArray(this.options, this.props);
        formatOptions(optionsCopy);
        return loadActiveOptions(optionsCopy);
      }
    },
    id: function id() {
      return (0, _util.generateId)();
    }
  },

  methods: {
    select: function select(item, menuIndex) {
      if (item.__IS__FLAT__OPTIONS) {
        this.activeValue = item.value;
      } else if (menuIndex) {
        this.activeValue.splice(menuIndex, this.activeValue.length - 1, item.value);
      } else {
        this.activeValue = [item.value];
      }
      this.$emit('pick', this.activeValue.slice());
    },
    handleMenuLeave: function handleMenuLeave() {
      this.$emit('menuLeave');
    },
    activeItem: function activeItem(item, menuIndex) {
      var len = this.activeOptions.length;
      this.activeValue.splice(menuIndex, len, item.value);
      this.activeOptions.splice(menuIndex + 1, len, item.children);
      if (this.changeOnSelect) {
        this.$emit('pick', this.activeValue.slice(), false);
      } else {
        this.$emit('activeItemChange', this.activeValue);
      }
    },
    scrollMenu: function scrollMenu(menu) {
      (0, _scrollIntoView2.default)(menu, menu.getElementsByClassName('is-active')[0]);
    },
    handleMenuEnter: function handleMenuEnter() {
      var _this2 = this;

      this.$nextTick(function () {
        return _this2.$refs.menus.forEach(function (menu) {
          return _this2.scrollMenu(menu);
        });
      });
    }
  },

  render: function render(h) {
    var _this3 = this;

    var activeValue = this.activeValue,
        activeOptions = this.activeOptions,
        visible = this.visible,
        expandTrigger = this.expandTrigger,
        popperClass = this.popperClass,
        hoverThreshold = this.hoverThreshold;

    var itemId = null;
    var itemIndex = 0;

    var hoverMenuRefs = {};
    var hoverMenuHandler = function hoverMenuHandler(e) {
      var offsetX = e.offsetX;
      var width = hoverMenuRefs.activeMenu.offsetWidth;
      var height = hoverMenuRefs.activeMenu.offsetHeight;

      if (e.target === hoverMenuRefs.activeItem) {
        clearTimeout(_this3.hoverTimer);
        var _hoverMenuRefs = hoverMenuRefs,
            activeItem = _hoverMenuRefs.activeItem;

        var offsetY_top = activeItem.offsetTop;
        var offsetY_Bottom = offsetY_top + activeItem.offsetHeight;

        hoverMenuRefs.hoverZone.innerHTML = '\n          <path style="pointer-events: auto;" fill="transparent" d="M' + offsetX + ' ' + offsetY_top + ' L' + width + ' 0 V' + offsetY_top + ' Z" />\n          <path style="pointer-events: auto;" fill="transparent" d="M' + offsetX + ' ' + offsetY_Bottom + ' L' + width + ' ' + height + ' V' + offsetY_Bottom + ' Z" />\n        ';
      } else {
        if (!_this3.hoverTimer) {
          _this3.hoverTimer = setTimeout(function () {
            hoverMenuRefs.hoverZone.innerHTML = '';
          }, hoverThreshold);
        }
      }
    };

    var menus = this._l(activeOptions, function (menu, menuIndex) {
      var isFlat = false;
      var menuId = 'menu-' + _this3.id + '-' + menuIndex;
      var ownsId = 'menu-' + _this3.id + '-' + (menuIndex + 1);
      var items = _this3._l(menu, function (item) {
        var events = {
          on: {}
        };

        if (item.__IS__FLAT__OPTIONS) isFlat = true;

        if (!item.disabled) {
          // keydown up/down/left/right/enter
          events.on.keydown = function (ev) {
            var keyCode = ev.keyCode;
            if (![37, 38, 39, 40, 13, 9, 27].includes(keyCode)) {
              return;
            }
            var currentEle = ev.target;
            var parentEle = _this3.$refs.menus[menuIndex];
            var menuItemList = parentEle.querySelectorAll("[tabindex='-1']");
            var currentIndex = Array.prototype.indexOf.call(menuItemList, currentEle); // 当前索引
            var nextIndex = void 0,
                nextMenu = void 0;
            if ([38, 40].includes(keyCode)) {
              if (keyCode === 38) {
                // up键
                nextIndex = currentIndex !== 0 ? currentIndex - 1 : currentIndex;
              } else if (keyCode === 40) {
                // down
                nextIndex = currentIndex !== menuItemList.length - 1 ? currentIndex + 1 : currentIndex;
              }
              menuItemList[nextIndex].focus();
            } else if (keyCode === 37) {
              // left键
              if (menuIndex !== 0) {
                var previousMenu = _this3.$refs.menus[menuIndex - 1];
                previousMenu.querySelector('[aria-expanded=true]').focus();
              }
            } else if (keyCode === 39) {
              // right
              if (item.children) {
                // 有子menu 选择子menu的第一个menuitem
                nextMenu = _this3.$refs.menus[menuIndex + 1];
                nextMenu.querySelectorAll("[tabindex='-1']")[0].focus();
              }
            } else if (keyCode === 13) {
              if (!item.children) {
                var id = currentEle.getAttribute('id');
                parentEle.setAttribute('aria-activedescendant', id);
                _this3.select(item, menuIndex);
                _this3.$nextTick(function () {
                  return _this3.scrollMenu(_this3.$refs.menus[menuIndex]);
                });
              }
            } else if (keyCode === 9 || keyCode === 27) {
              // esc tab
              _this3.$emit('closeInside');
            }
          };
          if (item.children) {
            var triggerEvent = {
              click: 'click',
              hover: 'mouseenter'
            }[expandTrigger];
            events.on[triggerEvent] = events.on['focus'] = function () {
              // focus 选中
              _this3.activeItem(item, menuIndex);
              _this3.$nextTick(function () {
                // adjust self and next level
                _this3.scrollMenu(_this3.$refs.menus[menuIndex]);
                _this3.scrollMenu(_this3.$refs.menus[menuIndex + 1]);
              });
            };
          } else {
            events.on.click = function () {
              _this3.select(item, menuIndex);
              _this3.$nextTick(function () {
                return _this3.scrollMenu(_this3.$refs.menus[menuIndex]);
              });
            };
          }
        }
        if (!item.disabled && !item.children) {
          // no children set id
          itemId = menuId + '-' + itemIndex;
          itemIndex++;
        }
        return h(
          'li',
          (0, _babelHelperVueJsxMergeProps2.default)([{
            'class': {
              'el-cascader-menu__item': true,
              'el-cascader-menu__item--extensible': item.children,
              'is-active': item.value === activeValue[menuIndex],
              'is-disabled': item.disabled
            },
            ref: item.value === activeValue[menuIndex] ? 'activeItem' : null
          }, events, {
            attrs: {
              tabindex: item.disabled ? null : -1,
              role: 'menuitem',
              'aria-haspopup': !!item.children,
              'aria-expanded': item.value === activeValue[menuIndex],
              id: itemId,
              'aria-owns': !item.children ? null : ownsId
            }
          }]),
          [item.label]
        );
      });
      var menuStyle = {};
      if (isFlat) {
        menuStyle.minWidth = _this3.inputWidth + 'px';
      }

      var isHoveredMenu = expandTrigger === 'hover' && activeValue.length - 1 === menuIndex;
      var hoverMenuEvent = {
        on: {}
      };

      if (isHoveredMenu) {
        hoverMenuEvent.on.mousemove = hoverMenuHandler;
        menuStyle.position = 'relative';
      }

      return h(
        'ul',
        (0, _babelHelperVueJsxMergeProps2.default)([{
          'class': {
            'el-cascader-menu': true,
            'el-cascader-menu--flexible': isFlat
          }
        }, hoverMenuEvent, {
          style: menuStyle,
          refInFor: true,
          ref: 'menus',
          attrs: { role: 'menu',
            id: menuId
          }
        }]),
        [items, isHoveredMenu ? h(
          'svg',
          {
            ref: 'hoverZone',
            style: {
              position: 'absolute',
              top: 0,
              height: '100%',
              width: '100%',
              left: 0,
              pointerEvents: 'none'
            }
          },
          []
        ) : null]
      );
    });

    if (expandTrigger === 'hover') {
      this.$nextTick(function () {
        var activeItem = _this3.$refs.activeItem;

        if (activeItem) {
          var activeMenu = activeItem.parentElement;
          var hoverZone = _this3.$refs.hoverZone;

          hoverMenuRefs = {
            activeMenu: activeMenu,
            activeItem: activeItem,
            hoverZone: hoverZone
          };
        } else {
          hoverMenuRefs = {};
        }
      });
    }

    return h(
      'transition',
      {
        attrs: { name: 'el-zoom-in-top' },
        on: {
          'before-enter': this.handleMenuEnter,
          'after-leave': this.handleMenuLeave
        }
      },
      [h(
        'div',
        {
          directives: [{
            name: 'show',
            value: visible
          }],

          'class': ['el-cascader-menus el-popper', popperClass],
          ref: 'wrapper'
        },
        [h(
          'div',
          {
            attrs: { 'x-arrow': true },
            'class': 'popper__arrow' },
          []
        ), menus]
      )]
    );
  }
};

/***/ }),
/* 358 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("C51g");

/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClickoutside),expression:"handleClickoutside"}],ref:"reference",staticClass:"el-cascader",class:[
    {
      'is-opened': _vm.menuVisible,
      'is-disabled': _vm.disabled
    },
    _vm.cascaderSize ? 'el-cascader--' + _vm.cascaderSize : ''
  ],on:{"click":_vm.handleClick,"mouseenter":function($event){_vm.inputHover = true},"focus":function($event){_vm.inputHover = true},"mouseleave":function($event){_vm.inputHover = false},"blur":function($event){_vm.inputHover = false},"keydown":_vm.handleKeydown}},[_c('el-input',{ref:"input",attrs:{"readonly":!_vm.filterable,"placeholder":_vm.currentLabels.length ? undefined : _vm.placeholder,"validate-event":false,"size":_vm.size,"disabled":_vm.disabled},on:{"input":_vm.debouncedInputChange},model:{value:(_vm.inputValue),callback:function ($$v) {_vm.inputValue=$$v},expression:"inputValue"}},[_c('template',{attrs:{"slot":"suffix"},slot:"suffix"},[(_vm.clearable && _vm.inputHover && _vm.currentLabels.length)?_c('i',{key:"1",staticClass:"el-input__icon el-icon-circle-close el-cascader__clearIcon",on:{"click":_vm.clearValue}}):_c('i',{key:"2",staticClass:"el-input__icon el-icon-arrow-down",class:{ 'is-reverse': _vm.menuVisible }})])],2),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.inputValue === ''),expression:"inputValue === ''"}],staticClass:"el-cascader__label"},[(_vm.showAllLevels)?[_vm._l((_vm.currentLabels),function(label,index){return [_vm._v("\n        "+_vm._s(label)+"\n        "),(index < _vm.currentLabels.length - 1)?_c('span',[_vm._v(" / ")]):_vm._e()]})]:[_vm._v("\n      "+_vm._s(_vm.currentLabels[_vm.currentLabels.length - 1])+"\n    ")]],2)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(361);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ddeee594_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(376);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_ddeee594_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _color = __webpack_require__(363);

var _color2 = _interopRequireDefault(_color);

var _pickerDropdown = __webpack_require__(364);

var _pickerDropdown2 = _interopRequireDefault(_pickerDropdown);

var _clickoutside = __webpack_require__(11);

var _clickoutside2 = _interopRequireDefault(_clickoutside);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElColorPicker',

  props: {
    value: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: String,
    popperClass: String
  },

  inject: {
    elFormItem: {
      default: ''
    }
  },

  directives: { Clickoutside: _clickoutside2.default },

  computed: {
    displayedColor: function displayedColor() {
      if (!this.value && !this.showPanelColor) {
        return 'transparent';
      } else {
        var _color$toRgb = this.color.toRgb(),
            r = _color$toRgb.r,
            g = _color$toRgb.g,
            b = _color$toRgb.b;

        return this.showAlpha ? 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.color.get('alpha') / 100 + ')' : 'rgb(' + r + ', ' + g + ', ' + b + ')';
      }
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    colorSize: function colorSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  watch: {
    value: function value(val) {
      if (!val) {
        this.showPanelColor = false;
      } else if (val && val !== this.color.value) {
        this.color.fromString(val);
      }
    },

    color: {
      deep: true,
      handler: function handler() {
        this.showPanelColor = true;
      }
    },
    displayedColor: function displayedColor(val) {
      this.$emit('active-change', val);
    }
  },

  methods: {
    handleTrigger: function handleTrigger() {
      if (this.disabled) return;
      this.showPicker = !this.showPicker;
    },
    confirmValue: function confirmValue(value) {
      this.$emit('input', this.color.value);
      this.$emit('change', this.color.value);
      this.showPicker = false;
    },
    clearValue: function clearValue() {
      this.$emit('input', null);
      this.$emit('change', null);
      this.showPanelColor = false;
      this.showPicker = false;
      this.resetColor();
    },
    hide: function hide() {
      this.showPicker = false;
      this.resetColor();
    },
    resetColor: function resetColor() {
      var _this = this;

      this.$nextTick(function (_) {
        if (_this.value) {
          _this.color.fromString(_this.value);
        } else {
          _this.showPanelColor = false;
        }
      });
    }
  },

  mounted: function mounted() {
    var value = this.value;
    if (value) {
      this.color.fromString(value);
    }
    this.popperElm = this.$refs.dropdown.$el;
  },
  data: function data() {
    var color = new _color2.default({
      enableAlpha: this.showAlpha,
      format: this.colorFormat
    });
    return {
      color: color,
      showPicker: false,
      showPanelColor: false
    };
  },


  components: {
    PickerDropdown: _pickerDropdown2.default
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var hsv2hsl = function hsv2hsl(hue, sat, val) {
  return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];
};

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
var isOnePointZero = function isOnePointZero(n) {
  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
};

var isPercentage = function isPercentage(n) {
  return typeof n === 'string' && n.indexOf('%') !== -1;
};

// Take input from [0, n] and return it as [0, 1]
var bound01 = function bound01(value, max) {
  if (isOnePointZero(value)) value = '100%';

  var processPercent = isPercentage(value);
  value = Math.min(max, Math.max(0, parseFloat(value)));

  // Automatically convert percentage into number
  if (processPercent) {
    value = parseInt(value * max, 10) / 100;
  }

  // Handle floating point rounding errors
  if (Math.abs(value - max) < 0.000001) {
    return 1;
  }

  // Convert into [0, 1] range if it isn't already
  return value % max / parseFloat(max);
};

var INT_HEX_MAP = { 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F' };

var toHex = function toHex(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b;

  var hexOne = function hexOne(value) {
    value = Math.min(Math.round(value), 255);
    var high = Math.floor(value / 16);
    var low = value % 16;
    return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
  };

  if (isNaN(r) || isNaN(g) || isNaN(b)) return '';

  return '#' + hexOne(r) + hexOne(g) + hexOne(b);
};

var HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };

var parseHexChannel = function parseHexChannel(hex) {
  if (hex.length === 2) {
    return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
  }

  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
};

var hsl2hsv = function hsl2hsv(hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  var smin = sat;
  var lmin = Math.max(light, 0.01);
  var sv = void 0;
  var v = void 0;

  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (light + sat) / 2;
  sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);

  return {
    h: hue,
    s: sv * 100,
    v: v * 100
  };
};

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
var rgb2hsv = function rgb2hsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);

  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h = void 0,
      s = void 0;
  var v = max;

  var d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }

  return { h: h * 360, s: s * 100, v: v * 100 };
};

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
var hsv2rgb = function hsv2rgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);

  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
};

var Color = function () {
  function Color(options) {
    _classCallCheck(this, Color);

    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;

    this.enableAlpha = false;
    this.format = 'hex';
    this.value = '';

    options = options || {};

    for (var option in options) {
      if (options.hasOwnProperty(option)) {
        this[option] = options[option];
      }
    }

    this.doOnChange();
  }

  Color.prototype.set = function set(prop, value) {
    if (arguments.length === 1 && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object') {
      for (var p in prop) {
        if (prop.hasOwnProperty(p)) {
          this.set(p, prop[p]);
        }
      }

      return;
    }

    this['_' + prop] = value;
    this.doOnChange();
  };

  Color.prototype.get = function get(prop) {
    return this['_' + prop];
  };

  Color.prototype.toRgb = function toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  };

  Color.prototype.fromString = function fromString(value) {
    var _this = this;

    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;

      this.doOnChange();
      return;
    }

    var fromHSV = function fromHSV(h, s, v) {
      _this._hue = h;
      _this._saturation = s;
      _this._value = v;

      _this.doOnChange();
    };

    if (value.indexOf('hsl') !== -1) {
      var parts = value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
        return val !== '';
      }).map(function (val, index) {
        return index > 2 ? parseFloat(val) : parseInt(val, 10);
      });

      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        var _hsl2hsv = hsl2hsv(parts[0], parts[1], parts[2]),
            h = _hsl2hsv.h,
            s = _hsl2hsv.s,
            v = _hsl2hsv.v;

        fromHSV(h, s, v);
      }
    } else if (value.indexOf('hsv') !== -1) {
      var _parts = value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
        return val !== '';
      }).map(function (val, index) {
        return index > 2 ? parseFloat(val) : parseInt(val, 10);
      });

      if (_parts.length === 4) {
        this._alpha = Math.floor(parseFloat(_parts[3]) * 100);
      }
      if (_parts.length >= 3) {
        fromHSV(_parts[0], _parts[1], _parts[2]);
      }
    } else if (value.indexOf('rgb') !== -1) {
      var _parts2 = value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
        return val !== '';
      }).map(function (val, index) {
        return index > 2 ? parseFloat(val) : parseInt(val, 10);
      });

      if (_parts2.length === 4) {
        this._alpha = Math.floor(parseFloat(_parts2[3]) * 100);
      }
      if (_parts2.length >= 3) {
        var _rgb2hsv = rgb2hsv(_parts2[0], _parts2[1], _parts2[2]),
            _h = _rgb2hsv.h,
            _s = _rgb2hsv.s,
            _v = _rgb2hsv.v;

        fromHSV(_h, _s, _v);
      }
    } else if (value.indexOf('#') !== -1) {
      var hex = value.replace('#', '').trim();
      var r = void 0,
          g = void 0,
          b = void 0;

      if (hex.length === 3) {
        r = parseHexChannel(hex[0] + hex[0]);
        g = parseHexChannel(hex[1] + hex[1]);
        b = parseHexChannel(hex[2] + hex[2]);
      } else if (hex.length === 6) {
        r = parseHexChannel(hex.substring(0, 2));
        g = parseHexChannel(hex.substring(2, 4));
        b = parseHexChannel(hex.substring(4));
      }

      var _rgb2hsv2 = rgb2hsv(r, g, b),
          _h2 = _rgb2hsv2.h,
          _s2 = _rgb2hsv2.s,
          _v2 = _rgb2hsv2.v;

      fromHSV(_h2, _s2, _v2);
    }
  };

  Color.prototype.doOnChange = function doOnChange() {
    var _hue = this._hue,
        _saturation = this._saturation,
        _value = this._value,
        _alpha = this._alpha,
        format = this.format;


    if (this.enableAlpha) {
      switch (format) {
        case 'hsl':
          var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = 'hsla(' + _hue + ', ' + Math.round(hsl[1] * 100) + '%, ' + Math.round(hsl[2] * 100) + '%, ' + _alpha / 100 + ')';
          break;
        case 'hsv':
          this.value = 'hsva(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%, ' + _alpha / 100 + ')';
          break;
        default:
          var _hsv2rgb = hsv2rgb(_hue, _saturation, _value),
              r = _hsv2rgb.r,
              g = _hsv2rgb.g,
              b = _hsv2rgb.b;

          this.value = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + _alpha / 100 + ')';
      }
    } else {
      switch (format) {
        case 'hsl':
          var _hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = 'hsl(' + _hue + ', ' + Math.round(_hsl[1] * 100) + '%, ' + Math.round(_hsl[2] * 100) + '%)';
          break;
        case 'hsv':
          this.value = 'hsv(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%)';
          break;
        case 'rgb':
          var _hsv2rgb2 = hsv2rgb(_hue, _saturation, _value),
              _r = _hsv2rgb2.r,
              _g = _hsv2rgb2.g,
              _b = _hsv2rgb2.b;

          this.value = 'rgb(' + _r + ', ' + _g + ', ' + _b + ')';
          break;
        default:
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
      }
    }
  };

  return Color;
}();

exports.default = Color;
;

/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_dropdown_vue__ = __webpack_require__(365);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_dropdown_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_dropdown_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ba5ff98_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_picker_dropdown_vue__ = __webpack_require__(375);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_picker_dropdown_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ba5ff98_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_picker_dropdown_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _svPanel = __webpack_require__(366);

var _svPanel2 = _interopRequireDefault(_svPanel);

var _hueSlider = __webpack_require__(369);

var _hueSlider2 = _interopRequireDefault(_hueSlider);

var _alphaSlider = __webpack_require__(372);

var _alphaSlider2 = _interopRequireDefault(_alphaSlider);

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _button = __webpack_require__(15);

var _button2 = _interopRequireDefault(_button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'el-color-picker-dropdown',

  mixins: [_vuePopper2.default, _locale2.default],

  components: {
    SvPanel: _svPanel2.default,
    HueSlider: _hueSlider2.default,
    AlphaSlider: _alphaSlider2.default,
    ElInput: _input2.default,
    ElButton: _button2.default
  },

  props: {
    color: {
      required: true
    },
    showAlpha: Boolean
  },

  data: function data() {
    return {
      customInput: ''
    };
  },


  computed: {
    currentColor: function currentColor() {
      var parent = this.$parent;
      return !parent.value && !parent.showPanelColor ? '' : parent.color.value;
    }
  },

  methods: {
    confirmValue: function confirmValue() {
      this.$emit('pick');
    },
    handleConfirm: function handleConfirm() {
      var valid = this.showAlpha ? this.validRGBA(this.customInput) : this.validRGBHex(this.customInput);
      if (valid) {
        this.color.fromString(this.customInput);
      } else {
        this.customInput = this.currentColor;
      }
    },
    validRGBHex: function validRGBHex(color) {
      return (/^#[A-Fa-f0-9]{6}$/.test(color)
      );
    },
    validRGBA: function validRGBA(color) {
      var matches = color.match(/^rgba\((\d+), ?(\d+), ?(\d+), ?([.0-9]+)\)$/);
      if (!matches) return false;
      var list = matches.map(function (v) {
        return parseInt(v, 10);
      }).slice(1);
      if (list.some(function (v) {
        return isNaN(v);
      })) return false;
      var r = list[0],
          g = list[1],
          b = list[2],
          a = list[3];

      if ([r, g, b].some(function (v) {
        return v < 0 || v > 255;
      }) || a < 0 || a > 1) return false;
      return true;
    }
  },

  mounted: function mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$el;
  },


  watch: {
    showPopper: function showPopper(val) {
      var _this = this;

      if (val === true) {
        this.$nextTick(function () {
          var _$refs = _this.$refs,
              sl = _$refs.sl,
              hue = _$refs.hue,
              alpha = _$refs.alpha;

          sl && sl.update();
          hue && hue.update();
          alpha && alpha.update();
        });
      }
    },
    currentColor: function currentColor(val) {
      this.customInput = val;
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_sv_panel_vue__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_sv_panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_sv_panel_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3efd9e06_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_sv_panel_vue__ = __webpack_require__(368);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_sv_panel_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3efd9e06_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_sv_panel_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _draggable = __webpack_require__(28);

var _draggable2 = _interopRequireDefault(_draggable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'el-sl-panel',

  props: {
    color: {
      required: true
    }
  },

  computed: {
    colorValue: function colorValue() {
      var hue = this.color.get('hue');
      var value = this.color.get('value');
      return { hue: hue, value: value };
    }
  },

  watch: {
    colorValue: function colorValue() {
      this.update();
    }
  },

  methods: {
    update: function update() {
      var saturation = this.color.get('saturation');
      var value = this.color.get('value');

      var el = this.$el;

      var _el$getBoundingClient = el.getBoundingClientRect(),
          width = _el$getBoundingClient.width,
          height = _el$getBoundingClient.height;

      if (!height) height = width * 3 / 4;

      this.cursorLeft = saturation * width / 100;
      this.cursorTop = (100 - value) * height / 100;

      this.background = 'hsl(' + this.color.get('hue') + ', 100%, 50%)';
    },
    handleDrag: function handleDrag(event) {
      var el = this.$el;
      var rect = el.getBoundingClientRect();

      var left = event.clientX - rect.left;
      var top = event.clientY - rect.top;
      left = Math.max(0, left);
      left = Math.min(left, rect.width);

      top = Math.max(0, top);
      top = Math.min(top, rect.height);

      this.cursorLeft = left;
      this.cursorTop = top;
      this.color.set({
        saturation: left / rect.width * 100,
        value: 100 - top / rect.height * 100
      });
    }
  },

  mounted: function mounted() {
    var _this = this;

    (0, _draggable2.default)(this.$el, {
      drag: function drag(event) {
        _this.handleDrag(event);
      },
      end: function end(event) {
        _this.handleDrag(event);
      }
    });

    this.update();
  },
  data: function data() {
    return {
      cursorTop: 0,
      cursorLeft: 0,
      background: 'hsl(0, 100%, 50%)'
    };
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-color-svpanel",style:({
      backgroundColor: _vm.background
    })},[_c('div',{staticClass:"el-color-svpanel__white"}),_c('div',{staticClass:"el-color-svpanel__black"}),_c('div',{staticClass:"el-color-svpanel__cursor",style:({
      top: _vm.cursorTop + 'px',
      left: _vm.cursorLeft + 'px'
    })},[_c('div')])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hue_slider_vue__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hue_slider_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hue_slider_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3709e77c_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_hue_slider_vue__ = __webpack_require__(371);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hue_slider_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3709e77c_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_hue_slider_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _draggable = __webpack_require__(28);

var _draggable2 = _interopRequireDefault(_draggable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'el-color-hue-slider',

  props: {
    color: {
      required: true
    },

    vertical: Boolean
  },

  data: function data() {
    return {
      thumbLeft: 0,
      thumbTop: 0
    };
  },


  computed: {
    hueValue: function hueValue() {
      var hue = this.color.get('hue');
      return hue;
    }
  },

  watch: {
    hueValue: function hueValue() {
      this.update();
    }
  },

  methods: {
    handleClick: function handleClick(event) {
      var thumb = this.$refs.thumb;
      var target = event.target;

      if (target !== thumb) {
        this.handleDrag(event);
      }
    },
    handleDrag: function handleDrag(event) {
      var rect = this.$el.getBoundingClientRect();
      var thumb = this.$refs.thumb;

      var hue = void 0;

      if (!this.vertical) {
        var left = event.clientX - rect.left;
        left = Math.min(left, rect.width - thumb.offsetWidth / 2);
        left = Math.max(thumb.offsetWidth / 2, left);

        hue = Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 360);
      } else {
        var top = event.clientY - rect.top;
        top = Math.min(top, rect.height - thumb.offsetHeight / 2);
        top = Math.max(thumb.offsetHeight / 2, top);

        hue = Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 360);
      }

      this.color.set('hue', hue);
    },
    getThumbLeft: function getThumbLeft() {
      if (this.vertical) return 0;
      var el = this.$el;
      var hue = this.color.get('hue');

      if (!el) return 0;
      var thumb = this.$refs.thumb;
      return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
    },
    getThumbTop: function getThumbTop() {
      if (!this.vertical) return 0;
      var el = this.$el;
      var hue = this.color.get('hue');

      if (!el) return 0;
      var thumb = this.$refs.thumb;
      return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
    },
    update: function update() {
      this.thumbLeft = this.getThumbLeft();
      this.thumbTop = this.getThumbTop();
    }
  },

  mounted: function mounted() {
    var _this = this;

    var _$refs = this.$refs,
        bar = _$refs.bar,
        thumb = _$refs.thumb;


    var dragConfig = {
      drag: function drag(event) {
        _this.handleDrag(event);
      },
      end: function end(event) {
        _this.handleDrag(event);
      }
    };

    (0, _draggable2.default)(bar, dragConfig);
    (0, _draggable2.default)(thumb, dragConfig);
    this.update();
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-color-hue-slider",class:{ 'is-vertical': _vm.vertical }},[_c('div',{ref:"bar",staticClass:"el-color-hue-slider__bar",on:{"click":_vm.handleClick}}),_c('div',{ref:"thumb",staticClass:"el-color-hue-slider__thumb",style:({
         left: _vm.thumbLeft + 'px',
         top: _vm.thumbTop + 'px'
       })})])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_alpha_slider_vue__ = __webpack_require__(373);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_alpha_slider_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_alpha_slider_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_219b4f1c_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_alpha_slider_vue__ = __webpack_require__(374);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_alpha_slider_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_219b4f1c_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_alpha_slider_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _draggable = __webpack_require__(28);

var _draggable2 = _interopRequireDefault(_draggable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'el-color-alpha-slider',

  props: {
    color: {
      required: true
    },
    vertical: Boolean
  },

  watch: {
    'color._alpha': function color_alpha() {
      this.update();
    },
    'color.value': function colorValue() {
      this.update();
    }
  },

  methods: {
    handleClick: function handleClick(event) {
      var thumb = this.$refs.thumb;
      var target = event.target;

      if (target !== thumb) {
        this.handleDrag(event);
      }
    },
    handleDrag: function handleDrag(event) {
      var rect = this.$el.getBoundingClientRect();
      var thumb = this.$refs.thumb;


      if (!this.vertical) {
        var left = event.clientX - rect.left;
        left = Math.max(thumb.offsetWidth / 2, left);
        left = Math.min(left, rect.width - thumb.offsetWidth / 2);

        this.color.set('alpha', Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 100));
      } else {
        var top = event.clientY - rect.top;
        top = Math.max(thumb.offsetHeight / 2, top);
        top = Math.min(top, rect.height - thumb.offsetHeight / 2);

        this.color.set('alpha', Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 100));
      }
    },
    getThumbLeft: function getThumbLeft() {
      if (this.vertical) return 0;
      var el = this.$el;
      var alpha = this.color._alpha;

      if (!el) return 0;
      var thumb = this.$refs.thumb;
      return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
    },
    getThumbTop: function getThumbTop() {
      if (!this.vertical) return 0;
      var el = this.$el;
      var alpha = this.color._alpha;

      if (!el) return 0;
      var thumb = this.$refs.thumb;
      return Math.round(alpha * (el.offsetHeight - thumb.offsetHeight / 2) / 100);
    },
    getBackground: function getBackground() {
      if (this.color && this.color.value) {
        var _color$toRgb = this.color.toRgb(),
            r = _color$toRgb.r,
            g = _color$toRgb.g,
            b = _color$toRgb.b;

        return 'linear-gradient(to right, rgba(' + r + ', ' + g + ', ' + b + ', 0) 0%, rgba(' + r + ', ' + g + ', ' + b + ', 1) 100%)';
      }
      return null;
    },
    update: function update() {
      this.thumbLeft = this.getThumbLeft();
      this.thumbTop = this.getThumbTop();
      this.background = this.getBackground();
    }
  },

  data: function data() {
    return {
      thumbLeft: 0,
      thumbTop: 0,
      background: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    var _$refs = this.$refs,
        bar = _$refs.bar,
        thumb = _$refs.thumb;


    var dragConfig = {
      drag: function drag(event) {
        _this.handleDrag(event);
      },
      end: function end(event) {
        _this.handleDrag(event);
      }
    };

    (0, _draggable2.default)(bar, dragConfig);
    (0, _draggable2.default)(thumb, dragConfig);
    this.update();
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-color-alpha-slider",class:{ 'is-vertical': _vm.vertical }},[_c('div',{ref:"bar",staticClass:"el-color-alpha-slider__bar",style:({
         background: _vm.background
       }),on:{"click":_vm.handleClick}}),_c('div',{ref:"thumb",staticClass:"el-color-alpha-slider__thumb",style:({
         left: _vm.thumbLeft + 'px',
         top: _vm.thumbTop + 'px'
       })})])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":_vm.doDestroy}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-color-dropdown"},[_c('div',{staticClass:"el-color-dropdown__main-wrapper"},[_c('hue-slider',{ref:"hue",staticStyle:{"float":"right"},attrs:{"color":_vm.color,"vertical":""}}),_c('sv-panel',{ref:"sl",attrs:{"color":_vm.color}})],1),(_vm.showAlpha)?_c('alpha-slider',{ref:"alpha",attrs:{"color":_vm.color}}):_vm._e(),_c('div',{staticClass:"el-color-dropdown__btns"},[_c('span',{staticClass:"el-color-dropdown__value"},[_c('el-input',{attrs:{"size":"mini"},on:{"blur":_vm.handleConfirm},nativeOn:{"keyup":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key)){ return null; }_vm.handleConfirm($event)}},model:{value:(_vm.customInput),callback:function ($$v) {_vm.customInput=$$v},expression:"customInput"}})],1),_c('el-button',{staticClass:"el-color-dropdown__link-btn",attrs:{"size":"mini","type":"text"},on:{"click":function($event){_vm.$emit('clear')}}},[_vm._v("\n        "+_vm._s(_vm.t('el.colorpicker.clear'))+"\n      ")]),_c('el-button',{staticClass:"el-color-dropdown__btn",attrs:{"plain":"","size":"mini"},on:{"click":_vm.confirmValue}},[_vm._v("\n        "+_vm._s(_vm.t('el.colorpicker.confirm'))+"\n      ")])],1)],1)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.hide),expression:"hide"}],class:[
    'el-color-picker',
    _vm.disabled ? 'is-disabled' : '',
    _vm.colorSize ? ("el-color-picker--" + _vm.colorSize) : ''
  ]},[(_vm.disabled)?_c('div',{staticClass:"el-color-picker__mask"}):_vm._e(),_c('div',{staticClass:"el-color-picker__trigger",on:{"click":_vm.handleTrigger}},[_c('span',{staticClass:"el-color-picker__color",class:{ 'is-alpha': _vm.showAlpha }},[_c('span',{staticClass:"el-color-picker__color-inner",style:({
          backgroundColor: _vm.displayedColor
        })}),(!_vm.value && !_vm.showPanelColor)?_c('span',{staticClass:"el-color-picker__empty el-icon-close"}):_vm._e()]),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.value || _vm.showPanelColor),expression:"value || showPanelColor"}],staticClass:"el-color-picker__icon el-icon-arrow-down"})]),_c('picker-dropdown',{ref:"dropdown",class:['el-color-picker__panel', _vm.popperClass || ''],attrs:{"color":_vm.color,"show-alpha":_vm.showAlpha},on:{"pick":_vm.confirmValue,"clear":_vm.clearValue},model:{value:(_vm.showPicker),callback:function ($$v) {_vm.showPicker=$$v},expression:"showPicker"}})],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(378);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6dc737e3_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(383);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6dc737e3_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _button = __webpack_require__(15);

var _button2 = _interopRequireDefault(_button);

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

var _transferPanel = __webpack_require__(380);

var _transferPanel2 = _interopRequireDefault(_transferPanel);

var _migrating = __webpack_require__(7);

var _migrating2 = _interopRequireDefault(_migrating);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElTransfer',

  mixins: [_emitter2.default, _locale2.default, _migrating2.default],

  components: {
    TransferPanel: _transferPanel2.default,
    ElButton: _button2.default
  },

  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    titles: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    buttonTexts: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    filterPlaceholder: {
      type: String,
      default: ''
    },
    filterMethod: Function,
    leftDefaultChecked: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    rightDefaultChecked: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    renderContent: Function,
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    format: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    filterable: Boolean,
    props: {
      type: Object,
      default: function _default() {
        return {
          label: 'label',
          key: 'key',
          disabled: 'disabled'
        };
      }
    }
  },

  data: function data() {
    return {
      leftChecked: [],
      rightChecked: []
    };
  },


  computed: {
    sourceData: function sourceData() {
      var _this = this;

      return this.data.filter(function (item) {
        return _this.value.indexOf(item[_this.props.key]) === -1;
      });
    },
    targetData: function targetData() {
      var _this2 = this;

      return this.data.filter(function (item) {
        return _this2.value.indexOf(item[_this2.props.key]) > -1;
      });
    },
    hasButtonTexts: function hasButtonTexts() {
      return this.buttonTexts.length === 2;
    }
  },

  watch: {
    value: function value(val) {
      this.dispatch('ElFormItem', 'el.form.change', val);
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {
          'footer-format': 'footer-format is renamed to format.'
        }
      };
    },
    onSourceCheckedChange: function onSourceCheckedChange(val) {
      this.leftChecked = val;
    },
    onTargetCheckedChange: function onTargetCheckedChange(val) {
      this.rightChecked = val;
    },
    addToLeft: function addToLeft() {
      var currentValue = this.value.slice();
      this.rightChecked.forEach(function (item) {
        var index = currentValue.indexOf(item);
        if (index > -1) {
          currentValue.splice(index, 1);
        }
      });
      this.$emit('input', currentValue);
      this.$emit('change', currentValue, 'left', this.rightChecked);
    },
    addToRight: function addToRight() {
      var _this3 = this;

      var currentValue = this.value.slice();
      this.leftChecked.forEach(function (item) {
        if (_this3.value.indexOf(item) === -1) {
          currentValue = currentValue.concat(item);
        }
      });
      this.$emit('input', currentValue);
      this.$emit('change', currentValue, 'right', this.leftChecked);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_transfer_panel_vue__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_transfer_panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_transfer_panel_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_c2f8be68_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_transfer_panel_vue__ = __webpack_require__(382);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_transfer_panel_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_c2f8be68_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_transfer_panel_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkboxGroup = __webpack_require__(35);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

var _checkbox = __webpack_require__(13);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _input = __webpack_require__(6);

var _input2 = _interopRequireDefault(_input);

var _locale = __webpack_require__(2);

var _locale2 = _interopRequireDefault(_locale);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  mixins: [_locale2.default],

  name: 'ElTransferPanel',

  componentName: 'ElTransferPanel',

  components: {
    ElCheckboxGroup: _checkboxGroup2.default,
    ElCheckbox: _checkbox2.default,
    ElInput: _input2.default,
    OptionContent: {
      props: {
        option: Object
      },
      render: function render(h) {
        var getParent = function getParent(vm) {
          if (vm.$options.componentName === 'ElTransferPanel') {
            return vm;
          } else if (vm.$parent) {
            return getParent(vm.$parent);
          } else {
            return vm;
          }
        };
        var parent = getParent(this);
        return parent.renderContent ? parent.renderContent(h, this.option) : h(
          'span',
          null,
          [this.option[parent.labelProp] || this.option[parent.keyProp]]
        );
      }
    }
  },

  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    renderContent: Function,
    placeholder: String,
    title: String,
    filterable: Boolean,
    format: Object,
    filterMethod: Function,
    defaultChecked: Array,
    props: Object
  },

  data: function data() {
    return {
      checked: [],
      allChecked: false,
      query: '',
      inputHover: false
    };
  },


  watch: {
    checked: function checked(val) {
      this.updateAllChecked();
      this.$emit('checked-change', val);
    },
    data: function data() {
      var _this = this;

      var checked = [];
      var filteredDataKeys = this.filteredData.map(function (item) {
        return item[_this.keyProp];
      });
      this.checked.forEach(function (item) {
        if (filteredDataKeys.indexOf(item) > -1) {
          checked.push(item);
        }
      });
      this.checked = checked;
    },
    checkableData: function checkableData() {
      this.updateAllChecked();
    },


    defaultChecked: {
      immediate: true,
      handler: function handler(val, oldVal) {
        var _this2 = this;

        if (oldVal && val.length === oldVal.length && val.every(function (item) {
          return oldVal.indexOf(item) > -1;
        })) return;
        var checked = [];
        var checkableDataKeys = this.checkableData.map(function (item) {
          return item[_this2.keyProp];
        });
        val.forEach(function (item) {
          if (checkableDataKeys.indexOf(item) > -1) {
            checked.push(item);
          }
        });
        this.checked = checked;
      }
    }
  },

  computed: {
    filteredData: function filteredData() {
      var _this3 = this;

      return this.data.filter(function (item) {
        if (typeof _this3.filterMethod === 'function') {
          return _this3.filterMethod(_this3.query, item);
        } else {
          var label = item[_this3.labelProp] || item[_this3.keyProp].toString();
          return label.toLowerCase().indexOf(_this3.query.toLowerCase()) > -1;
        }
      });
    },
    checkableData: function checkableData() {
      var _this4 = this;

      return this.filteredData.filter(function (item) {
        return !item[_this4.disabledProp];
      });
    },
    checkedSummary: function checkedSummary() {
      var checkedLength = this.checked.length;
      var dataLength = this.data.length;
      var _format = this.format,
          noChecked = _format.noChecked,
          hasChecked = _format.hasChecked;

      if (noChecked && hasChecked) {
        return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength).replace(/\${total}/g, dataLength) : noChecked.replace(/\${total}/g, dataLength);
      } else {
        return checkedLength + '/' + dataLength;
      }
    },
    isIndeterminate: function isIndeterminate() {
      var checkedLength = this.checked.length;
      return checkedLength > 0 && checkedLength < this.checkableData.length;
    },
    hasNoMatch: function hasNoMatch() {
      return this.query.length > 0 && this.filteredData.length === 0;
    },
    inputIcon: function inputIcon() {
      return this.query.length > 0 && this.inputHover ? 'circle-close' : 'search';
    },
    labelProp: function labelProp() {
      return this.props.label || 'label';
    },
    keyProp: function keyProp() {
      return this.props.key || 'key';
    },
    disabledProp: function disabledProp() {
      return this.props.disabled || 'disabled';
    },
    hasFooter: function hasFooter() {
      return !!this.$slots.default;
    }
  },

  methods: {
    updateAllChecked: function updateAllChecked() {
      var _this5 = this;

      var checkableDataKeys = this.checkableData.map(function (item) {
        return item[_this5.keyProp];
      });
      this.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every(function (item) {
        return _this5.checked.indexOf(item) > -1;
      });
    },
    handleAllCheckedChange: function handleAllCheckedChange(value) {
      var _this6 = this;

      this.checked = value ? this.checkableData.map(function (item) {
        return item[_this6.keyProp];
      }) : [];
    },
    clearQuery: function clearQuery() {
      if (this.inputIcon === 'circle-close') {
        this.query = '';
      }
    }
  }
};

/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-transfer-panel"},[_c('p',{staticClass:"el-transfer-panel__header"},[_c('el-checkbox',{attrs:{"indeterminate":_vm.isIndeterminate},on:{"change":_vm.handleAllCheckedChange},model:{value:(_vm.allChecked),callback:function ($$v) {_vm.allChecked=$$v},expression:"allChecked"}},[_vm._v("\n      "+_vm._s(_vm.title)+"\n      "),_c('span',[_vm._v(_vm._s(_vm.checkedSummary))])])],1),_c('div',{class:['el-transfer-panel__body', _vm.hasFooter ? 'is-with-footer' : '']},[(_vm.filterable)?_c('el-input',{staticClass:"el-transfer-panel__filter",attrs:{"size":"small","placeholder":_vm.placeholder},nativeOn:{"mouseenter":function($event){_vm.inputHover = true},"mouseleave":function($event){_vm.inputHover = false}},model:{value:(_vm.query),callback:function ($$v) {_vm.query=$$v},expression:"query"}},[_c('i',{class:['el-input__icon', 'el-icon-' + _vm.inputIcon],attrs:{"slot":"prefix"},on:{"click":_vm.clearQuery},slot:"prefix"})]):_vm._e(),_c('el-checkbox-group',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hasNoMatch && _vm.data.length > 0),expression:"!hasNoMatch && data.length > 0"}],staticClass:"el-transfer-panel__list",class:{ 'is-filterable': _vm.filterable },model:{value:(_vm.checked),callback:function ($$v) {_vm.checked=$$v},expression:"checked"}},_vm._l((_vm.filteredData),function(item){return _c('el-checkbox',{key:item[_vm.keyProp],staticClass:"el-transfer-panel__item",attrs:{"label":item[_vm.keyProp],"disabled":item[_vm.disabledProp]}},[_c('option-content',{attrs:{"option":item}})],1)})),_c('p',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasNoMatch),expression:"hasNoMatch"}],staticClass:"el-transfer-panel__empty"},[_vm._v(_vm._s(_vm.t('el.transfer.noMatch')))]),_c('p',{directives:[{name:"show",rawName:"v-show",value:(_vm.data.length === 0 && !_vm.hasNoMatch),expression:"data.length === 0 && !hasNoMatch"}],staticClass:"el-transfer-panel__empty"},[_vm._v(_vm._s(_vm.t('el.transfer.noData')))])],1),(_vm.hasFooter)?_c('p',{staticClass:"el-transfer-panel__footer"},[_vm._t("default")],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-transfer"},[_c('transfer-panel',_vm._b({attrs:{"data":_vm.sourceData,"title":_vm.titles[0] || _vm.t('el.transfer.titles.0'),"default-checked":_vm.leftDefaultChecked,"placeholder":_vm.filterPlaceholder || _vm.t('el.transfer.filterPlaceholder')},on:{"checked-change":_vm.onSourceCheckedChange}},'transfer-panel',_vm.$props,false),[_vm._t("left-footer")],2),_c('div',{staticClass:"el-transfer__buttons"},[_c('el-button',{class:['el-transfer__button', _vm.hasButtonTexts ? 'is-with-texts' : ''],attrs:{"type":"primary","disabled":_vm.rightChecked.length === 0},nativeOn:{"click":function($event){_vm.addToLeft($event)}}},[_c('i',{staticClass:"el-icon-arrow-left"}),(_vm.buttonTexts[0] !== undefined)?_c('span',[_vm._v(_vm._s(_vm.buttonTexts[0]))]):_vm._e()]),_c('el-button',{class:['el-transfer__button', _vm.hasButtonTexts ? 'is-with-texts' : ''],attrs:{"type":"primary","disabled":_vm.leftChecked.length === 0},nativeOn:{"click":function($event){_vm.addToRight($event)}}},[(_vm.buttonTexts[1] !== undefined)?_c('span',[_vm._v(_vm._s(_vm.buttonTexts[1]))]):_vm._e(),_c('i',{staticClass:"el-icon-arrow-right"})])],1),_c('transfer-panel',_vm._b({attrs:{"data":_vm.targetData,"title":_vm.titles[1] || _vm.t('el.transfer.titles.1'),"default-checked":_vm.rightDefaultChecked,"placeholder":_vm.filterPlaceholder || _vm.t('el.transfer.filterPlaceholder')},on:{"checked-change":_vm.onTargetCheckedChange}},'transfer-panel',_vm.$props,false),[_vm._t("right-footer")],2)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(385);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(386);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_956d8bb2_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(387);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_956d8bb2_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//

exports.default = {
  name: 'ElContainer',

  componentName: 'ElContainer',

  props: {
    direction: String
  },

  computed: {
    isVertical: function isVertical() {
      if (this.direction === 'vertical') {
        return true;
      } else if (this.direction === 'horizontal') {
        return false;
      }
      return this.$slots && this.$slots.default ? this.$slots.default.some(function (vnode) {
        var tag = vnode.componentOptions && vnode.componentOptions.tag;
        return tag === 'el-header' || tag === 'el-footer';
      }) : false;
    }
  }
};

/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"el-container",class:{ 'is-vertical': _vm.isVertical }},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(389);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(390);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_634a9d7e_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(391);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_634a9d7e_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//

exports.default = {
  name: 'ElHeader',

  componentName: 'ElHeader',

  props: {
    height: {
      type: String,
      default: '60px'
    }
  }
};

/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('header',{staticClass:"el-header",style:({ height: _vm.height })},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(393);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4a954950_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(395);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4a954950_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//

exports.default = {
  name: 'ElAside',

  componentName: 'ElAside',

  props: {
    width: {
      type: String,
      default: '300px'
    }
  }
};

/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('aside',{staticClass:"el-aside",style:({ width: _vm.width })},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(397);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_76da1255_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(399);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_76da1255_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//

exports.default = {
  name: 'ElMain',
  componentName: 'ElMain'
};

/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('main',{staticClass:"el-main"},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(401);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__ = __webpack_require__(402);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6320c4f3_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__ = __webpack_require__(403);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6320c4f3_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//

exports.default = {
  name: 'ElFooter',

  componentName: 'ElFooter',

  props: {
    height: {
      type: String,
      default: '60px'
    }
  }
};

/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('footer',{staticClass:"el-footer",style:({ height: _vm.height })},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })
/******/ ]);

/***/ }),

/***/ "hRKE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__("2LoE");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__("Yyxk");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "hX0p":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("lSMs").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "i8Ld":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__("xB8i");


/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.whitespace, rule.fullField));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (whitespace);

/***/ }),

/***/ "ifR3":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "jA/d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

var _popup = __webpack_require__("9lqe");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopperJS = _vue2.default.prototype.$isServer ? function () {} : __webpack_require__("DeJ7");
var stop = function stop(e) {
  return e.stopPropagation();
};

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
exports.default = {
  props: {
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    transition: String,
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },

  data: function data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },


  watch: {
    value: {
      immediate: true,
      handler: function handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },

    showPopper: function showPopper(val) {
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },

  methods: {
    createPopper: function createPopper() {
      var _this = this;

      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }

      var options = this.popperOptions;
      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;

      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }

      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }

      options.placement = this.currentPlacement;
      options.offset = this.offset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(function (_) {
        _this.$emit('created', _this);
        _this.resetTransformOrigin();
        _this.$nextTick(_this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },
    updatePopper: function updatePopper() {
      this.popperJS ? this.popperJS.update() : this.createPopper();
    },
    doDestroy: function doDestroy() {
      /* istanbul ignore if */
      if (this.showPopper || !this.popperJS) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },
    destroyPopper: function destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },
    resetTransformOrigin: function resetTransformOrigin() {
      var placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      var origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';
    },
    appendArrow: function appendArrow(element) {
      var hash = void 0;
      if (this.appended) {
        return;
      }

      this.appended = true;

      for (var item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }

      var arrow = document.createElement('div');

      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },

  beforeDestroy: function beforeDestroy() {
    this.doDestroy();
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },


  // call destroy in keep-alive mode
  deactivated: function deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
};

/***/ }),

/***/ "kDLO":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");


/**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'array') && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options, 'array');
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'array')) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (array);

/***/ }),

/***/ "kDoY":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "kL9Z":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 147);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = __webpack_require__("BbKf");

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(148);


/***/ }),

/***/ 148:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkboxGroup = __webpack_require__(149);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_checkboxGroup2.default.install = function (Vue) {
  Vue.component(_checkboxGroup2.default.name, _checkboxGroup2.default);
};

exports.default = _checkboxGroup2.default;

/***/ }),

/***/ 149:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_376416c7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_group_vue__ = __webpack_require__(151);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_checkbox_group_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_376416c7_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_checkbox_group_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 150:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _emitter = __webpack_require__(1);

var _emitter2 = _interopRequireDefault(_emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElCheckboxGroup',

  componentName: 'ElCheckboxGroup',

  mixins: [_emitter2.default],

  inject: {
    elFormItem: {
      default: ''
    }
  },

  props: {
    value: {},
    disabled: Boolean,
    min: Number,
    max: Number,
    size: String,
    fill: String,
    textColor: String
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxGroupSize: function checkboxGroupSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  watch: {
    value: function value(_value) {
      this.dispatch('ElFormItem', 'el.form.change', [_value]);
    }
  }
};

/***/ }),

/***/ 151:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-checkbox-group",attrs:{"role":"group","aria-label":"checkbox-group"}},[_vm._t("default")],2)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "l3hl":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("X609");
var document = __webpack_require__("lSMs").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "lSMs":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "leuU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = scrollIntoView;

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scrollIntoView(container, selected) {
  if (_vue2.default.prototype.$isServer) return;

  if (!selected) {
    container.scrollTop = 0;
    return;
  }

  var top = selected.offsetTop;
  var bottom = selected.offsetTop + selected.offsetHeight;
  var viewRectTop = container.scrollTop;
  var viewRectBottom = viewRectTop + container.clientHeight;

  if (top < viewRectTop) {
    container.scrollTop = top;
  } else if (bottom > viewRectBottom) {
    container.scrollTop = bottom - container.clientHeight;
  }
}

/***/ }),

/***/ "mbGH":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__("xB8i");


/**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number';
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);
  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  }
  // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type
  if (!key) {
    return false;
  }
  if (str || arr) {
    val = value.length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (range);

/***/ }),

/***/ "n/sI":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__ = __webpack_require__("Ldwu");
/**
 * Swiper 4.0.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://www.idangero.us/swiper/
 *
 * Copyright 2014-2017 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: October 18, 2017
 */



let w;
if (typeof window === 'undefined') {
  w = {
    navigator: {
      userAgent: '',
    },
    location: {},
    history: {},
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
      return {};
    },
    Image() {},
    Date() {},
  };
} else {
  w = window;
}

const win = w;

const Methods = {
  addClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* addClass */],
  removeClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["b" /* removeClass */],
  hasClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["c" /* hasClass */],
  toggleClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["d" /* toggleClass */],
  attr: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["e" /* attr */],
  removeAttr: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["f" /* removeAttr */],
  data: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["g" /* data */],
  transform: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["h" /* transform */],
  transition: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["i" /* transition */],
  on: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["j" /* on */],
  off: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["k" /* off */],
  trigger: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["l" /* trigger */],
  transitionEnd: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["m" /* transitionEnd */],
  outerWidth: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["n" /* outerWidth */],
  outerHeight: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["o" /* outerHeight */],
  offset: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["p" /* offset */],
  css: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["q" /* css */],
  each: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["r" /* each */],
  html: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["s" /* html */],
  text: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["t" /* text */],
  is: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["u" /* is */],
  index: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["v" /* index */],
  eq: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["w" /* eq */],
  append: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["x" /* append */],
  prepend: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["y" /* prepend */],
  next: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["z" /* next */],
  nextAll: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["A" /* nextAll */],
  prev: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["B" /* prev */],
  prevAll: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["C" /* prevAll */],
  parent: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["D" /* parent */],
  parents: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["E" /* parents */],
  closest: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["F" /* closest */],
  find: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["G" /* find */],
  children: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["H" /* children */],
  remove: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["I" /* remove */],
  add: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["J" /* add */],
  styles: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["K" /* styles */],
};

Object.keys(Methods).forEach((methodName) => {
  __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */].fn[methodName] = Methods[methodName];
});

const Utils = {
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  now() {
    return Date.now();
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = win.getComputedStyle(el, null);

    if (win.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || win.location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
      }
    }
    return query;
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  extend(...args) {
    const to = Object(args[0]);
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const Support = (function Support() {
  return {
    touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {
      return !!(('ontouchstart' in win) || (win.DocumentTouch && document instanceof win.DocumentTouch));
    }()),

    transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
      const div = document.createElement('div').style;
      return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
    }()),

    flexbox: (function checkFlexbox() {
      const div = document.createElement('div').style;
      const styles$$1 = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
      for (let i = 0; i < styles$$1.length; i += 1) {
        if (styles$$1[i] in div) return true;
      }
      return false;
    }()),

    observer: (function checkObserver() {
      return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          get() {
            supportsPassive = true;
          },
        });
        win.addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in win;
    }()),
  };
}());

class SwiperClass {
  constructor(params = {}) {
    const self = this;
    self.params = params;

    // Events
    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }
  on(events, handler) {
    const self = this;
    if (typeof handler !== 'function') return self;
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event].push(handler);
    });
    return self;
  }
  once(events, handler) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      handler.apply(self, args);
      self.off(events, onceHandler);
    }
    return self.on(events, onceHandler);
  }
  off(events, handler) {
    const self = this;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else {
        self.eventsListeners[event].forEach((eventHandler, index$$1) => {
          if (eventHandler === handler) {
            self.eventsListeners[event].splice(index$$1, 1);
          }
        });
      }
    });
    return self;
  }
  emit(...args) {
    const self = this;
    let events;
    let data$$1;
    let context;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data$$1 = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data$$1 = args[0].data;
      context = args[0].context || self;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach((event) => {
      if (self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data$$1);
        });
      }
    });
    return self;
  }
  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }
  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      const moduleParams = modulesParams[moduleName] || {};
      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }
  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }
  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach(m => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

var updateSize = function () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
};

var updateSlides = function () {
  const swiper = this;
  const params = swiper.params;

  const { $wrapperEl, size: swiperSize, rtl, wrongRTL } = swiper;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSlidesLength = slidesLength;
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index$$1 = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - (column * slidesPerColumn);
        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide
        .css(
          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
        )
        .attr('data-swiper-column', column)
        .attr('data-swiper-row', row);
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line
    if (params.slidesPerView === 'auto') {
      slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if ((index$$1) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if ((index$$1) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index$$1 += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (!Support.flexbox || params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(snapGrid[i]);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(snapGrid[i]);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.css({ marginLeft: `${spaceBetween}px` });
      else slides.css({ marginRight: `${spaceBetween}px` });
    } else slides.css({ marginBottom: `${spaceBetween}px` });
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
};

var updateAutoHeight = function () {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;

  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
      const index$$1 = swiper.activeIndex + i;
      if (index$$1 > swiper.slides.length) break;
      activeSlides.push(swiper.slides.eq(index$$1)[0]);
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
};

var updateSlidesOffset = function () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
};

var updateSlidesProgress = function (translate = this.translate || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress =
      (
        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
      ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible =
                (slideBefore >= 0 && slideBefore < swiper.size) ||
                (slideAfter > 0 && slideAfter <= swiper.size) ||
                (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
};

var updateProgress = function (translate = this.translate || 0) {
  const swiper = this;
  const params = swiper.params;

  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
};

var updateSlidesClasses = function () {
  const swiper = this;

  const { slides, params, $wrapperEl, activeIndex, realIndex } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
};

var updateActiveIndex = function (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtl ? swiper.translate : -swiper.translate;
  const { slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  swiper.emit('slideChange');
};

var updateClickedSlide = function (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
};

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

var getTranslate = function (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const { params, rtl, translate, $wrapperEl } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
};

var setTranslate = function (translate, byController) {
  const swiper = this;
  const { rtl, params, $wrapperEl, progress } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (!params.virtualTranslate) {
    if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    else $wrapperEl.transform(`translate(${x}px, ${y}px)`);
  }

  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
};

var minTranslate = function () {
  return (-this.snapGrid[0]);
};

var maxTranslate = function () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
};

var translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
};

var setTransition = function (duration, byController) {
  const swiper = this;

  swiper.$wrapperEl.transition(duration);

  swiper.emit('setTransition', duration, byController);
};

var transitionStart = function (runCallbacks = true) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  swiper.emit('transitionStart');

  if (!runCallbacks) return;
  if (activeIndex !== previousIndex) {
    swiper.emit('slideChangeTransitionStart');
    if (activeIndex > previousIndex) {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
};

var transitionEnd$1 = function (runCallbacks = true) {
  const swiper = this;
  const { activeIndex, previousIndex } = swiper;
  swiper.animating = false;
  swiper.setTransition(0);

  swiper.emit('transitionEnd');
  if (runCallbacks) {
    if (activeIndex !== previousIndex) {
      swiper.emit('slideChangeTransitionEnd');
      if (activeIndex > previousIndex) {
        swiper.emit('slideNextTransitionEnd');
      } else {
        swiper.emit('slidePrevTransitionEnd');
      }
    }
  }
};

var transition$1 = {
  setTransition,
  transitionStart,
  transitionEnd: transitionEnd$1,
};

const Browser = (function Browser() {
  function isIE9() {
    // create temporary DIV
    const div = document.createElement('div');
    // add content to tmp DIV which is wrapped into the IE HTML conditional statement
    div.innerHTML = '<!--[if lte IE 9]><i></i><![endif]-->';
    // return true / false value based on what will browser render
    return div.getElementsByTagName('i').length === 1;
  }
  function isSafari() {
    const ua = win.navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isSafari: isSafari(),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
    ie: win.navigator.pointerEnabled || win.navigator.msPointerEnabled,
    ieTouch: (win.navigator.msPointerEnabled && win.navigator.msMaxTouchPoints > 1) ||
             (win.navigator.pointerEnabled && win.navigator.maxTouchPoints > 1),
    lteIE9: isIE9(),
  };
}());

var slideTo = function (index$$1 = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index$$1;
  if (slideIndex < 0) slideIndex = 0;

  const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtl, $wrapperEl } = swiper;

  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }

  // Directions locks
  if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
    return false;
  }
  if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
    if ((activeIndex || 0) !== slideIndex) return false;
  }

  // Update Index
  swiper.updateActiveIndex(slideIndex);

  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    return false;
  }
  swiper.updateSlidesClasses();

  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks);

  if (speed === 0 || Browser.lteIE9) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.transitionEnd(runCallbacks);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    if (!swiper.animating) {
      swiper.animating = true;
      $wrapperEl.transitionEnd(() => {
        if (!swiper) return;
        swiper.transitionEnd(runCallbacks);
      });
    }
  }

  return true;
};

/* eslint no-unused-vars: "off" */
var slideNext = function (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
};

/* eslint no-unused-vars: "off" */
var slidePrev = function (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    return swiper.slideTo(swiper.activeIndex - 1, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex - 1, speed, runCallbacks, internal);
};

/* eslint no-unused-vars: "off" */
var slideReset = function (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
};

var slideToClickedSlide = function () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2)) ||
        (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
};

var slide = {
  slideTo,
  slideNext,
  slidePrev,
  slideReset,
  slideToClickedSlide,
};

var loopCreate = function () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index$$1, el) => {
    const slide = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(el);
    if (index$$1 < swiper.loopedSlides) appendSlides.push(el);
    if (index$$1 < slides.length && index$$1 >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index$$1);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
};

var loopFix = function () {
  const swiper = this;
  const { params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    swiper.slideTo(newIndex, 0, false, true);
  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex > slides.length - (params.slidesPerView * 2))) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    swiper.slideTo(newIndex, 0, false, true);
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
};

var loopDestroy = function () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
};

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

var setGrabCursor = function (moving) {
  const swiper = this;
  if (Support.touch || !swiper.params.simulateTouch) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
};

var unsetGrabCursor = function () {
  const swiper = this;
  if (Support.touch) return;
  swiper.el.style.cursor = '';
};

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

var appendSlide = function (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
};

var prependSlide = function (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
};

var removeSlide = function (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndex;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
};

var removeAllSlides = function () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
};

var manipulation = {
  appendSlide,
  prependSlide,
  removeSlide,
  removeAllSlides,
};

const Device = (function Device() {
  const ua = win.navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    windows: false,
    iphone: false,
    ipod: false,
    ipad: false,
    cordova: win.cordova || win.phonegap,
    phonegap: win.cordova || win.phonegap,
  };

  const windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);


  // Windows
  if (windows) {
    device.os = 'windows';
    device.osVersion = windows[2];
    device.windows = true;
  }
  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.iphone = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Desktop
  device.desktop = !(device.os || device.android || device.webView);

  // Webview
  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);

  // Minimal UI
  if (device.os && device.os === 'ios') {
    const osVersionArr = device.osVersion.split('.');
    const metaViewport = document.querySelector('meta[name="viewport"]');
    device.minimalUi =
      !device.webView &&
      (ipod || iphone) &&
      (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) &&
      metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
  }

  // Pixel Ratio
  device.pixelRatio = win.devicePixelRatio || 1;

  // Export object
  return device;
}());

var onTouchStart = function (event) {
  const swiper = this;
  const data$$1 = swiper.touchEventsData;
  const { params, touches } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  data$$1.isTouchEvent = e.type === 'touchstart';
  if (!data$$1.isTouchEvent && 'which' in e && e.which === 3) return;
  if (params.noSwiping && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e).closest(`.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e).closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
  if (Device.ios && params.iOSEdgeSwipeDetection && startX <= params.iOSEdgeSwipeThreshold) {
    return;
  }
  Utils.extend(data$$1, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data$$1.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data$$1.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target).is(data$$1.formElements)) preventDefault = false;
    if (document.activeElement && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(document.activeElement).is(data$$1.formElements)) {
      document.activeElement.blur();
    }
    if (preventDefault) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
};

var onTouchMove = function (event) {
  const swiper = this;
  const data$$1 = swiper.touchEventsData;
  const { params, touches, rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data$$1.isTouchEvent && e.type === 'mousemove') return;
  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data$$1.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data$$1.touchStartTime = Utils.now();
    }
    return;
  }
  if (data$$1.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (touches.currentY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||
        (touches.currentY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        return;
      }
    } else if (
      (touches.currentX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||
      (touches.currentX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data$$1.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target).is(data$$1.formElements)) {
      data$$1.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data$$1.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

  if (typeof data$$1.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data$$1.isScrolling = false;
    } else {
      touchAngle = (Math.atan2(Math.abs(touches.currentY - touches.startY), Math.abs(touches.currentX - touches.startX)) * 180) / Math.PI;
      data$$1.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
    }
  }
  if (data$$1.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data$$1.startMoving = true;
    }
  }
  if (!data$$1.isTouched) return;
  if (data$$1.isScrolling) {
    data$$1.isTouched = false;
    return;
  }
  if (!data$$1.startMoving) {
    return;
  }
  swiper.allowClick = false;
  e.preventDefault();
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data$$1.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data$$1.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data$$1.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data$$1.isMoved = true;

  let diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data$$1.currentTranslate = diff + data$$1.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data$$1.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data$$1.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data$$1.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data$$1.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data$$1.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data$$1.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data$$1.currentTranslate < data$$1.startTranslate) {
    data$$1.currentTranslate = data$$1.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data$$1.currentTranslate > data$$1.startTranslate) {
    data$$1.currentTranslate = data$$1.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data$$1.allowThresholdMove) {
      if (!data$$1.allowThresholdMove) {
        data$$1.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data$$1.currentTranslate = data$$1.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data$$1.currentTranslate = data$$1.startTranslate;
      return;
    }
  }

  if (!params.followFinger) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data$$1.velocities.length === 0) {
      data$$1.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data$$1.touchStartTime,
      });
    }
    data$$1.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data$$1.currentTranslate);
  // Update translate
  swiper.setTranslate(data$$1.currentTranslate);
};

var onTouchEnd = function (event) {
  const swiper = this;
  const data$$1 = swiper.touchEventsData;

  const { params, touches, rtl, $wrapperEl, slidesGrid, snapGrid } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data$$1.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data$$1.allowTouchCallbacks = false;
  if (!data$$1.isTouched) return;
  // Return Grab Cursor
  if (params.grabCursor && data$$1.isMoved && data$$1.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data$$1.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap', e);
    if (timeDiff < 300 && (touchEndTime - data$$1.lastClickTime) > 300) {
      if (data$$1.clickTimeout) clearTimeout(data$$1.clickTimeout);
      data$$1.clickTimeout = Utils.nextTick(() => {
        if (!swiper) return;
        swiper.emit('click', e);
      }, 300);
    }
    if (timeDiff < 300 && (touchEndTime - data$$1.lastClickTime) < 300) {
      if (data$$1.clickTimeout) clearTimeout(data$$1.clickTimeout);
      swiper.emit('doubleTap', e);
    }
  }

  data$$1.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (swiper) swiper.allowClick = true;
  });

  if (!data$$1.isTouched || !data$$1.isMoved || !swiper.swipeDirection || touches.diff === 0 || data$$1.currentTranslate === data$$1.startTranslate) {
    data$$1.isTouched = false;
    data$$1.isMoved = false;
    return;
  }
  data$$1.isTouched = false;
  data$$1.isMoved = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data$$1.currentTranslate;
  }
  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    } else if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data$$1.velocities.length > 1) {
        const lastMoveEvent = data$$1.velocities.pop();
        const velocityEvent = data$$1.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data$$1.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data$$1.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data$$1.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        if (!rtl) newPosition = -newPosition;
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
      } else if (params.freeModeSticky) {
        swiper.slideReset();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart();
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || !data$$1.allowMomentumBounce) return;
          swiper.emit('momentumBounce');

          swiper.setTransition(params.speed);
          swiper.setTranslate(afterBouncePosition);
          $wrapperEl.transitionEnd(() => {
            if (!swiper) return;
            swiper.transitionEnd();
          });
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart();
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
        stopIndex = i;
        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      swiper.slideTo(stopIndex + params.slidesPerGroup);
    }
    if (swiper.swipeDirection === 'prev') {
      swiper.slideTo(stopIndex);
    }
  }
};

var onResize = function () {
  const swiper = this;

  const { params, el, allowSlideNext, allowSlidePrev } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  if (params.freeMode) {
    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
    swiper.setTranslate(newTranslate);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
  } else {
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
};

var onClick = function (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
};

function attachEvents() {
  const swiper = this;

  const { params, touchEvents, el, wrapperEl } = swiper;

  {
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (Browser.ie) {
      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      (Support.touch ? target : document).addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      (Support.touch ? target : document).addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.addEventListener('mousedown', swiper.onTouchStart, false);
        document.addEventListener('mousemove', swiper.onTouchMove, capture);
        document.addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.addEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.on('resize observerUpdate', onResize);
}

function detachEvents() {
  const swiper = this;

  const { params, touchEvents, el, wrapperEl } = swiper;

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (Browser.ie) {
      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      (Support.touch ? target : document).removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      (Support.touch ? target : document).removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.removeEventListener('mousedown', swiper.onTouchStart, false);
        document.removeEventListener('mousemove', swiper.onTouchMove, capture);
        document.removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.removeEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.off('resize observerUpdate', onResize);
}

var events = {
  attachEvents,
  detachEvents,
};

var setBreakpoint = function () {
  const swiper = this;
  const { activeIndex, loopedSlides = 0, params } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;
  // Set breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);
  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : swiper.originalParams;
    const needsReLoop = params.loop && (breakPointsParams.slidesPerView !== params.slidesPerView);

    Utils.extend(swiper.params, breakPointsParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop) {
      const oldIndex = activeIndex - loopedSlides;
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo(oldIndex + loopedSlides, 0, false);
    }
  }
};

var getBreakpoint = function (breakpoints) {
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;
  const points = [];
  Object.keys(breakpoints).forEach((point) => {
    points.push(point);
  });
  points.sort((a, b) => parseInt(a, 10) > parseInt(b, 10));
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (point >= win.innerWidth && !breakpoint) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
};

var breakpoints = { setBreakpoint, getBreakpoint };

var addClasses = function () {
  const swiper = this;
  const { classNames, params, rtl, $el } = swiper;
  const suffixes = [];

  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (!Support.flexbox) {
    suffixes.push('no-flexbox');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
  }
  if (Device.android) {
    suffixes.push('android');
  }
  if (Device.ios) {
    suffixes.push('ios');
  }
  // WP8 Touch Events Fix
  if (win.navigator.pointerEnabled || win.navigator.msPointerEnabled) {
    suffixes.push(`wp8-${params.direction}`);
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
};

var removeClasses = function () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
};

var classes = { addClasses, removeClasses };

var loadImage = function (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  if (!imageEl.complete || !checkForComplete) {
    if (src) {
      image = new win.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
};

var preloadImages = function () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
};

var images = {
  loadImage,
  preloadImages,
};

var defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,

  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
  iOSEdgeSwipeDetection: false,
  iOSEdgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  centeredSlides: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: true,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

const prototypes = {
  update,
  translate,
  transition: transition$1,
  slide,
  loop,
  grabCursor,
  manipulation,
  events,
  breakpoints,
  classes,
  images,
};

const extendedDefaults = {};

class Swiper$1 extends SwiperClass {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!Swiper$1.prototype[protoMethod]) {
          Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;

    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object') return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object' &&
          !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Find el
    const $el = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index$$1, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new Swiper$1(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);

    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (win.navigator.pointerEnabled) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        } else if (win.navigator.msPointerEnabled) {
          desktop = ['MSPointerDown', 'MsPointerMove', 'MsPointerUp'];
        }

        return {
          start: Support.touch || !swiper.params.simulateTouch ? touch[0] : desktop[0],
          move: Support.touch || !swiper.params.simulateTouch ? touch[1] : desktop[1],
          end: Support.touch || !swiper.params.simulateTouch ? touch[2] : desktop[2],
        };
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, textarea, button, video',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }
  slidesPerViewDynamic() {
    const swiper = this;
    const { params, slides, slidesGrid, size: swiperSize, activeIndex } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper) return;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    let newTranslate;
    function setTranslate() {
      newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    swiper.emit('update');
  }
  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    let swiper = this;
    const { params, $el, $wrapperEl, slides } = swiper;
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index')
          .removeAttr('data-swiper-column')
          .removeAttr('data-swiper-row');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
      swiper = null;
    }
  }
  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static get Class() {
    return SwiperClass;
  }
  static get $() {
    return __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */];
  }
}

var Device$2 = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
};

var Support$2 = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

var Browser$2 = {
  name: 'browser',
  proto: {
    browser: Browser,
  },
  static: {
    browser: Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      win.addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      win.removeEventListener('resize', swiper.resize.resizeHandler);
      win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer = {
  func: win.MutationObserver || win.WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer.func;
    const observer = new ObserverFunc((mutations) => {
      mutations.forEach((mutation) => {
        swiper.emit('observerUpdate', mutation);
      });
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: false });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer.init.bind(swiper),
        attach: Observer.attach.bind(swiper),
        destroy: Observer.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtl && swiper.isHorizontal()) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1);
      slidesBefore = slidesPerGroup;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset$$1 = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset: offset$$1,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset$$1 !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset$$1}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset: offset$$1,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index$$1) => {
      swiper.$wrapperEl.append(renderSlide(slides[index$$1], index$$1));
    });
    prependIndexes.sort((a, b) => a < b).forEach((index$$1) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index$$1], index$$1));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset$$1}px`);
    onRendered();
  },
  renderSlide(slide, index$$1) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index$$1]) {
      return swiper.virtual.cache[index$$1];
    }
    const $slideEl = params.renderSlide
      ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(params.renderSlide.call(swiper, slide, index$$1))
      : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index$$1}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index$$1);
    if (params.cache) swiper.virtual.cache[index$$1] = $slideEl;
    return $slideEl;
  },
  appendSlide(slide) {
    const swiper = this;
    swiper.virtual.slides.push(slide);
    swiper.virtual.update(true);
  },
  prependSlide(slide) {
    const swiper = this;
    swiper.virtual.slides.unshift(slide);
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        newCache[cachedIndex + 1] = cache[cachedIndex];
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideNext(0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      Utils.extend(swiper.params, {
        watchSlidesProgress: true,
      });
      swiper.virtual.update();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Keyboard = {
  handle(event) {
    const swiper = this;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    // Directions locks
    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {
      return false;
    }
    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const windowScroll = {
        left: win.pageXOffset,
        top: win.pageYOffset,
      };
      const windowWidth = win.innerWidth;
      const windowHeight = win.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (swiper.rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [
        [swiperOffset.left, swiperOffset.top],
        [swiperOffset.left + swiper.width, swiperOffset.top],
        [swiperOffset.left, swiperOffset.top + swiper.height],
        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
      ];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (
          point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
            point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight
        ) {
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (kc === 37 || kc === 39) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if ((kc === 39 && !swiper.rtl) || (kc === 37 && swiper.rtl)) swiper.slideNext();
      if ((kc === 37 && !swiper.rtl) || (kc === 39 && swiper.rtl)) swiper.slidePrev();
    } else {
      if (kc === 38 || kc === 40) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (kc === 40) swiper.slideNext();
      if (kc === 38) swiper.slidePrev();
    }
    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable() {
    const swiper = this;
    if (swiper.keyboard.enabled) return;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(document).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable() {
    const swiper = this;
    if (!swiper.keyboard.enabled) return;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(document).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  },
};

var Keyboard$1 = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      keyboard: {
        enabled: false,
        enable: Keyboard.enable.bind(swiper),
        disable: Keyboard.disable.bind(swiper),
        handle: Keyboard.handle.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    },
  },
};

function isEventSupported() {
  const eventName = 'onwheel';
  let isSupported = eventName in document;

  if (!isSupported) {
    const element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported &&
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true
  ) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}
const Mousewheel = {
  lastScrollTime: Utils.now(),
  event: (function getEvent() {
    if (win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  }()),
  normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;

    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else { // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = (pX < 1) ? -1 : 1;
    }
    if (pY && !sY) {
      sY = (pY < 1) ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  },
  handle(event) {
    let e = event;
    const swiper = this;
    const params = swiper.params.mousewheel;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtl ? -1 : 1;

    const data$$1 = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data$$1.pixelX) > Math.abs(data$$1.pixelY)) delta = data$$1.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data$$1.pixelY) > Math.abs(data$$1.pixelX)) delta = data$$1.pixelY;
      else return true;
    } else {
      delta = Math.abs(data$$1.pixelX) > Math.abs(data$$1.pixelY) ? -data$$1.pixelX * rtlFactor : -data$$1.pixelY;
    }

    if (delta === 0) return true;

    if (params.invert) delta = -delta;

    if (!swiper.params.freeMode) {
      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
        if (delta < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            swiper.emit('scroll', e);
          } else if (params.releaseOnEdges) return true;
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          swiper.emit('scroll', e);
        } else if (params.releaseOnEdges) return true;
      }
      swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
    } else {
      // Freemode or scrollContainer:
      let position = swiper.getTranslate() + (delta * params.sensitivity);
      const wasBeginning = swiper.isBeginning;
      const wasEnd = swiper.isEnd;

      if (position >= swiper.minTranslate()) position = swiper.minTranslate();
      if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

      swiper.setTransition(0);
      swiper.setTranslate(position);
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();

      if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeModeSticky) {
        clearTimeout(swiper.mousewheel.timeout);
        swiper.mousewheel.timeout = Utils.nextTick(() => {
          swiper.slideReset();
        }, 300);
      }
      // Emit event
      swiper.emit('scroll', e);

      // Stop autoplay
      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.stopAutoplay();

      // Return page scroll on edge positions
      if (position === 0 || position === swiper.maxTranslate()) return true;
    }

    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    return false;
  },
  enable() {
    const swiper = this;
    if (!Mousewheel.event) return false;
    if (swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(swiper.params.mousewheel.eventsTarged);
    }
    target.on(Mousewheel.event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable() {
    const swiper = this;
    if (!Mousewheel.event) return false;
    if (!swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(swiper.params.mousewheel.eventsTarged);
    }
    target.off(Mousewheel.event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  },
};

var Mousewheel$1 = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarged: 'container',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      mousewheel: {
        enabled: false,
        enable: Mousewheel.enable.bind(swiper),
        disable: Mousewheel.disable.bind(swiper),
        handle: Mousewheel.handle.bind(swiper),
        lastScrollTime: Utils.now(),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy() {
      const swiper = this;
      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(params.nextEl);
      if (
        swiper.params.uniqueNavElements &&
        typeof params.nextEl === 'string' &&
        $nextEl.length > 1 &&
        swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(params.prevEl);
      if (
        swiper.params.uniqueNavElements &&
        typeof params.prevEl === 'string' &&
        $prevEl.length > 1 &&
        swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', (e) => {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
      });
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', (e) => {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
      });
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click');
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click');
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick &&
        !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target).is($prevEl) &&
        !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target).is($nextEl)
      ) {
        if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * 5}px`);
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev`);
      if ($el.length > 1) {
        bullets.each((index$$1, bullet) => {
          const $bullet = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(bullet);
          if ($bullet.index() === current) {
            $bullet.addClass(params.bulletActiveClass);
            if (params.dynamicBullets) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          $bullet
            .prev()
            .addClass(`${params.bulletActiveClass}-prev`)
            .prev()
            .addClass(`${params.bulletActiveClass}-prev-prev`);
          $bullet
            .next()
            .addClass(`${params.bulletActiveClass}-next`)
            .next()
            .addClass(`${params.bulletActiveClass}-next-next`);
        }
      }
      if (params.dynamicBullets) {
        const bulletsOffset = (((swiper.pagination.bulletSize * 5) - (swiper.pagination.bulletSize)) / 2) - (current * swiper.pagination.bulletSize);
        bullets.css(swiper.isHorizontal() ? 'left' : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(current + 1);
      $el.find(`.${params.totalClass}`).text(total);
    }
    if (params.type === 'progressbar') {
      const scale = (current + 1) / total;
      let scaleX = scale;
      let scaleY = 1;
      if (!swiper.isHorizontal()) {
        scaleY = scale;
        scaleX = 1;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML =
        `<span class="${params.currentClass}"></span>` +
        ' / ' +
        `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements &&
      typeof params.el === 'string' &&
      $el.length > 1 &&
      swiper.$el.find(params.el).length === 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index$$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index$$1 += swiper.loopedSlides;
        swiper.slideTo(index$$1);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,

      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      clickableClass: 'swiper-pagination-clickable', // NEW
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el &&
        swiper.params.pagination.hideOnClick &&
        swiper.pagination.$el.length > 0 &&
        !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtl, progress } = swiper;
    const { dragSize, trackSize, $dragEl, $el } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl && swiper.isHorizontal()) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      if (Support.transforms3d) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      } else {
        $dragEl.transform(`translateX(${newPos}px)`);
      }
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      if (Support.transforms3d) {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      } else {
        $dragEl.transform(`translateY(${newPos}px)`);
      }
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbarHide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar } = swiper;
    const { $el, dragSize, moveDivider } = scrollbar;

    let pointerPosition;
    if (swiper.isHorizontal()) {
      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
    } else {
      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
    }
    let position = (pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2);
    const positionMin = -swiper.minTranslate() * moveDivider;
    const positionMax = -swiper.maxTranslate() * moveDivider;
    if (position < positionMin) {
      position = positionMin;
    } else if (position > positionMax) {
      position = positionMax;
    }
    if (swiper.rtl) {
      position = positionMax - position;
    }
    position = -position / moveDivider;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideReset();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar } = swiper;
    const $el = scrollbar.$el;
    const target = Support.touch ? $el[0] : document;
    $el.on(swiper.scrollbar.dragEvents.start, swiper.scrollbar.onDragStart);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(target).on(swiper.scrollbar.dragEvents.move, swiper.scrollbar.onDragMove);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(target).on(swiper.scrollbar.dragEvents.end, swiper.scrollbar.onDragEnd);
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar } = swiper;
    const $el = scrollbar.$el;
    const target = Support.touch ? $el[0] : document;
    $el.off(swiper.scrollbar.dragEvents.start);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(target).off(swiper.scrollbar.dragEvents.move);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(target).off(swiper.scrollbar.dragEvents.end);
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl, touchEvents } = swiper;
    const params = swiper.params.scrollbar;

    let $el = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find('.swiper-scrollbar-drag');
    if ($dragEl.length === 0) {
      $dragEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])('<div class="swiper-scrollbar-drag"></div>');
      $el.append($dragEl);
    }

    swiper.scrollbar.dragEvents = (function dragEvents() {
      if ((swiper.params.simulateTouch === false && !Support.touch)) {
        return {
          start: 'mousedown',
          move: 'mousemove',
          end: 'mouseup',
        };
      }
      return touchEvents;
    }());

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof pOpacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof pScale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const { $el, slides, progress } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
      .each((index$$1, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
        .each((index$$1, el) => {
          const slideProgress = Math.min(Math.max(slideEl.progress, -1), 1);
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
      .each((index$$1, parallaxEl) => {
        const $parallaxEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      swiper.params.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(this);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    gesture.$imageEl.transition(0);
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (Support.gestures) {
      swiper.zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2)) {
        return;
      }
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (Device.android) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) image.startX = -image.startX;
      if (swiper.rtl) image.startY = -image.startY;
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal() &&
        (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||
          (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } else if (
        !swiper.isHorizontal() &&
        (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||
          (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    e.preventDefault();
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;

      zoom.scale = 1;
      zoom.currentScale = 1;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const slides = swiper.slides;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (Support.gestures) {
      slides.on('gesturestart', zoom.onGestureStart, passiveListener);
      slides.on('gesturechange', zoom.onGestureChange, passiveListener);
      slides.on('gestureend', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      slides.on(swiper.touchEvents.start, zoom.onGestureStart, passiveListener);
      slides.on(swiper.touchEvents.move, zoom.onGestureChange, passiveListener);
      slides.on(swiper.touchEvents.end, zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.slides.each((index$$1, slideEl) => {
      const $slideEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl);
      if ($slideEl.find(`.${swiper.params.zoom.containerClass}`).length > 0) {
        $slideEl.on(swiper.touchEvents.move, zoom.onTouchMove);
      }
    });
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const slides = swiper.slides;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (Support.gestures) {
      slides.off('gesturestart', zoom.onGestureStart, passiveListener);
      slides.off('gesturechange', zoom.onGestureChange, passiveListener);
      slides.off('gestureend', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      slides.off(swiper.touchEvents.start, zoom.onGestureStart, passiveListener);
      slides.off(swiper.touchEvents.move, zoom.onGestureChange, passiveListener);
      slides.off(swiper.touchEvents.end, zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.slides.each((index$$1, slideEl) => {
      const $slideEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl);
      if ($slideEl.find(`.${swiper.params.zoom.containerClass}`).length > 0) {
        $slideEl.off(swiper.touchEvents.move, zoom.onTouchMove);
      }
    });
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };
    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy = {
  loadInSlide(index$$1, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index$$1 === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index$$1}"]`)
      : swiper.slides.eq(index$$1);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params)) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const { $wrapperEl, params: swiperParams, slides, activeIndex } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index$$1) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index$$1}"]`).length) {
          return true;
        }
      } else if (slides[index$$1]) return true;
      return false;
    }
    function slideIndex(slideEl) {
      if (isVirtual) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl).attr('data-swiper-slide-index');
      }
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index$$1 = isVirtual ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl).attr('data-swiper-slide-index') : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(slideEl).index();
        swiper.lazy.loadInSlide(index$$1);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy.load.bind(swiper),
        loadInSlide: Lazy.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.preloadImages) swiper.params.preloadImages = false;
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
  },
};

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
const Controller = {
  LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ?
        new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) :
        new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = c.rtl && c.params.direction === 'horizontal' ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper$1) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper$1 && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper$1) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper$1 && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: false,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

const History = {
  init() {
    const swiper = this;
    if (!swiper.params.history) return;
    if (!win.history || !win.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    const history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues();
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      win.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy() {
    const swiper = this;
    if (!swiper.params.history.replaceState) {
      win.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState() {
    const swiper = this;
    swiper.history.paths = History.getPathValues();
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues() {
    const pathArray = win.location.pathname.slice(1).split('/');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return { key, value };
  },
  setHistory(key, index$$1) {
    const swiper = this;
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    const slide = swiper.slides.eq(index$$1);
    let value = History.slugify(slide.attr('data-history'));
    if (!win.location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    const currentState = win.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      win.history.replaceState({ value }, null, value);
    } else {
      win.history.pushState({ value }, null, value);
    }
  },
  slugify(text$$1) {
    return text$$1.toString().toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  },
  scrollToSlide(speed, value, runCallbacks) {
    const swiper = this;
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = History.slugify(slide.attr('data-history'));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index$$1 = slide.index();
          swiper.slideTo(index$$1, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  },
};

var History$1 = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      replaceState: false,
      key: 'slides',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      history: {
        init: History.init.bind(swiper),
        setHistory: History.setHistory.bind(swiper),
        setHistoryPopState: History.setHistoryPopState.bind(swiper),
        scrollToSlide: History.scrollToSlide.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
  },
};

const HashNavigation = {
  onHashCange() {
    const swiper = this;
    const newHash = document.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
    if (newHash !== activeSlideHash) {
      swiper.slideTo(swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index());
    }
  },
  setHash() {
    const swiper = this;
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
    if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
      win.history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      document.location.hash = hash || '';
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
    swiper.hashNavigation.initialized = true;
    const hash = document.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index$$1 = slide.index();
          swiper.slideTo(index$$1, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(win).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.params.hashNavigation.watchState) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(win).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
};
var HashNavigation$1 = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      hashNavigation: {
        initialized: false,
        init: HashNavigation.init.bind(swiper),
        destroy: HashNavigation.destroy.bind(swiper),
        setHash: HashNavigation.setHash.bind(swiper),
        onHashCange: HashNavigation.onHashCange.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
  },
};

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl.transitionEnd(() => {
        if (!swiper) return;
        swiper.autoplay.paused = false;
        if (!swiper.autoplay.running) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.run();
        }
      });
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      disableOnInteraction: true,
      stopOnLastSlide: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset$$1 = $slideEl[0].swiperSlideOffset;
      let tx = -offset$$1;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ?
        Math.max(1 - Math.abs($slideEl[0].progress), 0) :
        1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      Utils.extend(swiper.params, {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      });
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const { $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtl, size: swiperSize } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform$$1 = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform$$1);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2) +
          (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset$$1 = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset$$1}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      Utils.extend(swiper.params, {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      });
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset$$1 = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset$$1;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (swiper.rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }

      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper) return;
        if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      Utils.extend(swiper.params, {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      });
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const { width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform$$1 = swiper.translate;
    const center = isHorizontal ? -transform$$1 + (swiperWidth / 2) : -transform$$1 + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
      let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (Browser.ie) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

// Swiper Class
// Core Modules
Swiper$1.components = [
  Device$2,
  Support$2,
  Browser$2,
  Resize,
  Observer$1,
  Virtual$1,
  Keyboard$1,
  Mousewheel$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$1,
  Controller$1,
  A11y,
  History$1,
  HashNavigation$1,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow
];

/* harmony default export */ __webpack_exports__["a"] = (Swiper$1);


/***/ }),

/***/ "n3D3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _ariaUtils = __webpack_require__("5di0");

var _ariaUtils2 = _interopRequireDefault(_ariaUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @desc Dialog object providing modal focus management.
 *
 * Assumptions: The element serving as the dialog container is present in the
 * DOM and hidden. The dialog container has role='dialog'.
 *
 * @param dialogId
 *          The ID of the element serving as the dialog container.
 * @param focusAfterClosed
 *          Either the DOM node or the ID of the DOM node to focus when the
 *          dialog closes.
 * @param focusFirst
 *          Optional parameter containing either the DOM node or the ID of the
 *          DOM node to focus when the dialog opens. If not specified, the
 *          first focusable element in the dialog will receive focus.
 */
var aria = aria || {};
var tabEvent;

aria.Dialog = function (dialog, focusAfterClosed, focusFirst) {
  var _this = this;

  this.dialogNode = dialog;
  if (this.dialogNode === null || this.dialogNode.getAttribute('role') !== 'dialog') {
    throw new Error('Dialog() requires a DOM element with ARIA role of dialog.');
  }

  if (typeof focusAfterClosed === 'string') {
    this.focusAfterClosed = document.getElementById(focusAfterClosed);
  } else if ((typeof focusAfterClosed === 'undefined' ? 'undefined' : _typeof(focusAfterClosed)) === 'object') {
    this.focusAfterClosed = focusAfterClosed;
  } else {
    this.focusAfterClosed = null;
  }

  if (typeof focusFirst === 'string') {
    this.focusFirst = document.getElementById(focusFirst);
  } else if ((typeof focusFirst === 'undefined' ? 'undefined' : _typeof(focusFirst)) === 'object') {
    this.focusFirst = focusFirst;
  } else {
    this.focusFirst = null;
  }

  if (this.focusFirst) {
    this.focusFirst.focus();
  } else {
    _ariaUtils2.default.focusFirstDescendant(this.dialogNode);
  }

  this.lastFocus = document.activeElement;
  tabEvent = function tabEvent(e) {
    _this.trapFocus(e);
  };
  this.addListeners();
};

aria.Dialog.prototype.addListeners = function () {
  document.addEventListener('focus', tabEvent, true);
};

aria.Dialog.prototype.removeListeners = function () {
  document.removeEventListener('focus', tabEvent, true);
};

aria.Dialog.prototype.closeDialog = function () {
  var _this2 = this;

  this.removeListeners();
  if (this.focusAfterClosed) {
    setTimeout(function () {
      _this2.focusAfterClosed.focus();
    });
  }
};

aria.Dialog.prototype.trapFocus = function (event) {
  if (_ariaUtils2.default.IgnoreUtilFocusChanges) {
    return;
  }
  if (this.dialogNode.contains(event.target)) {
    this.lastFocus = event.target;
  } else {
    _ariaUtils2.default.focusFirstDescendant(this.dialogNode);
    if (this.lastFocus === document.activeElement) {
      _ariaUtils2.default.focusLastDescendant(this.dialogNode);
    }
    this.lastFocus = document.activeElement;
  }
};

exports.default = aria.Dialog;

/***/ }),

/***/ "nARF":
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("AYvJ");
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),

/***/ "nkWw":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (number);

/***/ }),

/***/ "p4+t":
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 280);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 280:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(281);


/***/ }),

/***/ 281:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tag = __webpack_require__(282);

var _tag2 = _interopRequireDefault(_tag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_tag2.default.install = function (Vue) {
  Vue.component(_tag2.default.name, _tag2.default);
};

exports.default = _tag2.default;

/***/ }),

/***/ 282:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue__ = __webpack_require__(283);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_466877f5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tag_vue__ = __webpack_require__(284);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tag_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_466877f5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tag_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 283:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElTag',
  props: {
    text: String,
    closable: Boolean,
    type: String,
    hit: Boolean,
    disableTransitions: Boolean,
    color: String,
    size: String
  },
  methods: {
    handleClose: function handleClose(event) {
      this.$emit('close', event);
    }
  },
  computed: {
    tagSize: function tagSize() {
      return this.size || (this.$ELEMENT || {}).size;
    }
  }
};

/***/ }),

/***/ 284:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.disableTransitions ? '' : 'el-zoom-in-center'}},[_c('span',{staticClass:"el-tag",class:[
      _vm.type ? 'el-tag--' + _vm.type : '',
      _vm.tagSize && ("el-tag--" + _vm.tagSize),
      {'is-hit': _vm.hit}
    ],style:({backgroundColor: _vm.color})},[_vm._t("default"),(_vm.closable)?_c('i',{staticClass:"el-tag__close el-icon-close",on:{"click":_vm.handleClose}}):_vm._e()],2)])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "q1/O":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("Lohu");
var createDesc = __webpack_require__("TUEb");
module.exports = __webpack_require__("PRM/") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "qLlb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function pattern(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string') && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string')) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (pattern);

/***/ }),

/***/ "qq67":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("13kP")('keys');
var uid = __webpack_require__("Fl16");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "rBjB":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 235);
/******/ })
/************************************************************************/
/******/ ({

/***/ 13:
/***/ (function(module, exports) {

module.exports = __webpack_require__("x018");

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = __webpack_require__("caRQ");

/***/ }),

/***/ 20:
/***/ (function(module, exports) {

module.exports = __webpack_require__("rNOT");

/***/ }),

/***/ 235:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(236);


/***/ }),

/***/ 236:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(237);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),

/***/ 237:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vuePopper = __webpack_require__(8);

var _vuePopper2 = _interopRequireDefault(_vuePopper);

var _debounce = __webpack_require__(13);

var _debounce2 = _interopRequireDefault(_debounce);

var _vdom = __webpack_require__(20);

var _util = __webpack_require__(2);

var _vue = __webpack_require__(5);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'ElTooltip',

  mixins: [_vuePopper2.default],

  props: {
    openDelay: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    manual: Boolean,
    effect: {
      type: String,
      default: 'dark'
    },
    popperClass: String,
    content: String,
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'el-fade-in-linear'
    },
    popperOptions: {
      default: function _default() {
        return {
          boundariesPadding: 10,
          gpuAcceleration: false
        };
      }
    },
    enterable: {
      type: Boolean,
      default: true
    },
    hideAfter: {
      type: Number,
      default: 0
    }
  },

  data: function data() {
    return {
      timeoutPending: null,
      focusing: false
    };
  },

  computed: {
    tooltipId: function tooltipId() {
      return 'el-tooltip-' + (0, _util.generateId)();
    }
  },
  beforeCreate: function beforeCreate() {
    var _this = this;

    if (this.$isServer) return;

    this.popperVM = new _vue2.default({
      data: { node: '' },
      render: function render(h) {
        return this.node;
      }
    }).$mount();

    this.debounceClose = (0, _debounce2.default)(200, function () {
      return _this.handleClosePopper();
    });
  },
  render: function render(h) {
    var _this2 = this;

    if (this.popperVM) {
      this.popperVM.node = h(
        'transition',
        {
          attrs: {
            name: this.transition
          },
          on: {
            'afterLeave': this.doDestroy
          }
        },
        [h(
          'div',
          {
            on: {
              'mouseleave': function mouseleave() {
                _this2.setExpectedState(false);_this2.debounceClose();
              },
              'mouseenter': function mouseenter() {
                _this2.setExpectedState(true);
              }
            },

            ref: 'popper',
            attrs: { role: 'tooltip',
              id: this.tooltipId,
              'aria-hidden': this.disabled || !this.showPopper ? 'true' : 'false'
            },
            directives: [{
              name: 'show',
              value: !this.disabled && this.showPopper
            }],

            'class': ['el-tooltip__popper', 'is-' + this.effect, this.popperClass] },
          [this.$slots.content || this.content]
        )]
      );
    }

    if (!this.$slots.default || !this.$slots.default.length) return this.$slots.default;

    var vnode = (0, _vdom.getFirstComponentChild)(this.$slots.default);

    if (!vnode) return vnode;

    var data = vnode.data = vnode.data || {};
    var on = vnode.data.on = vnode.data.on || {};
    var nativeOn = vnode.data.nativeOn = vnode.data.nativeOn || {};

    data.staticClass = this.concatClass(data.staticClass, 'el-tooltip');
    nativeOn.mouseenter = on.mouseenter = this.addEventHandle(on.mouseenter, this.show);
    nativeOn.mouseleave = on.mouseleave = this.addEventHandle(on.mouseleave, this.hide);
    nativeOn.focus = on.focus = this.addEventHandle(on.focus, this.handleFocus);
    nativeOn.blur = on.blur = this.addEventHandle(on.blur, this.handleBlur);
    nativeOn.click = on.click = this.addEventHandle(on.click, function () {
      _this2.focusing = false;
    });
    return vnode;
  },
  mounted: function mounted() {
    this.referenceElm = this.$el;
    if (this.$el.nodeType === 1) {
      this.$el.setAttribute('aria-describedby', this.tooltipId);
      this.$el.setAttribute('tabindex', 0);
    }
  },

  watch: {
    focusing: function focusing(val) {
      if (val) {
        this.referenceElm.className += ' focusing';
      } else {
        this.referenceElm.className = this.referenceElm.className.replace('focusing', '');
      }
    }
  },
  methods: {
    show: function show() {
      this.setExpectedState(true);
      this.handleShowPopper();
    },
    hide: function hide() {
      this.setExpectedState(false);
      this.debounceClose();
    },
    handleFocus: function handleFocus() {
      this.focusing = true;
      this.show();
    },
    handleBlur: function handleBlur() {
      this.focusing = false;
      this.hide();
    },
    addEventHandle: function addEventHandle(old, fn) {
      if (!old) {
        return fn;
      } else if (Array.isArray(old)) {
        return old.indexOf(fn) > -1 ? old : old.concat(fn);
      } else {
        return old === fn ? old : [old, fn];
      }
    },
    concatClass: function concatClass(a, b) {
      if (a && a.indexOf(b) > -1) return a;
      return a ? b ? a + ' ' + b : a : b || '';
    },
    handleShowPopper: function handleShowPopper() {
      var _this3 = this;

      if (!this.expectedState || this.manual) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this3.showPopper = true;
      }, this.openDelay);

      if (this.hideAfter > 0) {
        this.timeoutPending = setTimeout(function () {
          _this3.showPopper = false;
        }, this.hideAfter);
      }
    },
    handleClosePopper: function handleClosePopper() {
      if (this.enterable && this.expectedState || this.manual) return;
      clearTimeout(this.timeout);

      if (this.timeoutPending) {
        clearTimeout(this.timeoutPending);
      }
      this.showPopper = false;
    },
    setExpectedState: function setExpectedState(expectedState) {
      if (expectedState === false) {
        clearTimeout(this.timeoutPending);
      }
      this.expectedState = expectedState;
    }
  }
};

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

module.exports = __webpack_require__("5vqR");

/***/ }),

/***/ 8:
/***/ (function(module, exports) {

module.exports = __webpack_require__("jA/d");

/***/ })

/******/ });

/***/ }),

/***/ "rGkY":
/***/ (function(module, exports) {

var nestRE = /^(attrs|props|on|nativeOn|class|style|hook)$/

module.exports = function mergeJSXProps (objs) {
  return objs.reduce(function (a, b) {
    var aa, bb, key, nestedKey, temp
    for (key in b) {
      aa = a[key]
      bb = b[key]
      if (aa && nestRE.test(key)) {
        // normalize class
        if (key === 'class') {
          if (typeof aa === 'string') {
            temp = aa
            a[key] = aa = {}
            aa[temp] = true
          }
          if (typeof bb === 'string') {
            temp = bb
            b[key] = bb = {}
            bb[temp] = true
          }
        }
        if (key === 'on' || key === 'nativeOn' || key === 'hook') {
          // merge functions
          for (nestedKey in bb) {
            aa[nestedKey] = mergeFn(aa[nestedKey], bb[nestedKey])
          }
        } else if (Array.isArray(aa)) {
          a[key] = aa.concat(bb)
        } else if (Array.isArray(bb)) {
          a[key] = [aa].concat(bb)
        } else {
          for (nestedKey in bb) {
            aa[nestedKey] = bb[nestedKey]
          }
        }
      } else {
        a[key] = b[key]
      }
    }
    return a
  }, {})
}

function mergeFn (a, b) {
  return function () {
    a.apply(this, arguments)
    b.apply(this, arguments)
  }
}


/***/ }),

/***/ "rNOT":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.isVNode = isVNode;
exports.getFirstComponentChild = getFirstComponentChild;

var _util = __webpack_require__("caRQ");

function isVNode(node) {
  return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && (0, _util.hasOwn)(node, 'componentOptions');
};

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.tag;
  })[0];
};

/***/ }),

/***/ "rs4r":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

/* Modified from https://github.com/taylorhakes/fecha
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Taylor Hakes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*eslint-disable*/
// 把 YYYY-MM-DD 改成了 yyyy-MM-dd
(function (main) {
  'use strict';

  /**
   * Parse or format dates
   * @class fecha
   */

  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var noop = function noop() {};

  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };

  var formatFlags = {
    D: function D(dateObj) {
      return dateObj.getDay();
    },
    DD: function DD(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function Do(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function d(dateObj) {
      return dateObj.getDate();
    },
    dd: function dd(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function ddd(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function dddd(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function M(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function MM(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function MMM(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function MMMM(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function yy(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    yyyy: function yyyy(dateObj) {
      return dateObj.getFullYear();
    },
    h: function h(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function hh(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function H(dateObj) {
      return dateObj.getHours();
    },
    HH: function HH(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function m(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function mm(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function s(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function ss(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function S(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function SS(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function SSS(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function a(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function A(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function ZZ(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };

  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date(),
          cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/[\+\-]\d\d:?\d\d/, function (d, v) {
      var parts = (v + '').match(/([\+\-]|\d\d)/gi),
          minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.DD = parseFlags.D;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.Do = parseFlags.dd = parseFlags.d;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;

  // Some common format strings
  fecha.masks = {
    'default': 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };

  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];

    return mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
  };

  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format;

    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
      return false;
    }

    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }

      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });

    if (!isValid) {
      return false;
    }

    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  /* istanbul ignore next */
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = fecha;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return fecha;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    main.fecha = fecha;
  }
})(undefined);

/***/ }),

/***/ "sNst":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("f68a");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("1rx+") });


/***/ }),

/***/ "sy5a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__("f+uh");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__("xB8i");



/**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (integer);

/***/ }),

/***/ "tNH9":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "tjS7":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("x8DJ");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "ulw0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = function (Vue) {

  /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */

  function template(string) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (args.length === 1 && _typeof(args[0]) === 'object') {
      args = args[0];
    }

    if (!args || !args.hasOwnProperty) {
      args = {};
    }

    return string.replace(RE_NARGS, function (match, prefix, i, index) {
      var result = void 0;

      if (string[index - 1] === '{' && string[index + match.length] === '}') {
        return i;
      } else {
        result = (0, _util.hasOwn)(args, i) ? args[i] : null;
        if (result === null || result === undefined) {
          return '';
        }

        return result;
      }
    });
  }

  return template;
};

var _util = __webpack_require__("caRQ");

var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */

/***/ }),

/***/ "vV1w":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("LniK");
__webpack_require__("yp0o");
module.exports = __webpack_require__("QFRh").f('iterator');


/***/ }),

/***/ "w4xd":
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 346);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 346:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(347);


/***/ }),

/***/ 347:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _progress = __webpack_require__(348);

var _progress2 = _interopRequireDefault(_progress);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_progress2.default.install = function (Vue) {
  Vue.component(_progress2.default.name, _progress2.default);
};

exports.default = _progress2.default;

/***/ }),

/***/ 348:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue__ = __webpack_require__(349);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ddec355_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_progress_vue__ = __webpack_require__(350);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_progress_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ddec355_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_progress_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 349:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElProgress',
  props: {
    type: {
      type: String,
      default: 'line',
      validator: function validator(val) {
        return ['line', 'circle'].indexOf(val) > -1;
      }
    },
    percentage: {
      type: Number,
      default: 0,
      required: true,
      validator: function validator(val) {
        return val >= 0 && val <= 100;
      }
    },
    status: {
      type: String
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    barStyle: function barStyle() {
      var style = {};
      style.width = this.percentage + '%';
      return style;
    },
    relativeStrokeWidth: function relativeStrokeWidth() {
      return (this.strokeWidth / this.width * 100).toFixed(1);
    },
    trackPath: function trackPath() {
      var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);

      return 'M 50 50 m 0 -' + radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 ' + radius * 2 + ' a ' + radius + ' ' + radius + ' 0 1 1 0 -' + radius * 2;
    },
    perimeter: function perimeter() {
      var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
      return 2 * Math.PI * radius;
    },
    circlePathStyle: function circlePathStyle() {
      var perimeter = this.perimeter;
      return {
        strokeDasharray: perimeter + 'px,' + perimeter + 'px',
        strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
        transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
      };
    },
    stroke: function stroke() {
      var ret;
      switch (this.status) {
        case 'success':
          ret = '#13ce66';
          break;
        case 'exception':
          ret = '#ff4949';
          break;
        default:
          ret = '#20a0ff';
      }
      return ret;
    },
    iconClass: function iconClass() {
      if (this.type === 'line') {
        return this.status === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-cross';
      } else {
        return this.status === 'success' ? 'el-icon-check' : 'el-icon-close';
      }
    },
    progressTextSize: function progressTextSize() {
      return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.111111 + 2;
    }
  }
};

/***/ }),

/***/ 350:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-progress",class:[
    'el-progress--' + _vm.type,
    _vm.status ? 'is-' + _vm.status : '',
    {
      'el-progress--without-text': !_vm.showText,
      'el-progress--text-inside': _vm.textInside,
    }
  ],attrs:{"role":"progressbar","aria-valuenow":_vm.percentage,"aria-valuemin":"0","aria-valuemax":"100"}},[(_vm.type === 'line')?_c('div',{staticClass:"el-progress-bar"},[_c('div',{staticClass:"el-progress-bar__outer",style:({height: _vm.strokeWidth + 'px'})},[_c('div',{staticClass:"el-progress-bar__inner",style:(_vm.barStyle)},[(_vm.showText && _vm.textInside)?_c('div',{staticClass:"el-progress-bar__innerText"},[_vm._v(_vm._s(_vm.percentage)+"%")]):_vm._e()])])]):_c('div',{staticClass:"el-progress-circle",style:({height: _vm.width + 'px', width: _vm.width + 'px'})},[_c('svg',{attrs:{"viewBox":"0 0 100 100"}},[_c('path',{staticClass:"el-progress-circle__track",attrs:{"d":_vm.trackPath,"stroke":"#e5e9f2","stroke-width":_vm.relativeStrokeWidth,"fill":"none"}}),_c('path',{staticClass:"el-progress-circle__path",style:(_vm.circlePathStyle),attrs:{"d":_vm.trackPath,"stroke-linecap":"round","stroke":_vm.stroke,"stroke-width":_vm.relativeStrokeWidth,"fill":"none"}})])]),(_vm.showText && !_vm.textInside)?_c('div',{staticClass:"el-progress__text",style:({fontSize: _vm.progressTextSize + 'px'})},[(!_vm.status)?[_vm._v(_vm._s(_vm.percentage)+"%")]:_c('i',{class:_vm.iconClass})],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "wDOA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function () {
  if (_vue2.default.prototype.$isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;

  var outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);

  var widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';

  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);

  var widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;

  return scrollBarWidth;
};

var _vue = __webpack_require__("5vqR");

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scrollBarWidth = void 0;

;

/***/ }),

/***/ "x018":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-undefined */

var throttle = __webpack_require__("VMHY");

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}  atBegin       Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @return {Function} A new, debounced function.
 */
module.exports = function ( delay, atBegin, callback ) {
	return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};


/***/ }),

/***/ "x8DJ":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "xB8i":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return warning; });
/* harmony export (immutable) */ __webpack_exports__["e"] = format;
/* harmony export (immutable) */ __webpack_exports__["f"] = isEmptyValue;
/* unused harmony export isEmptyObject */
/* harmony export (immutable) */ __webpack_exports__["b"] = asyncMap;
/* harmony export (immutable) */ __webpack_exports__["d"] = complementError;
/* harmony export (immutable) */ __webpack_exports__["a"] = deepMerge;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__("4YfN");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__("hRKE");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);


var formatRegExp = /%[sdj%]/g;

var warning = function warning() {};

// don't print warning message when in production env or node runtime
if (false) {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn) {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function format() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var i = 1;
  var f = args[0];
  var len = args.length;
  if (typeof f === 'function') {
    return f.apply(null, args.slice(1));
  }
  if (typeof f === 'string') {
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case '%s':
          return String(args[i++]);
        case '%d':
          return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
          break;
        default:
          return x;
      }
    });
    for (var arg = args[i]; i < len; arg = args[++i]) {
      str += ' ' + arg;
    }
    return str;
  }
  return f;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }
  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }
  return false;
}

function isEmptyObject(obj) {
  return Object.keys(obj).length === 0;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index;
    index = index + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}

function asyncMap(objArr, option, func, callback) {
  if (option.first) {
    var flattenArr = flattenObjArr(objArr);
    return asyncSerialArray(flattenArr, func, callback);
  }
  var firstFields = option.firstFields || [];
  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var next = function next(errors) {
    results.push.apply(results, errors);
    total++;
    if (total === objArrLength) {
      callback(results);
    }
  };
  objArrKeys.forEach(function (key) {
    var arr = objArr[key];
    if (firstFields.indexOf(key) !== -1) {
      asyncSerialArray(arr, func, next);
    } else {
      asyncParallelArray(arr, func, next);
    }
  });
}

function complementError(rule) {
  return function (oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }
    return {
      message: oe,
      field: oe.field || rule.fullField
    };
  };
}

function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if ((typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(value)) === 'object' && __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(target[s]) === 'object') {
          target[s] = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}

/***/ }),

/***/ "xRTu":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("Fl16")('meta');
var isObject = __webpack_require__("X609");
var has = __webpack_require__("AsM0");
var setDesc = __webpack_require__("Lohu").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("YEmw")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "xhq7":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 392);
/******/ })
/************************************************************************/
/******/ ({

/***/ 19:
/***/ (function(module, exports) {

module.exports = __webpack_require__("MD5c");

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = __webpack_require__("caRQ");

/***/ }),

/***/ 38:
/***/ (function(module, exports) {

module.exports = __webpack_require__("wDOA");

/***/ }),

/***/ 392:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(393);


/***/ }),

/***/ 393:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _main = __webpack_require__(394);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_main2.default.install = function (Vue) {
  Vue.component(_main2.default.name, _main2.default);
};

exports.default = _main2.default;

/***/ }),

/***/ 394:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _resizeEvent = __webpack_require__(19);

var _scrollbarWidth = __webpack_require__(38);

var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

var _util = __webpack_require__(2);

var _bar = __webpack_require__(395);

var _bar2 = _interopRequireDefault(_bar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
// reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

exports.default = {
  name: 'ElScrollbar',

  components: { Bar: _bar2.default },

  props: {
    native: Boolean,
    wrapStyle: {},
    wrapClass: {},
    viewClass: {},
    viewStyle: {},
    noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
    tag: {
      type: String,
      default: 'div'
    }
  },

  data: function data() {
    return {
      sizeWidth: '0',
      sizeHeight: '0',
      moveX: 0,
      moveY: 0
    };
  },


  computed: {
    wrap: function wrap() {
      return this.$refs.wrap;
    }
  },

  render: function render(h) {
    var gutter = (0, _scrollbarWidth2.default)();
    var style = this.wrapStyle;

    if (gutter) {
      var gutterWith = '-' + gutter + 'px';
      var gutterStyle = 'margin-bottom: ' + gutterWith + '; margin-right: ' + gutterWith + ';';

      if (Array.isArray(this.wrapStyle)) {
        style = (0, _util.toObject)(this.wrapStyle);
        style.marginRight = style.marginBottom = gutterWith;
      } else if (typeof this.wrapStyle === 'string') {
        style += gutterStyle;
      } else {
        style = gutterStyle;
      }
    }
    var view = h(this.tag, {
      class: ['el-scrollbar__view', this.viewClass],
      style: this.viewStyle,
      ref: 'resize'
    }, this.$slots.default);
    var wrap = h(
      'div',
      {
        ref: 'wrap',
        style: style,
        on: {
          'scroll': this.handleScroll
        },

        'class': [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default'] },
      [[view]]
    );
    var nodes = void 0;

    if (!this.native) {
      nodes = [wrap, h(
        _bar2.default,
        {
          attrs: {
            move: this.moveX,
            size: this.sizeWidth }
        },
        []
      ), h(
        _bar2.default,
        {
          attrs: {
            vertical: true,
            move: this.moveY,
            size: this.sizeHeight }
        },
        []
      )];
    } else {
      nodes = [h(
        'div',
        {
          ref: 'wrap',
          'class': [this.wrapClass, 'el-scrollbar__wrap'],
          style: style },
        [[view]]
      )];
    }
    return h('div', { class: 'el-scrollbar' }, nodes);
  },


  methods: {
    handleScroll: function handleScroll() {
      var wrap = this.wrap;

      this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
      this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
    },
    update: function update() {
      var heightPercentage = void 0,
          widthPercentage = void 0;
      var wrap = this.wrap;
      if (!wrap) return;

      heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
      widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;

      this.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
      this.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
    }
  },

  mounted: function mounted() {
    if (this.native) return;
    this.$nextTick(this.update);
    !this.noresize && (0, _resizeEvent.addResizeListener)(this.$refs.resize, this.update);
  },
  beforeDestroy: function beforeDestroy() {
    if (this.native) return;
    !this.noresize && (0, _resizeEvent.removeResizeListener)(this.$refs.resize, this.update);
  }
};

/***/ }),

/***/ 395:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(4);

var _util = __webpack_require__(396);

/* istanbul ignore next */
exports.default = {
  name: 'Bar',

  props: {
    vertical: Boolean,
    size: String,
    move: Number
  },

  computed: {
    bar: function bar() {
      return _util.BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
    },
    wrap: function wrap() {
      return this.$parent.wrap;
    }
  },

  render: function render(h) {
    var size = this.size,
        move = this.move,
        bar = this.bar;


    return h(
      'div',
      {
        'class': ['el-scrollbar__bar', 'is-' + bar.key],
        on: {
          'mousedown': this.clickTrackHandler
        }
      },
      [h(
        'div',
        {
          ref: 'thumb',
          'class': 'el-scrollbar__thumb',
          on: {
            'mousedown': this.clickThumbHandler
          },

          style: (0, _util.renderThumbStyle)({ size: size, move: move, bar: bar }) },
        []
      )]
    );
  },


  methods: {
    clickThumbHandler: function clickThumbHandler(e) {
      this.startDrag(e);
      this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
    },
    clickTrackHandler: function clickTrackHandler(e) {
      var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
      var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
      var thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];

      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
    },
    startDrag: function startDrag(e) {
      e.stopImmediatePropagation();
      this.cursorDown = true;

      (0, _dom.on)(document, 'mousemove', this.mouseMoveDocumentHandler);
      (0, _dom.on)(document, 'mouseup', this.mouseUpDocumentHandler);
      document.onselectstart = function () {
        return false;
      };
    },
    mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
      if (this.cursorDown === false) return;
      var prevPage = this[this.bar.axis];

      if (!prevPage) return;

      var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
      var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];

      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
    },
    mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
      this.cursorDown = false;
      this[this.bar.axis] = 0;
      (0, _dom.off)(document, 'mousemove', this.mouseMoveDocumentHandler);
      document.onselectstart = null;
    }
  },

  destroyed: function destroyed() {
    (0, _dom.off)(document, 'mouseup', this.mouseUpDocumentHandler);
  }
};

/***/ }),

/***/ 396:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.renderThumbStyle = renderThumbStyle;
var BAR_MAP = exports.BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top'
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left'
  }
};

function renderThumbStyle(_ref) {
  var move = _ref.move,
      size = _ref.size,
      bar = _ref.bar;

  var style = {};
  var translate = 'translate' + bar.axis + '(' + move + '%)';

  style[bar.size] = size;
  style.transform = translate;
  style.msTransform = translate;
  style.webkitTransform = translate;

  return style;
};

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = __webpack_require__("6d3N");

/***/ })

/******/ });

/***/ }),

/***/ "xnvR":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = newMessages;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return messages; });
function newMessages() {
  return {
    'default': 'Validation error on field %s',
    required: '%s is required',
    'enum': '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      boolean: '%s is not a %s',
      integer: '%s is not an %s',
      float: '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}

var messages = newMessages();

/***/ }),

/***/ "xp85":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (ref) {
  return {
    methods: {
      focus: function focus() {
        this.$refs[ref].focus();
      }
    }
  };
};

;

/***/ }),

/***/ "yp0o":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("EIha");
var global = __webpack_require__("lSMs");
var hide = __webpack_require__("q1/O");
var Iterators = __webpack_require__("Ytca");
var TO_STRING_TAG = __webpack_require__("IFGh")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "z59m":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("tNH9");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "zYT2":
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 173);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 173:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(174);


/***/ }),

/***/ 174:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _button = __webpack_require__(175);

var _button2 = _interopRequireDefault(_button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
_button2.default.install = function (Vue) {
  Vue.component(_button2.default.name, _button2.default);
};

exports.default = _button2.default;

/***/ }),

/***/ 175:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_36b70ef5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__ = __webpack_require__(177);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_36b70ef5_hasScoped_false_preserveWhitespace_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ 176:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'ElButton',

  inject: {
    elFormItem: {
      default: ''
    }
  },

  props: {
    type: {
      type: String,
      default: 'default'
    },
    size: String,
    icon: {
      type: String,
      default: ''
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean
  },

  computed: {
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    buttonSize: function buttonSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },

  methods: {
    handleClick: function handleClick(evt) {
      this.$emit('click', evt);
    },
    handleInnerClick: function handleInnerClick(evt) {
      if (this.disabled) {
        evt.stopPropagation();
      }
    }
  }
};

/***/ }),

/***/ 177:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"el-button",class:[
    _vm.type ? 'el-button--' + _vm.type : '',
    _vm.buttonSize ? 'el-button--' + _vm.buttonSize : '',
    {
      'is-disabled': _vm.disabled,
      'is-loading': _vm.loading,
      'is-plain': _vm.plain,
      'is-round': _vm.round
    }
  ],attrs:{"disabled":_vm.disabled,"autofocus":_vm.autofocus,"type":_vm.nativeType},on:{"click":_vm.handleClick}},[(_vm.loading)?_c('i',{staticClass:"el-icon-loading",on:{"click":_vm.handleInnerClick}}):_vm._e(),(_vm.icon && !_vm.loading)?_c('i',{class:_vm.icon,on:{"click":_vm.handleInnerClick}}):_vm._e(),(_vm.$slots.default)?_c('span',{on:{"click":_vm.handleInnerClick}},[_vm._t("default")],2):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })

/******/ });

/***/ }),

/***/ "zydr":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__("xB8i");


/**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || __WEBPACK_IMPORTED_MODULE_0__util__["f" /* isEmptyValue */](value, type || rule.type))) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.required, rule.fullField));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (required);

/***/ })

});
//# sourceMappingURL=vendor.1c4633b50cfe175c2742.js.map